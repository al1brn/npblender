# MIT License
#
# Copyright (c) 2025 Alain Bernard
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the \"Software\"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""
Module Name: perlin
Author: Alain Bernard
Version: 0.1.0
Created: 2025-09-02
Last updated: 2025-09-02

Summary:
    Noise.

Perlin & Musgrave Noise (1D–4D) — NumPy implementation
Generated by ChatGPT (GPT-5 Thinking) on 2025-08-13.

Overview
--------
This module provides:
- Classic Perlin noise in 1D/2D/3D/4D (tileable via `period`)
- Fractional Brownian Motion (fBM)
- Musgrave variants: Multifractal, Ridged Multifractal, Hybrid Multifractal, Hetero Terrain
- Blender-style fBM wrapper (`blender_noise_fbm`)
- A single convenience API: `noise(...)` to sample any algorithm

Notes
-----
- `perlin` can be a `Perlin` instance or an integer seed; the dimension is inferred from `coords`.
- Seamless tiling: pass `period` (int or tuple of ints, in grid cells). The period is scaled per octave.
- Domain warp (`distortion`) breaks tiling by design.

Quick Example
-------------
``` python
import numpy as np
# 2D fBM, seamless tile:
N, T = 256, 8
xs = np.linspace(0, T, N, endpoint=False)
ys = np.linspace(0, T, N, endpoint=False)
xx, yy = np.meshgrid(xs, ys, indexing='xy')
coords = np.stack([xx, yy], axis=-1).reshape(-1, 2)
img = noise(coords, algo='fBM', perlin=42, octaves=6, lacunarity=2.0, gain=0.5, period=T)
img = img.reshape(N, N)
```
"""

__all__ = ["noise"]

import numpy as np

class Perlin:
    def __init__(self, dim=2, seed=0):
        assert dim in (1, 2, 3, 4), "dim must be 1, 2, 3 or 4"
        self.dim = dim
        rng = np.random.default_rng(seed)
        p = np.arange(256, dtype=np.int32)
        rng.shuffle(p)
        self.p = np.concatenate([p, p])  # table de permutations dupliquée

        if dim == 1:
            self.grads = np.array([+1, -1], dtype=np.int32)

        elif dim == 2:
            self.grads = np.array([
                [ 1, 0],[ -1, 0],[ 0, 1],[ 0,-1],
                [ 1, 1],[ -1, 1],[ 1,-1],[ -1,-1]
            ], dtype=np.float32)
            self.grads /= np.linalg.norm(self.grads, axis=1, keepdims=True)

        elif dim == 3:
            self.grads = np.array([
                [ 1, 1, 0],[ -1, 1, 0],[ 1,-1, 0],[ -1,-1, 0],
                [ 1, 0, 1],[ -1, 0, 1],[ 1, 0,-1],[ -1, 0,-1],
                [ 0, 1, 1],[  0,-1, 1],[ 0, 1,-1],[  0,-1,-1]
            ], dtype=np.float32)
            self.grads /= np.linalg.norm(self.grads, axis=1, keepdims=True)

        else:  # dim == 4
            # 24 vecteurs (±1, ±1, 0, 0) (toutes permutations + signes) + 8 vecteurs axes (±1,0,0,0)
            g = []
            axes = range(4)
            # (±1, ±1, 0, 0)
            for i in axes:
                for j in axes:
                    if j <= i: 
                        continue
                    for sx in (1, -1):
                        for sy in (1, -1):
                            v = np.zeros(4, dtype=np.float32)
                            v[i] = sx
                            v[j] = sy
                            g.append(v)
            # axes (±1,0,0,0)
            for a in axes:
                for s in (1, -1):
                    v = np.zeros(4, dtype=np.float32)
                    v[a] = s
                    g.append(v)
            self.grads = np.stack(g, axis=0)
            self.grads /= np.linalg.norm(self.grads, axis=1, keepdims=True)  # normalisés (32 au total)

    @staticmethod
    def fade(t):  # 6t^5 - 15t^4 + 10t^3
        return t*t*t*(t*(t*6 - 15) + 10)

    @staticmethod
    def lerp(a, b, t):
        return a + t*(b - a)

    def _hash(self, xi, yi=None, zi=None, wi=None, period=None):

        if period is not None:
            if isinstance(period, int):
                period = (period,) * self.dim
            if self.dim >= 1: xi = xi % period[0]
            if self.dim >= 2: yi = yi % period[1]
            if self.dim >= 3: zi = zi % period[2]
            if self.dim >= 4: wi = wi % period[3]
            
            return self._hash(xi, yi, zi, wi)

        p = self.p
        if self.dim == 1:
            return p[xi & 255]
        elif self.dim == 2:
            return p[(p[xi & 255] + (yi & 255)) & 255]
        elif self.dim == 3:
            return p[(p[(p[xi & 255] + (yi & 255)) & 255] + (zi & 255)) & 255]
        else:
            return p[(p[(p[(p[xi & 255] + (yi & 255)) & 255] + (zi & 255)) & 255] + (wi & 255)) & 255]
        
    def _grad_dot(self, h, xf, yf=None, zf=None, wf=None):
        if self.dim == 1:
            g = self.grads[h & 1]
            return g * xf
        elif self.dim == 2:
            g = self.grads[h & 7]
            return g[:, 0]*xf + g[:, 1]*yf
        elif self.dim == 3:
            g = self.grads[h % len(self.grads)]
            return g[:, 0]*xf + g[:, 1]*yf + g[:, 2]*zf
        else:
            g = self.grads[h % len(self.grads)]
            return g[:, 0]*xf + g[:, 1]*yf + g[:, 2]*zf + g[:, 3]*wf

    def noise(self, coords, period=None, out_dim=1):

        coords = np.asarray(coords, dtype=np.float32)

        # Multidimensionnal output
        if out_dim > 1:
            OFF = np.array([
                [37.1, 19.9,  7.3, 11.7],
                [13.4, 53.8, 29.2, 17.6],
                [41.5, 23.7, 61.3,  3.9],
                [ 2.6, 47.9, 31.7, 59.1],
            ], dtype=np.float32)[:, :self.dim]

            comps = []
            for i in range(out_dim):
                off = OFF[i % len(OFF)]
                comps.append(self.noise(coords + off, period=period, out_dim=1))
            return np.stack(comps, axis=-1)
        
        # Scalar output
        if coords.ndim == 0:  # scalaire
            if self.dim == 1:
                coords = coords.reshape(1, 1)
            else:
                raise ValueError(f"coords scalaire seulement accepté en 1D (dim={self.dim})")
        elif coords.ndim == 1:
            if self.dim == 1:
                coords = coords[:, None]    # (N,) -> (N,1)  ✅
            else:
                coords = coords[None, :]    # (dim,) -> (1,dim)
        assert coords.shape[1] == self.dim

        if self.dim == 1:
            x = coords[:, 0]
            xi = np.floor(x).astype(np.int32); xf = x - xi
            u = self.fade(xf)
            h0 = self._hash(xi, period=period); h1 = self._hash(xi+1, period=period)
            n0 = self._grad_dot(h0, xf)
            n1 = self._grad_dot(h1, xf-1.0)
            return self.lerp(n0, n1, u)

        if self.dim == 2:
            x, y = coords[:, 0], coords[:, 1]
            xi, yi = np.floor(x).astype(np.int32), np.floor(y).astype(np.int32)
            xf, yf = x - xi, y - yi
            u, v = self.fade(xf), self.fade(yf)
            h00 = self._hash(xi, yi, period=period);     h10 = self._hash(xi+1, yi, period=period)
            h01 = self._hash(xi, yi+1, period=period);   h11 = self._hash(xi+1, yi+1, period=period)
            n00 = self._grad_dot(h00, xf,     yf)
            n10 = self._grad_dot(h10, xf-1.0, yf)
            n01 = self._grad_dot(h01, xf,     yf-1.0)
            n11 = self._grad_dot(h11, xf-1.0, yf-1.0)
            nx0 = self.lerp(n00, n10, u)
            nx1 = self.lerp(n01, n11, u)
            return self.lerp(nx0, nx1, v)

        if self.dim == 3:
            x, y, z = coords[:, 0], coords[:, 1], coords[:, 2]
            xi, yi, zi = np.floor(x).astype(np.int32), np.floor(y).astype(np.int32), np.floor(z).astype(np.int32)
            xf, yf, zf = x - xi, y - yi, z - zi
            u, v, w = self.fade(xf), self.fade(yf), self.fade(zf)
            # 8 coins
            h000 = self._hash(xi, yi, zi, period=period);     h100 = self._hash(xi+1, yi, zi, period=period)
            h010 = self._hash(xi, yi+1, zi, period=period);   h110 = self._hash(xi+1, yi+1, zi, period=period)
            h001 = self._hash(xi, yi, zi+1, period=period);   h101 = self._hash(xi+1, yi, zi+1, period=period)
            h011 = self._hash(xi, yi+1, zi+1, period=period); h111 = self._hash(xi+1, yi+1, zi+1, period=period)
            n000 = self._grad_dot(h000, xf,     yf,     zf    )
            n100 = self._grad_dot(h100, xf-1.0, yf,     zf    )
            n010 = self._grad_dot(h010, xf,     yf-1.0, zf    )
            n110 = self._grad_dot(h110, xf-1.0, yf-1.0, zf    )
            n001 = self._grad_dot(h001, xf,     yf,     zf-1.0)
            n101 = self._grad_dot(h101, xf-1.0, yf,     zf-1.0)
            n011 = self._grad_dot(h011, xf,     yf-1.0, zf-1.0)
            n111 = self._grad_dot(h111, xf-1.0, yf-1.0, zf-1.0)
            nx00 = self.lerp(n000, n100, u); nx10 = self.lerp(n010, n110, u)
            nx01 = self.lerp(n001, n101, u); nx11 = self.lerp(n011, n111, u)
            nxy0 = self.lerp(nx00, nx10, v); nxy1 = self.lerp(nx01, nx11, v)
            return self.lerp(nxy0, nxy1, w)

        # 4D
        x, y, z, w = coords[:, 0], coords[:, 1], coords[:, 2], coords[:, 3]
        xi, yi = np.floor(x).astype(np.int32), np.floor(y).astype(np.int32)
        zi, wi = np.floor(z).astype(np.int32), np.floor(w).astype(np.int32)
        xf, yf, zf, wf = x - xi, y - yi, z - zi, w - wi
        u, v, s, t = self.fade(xf), self.fade(yf), self.fade(zf), self.fade(wf)

        # 16 coins de l’hypercube
        h0000 = self._hash(xi    , yi    , zi    , wi    , period=period)
        h1000 = self._hash(xi + 1, yi    , zi    , wi    , period=period)
        h0100 = self._hash(xi    , yi + 1, zi    , wi    , period=period)
        h1100 = self._hash(xi + 1, yi + 1, zi    , wi    , period=period)
        h0010 = self._hash(xi    , yi    , zi + 1, wi    , period=period)
        h1010 = self._hash(xi + 1, yi    , zi + 1, wi    , period=period)
        h0110 = self._hash(xi    , yi + 1, zi + 1, wi    , period=period)
        h1110 = self._hash(xi + 1, yi + 1, zi + 1, wi    , period=period)
        h0001 = self._hash(xi    , yi    , zi    , wi + 1, period=period)
        h1001 = self._hash(xi + 1, yi    , zi    , wi + 1, period=period)
        h0101 = self._hash(xi    , yi + 1, zi    , wi + 1, period=period)
        h1101 = self._hash(xi + 1, yi + 1, zi    , wi + 1, period=period)
        h0011 = self._hash(xi    , yi    , zi + 1, wi + 1, period=period)
        h1011 = self._hash(xi + 1, yi    , zi + 1, wi + 1, period=period)
        h0111 = self._hash(xi    , yi + 1, zi + 1, wi + 1, period=period)
        h1111 = self._hash(xi + 1, yi + 1, zi + 1, wi + 1, period=period)

        n0000 = self._grad_dot(h0000, xf    , yf    , zf    , wf    )
        n1000 = self._grad_dot(h1000, xf-1.0, yf    , zf    , wf    )
        n0100 = self._grad_dot(h0100, xf    , yf-1.0, zf    , wf    )
        n1100 = self._grad_dot(h1100, xf-1.0, yf-1.0, zf    , wf    )
        n0010 = self._grad_dot(h0010, xf    , yf    , zf-1.0, wf    )
        n1010 = self._grad_dot(h1010, xf-1.0, yf    , zf-1.0, wf    )
        n0110 = self._grad_dot(h0110, xf    , yf-1.0, zf-1.0, wf    )
        n1110 = self._grad_dot(h1110, xf-1.0, yf-1.0, zf-1.0, wf    )
        n0001 = self._grad_dot(h0001, xf    , yf    , zf    , wf-1.0)
        n1001 = self._grad_dot(h1001, xf-1.0, yf    , zf    , wf-1.0)
        n0101 = self._grad_dot(h0101, xf    , yf-1.0, zf    , wf-1.0)
        n1101 = self._grad_dot(h1101, xf-1.0, yf-1.0, zf    , wf-1.0)
        n0011 = self._grad_dot(h0011, xf    , yf    , zf-1.0, wf-1.0)
        n1011 = self._grad_dot(h1011, xf-1.0, yf    , zf-1.0, wf-1.0)
        n0111 = self._grad_dot(h0111, xf    , yf-1.0, zf-1.0, wf-1.0)
        n1111 = self._grad_dot(h1111, xf-1.0, yf-1.0, zf-1.0, wf-1.0)

        # Interpolation 4D (x -> y -> z -> w)
        nx000 = self.lerp(n0000, n1000, u); nx100 = self.lerp(n0100, n1100, u)
        nx010 = self.lerp(n0010, n1010, u); nx110 = self.lerp(n0110, n1110, u)
        nx001 = self.lerp(n0001, n1001, u); nx101 = self.lerp(n0101, n1101, u)
        nx011 = self.lerp(n0011, n1011, u); nx111 = self.lerp(n0111, n1111, u)

        nxy00 = self.lerp(nx000, nx100, v); nxy10 = self.lerp(nx010, nx110, v)
        nxy01 = self.lerp(nx001, nx101, v); nxy11 = self.lerp(nx011, nx111, v)

        nxyz0 = self.lerp(nxy00, nxy10, s)
        nxyz1 = self.lerp(nxy01, nxy11, s)

        return self.lerp(nxyz0, nxyz1, t)

def _ensure_coords(coords, dim):
    """Retourne un array float32 de shape (N, dim)."""
    a = np.asarray(coords, dtype=np.float32)
    if a.ndim == 0:  # scalaire
        if dim == 1:
            return a.reshape(1, 1)
        raise ValueError(f"coords scalaire seulement accepté en 1D (dim={dim})")

    if dim == 1:
        if a.ndim == 1:        # (N,)
            return a[:, None]  # -> (N,1)
        if a.ndim == 2 and a.shape[1] == 1:
            return a           # (N,1)
        raise ValueError("coords 1D attend (N,) ou (N,1)")
    else:
        if a.ndim == 1:
            a = a[None, :]     # -> (1,dim)
        if a.ndim == 2 and a.shape[1] == dim:
            return a
        raise ValueError(f"coords {dim}D attend (N,{dim})")
    
def _vector_noise(perlin, coords):
    """
    Bruit vectoriel pour le domain warp (même dim que coords).
    Construit en combinant des bruits scalaires décalés.
    """
    x = _ensure_coords(coords, perlin.dim)

    OFF = np.array([
        [37.1, 19.9,  7.3, 11.7],
        [13.4, 53.8, 29.2, 17.6],
        [41.5, 23.7, 61.3,  3.9],
        [ 2.6, 47.9, 31.7, 59.1],
    ], dtype=np.float32)

    d = x.shape[1]
    comps = []
    for i in range(d):
        off = OFF[i, :d]              # (d,)
        comps.append(perlin.noise(x + off))  # (N,)
    return np.stack(comps, axis=-1)   # (N,d)

def _scaled_period(period, dim, freq):
    """Période mise à l’échelle pour l’octave courante."""
    if period is None:
        return None
    if isinstance(period, int):
        period = (period,) * dim
    return tuple(max(1, int(round(p * freq))) for p in period)


def fbm(perlin, coords, octaves=5, lacunarity=2.0, gain=0.5, normalize=True, period=None, out_dim=1):
    """
    fBM générique (1D..4D) sur perlin.noise(coords).
    - period: int ou tuple d'int (période en cellules de grille). Si fourni, le fBM est tilable,
      à condition que period * (lacunarity**k) soit entier pour chaque octave k (ou arrondi ici).
    """
    x = _ensure_coords(coords, perlin.dim)

    # Normalise et prépare la période
    base_period = None
    if period is not None:
        if isinstance(period, int):
            base_period = (period,) * perlin.dim
        else:
            base_period = tuple(int(p) for p in period)

    amp = 1.0
    freq = 1.0
    total = 0.0
    amp_sum = 0.0
    n_int = int(np.floor(octaves))

    def octave_period(freq):
        if base_period is None:
            return None
        # On arrondit pour obtenir un entier; assure une vraie périodicité.
        return tuple(max(1, int(round(p * freq))) for p in base_period)

    for _ in range(n_int):
        total += amp * perlin.noise(x * freq, period=octave_period(freq), out_dim=out_dim)
        amp_sum += amp
        freq *= lacunarity
        amp  *= gain

    # Octave fractionnelle (mix simple de la dernière octave)
    frac = float(octaves) - n_int
    if frac > 1e-6:
        total   += frac * (amp * perlin.noise(x * freq, period=octave_period(freq), out_dim=out_dim))
        amp_sum += frac * amp

    if normalize and amp_sum > 0:
        total = total / amp_sum
    return total

def blender_noise_fbm(perlin, coords, *,
                      scale=5.0,
                      detail=5.0,
                      roughness=0.5,
                      lacunarity=2.0,
                      distortion=0.0,
                      warp_scale=None,
                      warp_gain=1.0,
                      period=None):
    """
    Reproduction de la Noise Texture (mode fBM) de Blender.
    NOTE: si 'distortion' != 0, la périodicité (period) ne peut pas être garantie.
    """
    x = _ensure_coords(coords, perlin.dim)
    x = x * float(scale)

    if distortion != 0.0:
        ws = float(scale if warp_scale is None else warp_scale)
        warp = _vector_noise(perlin, x * ws)  # Attention: casse la périodicité
        x = x + float(distortion) * float(warp_gain) * warp
        period = None  # désactive la périodicité pour éviter les mauvaises surprises

    return fbm(perlin, x,
               octaves=float(detail),
               lacunarity=float(lacunarity),
               gain=float(roughness),
               normalize=True,
               period=period)

def _prep_coords_and_spectrum(perlin, coords, detail, lacunarity, dimension, gain):
    x = _ensure_coords(coords, perlin.dim)
    # Fréquences : lacunarity^i
    i = np.arange(int(np.floor(detail)), dtype=np.float32)
    freqs = np.power(lacunarity, i)
    # Amplitudes spectrales : lacunarity^(-H*i), éventuellement modulées par gain^i
    amps = np.power(lacunarity, -dimension * i) * np.power(gain, i)
    # Octave fractionnelle éventuelle (pour detail non entier)
    frac = float(detail) - int(np.floor(detail))
    return x, freqs, amps, frac

def musgrave_fbm(perlin, coords, *, detail=5.0, lacunarity=2.0, dimension=1.0, gain=0.5, period=None, out_dim=1):
    """ Musgrave fBM = somme d'octaves avec spectre ~ lacunarity^(-H*i). """
    x, freqs, amps, frac = _prep_coords_and_spectrum(perlin, coords, detail, lacunarity, dimension, gain)
    total = 0.0
    for f, a in zip(freqs, amps):
        total += a * perlin.noise(x * f, period=_scaled_period(period, perlin.dim, f), out_dim=out_dim)
    if frac > 1e-6:
        f = lacunarity**len(freqs); a = (lacunarity**(-dimension * len(freqs))) * (gain**len(freqs))
        total += frac * a * perlin.noise(x * f, period=_scaled_period(period, perlin.dim, f), out_dim=out_dim)
    return total

def musgrave_multifractal(perlin, coords, *, detail=5.0, lacunarity=2.0, dimension=1.0, gain=0.5, period=None, out_dim=1):
    """ MultiFractal = produit cumulatif de (1 + a_i * noise_i). Valeurs > 0 typiquement. """
    x, freqs, amps, frac = _prep_coords_and_spectrum(perlin, coords, detail, lacunarity, dimension, gain)
    val = 1.0
    for f, a in zip(freqs, amps):
        n = perlin.noise(x * f, period=_scaled_period(period, perlin.dim, f), out_dim=out_dim)
        val = val * (1.0 + a * n)
    if frac > 1e-6:
        f = lacunarity**len(freqs); a = (lacunarity**(-dimension * len(freqs))) * (gain**len(freqs))
        n = perlin.noise(x * f, period=_scaled_period(period, perlin.dim, f), out_dim=out_dim)
        val = val * (1.0 + frac * a * n)
    return val

def musgrave_hetero_terrain(perlin, coords, *, detail=5.0, lacunarity=2.0, dimension=1.0, gain=0.5, offset=0.0, period=None, out_dim=1):
    x, freqs, amps, frac = _prep_coords_and_spectrum(perlin, coords, detail, lacunarity, dimension, gain)

    # octave 0 (robuste si n_int == 0)
    if len(freqs) == 0:
        f0, a0 = 1.0, 1.0
    else:
        f0, a0 = float(freqs[0]), float(amps[0])

    v = (perlin.noise(x * f0, period=_scaled_period(period, perlin.dim, f0), out_dim=out_dim) + offset) * a0

    # octaves suivantes
    for f, a in zip(freqs[1:], amps[1:]):
        n = perlin.noise(x * f, period=_scaled_period(period, perlin.dim, float(f)), out_dim=out_dim)
        v += (n + offset) * a * v

    # octave fractionnelle (s’il y en a une)
    if frac > 1e-6:
        k = len(freqs)
        f = float(lacunarity**k)
        a = float((lacunarity**(-dimension * k)) * (gain**k))
        n = perlin.noise(x * f, period=_scaled_period(period, perlin.dim, f), out_dim=out_dim)
        v += frac * (n + offset) * a * v
    return v

def musgrave_ridged_multifractal(perlin, coords, *, detail=5.0, lacunarity=2.0, dimension=1.0, gain=0.5, offset=1.0, period=None, out_dim=1):
    """ Ridged = crêtes : signal = (offset - |noise|)^2, accumulation pondérée. """
    x, freqs, amps, frac = _prep_coords_and_spectrum(perlin, coords, detail, lacunarity, dimension, gain)
    val = 0.0
    weight = 1.0
    for f, a in zip(freqs, amps):
        n = perlin.noise(x * f, period=_scaled_period(period, perlin.dim, f), out_dim=out_dim)
        signal = (offset - np.abs(n))**2
        signal *= a
        val += signal * weight
        weight = np.clip(signal * gain, 0.0, 1.0)
    if frac > 1e-6:
        f = lacunarity**len(freqs); a = (lacunarity**(-dimension * len(freqs))) * (gain**len(freqs))
        n = perlin.noise(x * f, period=_scaled_period(period, perlin.dim, f), out_dim=out_dim)
        signal = (offset - np.abs(n))**2 * a
        val += frac * signal * weight
    return val

def musgrave_hybrid_multifractal(perlin, coords, *, detail=5.0, lacunarity=2.0, dimension=1.0, gain=0.5, offset=0.0, period=None, out_dim=1):
    x, freqs, amps, frac = _prep_coords_and_spectrum(perlin, coords, detail, lacunarity, dimension, gain)

    # octave 0 (robuste si n_int == 0)
    if len(freqs) == 0:
        f0, a0 = 1.0, 1.0
    else:
        f0, a0 = float(freqs[0]), float(amps[0])

    n0 = perlin.noise(x * f0, period=_scaled_period(period, perlin.dim, f0), out_dim=out_dim)
    val = (n0 + offset) * a0
    weight = val

    # octaves suivantes
    for f, a in zip(freqs[1:], amps[1:]):
        n = perlin.noise(x * f, period=_scaled_period(period, perlin.dim, float(f)), out_dim=out_dim)
        signal = (n + offset) * a
        val += weight * signal
        weight = np.clip(weight * signal * gain, 0.0, 1.0)

    # octave fractionnelle
    if frac > 1e-6:
        k = len(freqs)
        f = float(lacunarity**k)
        a = float((lacunarity**(-dimension * k)) * (gain**k))
        n = perlin.noise(x * f, period=_scaled_period(period, perlin.dim, f), out_dim=out_dim)
        signal = (n + offset) * a
        val += frac * weight * signal
    return val


# ====================================================================================================
# API
# ====================================================================================================

def _infer_dim(coords):
    a = np.asarray(coords)
    if a.ndim == 0:
        return 1
    if a.ndim == 1:
        return 1
    if a.ndim == 2:
        return a.shape[1]
    raise ValueError("coords doit être (N,) pour 1D ou (N,dim) pour dim∈{1,2,3,4}")

def _as_perlin(perlin, dim):
    """Accepte soit une instance Perlin, soit une seed (int)."""
    if isinstance(perlin, Perlin):
        if perlin.dim != dim:
            raise ValueError(f"Perlin.dim={perlin.dim} ≠ coords.dim={dim}")
        return perlin
    # sinon, on suppose que c'est une seed
    return Perlin(dim=dim, seed=int(perlin))

def noise(coords, t=None, scale=1.0, octaves=5, lacunarity=2.0, gain=0.5,
          normalize=True, period=None, algo='fBM', perlin=0, out_dim=1, **kwargs):
    """
    Global noise API.

    Parameters
    ----------
    coords : array-like
        (N,) pour 1D, ou (N, dim) pour dim∈{1,2,3,4}.
    t : float = None
        Supplementary dimension
    scale : float = 1.0
        Échelle appliquée aux coordonnées (coords * scale).
    octaves : float
        Nb d'octaves (peut être non entier) pour fBM / variantes Musgrave.
    lacunarity : float
        Multiplicateur de fréquence par octave.
    gain : float
        Décroissance d'amplitude (selon l'algo).
    normalize : bool
        Normalisation (utilisée par fBM simple).
    period : int | tuple[int] | None
        Période (tiling) en cellules (propagée par octave si applicable).
    algo : str
        'perlin', 'fBM' (ou 'fbm'), 'multifractal' ('multi'),
        'ridged' ('ridged_multifractal'), 'hybrid' ('hybrid_multifractal'),
        'hetero' ('hetero_terrain').
    perlin : Perlin | int
        Instance Perlin, ou seed (int). La dim est déduite de coords.
    out_dim : int
        Number of dimensions in the result
    **kwargs :
        - dimension (float, défaut 1.0) : exposé pour les variantes Musgrave
        - offset (float) : utilisé par 'ridged', 'hybrid', 'hetero' (défauts adaptés)

    Returns
    -------
    np.ndarray
        Valeurs de bruit shape (N,) ou shape(N, out_dim)
    """

    coords = np.asarray(coords)
    dim = _infer_dim(coords)
    # Make sure at least 2D
    if dim == 1 and coords.ndim == 1:
        coords = coords[:, None]

    # Scale if required
    if scale != 1.0:
        coords = coords.astype(np.float32, copy=False) * float(scale)
    else:
        coords = coords.astype(np.float32, copy=False)

    # Add t as supplementary dimension
    if t is not None and dim < 4:
        t_arr = np.asarray(t, dtype=coords.dtype)
        t_col = np.broadcast_to(t_arr, coords.shape[:-1])[..., None]  # (..., 1)
        coords = np.concatenate([coords, t_col], axis=-1)
        dim += 1

    p = _as_perlin(perlin, dim)


    key = str(algo).strip().lower().replace(" ", "").replace("-", "_")

    # Params Musgrave optionnels
    H = float(kwargs.pop("dimension", 1.0))
    # offset par défaut dépend de l'algo (voir plus bas)
    off_user = kwargs.pop("offset", None)
    if kwargs:
        unknown = ", ".join(kwargs.keys())
        raise TypeError(f"Paramètres inconnus pour noise(...): {unknown}")

    # --- fBM (classique) ---
    if key in ("fbm", "f_bm"):
        return fbm(p, coords, octaves=octaves, lacunarity=lacunarity,
                   gain=gain, normalize=normalize, period=period, out_dim=out_dim)

    # --- Perlin brut (une octave) ---
    if key in ("perlin", "raw", "basic"):
        x = _ensure_coords(coords, dim)
        return p.noise(x, period=period, out_dim=out_dim)

    # --- Musgrave: Multifractal ---
    if key in ("multifractal", "multi"):
        return musgrave_multifractal(p, coords, detail=octaves,
                                     lacunarity=lacunarity, dimension=H,
                                     gain=gain, period=period, out_dim=out_dim)

    # --- Musgrave: Ridged ---
    if key in ("ridged", "ridged_multifractal", "ridge"):
        offset = float(1.0 if off_user is None else off_user)
        return musgrave_ridged_multifractal(p, coords, detail=octaves,
                                            lacunarity=lacunarity, dimension=H,
                                            gain=gain, offset=offset, period=period, out_dim=out_dim)

    # --- Musgrave: Hybrid ---
    if key in ("hybrid", "hybrid_multifractal"):
        offset = float(0.0 if off_user is None else off_user)
        return musgrave_hybrid_multifractal(p, coords, detail=octaves,
                                            lacunarity=lacunarity, dimension=H,
                                            gain=gain, offset=offset, period=period, out_dim=out_dim)

    # --- Musgrave: Hetero Terrain ---
    if key in ("hetero", "hetero_terrain", "heteroterrain"):
        offset = float(0.0 if off_user is None else off_user)
        return musgrave_hetero_terrain(p, coords, detail=octaves,
                                       lacunarity=lacunarity, dimension=H,
                                       gain=gain, offset=offset, period=period, out_dim=out_dim)

    raise ValueError(
        f"Unknown Noise algorithm: {algo!r}. "
        "Valid algorithms are: 'perlin', 'fBM', 'multifractal', 'ridged', 'hybrid', 'hetero'."
    )

# ====================================================================================================
# Test
# ====================================================================================================

if __name__ == "__main__":

    # --- auto-install matplotlib si manquant ---
    try:
        import matplotlib.pyplot as plt
    except ImportError:
        import subprocess
        import sys
        subprocess.check_call([sys.executable, "-m", "pip", "install", "matplotlib"])
        import matplotlib.pyplot as plt

    # -----------------------------
    # Paramètres généraux d'exemple
    # -----------------------------
    seed        = 42
    N_img       = 256      # taille des images 2D (N_img x N_img)
    scale       = 6.0
    detail      = 6.0
    roughness   = 0.5
    lacunarity  = 2.0

    # =============================
    # 1) Exemple 1D (profil fBM)
    # =============================
    p1 = Perlin(dim=1, seed=seed)
    x1 = np.linspace(0, 8, 2000, endpoint=True)
    y1 = fbm(p1, x1, octaves=detail, lacunarity=lacunarity, gain=roughness, normalize=True)

    plt.figure()
    plt.title("fBM 1D")
    plt.plot(x1, y1)
    plt.xlabel("x")
    plt.ylabel("noise")
    plt.tight_layout()

    # ======================================
    # 2) Slices 2D d'un bruit 3D (z fixé)
    # ======================================
    p3 = Perlin(dim=3, seed=seed)
    x = np.linspace(0, 1, N_img, endpoint=True)
    y = np.linspace(0, 1, N_img, endpoint=True)
    xx, yy = np.meshgrid(x, y, indexing='xy')

    z_values = [0.7, 1.4]  # deux tranches pour comparaison
    imgs_3d = []
    for z in z_values:
        coords3 = np.stack([xx * scale, yy * scale, np.full_like(xx, z*scale)], axis=-1).reshape(-1, 3)
        img = fbm(p3, coords3, octaves=detail, lacunarity=lacunarity, gain=roughness, normalize=True)
        imgs_3d.append(img.reshape(N_img, N_img))

    plt.figure(figsize=(8, 4))
    for i, (z, img) in enumerate(zip(z_values, imgs_3d), start=1):
        plt.subplot(1, 2, i)
        plt.title(f"Slice 2D d'un 3D (z={z:.2f})")
        plt.imshow(img, origin='lower')
        plt.axis('off')
    plt.tight_layout()

    # ======================================
    # 3) Slices 2D d'un bruit 4D (z,w fixés)
    # ======================================
    p4 = Perlin(dim=4, seed=seed)
    zw_pairs = [(0.8, 1.2), (1.3, 2.1)]
    imgs_4d = []
    for (z, w) in zw_pairs:
        coords4 = np.stack([
            xx * scale,
            yy * scale,
            np.full_like(xx, z*scale),
            np.full_like(yy, w*scale)
        ], axis=-1).reshape(-1, 4)
        img = fbm(p4, coords4, octaves=detail, lacunarity=lacunarity, gain=roughness, normalize=True)
        imgs_4d.append(img.reshape(N_img, N_img))

    plt.figure(figsize=(8, 4))
    for i, ((z, w), img) in enumerate(zip(zw_pairs, imgs_4d), start=1):
        plt.subplot(1, 2, i)
        plt.title(f"Slice 2D d'un 4D (z={z:.2f}, w={w:.2f})")
        plt.imshow(img, origin='lower')
        plt.axis('off')
    plt.tight_layout()

    # ======================================
    # 4) Exemple d'image 2D **tilée**
    #    (périodicité stricte sur T×T cellules)
    # ======================================
    p2 = Perlin(dim=2, seed=seed)

    # Pour une périodicité propre, on travaille sur [0, T) en coordonnées,
    # et on met period=T pour chaque octave (géré par fbm()).
    T = 8  # période en cellules (choisis une puissance de 2 si lacunarity=2.0)
    xs = np.linspace(0, T, N_img, endpoint=False)
    ys = np.linspace(0, T, N_img, endpoint=False)
    xxs, yys = np.meshgrid(xs, ys, indexing='xy')
    coords2_tiled = np.stack([xxs, yys], axis=-1).reshape(-1, 2)

    img_tiled = fbm(
        p2, coords2_tiled,
        octaves=detail,
        lacunarity=lacunarity,
        gain=roughness,
        normalize=True,
        period=T  # <- rend l'image tilable
    ).reshape(N_img, N_img)

    # Vérification visuelle : mosaïque 2×2
    mosaic = np.block([[img_tiled, img_tiled],
                       [img_tiled, img_tiled]])

    plt.figure(figsize=(9, 4))
    plt.subplot(1, 2, 1)
    plt.title(f"Texture tilée (période = {T})")
    plt.imshow(img_tiled, origin='lower')
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.title("Mosaïque 2×2 (bords sans couture)")
    plt.imshow(mosaic, origin='lower')
    plt.axis('off')
    plt.tight_layout()

    # ======================================
    # 5) Variantes Musgrave (images 2D)
    #    (utilise les fonctions: musgrave_fbm, musgrave_multifractal,
    #     musgrave_ridged_multifractal, musgrave_hybrid_multifractal,
    #     musgrave_hetero_terrain)
    # ======================================
    p2m = Perlin(dim=2, seed=seed)

    # Grille 2D (coords en [0,1], on multiplie ensuite par 'scale')
    x = np.linspace(0, 1, N_img, endpoint=True)
    y = np.linspace(0, 1, N_img, endpoint=True)
    xx, yy = np.meshgrid(x, y, indexing='xy')
    coords2 = np.stack([xx * scale, yy * scale], axis=-1).reshape(-1, 2)

    # Paramètres "Musgrave-like"
    H_dimension = 1.0   # "Dimension" (H)
    G_gain      = 0.5   # Gain supplémentaire (peut rester à 1.0 si tu veux)
    O_offset    = 1.0   # Offset pour ridged (souvent ~0.9–1.2)
    O2_offset   = 0.0   # Offset pour hetero/hybrid (0.0–1.0)

    img_m_fbm   = musgrave_fbm(p2m, coords2, detail=detail, lacunarity=lacunarity,
                               dimension=H_dimension, gain=G_gain).reshape(N_img, N_img)

    img_m_multi = musgrave_multifractal(p2m, coords2, detail=detail, lacunarity=lacunarity,
                                        dimension=H_dimension, gain=G_gain).reshape(N_img, N_img)

    img_m_ridge = musgrave_ridged_multifractal(p2m, coords2, detail=detail, lacunarity=lacunarity,
                                               dimension=H_dimension, gain=G_gain, offset=O_offset).reshape(N_img, N_img)

    img_m_hybrid = musgrave_hybrid_multifractal(p2m, coords2, detail=detail, lacunarity=lacunarity,
                                                dimension=H_dimension, gain=G_gain, offset=O2_offset).reshape(N_img, N_img)

    img_m_hetero = musgrave_hetero_terrain(p2m, coords2, detail=detail, lacunarity=lacunarity,
                                           dimension=H_dimension, gain=G_gain, offset=O2_offset).reshape(N_img, N_img)

    plt.figure(figsize=(12, 8))
    plt.subplot(2, 3, 1); plt.title("Musgrave fBM")
    plt.imshow(img_m_fbm, origin='lower'); plt.axis('off')

    plt.subplot(2, 3, 2); plt.title("Multifractal")
    plt.imshow(img_m_multi, origin='lower'); plt.axis('off')

    plt.subplot(2, 3, 3); plt.title("Ridged")
    plt.imshow(img_m_ridge, origin='lower'); plt.axis('off')

    plt.subplot(2, 3, 4); plt.title("Hybrid")
    plt.imshow(img_m_hybrid, origin='lower'); plt.axis('off')

    plt.subplot(2, 3, 5); plt.title("Hetero Terrain")
    plt.imshow(img_m_hetero, origin='lower'); plt.axis('off')

    plt.tight_layout()

    # ======================================
    # 6) Variantes Musgrave (profils 1D)
    # ======================================
    p1m = Perlin(dim=1, seed=seed)
    x1 = np.linspace(0, 8, 2000, endpoint=True)

    y_m_fbm    = musgrave_fbm(p1m, x1,  detail=detail, lacunarity=lacunarity, dimension=H_dimension, gain=G_gain)
    y_m_multi  = musgrave_multifractal(p1m, x1, detail=detail, lacunarity=lacunarity, dimension=H_dimension, gain=G_gain)
    y_m_ridge  = musgrave_ridged_multifractal(p1m, x1, detail=detail, lacunarity=lacunarity, dimension=H_dimension, gain=G_gain, offset=O_offset)
    y_m_hybrid = musgrave_hybrid_multifractal(p1m, x1, detail=detail, lacunarity=lacunarity, dimension=H_dimension, gain=G_gain, offset=O2_offset)
    y_m_hetero = musgrave_hetero_terrain(p1m, x1, detail=detail, lacunarity=lacunarity, dimension=H_dimension, gain=G_gain, offset=O2_offset)

    plt.figure(figsize=(10, 6)); plt.title("Musgrave 1D")
    plt.plot(x1, y_m_fbm,    label="fBM")
    plt.plot(x1, y_m_multi,  label="Multifractal")
    plt.plot(x1, y_m_ridge,  label="Ridged")
    plt.plot(x1, y_m_hybrid, label="Hybrid")
    plt.plot(x1, y_m_hetero, label="Hetero")
    plt.legend(); plt.xlabel("x"); plt.ylabel("valeur")
    plt.tight_layout()

    # ======================================
    # 7) Variante Musgrave **tilée** (2D)
    #    Exemple : fBM Musgrave avec tiling T×T
    # ======================================
    T = 8  # période en cellules
    xs = np.linspace(0, T, N_img, endpoint=False)
    ys = np.linspace(0, T, N_img, endpoint=False)
    xxs, yys = np.meshgrid(xs, ys, indexing='xy')
    coords2_t = np.stack([xxs, yys], axis=-1).reshape(-1, 2)

    img_m_fbm_tiled = musgrave_fbm(
        p2m, coords2_t,
        detail=detail,
        lacunarity=lacunarity,
        dimension=H_dimension,
        gain=G_gain,
        period=T
    ).reshape(N_img, N_img)

    mosaic_m = np.block([[img_m_fbm_tiled, img_m_fbm_tiled],
                         [img_m_fbm_tiled, img_m_fbm_tiled]])

    plt.figure(figsize=(9, 4))
    plt.subplot(1, 2, 1); plt.title(f"Musgrave fBM tilé (T={T})")
    plt.imshow(img_m_fbm_tiled, origin='lower'); plt.axis('off')

    plt.subplot(1, 2, 2); plt.title("Mosaïque 2×2 (sans couture)")
    plt.imshow(mosaic_m, origin='lower'); plt.axis('off')
    plt.tight_layout()

    # Affichage final (si pas déjà fait)
    plt.show()

