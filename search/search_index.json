{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"npblender","text":"<p>Numpy for Blender</p> <p>Doc in progress....</p> <p>Update soon :) (this is a test for the workflow)</p>"},{"location":"api/","title":"R\u00e9f\u00e9rence API","text":""},{"location":"api/#npblender.Camera","title":"Camera","text":"<pre><code>Camera(camera=None)\n</code></pre>"},{"location":"api/#npblender.Camera.distance_for_scale","title":"distance_for_scale","text":"<pre><code>distance_for_scale(size_max, scale=1.0, margin=0.0, fit_axis='auto')\n</code></pre> <p>Compute: - d0: distance at which an unscaled object of real size <code>size_max</code> exactly fits         the camera frame along <code>fit_axis</code> (largest dimension touches the borders). - d : distance such that the UNscaled object at distance d has the same apparent size         as the SCALED object (size_max * scale) at distance d0. (i.e. d = d0 / scale) - meters_per_pixel: world-space length at distance d that projects to exactly 1 pixel         (so two vertices closer than this fall onto the same pixel).</p> <p>Parameters:</p> Name Type Description Default <code>size_max</code> <code>float</code> <p>Largest real dimension of the mesh (Blender units).</p> required <code>scale</code> <code>float</code> <p>Geometry scale (&gt; 0) applied at distance d0.</p> <code>1.0</code> <code>margin</code> <code>float</code> <p>Extra margin around the frame (same convention as elsewhere).</p> <code>0.0</code> <code>fit_axis</code> <code>(auto, width, height)</code> <p>Which frame span to use to define \"exactly fits\". - \"auto\": min(width, height) - \"width\": frame width - \"height\": frame height</p> <code>\"auto\"</code> <p>Returns:</p> Name Type Description <code>d</code> <code>float</code> <p>Distance where the UNscaled object matches the apparent size of the SCALED one at d0 (d = d0 / scale).</p> <code>meters_per_pixel</code> <code>float</code> <p>World-space size corresponding to 1 pixel at distance d.</p> Notes <ul> <li>Uses Blender's view_frame on plane z = cam_z. width  = cam_x1 - cam_x0 height = cam_y1 - cam_y0</li> <li>Perspective: apparent_size \u221d size / distance equality \u21d2 size_max / d = (size_max * scale) / d0 \u21d2 d = d0 / scale.</li> </ul>"},{"location":"api/#npblender.Camera.pixels_per_meter","title":"pixels_per_meter","text":"<pre><code>pixels_per_meter(distances)\n</code></pre> <p>Returns the number of pixels per meter given the distances</p> Arguments <ul> <li>distances (array of floats) : the distances</li> </ul> <p>Returns:</p> Type Description <code>- array of floats : the size of a meter in pixels</code>"},{"location":"api/#npblender.Camera.visible_edges","title":"visible_edges","text":"<pre><code>visible_edges(mesh, radius=0.0, margin=0.0)\n</code></pre> <p>Mesh edges visibility</p> <p>The visibility of each point is computed with the given radius. An edge is considered invisible if both points are hidden for the same reason: both are left to the camera, or right, or behind...</p> <p>In the other case, the edge is considered as visible.</p> Arguments <p>mesh : Mesh     The mesh with points and edges radius : float     The radius of the camera margin : float     The margin of the camera</p> <p>Returns:</p> Name Type Description <code>vis</code> <code>array (n) of bools</code> <p>The visibility of each edge</p> <code>size</code> <code>array (n) of floats</code> <p>The size of the projected edges</p>"},{"location":"api/#npblender.Camera.visible_faces","title":"visible_faces","text":"<pre><code>visible_faces(mesh, margin=0.0, back_face_culling=False)\n</code></pre> <p>Mesh faces visibility</p> <p>A face is considered invisible if all its points are hidden for the same reason: all are left to the camera, or right, or behind...</p> Arguments <p>mesh : Mesh     The mesh with points and faces margin : float     The margin of the camera back_face_culling : bool     If True, the back face is not considered as visible</p> <p>Returns:</p> Name Type Description <code>vis</code> <code>array (n) of bools</code> <p>The visibility of each face</p> <code>size</code> <code>array (n) of floats</code> <p>The size of the projected faces</p> <code>proj</code> <code>array (n, 3) of floats</code> <p>The projected position of each face</p>"},{"location":"api/#npblender.Camera.visible_islands","title":"visible_islands","text":"<pre><code>visible_islands(mesh, islands, attribute='Island', margin=0.0)\n</code></pre> <p>Mesh islands visibility</p> <p>Islands are defined by an integer.</p> <p>Visibility is computed with the position and size of the islands</p> Arguments <p>mesh : Mesh     The mesh with points and faces islands: array of ints     One identifier per island attribute: attribute name     The attribute name to use for the islands margin : float     The margin of the camera</p> <p>Returns:</p> Type Description <code>    - couple of arrays : array[n, 7] of bools, array[n, 2] of floats</code>"},{"location":"api/#npblender.Camera.visible_points","title":"visible_points","text":"<pre><code>visible_points(verts, radius=0.0, margin=0.0, normals=None, return_proj=False)\n</code></pre> <p>Compute the visibility of vertices.</p> <p>For each vertex, the following values are computed: - visible : vertex is visible (all bools below are False) - behind : vertex is behind the visible rectangle - left : vertex is left to the visible rectangle - right : vertex if right to the visible rectangle - above : vertex is above the visible rectangle - below : vertex is below the visible rectangle - back : normal points outards - distance : distance to the camera - size : apparent size (based on radius)</p> Arguments <pre><code>- verts (array of vectors) : vertex locations\n- radius (array of floats or float = 0.) : size at the locations\n- margin (float, default=0.) : margin factor around the camera\n- normals (array of vectors = None) : normal pointing outwards are not visible\n</code></pre> <p>Returns:</p> Type Description <code>    - couple of arrays : array[n, 7] of bools, array[n, 2] of floats</code>"},{"location":"api/#npblender.Cloud","title":"Cloud","text":"<pre><code>Cloud(points=None, attr_from=None, **attrs)\n</code></pre> <p>               Bases: <code>Geometry</code></p> <p>Cloud Geometry class representing a collection of points with various attributes.</p> <p>This class provides methods to create, manipulate, and transform point clouds, including loading from and saving to Blender data structures, combining multiple clouds, and generating point distributions in various shapes (line, arc, circle, rectangle, pie, disk, cylinder, sphere, dome, cube, ball).</p> <p>Attributes:     points (Point): The vertices of the cloud with associated attributes.</p> <p>Methods:     from_geometry: Create a Cloud from another geometry with points.     from_cloud: Synonym for from_geometry.     capture: Capture data from another Cloud instance.     from_data: Initialize from Blender Mesh or PointCloud data.     to_data: Write the cloud geometry into a Blender Mesh.     from_object: Create a Cloud from a Blender object.     to_object: Create or update a Blender object with the cloud data.     object: Context manager for temporary Blender object editing.     join: Join other Clouds into this one.     transform, translate, scale: Geometric transformations.     Various distribution methods: line_dist, arc_dist, circle_dist, rect_dist, pie_dist, disk_dist,         cylinder_dist, sphere_dist, dome_dist, cube_dist, ball_dist for generating points in shapes.</p> <p>Cloud Geometry.</p> <p>Initialize a Cloud geometry object.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like of vectors</code> <p>The vertices of the cloud geometry. Default is None.</p> <code>None</code> <code>attr_from</code> <code>optional</code> <p>An optional source from which to join attributes.</p> <code>None</code> <code>**attrs</code> <code>dict</code> <p>Additional geometry attributes to be added.</p> <code>{}</code> Notes <ul> <li>Initializes an empty geometry with a Point container.</li> <li>Joins attributes from <code>attr_from</code> if provided.</li> <li>Appends given points and attributes to the geometry.</li> </ul>"},{"location":"api/#npblender.Cloud.capture","title":"capture","text":"<pre><code>capture(other)\n</code></pre> <p>Capture the data of another Mesh.</p> Arguments <pre><code>- other (Cloud) : the mesh to capture\n</code></pre> <p>Returns:</p> Type Description <code>    - self</code>"},{"location":"api/#npblender.Cloud.clear_geometry","title":"clear_geometry","text":"<pre><code>clear_geometry()\n</code></pre> <p>Clear the geometry.</p> <p>Delete all the content.</p>"},{"location":"api/#npblender.Cloud.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(data)\n</code></pre> <p>Initialize the geometry from a Blender data (Mesh or PointCloud)</p> Arguments <pre><code>- data (Blender Mesh or PointCloud) : the data to load\n</code></pre>"},{"location":"api/#npblender.Cloud.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(other, selection=None)\n</code></pre> <p>Create a Cloud from another gemetry with points domain.</p> Arguments <pre><code>- other (Geometry) : the geometry to copy\n- selection (selection) : a valid selection on points\n</code></pre> <p>Returns:</p> Type Description <code>    - Cloud</code>"},{"location":"api/#npblender.Cloud.from_object","title":"from_object  <code>classmethod</code>","text":"<pre><code>from_object(obj, evaluated=False)\n</code></pre> <p>Create a Mesh from an existing object.</p> Arguments <pre><code>- obj (str or Blender object) : the object to initialize from\n- evaluated (bool = False) : object modified by the modifiers if True, raw vertices otherwise\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Cloud.join","title":"join","text":"<pre><code>join(*others)\n</code></pre> <p>Join other clouds.</p> Arguments <pre><code>- other (Mesh) : the Meshes to append\n</code></pre>"},{"location":"api/#npblender.Cloud.to_data","title":"to_data","text":"<pre><code>to_data(data)\n</code></pre> <p>Write the geometry into a Blender Mesh</p> <p>[!CAUTION]: to_data creates a blender Mesh, not PointCloud since the pyton API doesn't allow to dynamically change the number of points</p> Arguments <pre><code>- mesh (Blender Mesh instance) : the mesh to write\n</code></pre>"},{"location":"api/#npblender.Cloud.to_object","title":"to_object","text":"<pre><code>to_object(obj, point_cloud=False, collection=None)\n</code></pre> <p>Create or update a blender object.</p> <p>By default, a mesh object is created. If as_point_cloud is True, the object is the converted to a PointCloud object.</p> Arguments <pre><code>- obj (str or Blender object) : the object the create\n- point_cloud (bool = False) : the object is a PointCloud object if True\n- collection (str or Blender collection) : the collection to add the object to\n</code></pre> <p>Returns:</p> Type Description <code>    - Blender Mesh or PointCloud object</code>"},{"location":"api/#npblender.Corner","title":"Corner","text":"<pre><code>Corner(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>               Bases: <code>Domain</code></p> <p>Corner domain stores a vertex index for face descriptions.</p> <p>This domain is specific to Mesh geometry. It keeps a pointer to the Mesh POINT domain.</p> <p>Attributes:</p> Name Type Description <code>- vertex_index (int)</code> <code>vertex index in the points array</code> <ul> <li>UVMap (float2, optional) : UV Map coordinates</li> </ul>"},{"location":"api/#npblender.Curve","title":"Curve","text":"<pre><code>Curve(points=None, splines=None, curve_type=POLY, materials=None, attr_from=None, **attrs)\n</code></pre> <p>               Bases: <code>Geometry</code></p> <p>Curve Geometry.</p> Arguments <pre><code>- points (array of vectors = None) : the vertices\n- splines (array of ints = None) : sizes\n- curve_type (array onf ints) : curve types\n- materials (str or list of strs = None) : list of materials used in the geometry\n- **attrs (dict) : other geometry attributes\n</code></pre>"},{"location":"api/#npblender.Curve.add_bezier","title":"add_bezier","text":"<pre><code>add_bezier(points, splines=None, handle_left=None, handle_right=None, cyclic=False, **attrs)\n</code></pre> <p>Add Bezier splines</p> <p>The arguments 'splines' gives the length(s) of the bezier spline(s). If None: - the number of points is taken (one spline is added) - points.shape[1] is taken if the shape of points is (m, , 3)</p> <p>handle_left and handle_right must have the same shape as points if provided. If they aren't provided, they are computed.</p> Arguments <ul> <li>points (array (n, 3) or (m, n, 3) of vectors) : the points of the curves</li> <li>splines (int or array of ints = None) : spline or splines length</li> <li>handle_left (same shape as points = None) : left handles</li> <li>handle_right (same shape as points = None) : right handles</li> <li>cyclic (bool = False) : whether the curve is cyclic or not</li> <li>attrs (dict) : spline and/or points attributes</li> </ul> <p>Returns:</p> Type Description <code>- dict ('points': added points indices, 'splines': added splines indices)</code>"},{"location":"api/#npblender.Curve.add_poly","title":"add_poly","text":"<pre><code>add_poly(points, splines=None, curve_type=POLY, cyclic=False, w=1.0, **attrs)\n</code></pre> <p>Add Poly or Nurbs splines</p> <p>The arguments 'splines' gives the length(s) of the spline(s). If None: - the number of points is taken (one spline is added) - points.shape[1] is taken if the shape of points is (m, , 3)</p> <p>Non bezeier splines use 4D points. If the provided vectors are 4D, the argument w is ignored.</p> Arguments <ul> <li>points (array (n, 3 or 4) or (m, n, 3 or 4) of vectors) : the points of the curves</li> <li>splines (int or array of ints = None) : spline or splines length</li> <li>cyclic (bool = False) : whether the curve is cyclic or not</li> <li>w (float) : w value, ignored if points are 4D</li> <li>attrs (dict) : spline and/or points attributes</li> </ul> <p>Returns:</p> Type Description <code>- dict ('points': added points indices, 'splines': added splines indices)</code>"},{"location":"api/#npblender.Curve.add_splines","title":"add_splines","text":"<pre><code>add_splines(points=None, splines=None, curve_type=POLY, **attrs)\n</code></pre> <p>Add splines</p>"},{"location":"api/#npblender.Curve.blender_data","title":"blender_data","text":"<pre><code>blender_data(readonly=False)\n</code></pre> <p>Acces to Blender Curve API.</p> <p>Transfer the geometry to a temporay Blender Curve. The example below use a blender Mesh to get the normals.</p> <pre><code>curve = Curve.Spiral()\n\nwith curve.blender_data() as bcurve:\n    print(\"Number of points\", len(bcurve.splines[0].points))\n\n# &gt; Number of points 65\n</code></pre> Arguments <pre><code>- readonly (bool=False) : don't read back the geometry if not modified\n</code></pre> <p>Returns:</p> Type Description <code>    - Blender Mesh</code>"},{"location":"api/#npblender.Curve.capture","title":"capture","text":"<pre><code>capture(other)\n</code></pre> <p>Capture the data of another Curve.</p> Arguments <pre><code>- other (Curve) : the mesh to capture\n</code></pre> <p>Returns:</p> Type Description <code>    - self</code>"},{"location":"api/#npblender.Curve.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Clear the geometry</p>"},{"location":"api/#npblender.Curve.compute_bezier_handles","title":"compute_bezier_handles  <code>staticmethod</code>","text":"<pre><code>compute_bezier_handles(points, cyclic=False, eps=1e-06)\n</code></pre> <p>Compute cubic Bezier handles (left/right) from anchors using Catmull-Rom style tangents.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>(N,3) or (B,N,3) float32/float64</code> <p>OPEN storage (no duplicated first point).</p> required <code>cyclic</code> <code>bool</code> <p>If True, wrap neighbors; else use one-sided differences at ends.</p> <code>False</code> <code>eps</code> <code>float</code> <p>Small epsilon to guard against zero-length tangents.</p> <code>1e-06</code> <p>Returns:</p> Type Description <code>left, right : same shape as `points`</code> <p>left[i]  = P[i] - T[i] * (len_in[i]  / 3) right[i] = P[i] + T[i] * (len_out[i] / 3) with len_in = ||P[i] - P[i-1]|| and len_out = ||P[i+1] - P[i]|| (wrapped if cyclic).</p>"},{"location":"api/#npblender.Curve.delete_points","title":"delete_points","text":"<pre><code>delete_points(points=None, splines=None)\n</code></pre> <p>Delete points.</p> Arguments <pre><code>points : points selection, optional\n    Points indices to delete directly.\nsplines : splines selection, optional\n    Splines owning vertices to delete.\n</code></pre>"},{"location":"api/#npblender.Curve.delete_splines","title":"delete_splines","text":"<pre><code>delete_splines(splines=None)\n</code></pre> <p>Delete splines.</p> Arguments <pre><code>splines : splines selection, optional\n    Splines owning vertices to delete.\n</code></pre>"},{"location":"api/#npblender.Curve.for_each_bucket","title":"for_each_bucket","text":"<pre><code>for_each_bucket(func)\n</code></pre> <p>Iterate over homogeneous spline buckets and call <code>func</code> once per bucket.</p> <p>Bucketing key: (curve_type, N, cyclic, resolution)    # resolution only relevant for BEZIER</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>Signature:     func(curve, curve_type, loop_total, is_cyclic, resolution=None) -&gt; any - <code>curve</code> is a Curve view on self . - <code>curve_type</code> is the spline type. - <code>loop_total</code> is the number of points in the spline. - <code>is_cyclic</code> is True if the spline is cyclic. - <code>resolution</code> is the resolution of the loop, or None if the spline is not Bezier.</p> required <p>Yields:</p> Type Description <code>(indices, result)</code> <p>indices : list[int]     Spline indices for this bucket, in stacking order. result : any     Whatever <code>func</code> returned for this bucket.</p>"},{"location":"api/#npblender.Curve.from_curve","title":"from_curve  <code>classmethod</code>","text":"<pre><code>from_curve(other, points=None, splines=None)\n</code></pre> <p>Create a Curve from another curve.</p> Arguments <pre><code>- other (Mesh) : the mesh to copy\n- points (selector = None) : points selection\n- splines (selector = None) : splines selection\n</code></pre> <p>Returns:</p> Type Description <code>    - Curve</code>"},{"location":"api/#npblender.Curve.from_curve_data","title":"from_curve_data  <code>classmethod</code>","text":"<pre><code>from_curve_data(data)\n</code></pre> <p>Initialize the geometry from a Blender Curve</p> Arguments <pre><code>- data (Blender Curve instance) : the curve to load\n</code></pre>"},{"location":"api/#npblender.Curve.from_object","title":"from_object  <code>classmethod</code>","text":"<pre><code>from_object(obj, evaluated=False)\n</code></pre> <p>Create a Curve from an existing curve.</p> Arguments <pre><code>- obj (str or Blender object) : the object to initialize from\n- evaluated (bool = False) : object modified by the modifiers if True, raw vertices otherwise\n</code></pre> <p>Returns:</p> Type Description <code>    - Curve</code>"},{"location":"api/#npblender.Curve.get_points_selection","title":"get_points_selection","text":"<pre><code>get_points_selection()\n</code></pre> <p>Get selection on points associated to the splines.</p> <p>If the Curve is not a view on splines, if return [:], otherwise it returns a selection on the points.</p> <p>Returns:</p> Type Description <code>    - sel (slice) : indices of splines points</code>"},{"location":"api/#npblender.Curve.join","title":"join","text":"<pre><code>join(*others)\n</code></pre> <p>Join other Curves.</p> Arguments <pre><code>- others (Curve) : the curves to append\n</code></pre>"},{"location":"api/#npblender.Curve.multiply","title":"multiply","text":"<pre><code>multiply(count, in_place=True)\n</code></pre> <p>Duplicate the geometry.</p> <p>Multiplying is a way to efficiently duplicate the geometry a great number of times. Once duplicated, the points can be reshapped to address each instance individually.</p> <pre><code>count = 16\n\ncube = Mesh.Cube() * count\n\n# Shape the points as 16 blocks of 8 vertices\npoints = np.reshape(cube.points.position, (16, 8, 3))\n\n# Place the cubes in a circle\nags = np.linspace(0, 2*np.pi, count, endpoint=False)\npoints[..., 0] += 6 * np.cos(ags)[:, None]\npoints[..., 1] += 6 * np.sin(ags)[:, None]\n\ncube.to_object(\"Cubes\")\n</code></pre> Arguments <pre><code>- count (int=10) : number of instances\n- attributes (name=value) : value for named attributes\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Curve.no_view","title":"no_view","text":"<pre><code>no_view()\n</code></pre> <p>Materialize a view-curve into a standalone curve (deep copy of splines and points), preserving all point-domain fields (handles, custom attrs, ...).</p>"},{"location":"api/#npblender.Curve.select","title":"select","text":"<pre><code>select(indices)\n</code></pre> <p>Explicit alias for subsetting splines; same semantics as curve[indices].</p>"},{"location":"api/#npblender.Curve.to_bezier","title":"to_bezier","text":"<pre><code>to_bezier(control_count=None, resolution=16)\n</code></pre> <p>Convert splines to Bezier splines (OPEN storage).</p> <p>Parameters:</p> Name Type Description Default <code>control_count</code> <code>int or None</code> <p>Number of anchor points to generate per spline. If None, keep current loop_total. For cyclic splines, anchors are sampled on [0,1) (no duplicate). For non-cyclic, on [0,1].</p> <code>None</code> <code>resolution</code> <code>int</code> <p>Per-segment resolution to write into <code>splines.resolution</code> (&gt;=1).</p> <code>16</code>"},{"location":"api/#npblender.Curve.to_curve_data","title":"to_curve_data","text":"<pre><code>to_curve_data(data)\n</code></pre> <p>Initialize the geometry from a Blender Curve</p> Arguments <pre><code>- data (Blender Curve instance) : the curve to load\n</code></pre>"},{"location":"api/#npblender.Curve.to_mesh","title":"to_mesh","text":"<pre><code>to_mesh(profile=None, caps=True, use_radius=True, camera_culling=False)\n</code></pre> <p>Transform curve to mesh</p> <p>If profile is None, the mesh contains only edges otherwise they are ignored</p> Arguments <ul> <li>profile (Curve = None) : profile curve</li> <li>caps (bool = True) : use caps</li> <li>use_radius (bool = True) : use the radius as a scale for profile</li> </ul> <p>Returns:</p> Type Description <code>-Mesh</code>"},{"location":"api/#npblender.Curve.to_object","title":"to_object","text":"<pre><code>to_object(obj, collection=None)\n</code></pre> <p>Create or update a blender object.</p> <p>The method 'to_object' creates the whole geometry. It creates a new object if it doesn't already exist. If the object exists, it must be a curve, there is no object type conversion.</p> <p>Once the object is created, use the method 'update_object' to change the vertices.</p> Arguments <pre><code>- obj (str or Blender object) : the object the create\n</code></pre> <p>Returns:</p> Type Description <code>    - Blender curve object</code>"},{"location":"api/#npblender.Curve.to_poly","title":"to_poly","text":"<pre><code>to_poly(resolution=None)\n</code></pre> <p>Convert the splines to Poly splines.</p> <p>If resolution is None: - <code>splines.resolution</code> is used to split Bezier segments - poly lines are left unchanged</p> <p>If resolution is not None, all splines are resampled using this value</p> Arguments: <pre><code>resolution (int):          Poly resolution, use spline resolution for Bezier if None.\n</code></pre>"},{"location":"api/#npblender.Edge","title":"Edge","text":"<pre><code>Edge(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>               Bases: <code>Domain</code></p> <p>Edge domain.</p> <p>Attributes:</p> Name Type Description <code>- vertex0 (int)</code> <code>index of the first vertex</code> <ul> <li>vertex1 (int) : index of the second vertex</li> </ul>"},{"location":"api/#npblender.Face","title":"Face","text":"<pre><code>Face(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>               Bases: <code>FaceSplineDomain</code></p>"},{"location":"api/#npblender.Face.area","title":"area","text":"<pre><code>area(corners, points)\n</code></pre> <p>Faces areas</p> <p>Args:     verts (array (:, 3) of floats): The vertices</p> <p>Returns:     array (len(self)) of floats: The surfaces</p>"},{"location":"api/#npblender.Face.area_vectors","title":"area_vectors","text":"<pre><code>area_vectors(corners, points)\n</code></pre> <p>Compute the surfaces vectors</p> <p>The surfaces are computed by cross products of triangles. This also gives the normal to the face. The normal vector normal the length of which is the surface is called the surface vector.</p> Arguments <pre><code>- faces (int or array of ints = None) : the faces\n</code></pre> <p>Returns:</p> Type Description <code>    - array of vectors of floats: The surfaces normals</code>"},{"location":"api/#npblender.Face.get_edges","title":"get_edges","text":"<pre><code>get_edges(corners)\n</code></pre> <p>Get all the edge couples of the faces.</p>"},{"location":"api/#npblender.Face.get_face_edges","title":"get_face_edges","text":"<pre><code>get_face_edges(corners)\n</code></pre> <p>Return edge couples with ordered vertex indices par face.</p> <p>The face edge couples can be accessed via loop_start and loop_total</p>"},{"location":"api/#npblender.Face.normal","title":"normal","text":"<pre><code>normal(corners, points)\n</code></pre> <p>Compute the normals</p> <p>Args:     verts (array (:, 3) of floats): The vertices</p> <p>Returns:     array (len(self), 3) of floats: The normals</p>"},{"location":"api/#npblender.Face.position","title":"position","text":"<pre><code>position(corners, points)\n</code></pre> <p>Centers of the faces</p> <p>Args:     verts (array (:, 3) of floats): The vertices</p> <p>Returns:     array (len(self), 3) of floats: The centers</p>"},{"location":"api/#npblender.FieldArray","title":"FieldArray","text":"<pre><code>FieldArray(a=None, mode='COPY', selector=None)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Dynamic structured array</p> <p>A structured array with cache management to optimize record appending.</p> <p>Initialize the array with another array</p> Arguments <ul> <li>a (array or FieldArray) : the array to initialize from</li> <li>mode (str in 'COPY', 'CAPTURE', 'EMPTY') : copy the content</li> <li>selector (Any = None) : a selector on data</li> </ul>"},{"location":"api/#npblender.FieldArray.actual_names","title":"actual_names  <code>property</code>","text":"<pre><code>actual_names\n</code></pre> <p>Column names.</p> <p>Returns the actual field names, excluding optional fields.</p>"},{"location":"api/#npblender.FieldArray.all_names","title":"all_names  <code>property</code>","text":"<pre><code>all_names\n</code></pre> <p>Column names.</p> <p>Returns all the field names, including optional ones.</p>"},{"location":"api/#npblender.FieldArray.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Array structured dtype</p> <p>Returns the dtype property of the structured array.</p>"},{"location":"api/#npblender.FieldArray.__array__","title":"__array__","text":"<pre><code>__array__(dtype=None)\n</code></pre> <p>Allow implicit conversion to np.ndarray</p>"},{"location":"api/#npblender.FieldArray.add","title":"add","text":"<pre><code>add(count, **fields)\n</code></pre> <p>Add count records</p> <p>New records are set with default values or values provided by the user in fields dict.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of records to add.</p> required <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/#npblender.FieldArray.append","title":"append","text":"<pre><code>append(**fields)\n</code></pre> <p>Append values to the structured array.</p> <p>The number of records to append is determined by the number of fields provided in the fields dictionary. The values of the fields are copied to the new records.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/#npblender.FieldArray.as_kwargs","title":"as_kwargs","text":"<pre><code>as_kwargs(selector=None, include=None, exclude=None)\n</code></pre> <p>Return a dictionary of field values formatted as kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>slice, int, list, or mask</code> <p>Optional selection of elements to extract.</p> <code>None</code> <code>include</code> <code>list[str]</code> <p>List of field names (original or python names) to include.</p> <code>None</code> <code>exclude</code> <code>list[str]</code> <p>List of field names (original or python names) to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Mapping from python-safe field names to array values.</p>"},{"location":"api/#npblender.FieldArray.copy_field","title":"copy_field","text":"<pre><code>copy_field(field_name, new_name, **infos)\n</code></pre> <p>Duplicate an existing field under a new name, with optional metadata overrides.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the existing field to copy.</p> required <code>new_name</code> <code>str</code> <p>The name of the new field to create.</p> required <code>infos</code> <code>keyword arguments</code> <p>Optional metadata (e.g. default, unit, description...) to override or supplement the original field's metadata.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the source field does not exist.</p> <code>ValueError</code> <p>If the target name already exists or is reserved.</p>"},{"location":"api/#npblender.FieldArray.delete","title":"delete","text":"<pre><code>delete(index)\n</code></pre> <p>Delete a selection of items from the array.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int, slice, or array-like</code> <p>The indices of the elements to delete from the current data.</p> required Notes <p>This operates only on the valid range <code>[0:self._length]</code>. The internal buffer is preserved (no reallocation).</p>"},{"location":"api/#npblender.FieldArray.extend","title":"extend","text":"<pre><code>extend(other, join_fields=True)\n</code></pre> <p>Append multiple records from another array or FieldArray.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray or structured np.ndarray</code> <p>The array of records to append. Must have named fields matching a subset of the current array's fields.</p> required"},{"location":"api/#npblender.FieldArray.filtered","title":"filtered","text":"<pre><code>filtered(selector, *, copy=False)\n</code></pre> <p>Return a FieldArray containing only the selected records.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>array\u2011like, slice or int</code> <p>Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice. It is applied to the current valid part of the buffer (<code>self._data[:self._length]</code>).</p> required <code>copy</code> <code>bool</code> <ul> <li>False    (default) =&gt; the new array shares the same memory                          (changes propagate both ways).</li> <li>True           =&gt; the data are physically copied.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>FieldArray</code> <p>A new instance holding exactly <code>len(selector)</code> records and inheriting the current field\u2011infos.</p>"},{"location":"api/#npblender.FieldArray.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Build a FieldArray from a dictionary with field data and optional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, array - like or (array, dict)]</code> <p>Mapping field names to arrays or (array, infos). Infos must include NAME.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the data. Default: True.</p> required <p>Returns:</p> Type Description <code>FieldArray</code>"},{"location":"api/#npblender.FieldArray.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> <p>Get attribute by name.</p> <p>If name is not an actual field, return default value. Name can be an array.</p> <pre><code>pos = field_array.get(\"position\", (0, 0, 1))\npos = field_array.get([[0, 0, 1], [0, 0, 0]])\n</code></pre>"},{"location":"api/#npblender.FieldArray.join_fields","title":"join_fields","text":"<pre><code>join_fields(other, exclude=[])\n</code></pre> <p>Add all missing fields from another FieldArray.</p> <p>For every field in <code>other</code> that is not present in <code>self</code>, a new field is created with the same dtype and shape, and initialized with its default value across all existing records.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray</code> <p>Another FieldArray instance whose fields will be checked for missing fields.</p> required <p>Returns:</p> Type Description <code>self</code>"},{"location":"api/#npblender.FieldArray.multiply","title":"multiply","text":"<pre><code>multiply(count)\n</code></pre> <p>Duplicate the current records <code>count</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of times to repeat the current records.</p> required Notes <p>This duplicates the current valid records (up to self._length). If the array is empty or count &lt;= 1, nothing happens.</p> Example: <p>If the array has 3 records and count == 4, the result will be:</p> <p>[rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]</p>"},{"location":"api/#npblender.FieldArray.new_field","title":"new_field","text":"<pre><code>new_field(name, dtype, shape=None, default=0, optional=False, **infos)\n</code></pre> <p>Add a field to the structured array.</p> Arguments <pre><code>- name (str) : field name\n- dtype (type) : a valid numpy dtype\n- shape (tuple = None) : the shape of the field\n- default (any = 0) : default value\n- optional (bool = False) : the field is created only when accessed\n- infos (dict) : field infos\n</code></pre>"},{"location":"api/#npblender.FieldArray.to_dict","title":"to_dict","text":"<pre><code>to_dict(*, copy=True, with_infos=True)\n</code></pre> <p>Convert the array to a dictionary of fields or (field, infos) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Whether to copy the arrays.</p> <code>True</code> <code>with_infos</code> <code>bool</code> <p>If True, return (array, infos) for each field.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, array or (array, dict)]</code>"},{"location":"api/#npblender.Geometry","title":"Geometry","text":""},{"location":"api/#npblender.Geometry.add_materials","title":"add_materials","text":"<pre><code>add_materials(materials)\n</code></pre> <p>Add a materials list to the existing one.</p> <p>If a material already exist, it is not added another time.</p> Arguments <pre><code>- materials (list of strs) : the list of materials to append.\n</code></pre>"},{"location":"api/#npblender.Geometry.get_material_index","title":"get_material_index","text":"<pre><code>get_material_index(mat_name)\n</code></pre> <p>Return the index of a material name.</p> <p>If the material doesn't exist, it is created</p> Arguments <pre><code>- mat_name (str) : material name\n</code></pre> <p>Returns:</p> Type Description <code>    - int : index of the material name in the materials list</code>"},{"location":"api/#npblender.Geometry.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other, **kwargs)\n</code></pre> <p>Capture the attributes from another geometry.</p> <p>Other can be a different geometry, in that case, only domains with the same name are captured. kwargs allows to filter the domains to capture:</p> <pre><code>mesh.join_attributes(other_mesh, faces=False)\nmesh.join_attributes(curve)\n</code></pre> <p>Returns:     - self</p>"},{"location":"api/#npblender.Geometry.load_models","title":"load_models  <code>staticmethod</code>","text":"<pre><code>load_models(*specs)\n</code></pre> <p>Load a geometry or geometries from specifications.</p> <p>The specs can be:     - a Blender collection     - a Blender object     - a Geometry</p> Arguments <pre><code>- specs (list of objects / collections) : the models to load\n</code></pre> <p>Returns:</p> Type Description <code>    - list of geometries</code>"},{"location":"api/#npblender.Geometry.load_object","title":"load_object  <code>staticmethod</code>","text":"<pre><code>load_object(name)\n</code></pre> <p>Load a Blender object and returns either a Mesh or a Curve.</p> Arguments <pre><code>- name (str or bpy.types.Object) : the object to load\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh or Curve</code>"},{"location":"api/#npblender.Instances","title":"Instances","text":"<pre><code>Instances(points=None, models=None, model_index=None, attr_from=None, **attributes)\n</code></pre> <p>               Bases: <code>Geometry</code></p> <p>Create new instances.</p> Arguments <pre><code>- points (array of vectors = None) : instances locations\n- models (geometry or list of geometries = None) : the geometries to instantiate\n- model_index (int = 0) : model index of instances\n- **attributes (dict) : other geometry attributes\n</code></pre>"},{"location":"api/#npblender.Mesh","title":"Mesh","text":"<pre><code>Mesh(points=None, corners=None, faces=None, edges=None, materials=None, attr_from=None, **attrs)\n</code></pre> <p>               Bases: <code>Geometry</code></p> <p>Mesh Geometry.</p> Arguments <pre><code>- points (array of vectors = None) : the vertices\n- corners (array of ints = None) : corners, i.e. indices on the array of points\n- faces (array of ints = None) : size of the faces, the sum of this array must be equal to the length of the corners array\n- edges (array of couples of ints = None) : list of edges defined by two vertex indices\n- materials (str or list of strs = None) : list of materials used in the geometry\n- attr_from (Geometry) : domain attributes to copy from\n- **attrs (dict) : other geometry attributes\n</code></pre>"},{"location":"api/#npblender.Mesh.add_geometry","title":"add_geometry","text":"<pre><code>add_geometry(points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs)\n</code></pre> <p>Add geometry to the mesh.</p> <p>This method adds vertices, edges, corners, and faces to the mesh. The added geometry can reference existing vertices and is appended without shifting indices.</p> <p>Note:     To add independent geometry (with new vertices), use <code>Mesh.join_geometry</code> instead.</p> <p>Examples:</p> <p>cube = Mesh.cube()</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like of vectors</code> <p>Vertices to add to the mesh.</p> <code>None</code> <code>corners</code> <code>array-like of int</code> <p>Indices referring to vertices in the points array.</p> <code>None</code> <code>faces</code> <code>int, array-like of int, or list of lists</code> <p>Defines the faces: - If <code>corners</code> is provided:     - None: Single face made of all corners.     - int: All faces have the same size (must divide the number of corners).     - array-like: Face sizes; sum must equal the number of corners. - If <code>corners</code> is None:     - Must be a list of lists, each sublist is a list of corners.</p> <code>None</code> <code>edges</code> <code>array-like of pairs of int</code> <p>Edges defined by pairs of vertex indices.</p> <code>None</code> <code>safe_mode</code> <code>bool</code> <p>If True, perform a mesh integrity check after adding geometry.</p> <code>False</code> <code>**attrs</code> <code>dict</code> <p>Additional geometry attributes to apply.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys {'points', 'corners', 'faces', 'edges'} mapping to lists of added geometry indices.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If faces and corners lengths are inconsistent or invalid.</p>"},{"location":"api/#npblender.Mesh.add_geometry--add-a-triangle-on-existing-vertices","title":"Add a triangle on existing vertices","text":""},{"location":"api/#npblender.Mesh.add_geometry--corners-argument-refers-to-cube-vertices","title":"corners argument refers to cube vertices","text":"<p>cube.add_geometry(corners=[0, 1, 2], faces=3)</p>"},{"location":"api/#npblender.Mesh.add_geometry--add-a-triangle-with-additional-vertices","title":"Add a triangle with additional vertices","text":""},{"location":"api/#npblender.Mesh.add_geometry--corners-argument-refers-to-the-new-vertices","title":"corners argument refers to the new vertices","text":"<p>cube.join_geometry(points=[[0, 0, 0], [0, 1, 0], [1, 0, 0]], corners=[0, 1, 2], faces=3)</p>"},{"location":"api/#npblender.Mesh.add_points","title":"add_points","text":"<pre><code>add_points(points, **attributes)\n</code></pre> <p>Add vertices.</p> Arguments <pre><code>- points (array of vectors) : the vertices to add\n- attributes (name=value) : value for named attributes\n</code></pre> <p>Returns:</p> Type Description <code>    - array of ints : indices of the added vertices</code>"},{"location":"api/#npblender.Mesh.bl_circle","title":"bl_circle  <code>classmethod</code>","text":"<pre><code>bl_circle(radius=1, segments=16, fill_tris=False, materials=None)\n</code></pre> <p>Create a Circle.</p> <p>Blender constructor for a Circle.</p> Arguments <pre><code>- radius (float=1.) : circle radius\n- segments (int=16) : number of segments\n- fill_tris (bool = False) : fill with triangle fans\n- materials (list of strs = None) : materials list\n- transformation (Transformations = None) : the transformation to apply\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Mesh.bl_cone","title":"bl_cone  <code>classmethod</code>","text":"<pre><code>bl_cone(radius1=1, radius2=0, depth=2, segments=16, side_segments=1, cap_ends=True, cap_tris=False, materials=None)\n</code></pre> <p>Create a Cone.</p> <p>Blender constructor for a Cone.</p> Arguments <pre><code>- radius1 (float=1.) : base radius\n- radius2 (float=0.) : top radius\n- depth (float=2.) : cone height\n- segments (int=16) : number of segments\n- cap_ends (bool=True) : fill cap faces\n- cap_tris (bool = False) : fill with triangle fans\n- materials (list of strs = None) : materials list\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Mesh.bl_grid","title":"bl_grid  <code>classmethod</code>","text":"<pre><code>bl_grid(x_segments=1, y_segments=1, size=2, materials=None)\n</code></pre> <p>Create a Grid.</p> <p>Blender constructor for a Grid.</p> Arguments <pre><code>- x_segments (int=1) : number of segments along x axis\n- y_segments (int=1) : number of segments along y axis\n- size (float or tuple of floats = 1. : size of the grid\n- materials (list of strs = None) : materials list\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Mesh.blender_data","title":"blender_data","text":"<pre><code>blender_data(readonly=False)\n</code></pre> <p>Acces to Blender Mesh API.</p> <p>Transfer the geometry to a temporay Blender Mesh. The example below use a blender Mesh to get the normals.</p> <pre><code>mesh = Mesh.Cube()\n\nwith mesh.blender_data() as data:\n    normals = np.array([poly.normal for poly in data.polygons])\n\nprint(normals)\n\n# &gt; [[-1. -0.  0.]\n#    [ 0.  1.  0.]\n#    [ 1. -0.  0.]\n#    [ 0. -1.  0.]\n#    [ 0.  0. -1.]\n#    [ 0. -0.  1.]]\n</code></pre> Arguments <pre><code>- readonly (bool=False) : don't read back the geometry if not modified\n</code></pre> <p>Returns:</p> Type Description <code>    - Blender Mesh</code>"},{"location":"api/#npblender.Mesh.bmesh","title":"bmesh","text":"<pre><code>bmesh(readonly=False)\n</code></pre> <p>Acces to bmesh api.</p> <p>The example below use bmesh to offset the vertices of +1 in the x axis.</p> <pre><code>mesh = Mesh.Cube()\n\n# Move the vertices with bmesh\nwith mesh.bmesh() as bm:\n    for v in bm.verts:\n        v.co.x += 1.0\n\n# Move the vertices directy in numpy array\nmesh.points.position[:, 1] += 1\n\n# Cube moved along x and y\nmesh.to_object(\"Cube\")\n</code></pre> Arguments <pre><code>- readonly (bool=False) : avoid to read back the bmesh if not modications were done\n</code></pre>"},{"location":"api/#npblender.Mesh.boolean","title":"boolean","text":"<pre><code>boolean(other, operation='DIFFERENCE')\n</code></pre> <p>Apply a boolean operation with another object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Mesh</code> <p>The object to use as boolean operand.</p> required <code>operation</code> <code>str</code> <p>Boolean operation: 'INTERSECT', 'UNION', or 'DIFFERENCE'.</p> <code>'DIFFERENCE'</code>"},{"location":"api/#npblender.Mesh.bridge_loops","title":"bridge_loops","text":"<pre><code>bridge_loops(loop0, loop1, close=False, segments=1, **attributes)\n</code></pre> <p>Create a grid linking two loops of the same size.</p> Arguments <ul> <li>loop0 (array of ints) : the first loop</li> <li>loop1 (array of ints) : the second loop</li> <li>segments (int = 1) : the number of segments to join the loops</li> <li>attributes (dict) : attributes to add to the mesh</li> </ul>"},{"location":"api/#npblender.Mesh.capture","title":"capture","text":"<pre><code>capture(other)\n</code></pre> <p>Capture the data of another Mesh.</p> Arguments <pre><code>- other (Mesh) : the mesh to capture\n</code></pre> <p>Returns:</p> Type Description <code>    - self</code>"},{"location":"api/#npblender.Mesh.chain_link","title":"chain_link  <code>classmethod</code>","text":"<pre><code>chain_link(major_segments=48, minor_segments=12, radius=1.0, section=0.5, length=4.0, materials=None)\n</code></pre> <p>Create a chain link.</p> <pre><code># ----- Some maths\n\n# Chain follows a catenary curve\ndef catenary(t):\n    return np.stack((t, np.zeros_like(t), np.cosh(t)), axis=-1)\n\n# Orientation is given by the derivative\ndef derivative(t):\n    dt = 1/10000\n    return (catenary(t + dt) - catenary(t - dt))/(2*dt)\n\n# Catenary length\npts = catenary(np.linspace(-1, 1, 1000))\ncat_s = np.cumsum(np.linalg.norm(pts[1:] - pts[:-1], axis=-1))\ncat_len = cat_s[-1]\n\n# Catenary inverse : t from length\ndef cat_inverse(l):\n    return 2*np.argmin(np.abs(cat_s - l))/1000 - 1\n\n# ----- Let's build the geometry\n\n# One chain link\nsection = .02\nlength  = .15\nlink = MeshBuilder.ChainLink(radius=.04, section=section, length=length)\n\n# Link length taking into account the section\nl = length - 2*section\n\n# Number of links\ncount = round(cat_len / l)\n\n# The chain\nchain = link*count\n\n# Rotate pi/2 one on two\neulers = Eulers(shape=count)\neulers[[i % 2 == 1 for i in range(count)]] = (0, np.pi/2, 0)\n\nchain.rotate(eulers)\nchain.rotate_z(np.pi/2)\n\n# Location of each link\nt = np.array([cat_inverse(l*i) for i in range(count)])\n\nchain.toward(derivative(t), track_axis='X', up_axis='Z')\nchain.translate(catenary(t))\n\n# To object\nchain.to_object(\"Catenary\")\n</code></pre> Arguments <pre><code>- major_segments (int=48) : number of segments for the link\n- minor_segments (int=12) : number of segments for the section\n- radius (float=1.) : radius of the link\n- section (float=.5) : section (diameter)\n- length (float=4.) : total length of the link\n- materials (list of strs = None) : materials list\n</code></pre> <p>Returns:</p> Type Description <code>    - MeshBuilder</code>"},{"location":"api/#npblender.Mesh.circle","title":"circle  <code>classmethod</code>","text":"<pre><code>circle(radius=1, segments=16, fill_segments=0, cap='NONE', materials=None)\n</code></pre> <p>Create a Circle.</p> <p>'fill_segments' argument gives the number of internal circles to create. If zero, the circle if filled with a polygon. If positive, the circle is filled with triangle fans.</p> Arguments <pre><code>- radius (float=1.) : circle radius\n- segments (int=16) : number of segments\n- fill_segments (int = 0) : number of internal segments, polygon is None\n- materials (list of strs = None) : materials list\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Mesh.clear_geometry","title":"clear_geometry","text":"<pre><code>clear_geometry()\n</code></pre> <p>Clear the geometry.</p> <p>Delete all the content.</p>"},{"location":"api/#npblender.Mesh.cone","title":"cone  <code>classmethod</code>","text":"<pre><code>cone(vertices=32, side_segments=1, fill_segments=1, radius_top=0, radius_bottom=1, depth=2, fill_type='NGON', materials=None)\n</code></pre> <p>Create a Cone.</p> Arguments <pre><code>- vertices (int=16) : number of segments\n- side_segments (int = 1) : number of vertical segments\n- fill_segments (int = 1) : number of internal circles on the caps\n- radius_top (float=0) : top radius\n- radius_bottom (float=1) : bottom radius\n- depth (float=2.) : cylinder height\n- fill_type (str or couple of strs ='NGON' in 'NGON', 'FANS', 'NONE') : cap filling\n- materials (list of strs = None) : materials list\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Mesh.cube","title":"cube  <code>classmethod</code>","text":"<pre><code>cube(size=2, materials=None)\n</code></pre> <p>Create a Cube.</p> Arguments <pre><code>- size (float=1.) : size of the cube\n- materials (list of strs = None) : materials list\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Mesh.cylinder","title":"cylinder  <code>classmethod</code>","text":"<pre><code>cylinder(vertices=32, side_segments=1, radius=1, depth=2, fill_type='NGON', materials=None)\n</code></pre> <p>Create a Cylinder.</p> Arguments <pre><code>- vertices (int=16) : number of segments\n- side_segments (int = 1) : number of vertical segments\n- radius (float=1.) : radius\n- depth (float=2.) : cylinder height\n- fill_type (str or couple of strs ='NGON' in 'NGON', 'TRIANGLE_FAN', 'NONE') : cap filling\n- materials (list of strs = None) : materials list\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Mesh.delete_faces","title":"delete_faces","text":"<pre><code>delete_faces(selection)\n</code></pre> <p>Delete only faces.</p>"},{"location":"api/#npblender.Mesh.delete_vertices","title":"delete_vertices","text":"<pre><code>delete_vertices(points=None, faces=None, edges=None)\n</code></pre> <p>Delete vertices.</p> Arguments <pre><code>points : array selection, optional\n    Vertex indices to delete directly.\nfaces : array selection, optional\n    Faces owning vertices to delete.\nedges : array selection, optional\n    Edges owning vertices to delete.\n</code></pre>"},{"location":"api/#npblender.Mesh.disk","title":"disk  <code>classmethod</code>","text":"<pre><code>disk(radius=1, segments=16, fill_segments=0, cap='NGON', materials=None)\n</code></pre> <p>Create a disk.</p> <p>Same as circle but default cap is NGON</p>"},{"location":"api/#npblender.Mesh.extrude_faces","title":"extrude_faces","text":"<pre><code>extrude_faces(selection, offset=None, scale=1.0)\n</code></pre> <p>Extrude individual faces.</p> <p>If offset is None, faces are extruder along their normal</p> Arguments <pre><code>- selection : indices of the faces to extrude\n- offset (vector or array of vectors) : the extrusion vector\n- scale (float = 1) : scale factor for offsets\n- dissolve (bool = True) : remove starting faces\n</code></pre> <p>Returns:</p> Type Description <code>    - dictionnary : 'top' : extruded faces, 'side' : extruded side faces</code>"},{"location":"api/#npblender.Mesh.extrude_loop","title":"extrude_loop","text":"<pre><code>extrude_loop(loop, offset, close=False, clockwise=False, **attributes)\n</code></pre> <p>Extrude a loop of vertices.</p> Arguments <pre><code>- loop (array of ints) : vertex indices\n- offset (float = 1) : multiplicator of the direction vector\n- direction (vector = None) : extrusion direction, normal if None\n- clockwise (bool=False) : faces orientation\n- attributes : attribute for the new geometry\n</code></pre> <p>Returns:</p> Type Description <code>    - dictionnary of the created geometry : vertex indices, face indices</code>"},{"location":"api/#npblender.Mesh.extrude_region","title":"extrude_region","text":"<pre><code>extrude_region(selection, offset=(0, 0, 1), dissolve=False)\n</code></pre> <p>Extrude individual faces.</p> Arguments <pre><code>- selection : indices of the faces to extrude\n- offset (vector = (0, 0, 1)) : the extrusion vector\n- dissolve (bool = True) : remove starting faces\n</code></pre> <p>Returns:</p> Type Description <code>    - dictionnary : 'top' : extruded faces, 'side' : extruded side faces</code>"},{"location":"api/#npblender.Mesh.extrude_vertices","title":"extrude_vertices","text":"<pre><code>extrude_vertices(selection, offset, **attributes)\n</code></pre> <p>Extrude individual vertices</p> Arguments <pre><code>- selection (selector) : points selection, all if None\n- offset (vector or array of vectors) : extrusion vector\n- attributes (dict) : points attributes\n</code></pre> <p>Returns:</p> Type Description <code>    - dictionnary of the created geometry : vertex indices, face indices</code>"},{"location":"api/#npblender.Mesh.fill_cap","title":"fill_cap","text":"<pre><code>fill_cap(loop, mode='NGON', center=None, segments=1, clockwise=False, **attributes)\n</code></pre> <p>Fill a cap between an existing loop</p> <p>For NGON mode, center is not required. For FANS mode, a center point is required: - if center is None, it is computed as the center of the loop - if center is an int, it is the index of the point to use - otherwise, the center is considered as the point to use</p> Arguments <ul> <li>loop (array of ints) : the circle loop</li> <li>mode (FillCap = 'NGON') : NGON or FANS</li> <li>center (point index or point or None) : center of the cap</li> <li>clockwise (bool = False) : order of the corners in the loop</li> <li>indexing (str = 'ij') : indexing of the points</li> <li>attributes (dict) : attributes to add to the mesh (see Geometry.add_geometry(</li> </ul>"},{"location":"api/#npblender.Mesh.from_mesh","title":"from_mesh  <code>classmethod</code>","text":"<pre><code>from_mesh(other, points=None, faces=None, edges=None)\n</code></pre> <p>Create a Mesh from another mesh.</p> Arguments <pre><code>- other (Mesh) : the mesh to copy\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Mesh.from_mesh_data","title":"from_mesh_data  <code>classmethod</code>","text":"<pre><code>from_mesh_data(data)\n</code></pre> <p>Initialize the geometry from a Blender Mesh</p> Arguments <pre><code>- mesh (Blender Mesh instance) : the mesh to load\n</code></pre>"},{"location":"api/#npblender.Mesh.from_object","title":"from_object  <code>classmethod</code>","text":"<pre><code>from_object(obj, evaluated=False)\n</code></pre> <p>Create a Mesh from an existing object.</p> Arguments <pre><code>- obj (str or Blender object) : the object to initialize from\n- evaluated (bool = False) : object modified by the modifiers if True, raw vertices otherwise\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Mesh.get_islands","title":"get_islands","text":"<pre><code>get_islands()\n</code></pre> <p>Get an island id per face.</p>"},{"location":"api/#npblender.Mesh.grid","title":"grid  <code>classmethod</code>","text":"<pre><code>grid(size_x=1, size_y=1, vertices_x=3, vertices_y=3, materials=None)\n</code></pre> <p>Create a Grid.</p> <p>[!IMPORTANT] Grid is created with indexing = 'ij': shape = (resolution x, resolution y)</p> Arguments <pre><code>- size_x (float=1) : size along x\n_ size_y (float=1) : size along y\n- vertices_x (int=3) : number of vertices along x\n- vertices_y (int=3) : number of vertices along y\n- materials (list of strs = None) : materials list\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Mesh.icosphere","title":"icosphere  <code>classmethod</code>","text":"<pre><code>icosphere(radius=1, subdivisions=2, materials=None)\n</code></pre> <p>Create a IcoSphere.</p> <p>Blender constructor for a IcoSphere.</p> Arguments <pre><code>- radius (float=1.) : radius\n- subdivisions (int=2) : number subdivisions\n- materials (list of strs = None) : materials list\n- transformation (Transformations = None) : the transformation to apply\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Mesh.inset_faces","title":"inset_faces","text":"<pre><code>inset_faces(selection, thickness=0.1, depth=0.0, use_even_offset=True, use_relative_offset=False)\n</code></pre> <p>Extrude individual faces.</p> <p>If offset is None, faces are extruder along their normal</p> Arguments <p>selection : selection on faces     indices of the faces to inset thickness : float     Inset thickness. depth : float     Inset depth (extrusion). use_even_offset : bool     Keep consistent thickness. use_relative_offset : bool     Offset relative to face size.</p> <p>Returns:</p> Type Description <code>dict with:</code> <p>'faces' : list of new inset faces</p>"},{"location":"api/#npblender.Mesh.join","title":"join","text":"<pre><code>join(*others)\n</code></pre> <p>Join other Meshes.</p> Arguments <pre><code>- others (Mesh) : the Mesh to append\n</code></pre>"},{"location":"api/#npblender.Mesh.join_geometry","title":"join_geometry","text":"<pre><code>join_geometry(points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs)\n</code></pre> <p>Join geometry defined by components.</p> <p>The geometry passed in argument is consistent and doesn't refer to existing vertices. It is used to build an independant mesh which is then joined. See 'add_geometry' which, on the contrary, can refer to existing vertices.</p> <p>Returns:</p> Type Description <code>    - self</code>"},{"location":"api/#npblender.Mesh.line","title":"line  <code>classmethod</code>","text":"<pre><code>line(start=(0, 0, 0), end=(0, 0, 1), segments=1, materials=None)\n</code></pre> <p>Create a mesh with lines between the given positions.</p> Arguments <pre><code>- start (vertex =(0, 0, 0) : position of the start of the lines\n- end (vertex=(0, 0, 1) : position of the end of the lines\n- count (int=2) : number of points in the line\n</code></pre> <p>Returns:</p> Type Description <code>    - mesh (Mesh) : the mesh</code>"},{"location":"api/#npblender.Mesh.monkey","title":"monkey  <code>classmethod</code>","text":"<pre><code>monkey(materials=None)\n</code></pre> <p>Create a Monkey.</p> Arguments <pre><code>- materials (list of strs = None) : materials list\n</code></pre> <p>Returns:</p> Type Description <code>    - MeshBuilder</code>"},{"location":"api/#npblender.Mesh.multiply","title":"multiply","text":"<pre><code>multiply(count, in_place=True)\n</code></pre> <p>Duplicate the geometry.</p> <p>Multiplying is a way to efficiently duplicate the geometry a great number of times. Once duplicated, the vertices can be reshapped to address each instance individually.</p> <pre><code>count = 16\n\ncube = Mesh.Cube() * count\n\n# Shape the points as 16 blocks of 8 vertices\npoints = np.reshape(cube.points.position, (16, 8, 3))\n\n# Place the cubes in a circle\nags = np.linspace(0, 2*np.pi, count, endpoint=False)\npoints[..., 0] += 6 * np.cos(ags)[:, None]\npoints[..., 1] += 6 * np.sin(ags)[:, None]\n\ncube.to_object(\"Cubes\")\n</code></pre> Arguments <pre><code>- count (int=10) : number of instances\n- attributes (name=value) : value for named attributes\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Mesh.points_cloud","title":"points_cloud  <code>classmethod</code>","text":"<pre><code>points_cloud(points=None, materials=None)\n</code></pre> <p>Create a mesh with points at the given positions.</p> Arguments <pre><code>- position (shaped array (?, 3)=(0, 0, 0) : position of the points\n</code></pre> <p>Returns:</p> Type Description <code>    - mesh (Mesh) : the mesh</code>"},{"location":"api/#npblender.Mesh.pyramid","title":"pyramid  <code>classmethod</code>","text":"<pre><code>pyramid(size=1, materials=None)\n</code></pre> <p>Create a Pyramid.</p> Arguments <pre><code>- size (float=1.) : size\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Mesh.remove_doubles","title":"remove_doubles","text":"<pre><code>remove_doubles(dist=0.001)\n</code></pre> <p>Remove doubles.</p> <p>Arguments:     - dist (float=0.001) : maximum distance between vertices to merge.</p>"},{"location":"api/#npblender.Mesh.separate_faces","title":"separate_faces","text":"<pre><code>separate_faces(groups=None)\n</code></pre> <p>Split faces into isolated islands</p> Arguments <ul> <li>groups (list of ints):     group ids of faces</li> </ul>"},{"location":"api/#npblender.Mesh.solidify","title":"solidify","text":"<pre><code>solidify(thickness=0.01, offset=-1)\n</code></pre> <p>Boolean difference with another MeshBuilder.</p> <p>The methods uses the Solidify Modifier</p> <pre><code>glass = Mesh.Circle(segments=128)\nglass.extrude_faces(0, -.01)\nglass.extrude_faces(0, -2)\nglass.extrude_faces(0, -.01)\n\nglass.points.translate((0, 0, 2))\n\nglass = glass.solidify(thickness=.1)\n\nglass.to_object(\"Solidify\", shade_smooth=True)\n</code></pre> Arguments <pre><code>- thickness (float=.01) : thickness\n- offset (float=-1) : offset\n</code></pre> <p>Returns:</p> Type Description <code>    - MeshBuilder : the result of the solidify operation</code>"},{"location":"api/#npblender.Mesh.solidify_socle","title":"solidify_socle","text":"<pre><code>solidify_socle(shape, z=0, bottom_material_index=0)\n</code></pre> <p>The mesh is supposed to be a grid.</p> <p>The socle is buit by extruding the external edges to the value z.</p> Arguments <ul> <li>shape (tuple of ints) : the grid shade</li> <li>z (float) : socle base z</li> <li>bottom_material_index (int = 0) : base face material index</li> <li>attributes (dict) : attributes to faces</li> </ul> <p>Returns:</p> Type Description <code>- bottom face index (int) : the index of bottom face</code>"},{"location":"api/#npblender.Mesh.to_curve_REVIEW","title":"to_curve_REVIEW","text":"<pre><code>to_curve_REVIEW()\n</code></pre> <p>Convert mesh to curve</p> <p>Simple conversion when edges domain is defined</p>"},{"location":"api/#npblender.Mesh.to_mesh_data","title":"to_mesh_data","text":"<pre><code>to_mesh_data(data)\n</code></pre> <p>Write the geometry into a Blender Mesh</p> Arguments <pre><code>- mesh (Blender Mesh instance) : the mesh to write\n</code></pre>"},{"location":"api/#npblender.Mesh.to_object","title":"to_object","text":"<pre><code>to_object(obj, shade_smooth=None, shapekeys=None, collection=None)\n</code></pre> <p>Create or update a blender object.</p> <p>The method 'to_object' creates the whole geometry. It creates a new object if it doesn't already exist. If the object exists, it must be a mesh, there is no object type conversion.</p> <p>Once the object is created, use the method 'update_object' to change the vertices.</p> Arguments <pre><code>- obj (str or Blender object) : the object the create\n</code></pre> <p>Returns:</p> Type Description <code>    - Blender mesh object</code>"},{"location":"api/#npblender.Mesh.torus","title":"torus  <code>classmethod</code>","text":"<pre><code>torus(major_segments=48, minor_segments=12, major_radius=1.0, minor_radius=0.25, materials=None)\n</code></pre> <p>Create a Torus.</p> Arguments <pre><code>- major_segments (int=48) : number of segments for the major radius\n- minor_segments (int=12) : number of segments for the minor radius\n- major_radius (float=1.) : major radius\n- minor_radius (float=.25) : minor radius\n- materials (list of strs = None) : materials list\n- transformation (Transformations = None) : the transformation to apply\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Mesh.uvsphere","title":"uvsphere  <code>classmethod</code>","text":"<pre><code>uvsphere(segments=32, rings=16, radius=1, materials=None)\n</code></pre> <p>Create a uv sphere.</p> Arguments <pre><code>- segments (int=32) : number of segments\n- rings (int=16) : number of rings\n- radius (float=1.) : radius\n- materials (list of strs = None) : materials list\n- transformation (Transformations = None) : the transformation to apply\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Mesh.vectors_field","title":"vectors_field  <code>classmethod</code>","text":"<pre><code>vectors_field(locations, vectors, radius=0.05, scale_length=1.0, angle=24.0, segments=8, head=None, adjust_norm=None, materials=None)\n</code></pre> <p>Create an arrow at each location corresponding to the vectors.</p> <p>The arrow length is equal to the corresponding vector lengths. The arrow radius is constant and equal to the value passe in argument for lengths greater that the argument scale_length. When the length is less than this value, the arrow is scaled down.</p> <p>Use the adjust_norm argument to transform the vector lengths to arrows lengths.</p> Arguments <pre><code>- locations (array of 3-vectors) : vectors locations\n- vectors (array of 3 vectors) : vectors to visualize\n- radius (float = .05) : arrow radius\n- angle (float = 24) : head radius in degrees\n- segments (int = 8) : number of segments for the section\n- head (mesh = None) : mesh model for the head. Create a cone if None\n- adjust_norm (max length or function = None) : max arrow length or function transforming\n    the vector length into arrow length\n- scale_length (float = 1.) : arrow length below which the arrow radius is scaled\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh Object</code>"},{"location":"api/#npblender.Meshes","title":"Meshes","text":"<pre><code>Meshes(mesh=None, mesh_id=None, attr_from=None, **attributes)\n</code></pre> <p>               Bases: <code>Geometry</code></p> <p>Instances based on mesh buckets.</p> <p>Instances is best for managing a high number of instances with a low number of models. Meshes manages one mesh per point</p> Arguments <pre><code>- mesh (Mesh) : the mesh containing the geometry\n- mesh_id (int = None) : mesh points attribute defining the instances\n- attr_from (Geometry) : geometry where to capture attributes from\n- **attributes (dict) : other geometry attributes\n</code></pre>"},{"location":"api/#npblender.MultiResGrid","title":"MultiResGrid","text":"<pre><code>MultiResGrid(func, shape=(3, 3), u_space=(0, 1), v_space=(0, 1), is_altitude=False, normal_func=None)\n</code></pre> <p>               Bases: <code>Mesh</code></p> <p>Multi resolution grid</p> <p>A surface defined by a function of two parameters u and v. The function can return either a vector or an altitude, u and being interpretated as (x, y).</p> <p>The grid resolution is defined by a depth when calling the method update_grid. The method accepts a camera to adapt its the resolution only to the visible parts.</p> Arguments <ul> <li>shape (2-tuple of ints) : initial division</li> <li>u_space (2-tuple of floats) : u min and max values</li> <li>v_space (2-tuple of floats) : v min and max values</li> <li>is_altitude (bool = False) : the function returns z only vector is built with (u, v) as (x, y)</li> </ul>"},{"location":"api/#npblender.MultiResGrid.call_func","title":"call_func","text":"<pre><code>call_func(u, v)\n</code></pre> <p>Call the surface function</p> Arguments <ul> <li>u (array of floats) : u value</li> <li>v (array of floats) : v value</li> </ul> <p>Returns:</p> Type Description <code>- array of vectors</code>"},{"location":"api/#npblender.MultiResGrid.compute_normals","title":"compute_normals","text":"<pre><code>compute_normals(u, v, du, dv)\n</code></pre> <p>Compute the face normals</p>"},{"location":"api/#npblender.MultiResGrid.get_normals","title":"get_normals","text":"<pre><code>get_normals(u, v)\n</code></pre> <p>Call the surface function</p> Arguments <ul> <li>u (array of floats) : u value</li> <li>v (array of floats) : v value</li> </ul> <p>Returns:</p> Type Description <code>- array of vectors</code>"},{"location":"api/#npblender.MultiResGrid.update_grid","title":"update_grid","text":"<pre><code>update_grid(depth=0, camera=None, max_vertices=10000000, max_size=0.05)\n</code></pre> <p>Update the grid resolution with the given depth</p> Arguments <ul> <li>depth (int) : maximum depth</li> <li>camera (Camera) : camera to compute visible faces</li> <li>max_vertices (int = 10_000_000) : maximum number of vertices</li> <li>max_size (float = .05) : maximum size of faces</li> </ul>"},{"location":"api/#npblender.ShapeKeys","title":"ShapeKeys","text":"<pre><code>ShapeKeys(rec_array, count=1, relative=True, extrapolation='CLIP', ignore_int=True, ignore_bool=True)\n</code></pre> <p>ShapeKeys manages a stack of structured arrays (like FieldArrays), with the same structure and same number of elements in each array.</p> <p>Parameters:</p> Name Type Description Default <code>rec_array</code> <code>ndarray(structured) or FieldArray</code> <p>The reference array to replicate.</p> required <code>count</code> <code>int</code> <p>The number of copies to initialize.</p> <code>1</code> <code>relative</code> <code>bool</code> <p>Optional flag, for later use.</p> <code>True</code>"},{"location":"api/#npblender.ShapeKeys.abs_interpolate","title":"abs_interpolate","text":"<pre><code>abs_interpolate(t, smooth=1)\n</code></pre> <p>Absolute interpolation between keyframes.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float or array_like</code> <p>Interpolation factor(s) in [0, 1].</p> required <code>extrapolation</code> <code>(CLIP, CYCLIC, BACK)</code> <p>How to handle t values outside [0, 1].</p> <code>'CLIP'</code> <code>smooth</code> <code>(int, str or callable)</code> <p>Smoothing method:     - int: degree of BSpline     - 'CUBIC': cubic spline     - callable: function to apply to t     - None: linear interpolation</p> <code>1</code> <p>Returns:</p> Type Description <code>recarray or array of recarrays</code> <p>Interpolated values with only float fields (others ignored).</p>"},{"location":"api/#npblender.ShapeKeys.rel_interpolate","title":"rel_interpolate","text":"<pre><code>rel_interpolate(weights, smooth=1)\n</code></pre> <p>Relative interpolation using deltas from base shape.</p> <p>Parameters:</p> Name Type Description Default <code>weights</code> <code>array_like</code> <ul> <li>shape (K,) for one result</li> <li>shape (M, K) for multiple results where K = number of shapes - 1</li> </ul> required <code>smooth</code> <code>int, str, callable, or None</code> <p>Smoothing method (same as abs_interpolate)</p> <code>1</code> <p>Returns:</p> Type Description <code>np.recarray or array of recarrays</code> <p>Interpolated result(s) (only float fields)</p>"},{"location":"api/#npblender.Simulation","title":"Simulation","text":"<pre><code>Simulation(compute=None, reset=None, view=None)\n</code></pre> <p>               Bases: <code>Animation</code></p>"},{"location":"api/#npblender.Simulation.add_action","title":"add_action","text":"<pre><code>add_action(func, *args, start=0, duration=None, flags=0, **kwargs)\n</code></pre> <p>Add an action to the simulation</p> <p>To add an event, you can use &lt;#add_event&gt;.</p> Arguments <ul> <li>func (function) : function of template f(simulation, args, *kwargs)</li> <li>top (float = 0) : start time for the actiuon</li> <li>duration (float = None) : duration of the action (0: call once, None: never stops)</li> <li>after (bool = False) : exec the action after the exec_loop</li> </ul> <p>Returns:</p> Type Description <code>- Action : the action added to the simulation</code>"},{"location":"api/#npblender.Simulation.add_event","title":"add_event","text":"<pre><code>add_event(func, *args, start=0, flags=0, **kwargs)\n</code></pre> <p>Add an event to the simulation</p> <p>The event is executed once. To add an action called at each step, use &lt;#add_action&gt;.</p> Arguments <ul> <li>func (function) : function of template f(simulation, args, *kwargs)</li> <li>top (float = 0) : start time for the actiuon</li> <li>after (bool = False) : exec the action after the exec_loop</li> </ul> <p>Returns:</p> Type Description <code>- Action : the event added to the simulation</code>"},{"location":"api/#npblender.Simulation.change_attribute","title":"change_attribute","text":"<pre><code>change_attribute(attribute, value, incr=None, factor=None)\n</code></pre> <p>Modify a points attribute</p> <pre><code># gravity\nself.add_action(\"change_attribute\", \"accel\", value=(0, 0, -9.81))\n</code></pre>"},{"location":"api/#npblender.Simulation.newton_law","title":"newton_law","text":"<pre><code>newton_law(G=1, power=2, min_distance=0.001)\n</code></pre> <p>Newton's law between points</p> <p>The force between two points is given by:</p> <p>F = G.m1.m2 / dist**p</p>"},{"location":"api/#npblender.Simulation.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the simulation</p>"},{"location":"api/#npblender.Spline","title":"Spline","text":"<pre><code>Spline(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>               Bases: <code>FaceSplineDomain</code></p> <p>Spline domain.</p> <p>Spline domain is specific to Curve geometry. A spline is an array of control points. A Spline is similare to a Face but points directly to the control points and not indirectly as for the faces.</p> <p>Attributes:</p> Name Type Description <code>- loop_start (int)</code> <code>first index in control points array</code> <ul> <li>loop_total (int) : number of control points</li> <li>material_index (int, optional) : material index</li> <li>resolution (int, optional) : spline resolution</li> <li>cyclic (bool, optional) : spline is cyclic or not</li> <li>order (int, optional) : Nurbs spline order</li> <li>bezierpoint (bool, optional) : Nurbs spline bezierpoint flag</li> <li>endpoint (bool, optional) : Nurbs spline endpoint flag</li> </ul>"},{"location":"api/#npblender.Spline.functions","title":"functions  <code>property</code>","text":"<pre><code>functions\n</code></pre> <p>Return the functions representing the splines.</p> <p>The functions are scipy BSplines initialized with the splines parameters.</p> <p>Returns:</p> Type Description <code>    - list of BSpline functions</code>"},{"location":"api/#npblender.Spline.length","title":"length  <code>property</code>","text":"<pre><code>length\n</code></pre> <p>Length of the splines.</p> <p>Returns:</p> Type Description <code>    - List of spline lengths</code>"},{"location":"api/#npblender.Spline.add_splines","title":"add_splines","text":"<pre><code>add_splines(splines, **attributes)\n</code></pre> <p>Add splines.</p> Arguments <pre><code>- splines (array of ints) : the number of control points per spline\n- attributes (attribute names, attribute values) : value of the corner attributes\n</code></pre>"},{"location":"api/#npblender.Spline.load_bl_attributes","title":"load_bl_attributes","text":"<pre><code>load_bl_attributes(data)\n</code></pre> <p>Read the object attributes.</p> Arguments <pre><code>- spec (str or data) : the data to set the attributes to\n</code></pre>"},{"location":"api/#npblender.Spline.tangent","title":"tangent","text":"<pre><code>tangent(t)\n</code></pre> <p>Tangents of the splines at a given time.</p> Arguments <pre><code>- t (float) : spline parameter between 0 and 1\n</code></pre> <p>Returns:</p> Type Description <code>    - list of spline tangents evaluated at time t.</code>"},{"location":"api/#npblender.Spline.to_object","title":"to_object","text":"<pre><code>to_object(data, update=False)\n</code></pre> <p>Transfer the attributes to a blender mesh object.</p> Arguments <pre><code>- spec (str or data) : the mesh to set the attributes to\n- attributes (array of st = None) : the attributes to transfer (all if None)\n- update (bool=False) : update the attributes values without trying to create them\n</code></pre>"},{"location":"api/mesh/","title":"Mesh","text":"<p>               Bases: <code>Geometry</code></p> <p>Mesh Geometry.</p> Arguments <pre><code>- points (array of vectors = None) : the vertices\n- corners (array of ints = None) : corners, i.e. indices on the array of points\n- faces (array of ints = None) : size of the faces, the sum of this array must be equal to the length of the corners array\n- edges (array of couples of ints = None) : list of edges defined by two vertex indices\n- materials (str or list of strs = None) : list of materials used in the geometry\n- attr_from (Geometry) : domain attributes to copy from\n- **attrs (dict) : other geometry attributes\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def __init__(self, points=None, corners=None, faces=None, edges=None, materials=None, attr_from=None, **attrs):\n    \"\"\" Mesh Geometry.\n\n    Arguments\n    ---------\n        - points (array of vectors = None) : the vertices\n        - corners (array of ints = None) : corners, i.e. indices on the array of points\n        - faces (array of ints = None) : size of the faces, the sum of this array must be equal to the length of the corners array\n        - edges (array of couples of ints = None) : list of edges defined by two vertex indices\n        - materials (str or list of strs = None) : list of materials used in the geometry\n        - attr_from (Geometry) : domain attributes to copy from\n        - **attrs (dict) : other geometry attributes\n    \"\"\"\n\n    # ----- Initialize an empty geometry\n\n    self.points  = Vertex()\n    self.corners = Corner()\n    self.faces   = Face()\n    self.edges   = Edge()\n\n    self.join_attributes(attr_from)\n\n    # ----- The materials\n\n    if materials is None:\n        self.materials = []\n    elif isinstance(materials, str):\n        self.materials = [materials]\n    else:\n        self.materials = [mat for mat in materials]\n\n    # ----- Add geometry\n\n    self.add_geometry(points, corners, faces, edges, **attrs)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bounding_box","title":"bounding_box  <code>property</code>","text":"<pre><code>bounding_box\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bounding_box_dims","title":"bounding_box_dims  <code>property</code>","text":"<pre><code>bounding_box_dims\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.corners","title":"corners  <code>instance-attribute</code>","text":"<pre><code>corners = Corner()\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.domain_names","title":"domain_names  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>domain_names = ['points', 'corners', 'faces', 'edges']\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.edges","title":"edges  <code>instance-attribute</code>","text":"<pre><code>edges = Edge()\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.faces","title":"faces  <code>instance-attribute</code>","text":"<pre><code>faces = Face()\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.materials","title":"materials  <code>instance-attribute</code>","text":"<pre><code>materials = []\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.max_size","title":"max_size  <code>property</code>","text":"<pre><code>max_size\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.points","title":"points  <code>instance-attribute</code>","text":"<pre><code>points = Vertex()\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.__imul__","title":"__imul__","text":"<pre><code>__imul__(count)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def __imul__(self, count):\n    return self.multiply(count, in_place=True)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.__mul__","title":"__mul__","text":"<pre><code>__mul__(count)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def __mul__(self, count):\n    return self.multiply(count, in_place=False)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def __repr__(self):\n    s = \"Mesh:\\n   \" + \"\\n   \".join([str(self.points), str(self.corners), str(self.faces)])\n    return s\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def __str__(self):\n    return f\"&lt;Mesh: points {len(self.points)}, corners {len(self.corners)}, faces {len(self.faces)}, edges {len(self.edges)}&gt;\"\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh._all_primitives","title":"_all_primitives  <code>staticmethod</code>","text":"<pre><code>_all_primitives()\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@staticmethod\ndef _all_primitives():\n\n    rng = np.random.default_rng(0)\n\n    def toobj(mesh, name, x):\n        mesh.materials = [\"Material\"]   \n        mesh.points.x += x - np.min(mesh.points.x)\n        x = np.max(mesh.points.x) + 1\n\n        mesh.to_object(name, shade_smooth=False)\n\n        return x\n\n    x = 0\n\n    # ----- Points\n    mesh = Mesh.points(rng.uniform(-1, 1, size=(1000, 3)))\n    x = toobj(mesh, \"points\", x)\n\n    # ----- Lines\n    mesh = Mesh.line([0, 0, 0], [[0, -2, 1], [0, -1, 1], [0, 0, 1], [0, 1, 1], [0, 1, 1]])\n    mesh.join(Mesh.line([1, 0, 0], [[1, -2, 1], [1, -1, 1], [1, 0, 1], [1, 1, 1], [1, 1, 1]], segments=3))\n    mesh.join(Mesh.line([-1, 0, 0], [-1, 0, 1], segments=10))\n    x = toobj(mesh, \"line\", x)\n\n    # ----- Grid\n    mesh = Mesh.grid().translate((0, 0, 1)).join(Mesh.grid(5, 3, 50, 30))\n    x = toobj(mesh, \"grid\", x)\n\n    # ----- Cicle\n    mesh = Mesh.circle().join(Mesh.circle(cap='NGON').translate((0, 0, 1)), Mesh.circle(cap='FANS').translate((0, 0, 2)))      \n    x = toobj(mesh, \"circle\", x)\n\n    # ----- Cone\n    mesh = Mesh.cone(fill_type='NONE').join(\n        Mesh.cone(side_segments=10).translate((0, 0, 3)),\n        Mesh.cone(fill_type='NGON').translate((0, 0, 6)),\n        Mesh.cone(fill_type='FANS').translate((0, 0, 9)),\n    )\n    x = toobj(mesh, \"cone\", x)\n\n    # ----- Cylinder\n    mesh = Mesh.cylinder(fill_type='NONE').join(\n        Mesh.cylinder(side_segments=10).translate((0, 0, 3)),\n        Mesh.cylinder(fill_type='NGON').translate((0, 0, 6)),\n        Mesh.cylinder(fill_type='FANS').translate((0, 0, 9)),\n    )\n    x = toobj(mesh, \"cylinder\", x)\n\n    # ----- Arrow\n    mesh = Mesh().join(\n        Mesh.arrow((-1, 0, 0)),\n        Mesh.arrow((+1, 0, 0)),\n        Mesh.arrow((0, -1, 0)),\n        Mesh.arrow((0, +1, 0)),\n        Mesh.arrow((0, 0, -1)),\n        Mesh.arrow((0, 0, +1)),\n    )\n    x = toobj(mesh, \"arrow\", x)\n\n    # ----- Vectors field\n    n = 50\n    pos = rng.uniform(-1, 1, size=(n, 3))\n    ori = rng.uniform(-1, 1, size=(n, 3))\n    mesh = Mesh.vectors_field(\n        pos,\n        ori,\n        radius = .02,\n    )\n    x = toobj(mesh, \"vectors_field\", x)\n\n    # ----- Simple\n    for name in [\"cube\", \"pyramid\", \"uvsphere\", \"icosphere\", \"torus\", \"chain_link\", \"monkey\"]:\n        f = getattr(Mesh, name)\n        mesh = f()\n        x = toobj(mesh, name, x)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh._attributes_per_domain","title":"_attributes_per_domain","text":"<pre><code>_attributes_per_domain(**attrs)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def _attributes_per_domain(self, **attrs):\n\n    dispatched = {\n        'points'  : {},\n        'corners' : {},\n        'faces'   : {},\n        'edges'   : {},\n        }\n\n    for k, v in attrs.items():\n        count = 0\n\n        if k in self.points.all_names:\n            dispatched['points'][k] = v\n            count += 1\n\n        if k in self.corners.all_names:\n            dispatched['corners'][k] = v\n            count += 1\n\n        if k in self.faces.all_names:\n            dispatched['faces'][k] = v\n            count += 1\n\n        if k in self.edges.all_names:\n            dispatched['edges'][k] = v\n            count += 1\n\n        if count == 0:\n            raise AttributeError(f\"Unknown mesh attribute '{k}'.\\n\"\n                                 f\"- points:  {self.points.all_names}\\n\"\n                                 f\"- corners: {self.corners.all_names}\\n\"\n                                 f\"- faces:   {self.faces.all_names}\\n\"\n                                 f\"- edges:   {self.edges.all_names}\\n\"\n                                 )\n\n        if count &gt; 1:\n            raise AttributeError(f\"Mesh add_geometry&gt; attribute '{k}' is ambigous, it belongs to more than one domain (count).\\n\"\n                                 f\"- points:  {self.points.all_names}\\n\"\n                                 f\"- corners: {self.corners.all_names}\\n\"\n                                 f\"- faces:   {self.faces.all_names}\\n\"\n                                 f\"- edges:   {self.edges.all_names}\\n\"\n                                 )\n    return dispatched\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh._bm_edges","title":"_bm_edges","text":"<pre><code>_bm_edges(bm)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def _bm_edges(self, bm):\n    nedges = len(bm.edges)\n    edges  = np.empty(nedges, dtype=object)\n    verts  = np.empty((nedges, 2), dtype=bint)\n\n    for i_edge, edge in enumerate(bm.edges):\n        edges[i_edge] = edge\n\n        i0, i1 = edge.verts[0].index, edge.verts[1].index\n        verts[i_edge] = (i0, i1) if i0 &lt; i1 else (i1, i0)\n\n    return edges, verts\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh._bm_verts","title":"_bm_verts","text":"<pre><code>_bm_verts(bm)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def _bm_verts(self, bm):\n    nverts = len(self.points.ravel())\n    verts  = np.zeros(nverts, dtype=object)\n    for vert in bm.verts:\n        verts[vert.index] = vert\n    return verts\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh._check_transformation_shape","title":"_check_transformation_shape","text":"<pre><code>_check_transformation_shape(t_shape, npoints, label='Transformation')\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def _check_transformation_shape(self, t_shape, npoints, label=\"Transformation\"):\n    if t_shape == ():\n        return (npoints, 3)\n\n    elif len(t_shape) == 1:\n        if t_shape[0] in [1, npoints]:\n            return (npoints, 3)\n\n    else:\n        n = int(np.prod(t_shape))\n        if npoints % n == 0:\n            return t_shape[:-1] + (-1, 3)\n\n    raise AttributeError(f\"{label} shape {t_shape} is not valid to transform {npoints} points.\")\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh._test_edition","title":"_test_edition","text":"<pre><code>_test_edition()\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def _test_edition():\n    rng = np.random.default_rng(0)\n\n    # extrude vertices\n    mesh = Mesh.icosphere()\n    sel = rng.uniform(0, 1, len(mesh.points)) &lt; .5\n    mesh.extrude_vertices(sel, mesh.points.position[sel])\n    mesh.to_object(\"extrude_vertices\", shade_smooth=False)\n\n    # extrude loop of vertices\n    mesh = Mesh.circle(materials=\"Material\")\n    mesh.extrude_loop(np.arange(len(mesh.points)), offset=(0, 0, 1), close=True)\n    mesh.points.x += 2\n    mesh.to_object(\"extrude_loop\", shade_smooth=False)\n\n    # extrude individualfaces\n    mesh = Mesh.icosphere()\n    sel = rng.uniform(0, 1, len(mesh.faces)) &lt; .5\n    inds = np.arange(len(mesh.faces))[sel]\n    res = mesh.extrude_faces(sel, scale=.3)\n    res = mesh.inset_faces(res['top'])\n    res = mesh.extrude_faces(res['top'], scale=-.1)\n    mesh.points.x += 4\n    mesh.to_object(\"extrude_faces\", shade_smooth=False)\n\n    # extrude region\n    mesh = Mesh.grid(1, 1, 11, 11)\n    sel = [23, 24, 25, 26, 27, 34, 35, 36, 45]\n    res = mesh.extrude_region(sel, (0, 0, 1), dissolve=False)\n    mesh.extrude_region(res['top'], (0, 0, .5), dissolve=True)\n    mesh.points.x += 7\n    mesh.to_object(\"extrude_region\", shade_smooth=False)\n\n    # solidify socle\n    mesh = Mesh.grid(2, 1.6/3, 80, 30)\n    mesh.points.z = .5 + rng.uniform(-.05, .05, len(mesh.points))\n    mesh.points.x += 10\n    mesh.solidify_socle(shape=(80, 30), z=0)\n    mesh.to_object(\"solidify_socle\", shade_smooth=False)\n\n    # boolean\n    cube = Mesh.cube()\n    cyl = Mesh.cylinder(radius=.5, depth = 3)\n    mesh = cube.boolean(cyl)\n    mesh.points.x += 13\n    mesh.to_object(\"boolean difference\", shade_smooth=False)\n\n    # solidify\n    mesh = Mesh.grid().solidify(thickness=.2)\n    mesh.points.x += 16\n    mesh.to_object(\"solidify\", shade_smooth=False)\n\n    # triangulate\n    mesh = Mesh.cube().triangulate()\n    mesh.points.x += 19\n    mesh.to_object(\"triangulate\", shade_smooth=False)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_geometry","title":"add_geometry","text":"<pre><code>add_geometry(points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs)\n</code></pre> <p>Add geometry to the mesh.</p> <p>This method adds vertices, edges, corners, and faces to the mesh. The added geometry can reference existing vertices and is appended without shifting indices.</p> <p>Note:     To add independent geometry (with new vertices), use <code>Mesh.join_geometry</code> instead.</p> <p>Examples:</p> <p>cube = Mesh.cube()</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like of vectors</code> <p>Vertices to add to the mesh.</p> <code>None</code> <code>corners</code> <code>array-like of int</code> <p>Indices referring to vertices in the points array.</p> <code>None</code> <code>faces</code> <code>int, array-like of int, or list of lists</code> <p>Defines the faces: - If <code>corners</code> is provided:     - None: Single face made of all corners.     - int: All faces have the same size (must divide the number of corners).     - array-like: Face sizes; sum must equal the number of corners. - If <code>corners</code> is None:     - Must be a list of lists, each sublist is a list of corners.</p> <code>None</code> <code>edges</code> <code>array-like of pairs of int</code> <p>Edges defined by pairs of vertex indices.</p> <code>None</code> <code>safe_mode</code> <code>bool</code> <p>If True, perform a mesh integrity check after adding geometry.</p> <code>False</code> <code>**attrs</code> <code>dict</code> <p>Additional geometry attributes to apply.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys {'points', 'corners', 'faces', 'edges'} mapping to lists of added geometry indices.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If faces and corners lengths are inconsistent or invalid.</p> Source code in <code>npblender/mesh.py</code> <pre><code>def add_geometry(self, points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs):\n    \"\"\"Add geometry to the mesh.\n\n    This method adds vertices, edges, corners, and faces to the mesh. The added geometry\n    can reference existing vertices and is appended without shifting indices.\n\n    Note:\n        To add independent geometry (with new vertices), use `Mesh.join_geometry` instead.\n\n    Examples:\n    &gt;&gt;&gt; cube = Mesh.cube()\n    &gt;&gt;&gt; # Add a triangle on existing vertices\n    &gt;&gt;&gt; # corners argument refers to cube vertices\n    &gt;&gt;&gt; cube.add_geometry(corners=[0, 1, 2], faces=3)\n\n    &gt;&gt;&gt; # Add a triangle with additional vertices\n    &gt;&gt;&gt; # corners argument refers to the new vertices\n    &gt;&gt;&gt; cube.join_geometry(points=[[0, 0, 0], [0, 1, 0], [1, 0, 0]], corners=[0, 1, 2], faces=3)\n\n    Parameters\n    ----------\n    points : array-like of vectors, optional\n        Vertices to add to the mesh.\n    corners : array-like of int, optional\n        Indices referring to vertices in the points array.\n    faces : int, array-like of int, or list of lists, optional\n        Defines the faces:\n        - If `corners` is provided:\n            - None: Single face made of all corners.\n            - int: All faces have the same size (must divide the number of corners).\n            - array-like: Face sizes; sum must equal the number of corners.\n        - If `corners` is None:\n            - Must be a list of lists, each sublist is a list of corners.\n    edges : array-like of pairs of int, optional\n        Edges defined by pairs of vertex indices.\n    safe_mode : bool, optional\n        If True, perform a mesh integrity check after adding geometry.\n    **attrs : dict\n        Additional geometry attributes to apply.\n\n    Returns\n    -------\n    dict\n        Dictionary with keys {'points', 'corners', 'faces', 'edges'} mapping to lists of added geometry indices.\n\n    Raises\n    ------\n    ValueError\n        If faces and corners lengths are inconsistent or invalid.\n    \"\"\"\n\n    disp_attrs = self._attributes_per_domain(**attrs)\n    added = {'points': [], 'corners': [], 'faces': [], 'edges': []}\n\n    # ----------------------------------------------------------------------------------------------------\n    # Add vertices\n    # ----------------------------------------------------------------------------------------------------\n\n    if points is not None:\n        added['points'] = self.points.append(position=points, **disp_attrs['points'])\n\n    # ----------------------------------------------------------------------------------------------------\n    # Edges\n    # ----------------------------------------------------------------------------------------------------\n\n    if edges is not None:\n        if np.shape(edges) == (2,):\n            added['edges'] = self.edges.append(vertex0=edges[0], vertex1=edges[1], **disp_attrs['edges'])\n        else:\n            added['edges'] = self.edges.append(vertex0=edges[:, 0], vertex1=edges[:, 1], **disp_attrs['edges'])\n\n    # ----------------------------------------------------------------------------------------------------\n    # Corners and Faces\n    # ----------------------------------------------------------------------------------------------------\n\n    # If corners is provided, faces can be:\n    # - None -&gt; single face made of all corners\n    # - int -&gt; faces are all the same size (len(corners) must be a multiplief of faces)\n    # - array like -&gt; face sizes (len(corners) == np.sum(faces))\n    #\n    # If faces is provided, corners can be:\n    # - None -&gt; faces must be an array of arrays, each array being of list of corners\n    # - not None -&gt; see above\n\n    ok_faces = True\n    if corners is None:\n        if faces is None:\n            ok_faces = False\n        else:\n            corners = []\n            sizes = []\n            ok = hasattr(faces, '__len__')\n            if ok:\n                for face in faces:\n                    ok = hasattr(faces, '__len__') and len(face) &gt; 2\n                    if not ok:\n                        break\n                    corners.extend(face)\n                    sizes.append(len(face))\n            if not ok:\n                raise ValueError(f\"Mesh add_geometry&gt; when corners is None, faces must be None or an array of arrays, each array being of list of corners.\")\n            faces = sizes\n\n    else:\n        corners = np.asarray(corners)\n        ncorners = len(corners)\n        if faces is None:\n            faces = [ncorners]\n\n        else:\n            faces = np.asarray(faces)\n            if faces.shape == ():\n                size = int(faces)\n                if ncorners % size != 0:\n                    raise ValueError(f\"Mesh add_geometry&gt; when faces is a single number {size}, it must divide the number of corners ({ncorners}).\")\n                faces = [size]*(ncorners // size)\n            else:\n                if np.sum(faces) != ncorners:\n                    raise ValueError(f\"Mesh add_geometry&gt; the sum of faces ({np.sum(faces)}) must be equal to the number of corners ({ncorners}).\")\n\n    if ok_faces:\n        added['corners'] = self.corners.append(vertex_index=corners, **disp_attrs['corners'])\n        added['faces'] = self.faces.append_sizes(faces, **disp_attrs['faces'])\n\n    if safe_mode:\n        self.check()\n\n    return added\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_geometry--add-a-triangle-on-existing-vertices","title":"Add a triangle on existing vertices","text":""},{"location":"api/mesh/#npblender.mesh.Mesh.add_geometry--corners-argument-refers-to-cube-vertices","title":"corners argument refers to cube vertices","text":"<p>cube.add_geometry(corners=[0, 1, 2], faces=3)</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_geometry--add-a-triangle-with-additional-vertices","title":"Add a triangle with additional vertices","text":""},{"location":"api/mesh/#npblender.mesh.Mesh.add_geometry--corners-argument-refers-to-the-new-vertices","title":"corners argument refers to the new vertices","text":"<p>cube.join_geometry(points=[[0, 0, 0], [0, 1, 0], [1, 0, 0]], corners=[0, 1, 2], faces=3)</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_materials","title":"add_materials","text":"<pre><code>add_materials(materials)\n</code></pre> <p>Add a materials list to the existing one.</p> <p>If a material already exist, it is not added another time.</p> Arguments <pre><code>- materials (list of strs) : the list of materials to append.\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def add_materials(self, materials):\n    \"\"\" Add a materials list to the existing one.\n\n    If a material already exist, it is not added another time.\n\n    Arguments\n    ---------\n        - materials (list of strs) : the list of materials to append.\n    \"\"\"\n    if isinstance(materials, str):\n        self.materials.append(materials)\n    else:\n        self.materials.extend(materials)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_points","title":"add_points","text":"<pre><code>add_points(points, **attributes)\n</code></pre> <p>Add vertices.</p> Arguments <pre><code>- points (array of vectors) : the vertices to add\n- attributes (name=value) : value for named attributes\n</code></pre> <p>Returns:</p> Type Description <code>    - array of ints : indices of the added vertices</code> Source code in <code>npblender/mesh.py</code> <pre><code>def add_points(self, points,  **attributes):\n    \"\"\" Add vertices.\n\n    Arguments\n    ---------\n        - points (array of vectors) : the vertices to add\n        - attributes (name=value) : value for named attributes\n\n    Returns\n    -------\n        - array of ints : indices of the added vertices\n    \"\"\"\n    npoints = len(self.points)\n    return self.points.append(position=points, **attributes)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.apply_scale","title":"apply_scale","text":"<pre><code>apply_scale(scale, pivot=None)\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def apply_scale(self, scale, pivot=None):\n    return self.transformation(scale=scale, pivot=pivot)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.arrow","title":"arrow  <code>classmethod</code>","text":"<pre><code>arrow(vector=(0, 0, 1), radius=0.05, angle=24.0, segments=8, adjust_norm=None, materials=None)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef arrow(cls, vector=(0, 0, 1), radius=.05, angle=24., segments=8, adjust_norm=None, materials=None):\n\n    height = np.linalg.norm(vector)\n    if type(adjust_norm).__name__ == 'function':\n        height = adjust_norm(height)\n    elif adjust_norm is not None:\n        height = min(adjust_norm, height)\n\n    head_radius = 3*radius\n    head_height = head_radius/np.tan(np.radians(angle))\n\n    cyl_height = height - head_height*.8\n\n    #cyl  = cls.cylinder(vertices=segments, side_segments=2, radius=radius, depth=cyl_height, transformation=Transformations(position=(0, 0, cyl_height/2)), materials=materials)\n    cyl = cls.cylinder(vertices=segments, side_segments=2, radius=radius, depth=cyl_height, materials=materials)\n    cyl.points.z += cyl_height/2\n    cyl.points[[segments + i for i in range(segments)]].position -= (0, 0, cyl_height/2 - .01)\n\n    cone = cls.cone(vertices=segments, side_segments=2, fill_segments=1, radius_top=0, radius_bottom=head_radius, depth=head_height, fill_type='FANS', materials=materials)\n    cone.points[-1].position += (0, 0, head_height/10)\n    cone.points.position += (0, 0, height - head_height/2)\n\n    arrow = cyl.join(cone)\n    #arrow.points.position = tracker(vector, track_axis='Z') @ arrow.points.position\n    arrow.points.position = Rotation.look_at((0, 0, 1), vector) @ arrow.points.position\n\n    return arrow\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_circle","title":"bl_circle  <code>classmethod</code>","text":"<pre><code>bl_circle(radius=1, segments=16, fill_tris=False, materials=None)\n</code></pre> <p>Create a Circle.</p> <p>Blender constructor for a Circle.</p> Arguments <pre><code>- radius (float=1.) : circle radius\n- segments (int=16) : number of segments\n- fill_tris (bool = False) : fill with triangle fans\n- materials (list of strs = None) : materials list\n- transformation (Transformations = None) : the transformation to apply\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef bl_circle(cls, radius=1, segments=16, fill_tris=False, materials=None):\n    \"\"\" Create a Circle.\n\n    Blender constructor for a Circle.\n\n    Arguments\n    ---------\n        - radius (float=1.) : circle radius\n        - segments (int=16) : number of segments\n        - fill_tris (bool = False) : fill with triangle fans\n        - materials (list of strs = None) : materials list\n        - transformation (Transformations = None) : the transformation to apply\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    mesh = cls(materials=materials)\n    with mesh.bmesh() as bm:\n        bmesh.ops.create_circle(bm, cap_ends=True, cap_tris=fill_tris, segments=segments, radius=radius, calc_uvs=True)\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_cone","title":"bl_cone  <code>classmethod</code>","text":"<pre><code>bl_cone(radius1=1, radius2=0, depth=2, segments=16, side_segments=1, cap_ends=True, cap_tris=False, materials=None)\n</code></pre> <p>Create a Cone.</p> <p>Blender constructor for a Cone.</p> Arguments <pre><code>- radius1 (float=1.) : base radius\n- radius2 (float=0.) : top radius\n- depth (float=2.) : cone height\n- segments (int=16) : number of segments\n- cap_ends (bool=True) : fill cap faces\n- cap_tris (bool = False) : fill with triangle fans\n- materials (list of strs = None) : materials list\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef bl_cone(cls, radius1=1, radius2=0, depth=2, segments=16, side_segments=1, cap_ends=True, cap_tris=False, materials=None):\n    \"\"\" Create a Cone.\n\n    Blender constructor for a Cone.\n\n    Arguments\n    ---------\n        - radius1 (float=1.) : base radius\n        - radius2 (float=0.) : top radius\n        - depth (float=2.) : cone height\n        - segments (int=16) : number of segments\n        - cap_ends (bool=True) : fill cap faces\n        - cap_tris (bool = False) : fill with triangle fans\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    mesh = cls(materials=materials)\n    with mesh.bmesh() as bm:\n        res = bmesh.ops.create_cone(bm, cap_ends=cap_ends, cap_tris=cap_tris, segments=segments, radius1=radius1, radius2=radius2, depth=depth, calc_uvs=True)\n        if side_segments &gt; 1:\n\n            edges_to_cut = [\n                e for e in bm.edges\n                if (e.verts[0].co.z &gt; 0 and e.verts[1].co.z &lt; 0)\n                or (e.verts[0].co.z &lt; 0 and e.verts[1].co.z &gt; 0)\n            ]\n\n            # Edges subidivision\n            bmesh.ops.subdivide_edges(\n                bm,\n                edges         = edges_to_cut,\n                cuts          = side_segments - 1,\n                use_grid_fill = False\n            )\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_grid","title":"bl_grid  <code>classmethod</code>","text":"<pre><code>bl_grid(x_segments=1, y_segments=1, size=2, materials=None)\n</code></pre> <p>Create a Grid.</p> <p>Blender constructor for a Grid.</p> Arguments <pre><code>- x_segments (int=1) : number of segments along x axis\n- y_segments (int=1) : number of segments along y axis\n- size (float or tuple of floats = 1. : size of the grid\n- materials (list of strs = None) : materials list\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef bl_grid(cls, x_segments=1, y_segments=1, size=2, materials=None):\n    \"\"\" Create a Grid.\n\n    Blender constructor for a Grid.\n\n    Arguments\n    ---------\n        - x_segments (int=1) : number of segments along x axis\n        - y_segments (int=1) : number of segments along y axis\n        - size (float or tuple of floats = 1. : size of the grid\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    mesh = cls(materials=materials)\n    with mesh.bmesh() as bm:\n        bmesh.ops.create_grid(bm, x_segments=x_segments, y_segments=y_segments, size=size, calc_uvs=True)\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.blender_data","title":"blender_data","text":"<pre><code>blender_data(readonly=False)\n</code></pre> <p>Acces to Blender Mesh API.</p> <p>Transfer the geometry to a temporay Blender Mesh. The example below use a blender Mesh to get the normals.</p> <pre><code>mesh = Mesh.Cube()\n\nwith mesh.blender_data() as data:\n    normals = np.array([poly.normal for poly in data.polygons])\n\nprint(normals)\n\n# &gt; [[-1. -0.  0.]\n#    [ 0.  1.  0.]\n#    [ 1. -0.  0.]\n#    [ 0. -1.  0.]\n#    [ 0.  0. -1.]\n#    [ 0. -0.  1.]]\n</code></pre> Arguments <pre><code>- readonly (bool=False) : don't read back the geometry if not modified\n</code></pre> <p>Returns:</p> Type Description <code>    - Blender Mesh</code> Source code in <code>npblender/mesh.py</code> <pre><code>@contextmanager\ndef blender_data(self, readonly=False):\n    \"\"\" Acces to Blender Mesh API.\n\n    Transfer the geometry to a temporay Blender Mesh.\n    The example below use a blender Mesh to get the normals.\n\n    ``` python\n    mesh = Mesh.Cube()\n\n    with mesh.blender_data() as data:\n        normals = np.array([poly.normal for poly in data.polygons])\n\n    print(normals)\n\n    # &gt; [[-1. -0.  0.]\n    #    [ 0.  1.  0.]\n    #    [ 1. -0.  0.]\n    #    [ 0. -1.  0.]\n    #    [ 0.  0. -1.]\n    #    [ 0. -0.  1.]]\n    ```\n\n    Arguments\n    ---------\n        - readonly (bool=False) : don't read back the geometry if not modified\n\n    Returns\n    -------\n        - Blender Mesh\n    \"\"\"\n\n    data = bpy.data.meshes.get(DATA_TEMP_NAME)\n    if data is None:\n        data = bpy.data.meshes.new(DATA_TEMP_NAME)\n\n    self.to_mesh_data(data)\n\n    yield data\n\n    # ----- Back\n\n    if not readonly:\n        self.capture(Mesh.from_mesh_data(data))\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bmesh","title":"bmesh","text":"<pre><code>bmesh(readonly=False)\n</code></pre> <p>Acces to bmesh api.</p> <p>The example below use bmesh to offset the vertices of +1 in the x axis.</p> <pre><code>mesh = Mesh.Cube()\n\n# Move the vertices with bmesh\nwith mesh.bmesh() as bm:\n    for v in bm.verts:\n        v.co.x += 1.0\n\n# Move the vertices directy in numpy array\nmesh.points.position[:, 1] += 1\n\n# Cube moved along x and y\nmesh.to_object(\"Cube\")\n</code></pre> Arguments <pre><code>- readonly (bool=False) : avoid to read back the bmesh if not modications were done\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@contextmanager\ndef bmesh(self, readonly=False):\n    \"\"\" Acces to bmesh api.\n\n    The example below use bmesh to offset the vertices of +1 in the x axis.\n\n    ``` python\n    mesh = Mesh.Cube()\n\n    # Move the vertices with bmesh\n    with mesh.bmesh() as bm:\n        for v in bm.verts:\n            v.co.x += 1.0\n\n    # Move the vertices directy in numpy array\n    mesh.points.position[:, 1] += 1\n\n    # Cube moved along x and y\n    mesh.to_object(\"Cube\")\n    ```\n\n    Arguments\n    ---------\n        - readonly (bool=False) : avoid to read back the bmesh if not modications were done\n    \"\"\"\n\n    data = bpy.data.meshes.get(DATA_TEMP_NAME)\n    if data is None:\n        data = bpy.data.meshes.new(DATA_TEMP_NAME)\n    self.to_mesh_data(data)\n\n    bm = bmesh.new()   # create an empty BMesh\n    bm.from_mesh(data) # fill it in from a Mesh\n\n    yield bm\n\n    # ----- Back\n\n    if not readonly:\n        bm.to_mesh(data)\n        self.capture(Mesh.from_mesh_data(data))\n\n    bm.free()\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.boolean","title":"boolean","text":"<pre><code>boolean(other, operation='DIFFERENCE')\n</code></pre> <p>Apply a boolean operation with another object.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Mesh</code> <p>The object to use as boolean operand.</p> required <code>operation</code> <code>str</code> <p>Boolean operation: 'INTERSECT', 'UNION', or 'DIFFERENCE'.</p> <code>'DIFFERENCE'</code> Source code in <code>npblender/mesh.py</code> <pre><code>def boolean(self, other, operation='DIFFERENCE'):\n    \"\"\"\n    Apply a boolean operation with another object.\n\n    Parameters\n    ----------\n    other : Mesh\n        The object to use as boolean operand.\n    operation : str\n        Boolean operation: 'INTERSECT', 'UNION', or 'DIFFERENCE'.\n    \"\"\"\n\n    with other.object(0, readonly=True) as other_obj:\n\n        with self.object(1) as obj:\n            mod = obj.modifiers.new(name=\"Boolean\", type='BOOLEAN')\n            mod.object = other_obj\n            mod.operation = operation\n\n            # Apply modifier\n            bpy.ops.object.modifier_apply(modifier=mod.name)\n\n            mesh = Mesh.from_object(obj)\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bridge_loops","title":"bridge_loops","text":"<pre><code>bridge_loops(loop0, loop1, close=False, segments=1, **attributes)\n</code></pre> <p>Create a grid linking two loops of the same size.</p> Arguments <ul> <li>loop0 (array of ints) : the first loop</li> <li>loop1 (array of ints) : the second loop</li> <li>segments (int = 1) : the number of segments to join the loops</li> <li>attributes (dict) : attributes to add to the mesh</li> </ul> Source code in <code>npblender/mesh.py</code> <pre><code>def bridge_loops(self, loop0, loop1, close=False, segments=1, **attributes):\n    \"\"\" Create a grid linking two loops of the same size.\n\n    Arguments\n    ---------\n    - loop0 (array of ints) : the first loop\n    - loop1 (array of ints) : the second loop\n    - segments (int = 1) : the number of segments to join the loops\n    - attributes (dict) : attributes to add to the mesh\n    \"\"\"\n    segments = max(1, segments)\n\n    if close:\n        loop0 = np.append(loop0, loop0[0]).astype(bint)\n        loop1 = np.append(loop1, loop1[0]).astype(bint)\n    else:\n        loop0 = np.asarray(loop0, dtype=bint)\n        loop1 = np.asarray(loop1, dtype=bint)\n\n    sel0 = np.stack((loop0[:-1], loop0[1:]), axis=-1)\n    sel1 = np.stack((loop1[:-1], loop1[1:]), axis=-1)\n\n    sel0 = np.sort(sel0, axis=-1)\n    sel1 = np.sort(sel1, axis=-1)\n\n    with self.bmesh() as bm:\n\n        edges, verts_indices = self._bm_edges(bm)\n\n        # Prepare edges view\n        dtype = np.dtype([('a', bint), ('b', bint)])\n        edges_view = verts_indices.view(dtype)\n\n        # First loop\n        sel0_view = sel0.view(dtype)\n        mask = np.isin(edges_view.ravel(), sel0_view.ravel())\n\n        edges_to_bridge = list(edges[mask])\n\n        # Second loop\n        sel1_view = sel1.view(dtype)\n        mask = np.isin(edges_view.ravel(), sel1_view.ravel())\n\n        edges_to_bridge.extend(list(edges[mask]))\n\n        if len(edges_to_bridge) == 0:\n            return\n\n        # Bridge\n        res = bmesh.ops.bridge_loops(\n            bm, \n            edges=edges_to_bridge,\n            #use_cyclic = close,\n            #segments=segments,\n            )\n\n        # Grid\n        if segments &gt; 1:\n            bmesh.ops.subdivide_edges(\n                bm,\n                edges=res['edges'],\n                cuts=segments - 1,\n                use_grid_fill=False\n            )\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bvh_tree","title":"bvh_tree","text":"<pre><code>bvh_tree(count=None)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def bvh_tree(self, count=None):\n    if count is None:\n        return BVHTree.FromPolygons(self.points.position, self.faces.sequences(), all_triangles=False, epsilon=0.0)\n\n    else:\n        pos    = self.points.position\n        pos    = pos.reshape(count, -1, 3)\n\n        nfaces = len(self.faces)//count\n        inds   = list(self.corners.vertex_index)\n        faces  = [inds[lstart:lstart+ltotal] for (lstart, ltotal) in zip(self.faces.loop_start[:nfaces], self.faces.loop_total[:nfaces])]\n\n        return [BVHTree.FromPolygons(pos[i], faces, all_triangles=False, epsilon=0.0) for i in range(count)]\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.capture","title":"capture","text":"<pre><code>capture(other)\n</code></pre> <p>Capture the data of another Mesh.</p> Arguments <pre><code>- other (Mesh) : the mesh to capture\n</code></pre> <p>Returns:</p> Type Description <code>    - self</code> Source code in <code>npblender/mesh.py</code> <pre><code>def capture(self, other):\n    \"\"\" Capture the data of another Mesh.\n\n    Arguments\n    ---------\n        - other (Mesh) : the mesh to capture\n\n    Returns\n    -------\n        - self\n    \"\"\"\n\n    self.materials = other.materials\n\n    self.points  = other.points\n    self.corners = other.corners\n    self.faces   = other.faces\n    self.edges   = other.edges\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.chain_link","title":"chain_link  <code>classmethod</code>","text":"<pre><code>chain_link(major_segments=48, minor_segments=12, radius=1.0, section=0.5, length=4.0, materials=None)\n</code></pre> <p>Create a chain link.</p> <pre><code># ----- Some maths\n\n# Chain follows a catenary curve\ndef catenary(t):\n    return np.stack((t, np.zeros_like(t), np.cosh(t)), axis=-1)\n\n# Orientation is given by the derivative\ndef derivative(t):\n    dt = 1/10000\n    return (catenary(t + dt) - catenary(t - dt))/(2*dt)\n\n# Catenary length\npts = catenary(np.linspace(-1, 1, 1000))\ncat_s = np.cumsum(np.linalg.norm(pts[1:] - pts[:-1], axis=-1))\ncat_len = cat_s[-1]\n\n# Catenary inverse : t from length\ndef cat_inverse(l):\n    return 2*np.argmin(np.abs(cat_s - l))/1000 - 1\n\n# ----- Let's build the geometry\n\n# One chain link\nsection = .02\nlength  = .15\nlink = MeshBuilder.ChainLink(radius=.04, section=section, length=length)\n\n# Link length taking into account the section\nl = length - 2*section\n\n# Number of links\ncount = round(cat_len / l)\n\n# The chain\nchain = link*count\n\n# Rotate pi/2 one on two\neulers = Eulers(shape=count)\neulers[[i % 2 == 1 for i in range(count)]] = (0, np.pi/2, 0)\n\nchain.rotate(eulers)\nchain.rotate_z(np.pi/2)\n\n# Location of each link\nt = np.array([cat_inverse(l*i) for i in range(count)])\n\nchain.toward(derivative(t), track_axis='X', up_axis='Z')\nchain.translate(catenary(t))\n\n# To object\nchain.to_object(\"Catenary\")\n</code></pre> Arguments <pre><code>- major_segments (int=48) : number of segments for the link\n- minor_segments (int=12) : number of segments for the section\n- radius (float=1.) : radius of the link\n- section (float=.5) : section (diameter)\n- length (float=4.) : total length of the link\n- materials (list of strs = None) : materials list\n</code></pre> <p>Returns:</p> Type Description <code>    - MeshBuilder</code> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef chain_link(cls, major_segments=48, minor_segments=12, radius=1., section=0.5, length=4., materials=None):\n    \"\"\" Create a chain link.\n\n    ``` python\n    # ----- Some maths\n\n    # Chain follows a catenary curve\n    def catenary(t):\n        return np.stack((t, np.zeros_like(t), np.cosh(t)), axis=-1)\n\n    # Orientation is given by the derivative\n    def derivative(t):\n        dt = 1/10000\n        return (catenary(t + dt) - catenary(t - dt))/(2*dt)\n\n    # Catenary length\n    pts = catenary(np.linspace(-1, 1, 1000))\n    cat_s = np.cumsum(np.linalg.norm(pts[1:] - pts[:-1], axis=-1))\n    cat_len = cat_s[-1]\n\n    # Catenary inverse : t from length\n    def cat_inverse(l):\n        return 2*np.argmin(np.abs(cat_s - l))/1000 - 1\n\n    # ----- Let's build the geometry\n\n    # One chain link\n    section = .02\n    length  = .15\n    link = MeshBuilder.ChainLink(radius=.04, section=section, length=length)\n\n    # Link length taking into account the section\n    l = length - 2*section\n\n    # Number of links\n    count = round(cat_len / l)\n\n    # The chain\n    chain = link*count\n\n    # Rotate pi/2 one on two\n    eulers = Eulers(shape=count)\n    eulers[[i % 2 == 1 for i in range(count)]] = (0, np.pi/2, 0)\n\n    chain.rotate(eulers)\n    chain.rotate_z(np.pi/2)\n\n    # Location of each link\n    t = np.array([cat_inverse(l*i) for i in range(count)])\n\n    chain.toward(derivative(t), track_axis='X', up_axis='Z')\n    chain.translate(catenary(t))\n\n    # To object\n    chain.to_object(\"Catenary\")\n    ```\n\n    Arguments\n    ---------\n        - major_segments (int=48) : number of segments for the link\n        - minor_segments (int=12) : number of segments for the section\n        - radius (float=1.) : radius of the link\n        - section (float=.5) : section (diameter)\n        - length (float=4.) : total length of the link\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - MeshBuilder\n    \"\"\"\n\n    delta = length - 2*radius\n\n    # Starting from a torus\n    clink = cls.torus(\n        major_radius    = radius, \n        minor_radius    = section/2, \n        major_segments  = major_segments, \n        minor_segments  = minor_segments, \n        materials       = materials\n    )\n    # Nothing else\n    if delta &lt; radius/10:\n        return clink\n\n    epsilon = radius/major_segments\n\n    # Delete half of the points\n    clink.delete_vertices(points=clink.points.y &lt; -epsilon)\n    npoints = len(clink.points)\n    borders = clink.points.y &lt; epsilon\n    loop0 = np.arange(npoints)[np.logical_and(borders, clink.points.x &lt; 0)]\n    loop1 = np.arange(npoints)[np.logical_and(borders, clink.points.x &gt; 0)]\n    clink.points.y += delta/2\n\n    # Duplicate and inverse\n    half = Mesh.from_mesh(clink)\n    half.points.position[:, :2] *= -1\n\n    # Join\n    clink.join(half)\n\n    # Bridge\n    clink.bridge_loops(loop0, loop1 + npoints, close=True)\n    clink.bridge_loops(loop1, loop0 + npoints, close=True)\n\n    # UVMap\n    nu, nv = major_segments + 3, minor_segments + 1\n    uvmap = grid_uv_map(nu, nv).reshape(nu - 1, nv - 1, 4, 2)\n\n    ratio = (length - radius)/(length - radius + np.pi*radius)\n    dx_side = ratio/2\n\n    uvmap[:-2,..., 0] *= (1 - ratio)/(1 - 2/nu)\n    uvmap[-2,:, [0, 3], 0] = 1 - ratio\n    uvmap[-2,:, [1, 2], 0] = 1 - ratio/2\n    uvmap[-1,:, [0, 3], 0] = 1 - ratio/2\n\n    clink.corners.UVMap = uvmap.reshape(-1, 2)\n\n    return clink\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.check","title":"check","text":"<pre><code>check(title='Mesh Check', halt=True)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def check(self, title=\"Mesh Check\", halt=True):\n    ok = self.corners.check(len(self.points), halt=False) and \\\n           self.faces.check(len(self.corners), halt=False) and \\\n           self.edges.check(len(self.points), halt=False)\n    if ok:\n        return True\n    elif halt:\n        raise Exception(f\"{title} check failed\")\n    else:\n        print(f\"{title} check failed\")\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.circle","title":"circle  <code>classmethod</code>","text":"<pre><code>circle(radius=1, segments=16, fill_segments=0, cap='NONE', materials=None)\n</code></pre> <p>Create a Circle.</p> <p>'fill_segments' argument gives the number of internal circles to create. If zero, the circle if filled with a polygon. If positive, the circle is filled with triangle fans.</p> Arguments <pre><code>- radius (float=1.) : circle radius\n- segments (int=16) : number of segments\n- fill_segments (int = 0) : number of internal segments, polygon is None\n- materials (list of strs = None) : materials list\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef circle(cls, radius=1, segments=16, fill_segments=0, cap='NONE', materials=None):\n    \"\"\" Create a Circle.\n\n    'fill_segments' argument gives the number of internal circles to create.\n    If zero, the circle if filled with a polygon.\n    If positive, the circle is filled with triangle fans.\n\n    Arguments\n    ---------\n        - radius (float=1.) : circle radius\n        - segments (int=16) : number of segments\n        - fill_segments (int = 0) : number of internal segments, polygon is None\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    ag = np.linspace(0, 2*np.pi, segments, endpoint=False)\n    x = radius*np.cos(ag)\n    y = radius*np.sin(ag)\n    points = np.stack((x, y, np.zeros_like(x)), axis=-1)\n\n    if cap == 'NONE':\n        i = np.arange(segments)\n        edges = np.stack((i, np.roll(i, shift=-1)), axis=-1)\n        return cls(points=points, edges=edges)\n\n    elif cap == 'NGON':\n        return cls(\n            points      = points, \n            corners     = np.arange(segments), \n            faces       = segments,\n            UVMap       = disk_uv_map(segments, mode='NGON').reshape(-1, 2),\n            materials   = materials,\n        )\n\n    elif cap == 'FANS':\n        points = np.append(points, [[0, 0, 0]], axis=0)\n        topo = fans_corners(segments)\n\n        return cls(\n            points      = points, \n            corners     = topo.ravel(), \n            faces       = 3,\n            UVMap       = disk_uv_map(segments, mode='FANS').reshape(-1, 2),\n            materials   = materials,\n        )\n\n    #mesh = cls(points=points)\n    #mesh.fill_cap(np.arange(segments), mode=cap, center=segments, clockwise=True)\n\n    assert(False)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.clear_geometry","title":"clear_geometry","text":"<pre><code>clear_geometry()\n</code></pre> <p>Clear the geometry.</p> <p>Delete all the content.</p> Source code in <code>npblender/mesh.py</code> <pre><code>def clear_geometry(self):\n    \"\"\" Clear the geometry.\n\n    Delete all the content.\n    \"\"\"\n\n    self.points.clear()\n    self.corners.clear()\n    self.faces.clear()\n    self.edges.clear()\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.compute_attribute_on_domain","title":"compute_attribute_on_domain","text":"<pre><code>compute_attribute_on_domain(domain_from, attr, domain_to)\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def compute_attribute_on_domain(self, domain_from, attr, domain_to):\n\n    if domain_from == domain_to:\n        return attr\n\n    if (domain_from not in self.domain_names) or (domain_to not in self.domain_names):\n        raise AttributeError(\n            f\"The geometry '{type(self).__name__}' doesn't have domains '{domain_from}' and '{domain_to}'.\\n\"\n            f\"Valid domains are: {self.domain_names}.\"\n            )\n\n    if domain_from == 'points':\n        if domain_to == 'faces':\n            return self.points.compute_attribute_on_faces(attr, self.corners, self.faces)\n        elif domain_to == 'edges':\n            return self.points.compute_attribute_on_edges(attr, self.edges)\n        elif domain_to == 'corners':\n            return self.points.compute_attribute_on_corners(attr, self.corners)\n        elif domain_to == 'splines':\n            return self.points.compute_attribute_on_splines(attr, self.splines)\n\n    elif domain_from == 'faces':\n        if domain_to == 'points':\n            return self.faces.compute_attribute_on_points(attr, self.corners, self.points)\n        elif domain_to == 'edges':\n            pass\n        elif domain_to == 'corners':\n            pass\n\n    elif domain_from == 'edges':\n        if domain_to == 'points':\n            return self.edges.compute_attribute_on_points(attr, self.points)\n        elif domain_to == 'faces':\n            pass\n        elif domain_to == 'corners':\n            pass\n\n    elif domain_from == 'corners':\n        if domain_to == 'points':\n            return self.corners.compute_attribute_on_points(attr, self.points)\n        elif domain_to == 'faces':\n            pass\n        elif domain_to == 'edges':\n            pass\n\n    elif domain_from == 'splines':\n        if domain_to == 'points':\n            return self.splines.compute_attribute_on_points(attr, self.points)\n\n    raise Exception(\n        f\"Sorry, computing attribue from '{domain_from}' to '{domain_to}' is not implemented yet.\")\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.compute_attribute_on_domain_OLD","title":"compute_attribute_on_domain_OLD","text":"<pre><code>compute_attribute_on_domain_OLD(attr_name, domain_name)\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def compute_attribute_on_domain_OLD(self, attr_name, domain_name):\n\n    from numba import njit, prange\n\n    # ---------------------------------------------------------------------------\n    # Faces to points\n\n    @njit(cache=True)\n    def _faces_to_points(loop_start, loop_total, vertex_index, source, res):\n        V = res.shape[0]\n        F = loop_start.shape[0]\n\n        count = np.zeros(V, dtype=np.int32)\n        for f in range(F):\n            s, t, val = loop_start[f], loop_total[f], source[f]\n            for k in range(t):\n                v = vertex_index[s + k]\n                res[v] += val\n                count[v] += 1\n\n        trailing = 1\n        for d in range(1, res.ndim):\n            trailing *= res.shape[d]\n\n        R2 = res.reshape((V, trailing))\n        for v in range(V):\n            c = count[v]\n            if c &gt; 0:\n                inv = 1.0 / c\n                for j in range(trailing):\n                    R2[v, j] *= inv\n\n        return res\n\n    # ---------------------------------------------------------------------------\n    # Points to faces\n\n    @njit(cache=True)\n    def _points_to_faces(loop_start, loop_total, vertex_index, source, res):\n        F = loop_start.shape[0]\n\n        for f in range(F):\n            s = loop_start[f]\n            t = loop_total[f]\n            for k in range(t):\n                v = vertex_index[s + k]\n                res[f] += source[v]\n            inv = 1.0 / t\n            res[f] *= inv\n\n        return res\n\n    # ---------------------------------------------------------------------------\n    # Get the source domain for attribute\n    # ---------------------------------------------------------------------------\n\n    source_domain_name = None\n    for name in self.domain_names:\n        source_domain = getattr(self, name)\n        if attr_name in source_domain._infos:\n            source_domain_name = name\n            break\n\n    if source_domain_name is None:\n        raise AttributeError(f\"No domain has an attribute named '{attr_name}'\")\n\n    # ---------------------------------------------------------------------------\n    # Prepare\n    # ---------------------------------------------------------------------------\n\n    domain_name = domain_name.lower()\n\n    source = source_domain[attr_name]\n\n    # Source = Target domain\n    if domain_name == source_domain_name:\n        return source\n\n    # Resulting array\n    item_shape = source_domain._infos[attr_name]['shape']\n    target_domain = getattr(self, domain_name)\n    res = np.zeros((len(target_domain),) + item_shape, dtype=source.dtype)\n    count = None\n\n    # ---------------------------------------------------------------------------\n    # Different cases\n    # ---------------------------------------------------------------------------\n\n    # Faces to points\n    if source_domain_name == 'faces' and domain_name == 'points':\n        if True:\n            res = _faces_to_points(\n                np.ascontiguousarray(self.faces.loop_start, dtype=np.int32),\n                np.ascontiguousarray(self.faces.loop_total, dtype=np.int32),\n                np.ascontiguousarray(self.corners.vertex_index, dtype=np.int32),\n                np.ascontiguousarray(source, dtype=source.dtype),\n                np.ascontiguousarray(res, dtype=res.dtype),\n            )\n\n        else:\n            count = np.zeros(len(target_domain), dtype=int)\n            for loop_start, loop_total, val in zip(self.faces.loop_start, self.faces.loop_total, source):\n                corners = self.corners.vertex_index[loop_start:loop_start+loop_total]\n                res[corners] += val\n                count[corners] += 1\n\n    # Points to faces\n    elif source_domain_name == 'points' and domain_name == 'faces':\n        if True:\n            res = _points_to_faces(\n                np.ascontiguousarray(self.faces.loop_start, dtype=np.int32),\n                np.ascontiguousarray(self.faces.loop_total, dtype=np.int32),\n                np.ascontiguousarray(self.corners.vertex_index, dtype=np.int32),\n                np.ascontiguousarray(source, dtype=source.dtype),\n                np.ascontiguousarray(res, dtype=res.dtype),\n            )\n        else:\n            for i_face, (loop_start, loop_total) in enumerate(zip(self.faces.loop_start, self.faces.loop_total)):\n                corners = self.corners[loop_start:loop_start+loop_total]\n                res[i_face] = np.average(source[corners], axis=0)\n\n    # Edges to points\n    elif source_domain_name == 'edges' and domain_name == 'points':\n        count = np.zeros(len(target_domain), dtype=int)\n        for v0, v1, value in zip(self.edges.vertex0, self.edges.vertex1, source):\n            res[v0] += value\n            res[v1] += value\n            count[v0] += 1\n            count[v1] += 1\n\n    # Points to edges\n    elif source_domain_name == 'points' and domain_name == 'edges':\n        for i_edge, (v0, v1) in enumerate(zip(self.edges.vertex0, self.edges.vertex1)):\n            res[i_edge] = (source[v0] + source[v1])/2\n\n    # Splines to points\n    elif source_domain_name == 'splines' and domain_name == 'points':\n        for loop_start, loop_total, val in zip(self.faces.loop_start, self.faces.loop_total, source):\n            res[loop_start:loop_start+loop_total] = val\n\n    # Points to splines\n    elif source_domain_name == 'points' and domain_name == 'splines':\n        for i_spline, (loop_start, loop_total) in enumerate(zip(self.faces.loop_start, self.faces.loop_total)):\n            res[i_spline] = np.average(source[loop_start:loop_start+loop_total], axis=0)\n\n    # Not implemented\n    else:\n        raise Exception(f\"Sorry: compute_attribute from '{source_domain_name}' to '{domain_name}' domains is not implemented yet.\")\n\n    # ---------------------------------------------------------------------------\n    # Finalization\n    # ---------------------------------------------------------------------------\n\n    if count is not None:\n        if len(item_shape) == 1:\n            count = count[:, None]\n        elif len(item_shape) == 2:\n            count = count[:, None, None]\n\n        res = res/count\n\n    return res\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.cone","title":"cone  <code>classmethod</code>","text":"<pre><code>cone(vertices=32, side_segments=1, fill_segments=1, radius_top=0, radius_bottom=1, depth=2, fill_type='NGON', materials=None)\n</code></pre> <p>Create a Cone.</p> Arguments <pre><code>- vertices (int=16) : number of segments\n- side_segments (int = 1) : number of vertical segments\n- fill_segments (int = 1) : number of internal circles on the caps\n- radius_top (float=0) : top radius\n- radius_bottom (float=1) : bottom radius\n- depth (float=2.) : cylinder height\n- fill_type (str or couple of strs ='NGON' in 'NGON', 'FANS', 'NONE') : cap filling\n- materials (list of strs = None) : materials list\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef cone(cls, vertices=32, side_segments=1, fill_segments=1, radius_top=0, radius_bottom=1, depth=2, fill_type='NGON', materials=None):\n    \"\"\" Create a Cone.\n\n    Arguments\n    ---------\n        - vertices (int=16) : number of segments\n        - side_segments (int = 1) : number of vertical segments\n        - fill_segments (int = 1) : number of internal circles on the caps\n        - radius_top (float=0) : top radius\n        - radius_bottom (float=1) : bottom radius\n        - depth (float=2.) : cylinder height\n        - fill_type (str or couple of strs ='NGON' in 'NGON', 'FANS', 'NONE') : cap filling\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    # Empty geometry if fhe two radius are null\n    if radius_top == 0 and radius_bottom == 0:\n        return cls()\n\n    mesh = cls.bl_cone(\n        radius1       = radius_bottom,\n        radius2       = radius_top,\n        segments      = vertices,\n        side_segments = side_segments,\n        depth         = depth,\n        cap_ends      = fill_type in ['NGON', 'FANS'],\n        cap_tris      = fill_type == 'FANS',\n        materials     = materials,\n    )\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.cube","title":"cube  <code>classmethod</code>","text":"<pre><code>cube(size=2, materials=None)\n</code></pre> <p>Create a Cube.</p> Arguments <pre><code>- size (float=1.) : size of the cube\n- materials (list of strs = None) : materials list\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef cube(cls, size=2, materials=None):\n    \"\"\" Create a Cube.\n\n    Arguments\n    ---------\n        - size (float=1.) : size of the cube\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    verts = [[-1., -1., -1.], [-1., -1.,  1.], [-1.,  1., -1.], [-1.,  1.,  1.], [ 1., -1., -1.], [ 1., -1.,  1.], [ 1.,  1., -1.], [ 1.,  1.,  1.],]\n    corners = [0, 1, 3, 2,  2, 3, 7, 6,  6, 7, 5, 4,  4, 5, 1, 0,  2, 6, 4, 0,  7, 3, 1, 5]\n    faces = [4]*6\n    uvs   = [[0.375, 0.000], [0.625, 0.000], [0.625, 0.250], [0.375, 0.250], [0.375, 0.250], [0.625, 0.250], [0.625, 0.500], [0.375, 0.500],\n             [0.375, 0.500], [0.625, 0.500], [0.625, 0.750], [0.375, 0.750], [0.375, 0.750], [0.625, 0.750], [0.625, 1.000], [0.375, 1.000],\n             [0.125, 0.500], [0.375, 0.500], [0.375, 0.750], [0.125, 0.750], [0.625, 0.500], [0.875, 0.500], [0.875, 0.750], [0.625, 0.750], ]\n\n\n    mesh = cls(points=verts, corners=corners, faces=faces, materials=materials, UVMap=uvs)\n\n    size = np.asarray(size)\n    mesh.points.position *= size/2\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.cylinder","title":"cylinder  <code>classmethod</code>","text":"<pre><code>cylinder(vertices=32, side_segments=1, radius=1, depth=2, fill_type='NGON', materials=None)\n</code></pre> <p>Create a Cylinder.</p> Arguments <pre><code>- vertices (int=16) : number of segments\n- side_segments (int = 1) : number of vertical segments\n- radius (float=1.) : radius\n- depth (float=2.) : cylinder height\n- fill_type (str or couple of strs ='NGON' in 'NGON', 'TRIANGLE_FAN', 'NONE') : cap filling\n- materials (list of strs = None) : materials list\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef cylinder(cls, vertices=32, side_segments=1, radius=1, depth=2, fill_type='NGON', materials=None):\n    \"\"\" Create a Cylinder.\n\n    Arguments\n    ---------\n        - vertices (int=16) : number of segments\n        - side_segments (int = 1) : number of vertical segments\n        - radius (float=1.) : radius\n        - depth (float=2.) : cylinder height\n        - fill_type (str or couple of strs ='NGON' in 'NGON', 'TRIANGLE_FAN', 'NONE') : cap filling\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    mesh = cls.bl_cone(\n        radius1       = radius,\n        radius2       = radius,\n        segments      = vertices,\n        side_segments = side_segments,\n        depth         = depth,\n        cap_ends      = fill_type in ['NGON', 'FANS'],\n        cap_tris      = fill_type == 'FANS',\n        materials     = materials,\n    )\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.delete_faces","title":"delete_faces","text":"<pre><code>delete_faces(selection)\n</code></pre> <p>Delete only faces.</p> Source code in <code>npblender/mesh.py</code> <pre><code>def delete_faces(self, selection):\n    \"\"\" Delete only faces.\n    \"\"\"\n    self.faces.delete_loops(selection, self.corners)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.delete_vertices","title":"delete_vertices","text":"<pre><code>delete_vertices(points=None, faces=None, edges=None)\n</code></pre> <p>Delete vertices.</p> Arguments <pre><code>points : array selection, optional\n    Vertex indices to delete directly.\nfaces : array selection, optional\n    Faces owning vertices to delete.\nedges : array selection, optional\n    Edges owning vertices to delete.\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def delete_vertices(self, points=None, faces=None, edges=None):\n    \"\"\"Delete vertices.\n\n    Arguments\n    ---------\n        points : array selection, optional\n            Vertex indices to delete directly.\n        faces : array selection, optional\n            Faces owning vertices to delete.\n        edges : array selection, optional\n            Edges owning vertices to delete.\n    \"\"\"\n    go = False\n    if points is not None:\n        p_sel = set(np.arange(len(self.points))[points])\n        go = True\n    if faces is not None:\n        f_sel = set(np.arange(len(self.faces))[faces])\n        go = True\n    if edges is not None:\n        e_sel = set(np.arange(len(self.edges))[edges])\n        go = True\n\n    if not go:\n        return \n\n    with self.bmesh() as bm:\n        verts_to_delete = set()\n\n        for vert in bm.verts:\n            if points is not None and vert.index in p_sel:\n                verts_to_delete.add(vert)\n                continue\n\n            if faces is not None:\n                if any(f.index in f_sel for f in vert.link_faces):\n                    verts_to_delete.add(vert)\n                    continue\n\n            if edges is not None:\n                if any(e.index in e_sel for e in vert.link_edges):\n                    verts_to_delete.add(vert)\n                    continue\n\n        bmesh.ops.delete(bm, geom=list(verts_to_delete), context='VERTS')\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.disk","title":"disk  <code>classmethod</code>","text":"<pre><code>disk(radius=1, segments=16, fill_segments=0, cap='NGON', materials=None)\n</code></pre> <p>Create a disk.</p> <p>Same as circle but default cap is NGON</p> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef disk(cls, radius=1, segments=16, fill_segments=0, cap='NGON', materials=None):\n    \"\"\" Create a disk.\n\n    Same as circle but default cap is NGON\n    \"\"\"    \n    return cls.circle(radius=radius, segments=segments, fill_segments=fill_segments, cap=cap, materials=materials)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.dual","title":"dual","text":"<pre><code>dual(center='median')\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def dual(self, center=\"median\"):\n\n    verts = np.empty((len(self.faces), 3), np.float32)\n    corners = []\n    faces = []\n\n    with self.bmesh() as bm:\n\n        bm.faces.ensure_lookup_table()\n        bm.verts.ensure_lookup_table()    \n        bm.edges.ensure_lookup_table()    \n\n        # ---------------------------------------------------------------------------\n        # Faces become points\n        # ---------------------------------------------------------------------------\n\n        if center.lower() == 'median':\n            for f in bm.faces:\n                c = f.calc_center_median()\n                verts[f.index] = (c.x, c.y, c.z)\n\n        elif center.lower() == 'bounds':\n            for f in bm.faces:\n                c = f.calc_center_bounds()\n                verts[f.index] = (c.x, c.y, c.z)\n\n        elif center.lower() == 'weighted':\n            for f in bm.faces:\n                c = f.calc_center_median_weighted()\n                verts[f.index] = (c.x, c.y, c.z)\n\n        else:\n            raise ValueError(f\"Center must be in ('median', 'bounds','weighted').\")\n\n        # ---------------------------------------------------------------------------\n        # Vertices becom faces\n        # ---------------------------------------------------------------------------\n\n        for v in bm.verts:\n            # Faces need to be ordered (link_faces is not good)\n            # Get the edges as couples (face.index, face.index)\n            # then chain the edges\n\n            couples = []\n            first = True\n            for edge in v.link_edges:\n\n                if len(edge.link_faces) != 2:\n                    couples = []\n                    break\n\n                # First is used for the order between:\n                # - face0 then face1\n                # - face1 then face0\n                if first:\n                    first = False\n\n                    # The edge links two vertices\n                    other_index = edge.verts[0].index if edge.verts[1].index == v.index else edge.verts[1].index\n\n                    # We select as first face the one where loop is v -&gt; other                \n                    face0 = edge.link_faces[0]\n                    for i_loop, lp in enumerate(face0.loops):\n                        if lp.vert.index == other_index:\n                            j = (i_loop + 1)%len(face0.loops)\n                            take0 = face0.loops[j].vert.index == v.index\n                            break\n\n                    if take0:\n                        loop = [edge.link_faces[0].index, edge.link_faces[1].index]\n                    else:\n                        loop = [edge.link_faces[1].index, edge.link_faces[0].index]\n\n                else:\n                    couples.append((edge.link_faces[0].index, edge.link_faces[1].index))\n\n            if len(couples) &lt; 2:\n                continue\n\n            # Build the other faces by chaing the edges \n            # First loop to consume the edge couples      \n            for _ in range(len(couples)):\n                found = False\n                # Second loop to find the following edge\n                for i, e in enumerate(couples):\n                    if e[0] == loop[-1]:\n                        loop.append(e[1])\n                        found = True\n                    elif e[1] == loop[-1]:\n                        loop.append(e[0])\n                        found = True\n                    else:\n                        continue\n                    break\n\n                if found:\n                    del couples[i]\n                else:\n                    loop = []\n                    break\n\n            if len(loop) &lt; 3:\n                continue\n\n            faces.append(len(loop))\n            corners.extend(loop)\n\n    # We can build the dual mesh\n    return Mesh(points=verts, corners=corners, faces=faces, materials=self.materials)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.dummy","title":"dummy  <code>classmethod</code>","text":"<pre><code>dummy(points_count=0, corners_count=0, faces=None, edges=None, seed=0, **attrs)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef dummy(cls, points_count=0, corners_count=0, faces=None, edges=None, seed=0, **attrs):\n    rng = np.random.default_rng(seed)\n    verts = rng.uniform(-1, 1, (points_count, 3)) if points_count else None\n    corners = rng.uniform(0, points_count, corners_count) if corners_count else None\n    loops = None\n\n    if faces is None:\n        n = corners_count if corners_count else points_count\n        if n &gt; 0:\n            loops = [4] * (n //4)\n            loops[0] = n - np.sum(loops[1:])\n        else:\n            loops = None\n    else:\n        loops = faces\n\n    return cls(points=verts, corners=corners, faces=loops, edges=edges,**attrs)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_faces","title":"extrude_faces","text":"<pre><code>extrude_faces(selection, offset=None, scale=1.0)\n</code></pre> <p>Extrude individual faces.</p> <p>If offset is None, faces are extruder along their normal</p> Arguments <pre><code>- selection : indices of the faces to extrude\n- offset (vector or array of vectors) : the extrusion vector\n- scale (float = 1) : scale factor for offsets\n- dissolve (bool = True) : remove starting faces\n</code></pre> <p>Returns:</p> Type Description <code>    - dictionnary : 'top' : extruded faces, 'side' : extruded side faces</code> Source code in <code>npblender/mesh.py</code> <pre><code>def extrude_faces(self, selection, offset=None, scale=1.):\n    \"\"\" Extrude individual faces.\n\n    If offset is None, faces are extruder along their normal\n\n    Arguments\n    ---------\n        - selection : indices of the faces to extrude\n        - offset (vector or array of vectors) : the extrusion vector\n        - scale (float = 1) : scale factor for offsets\n        - dissolve (bool = True) : remove starting faces\n\n    Returns\n    -------\n        - dictionnary : 'top' : extruded faces, 'side' : extruded side faces\n    \"\"\"\n\n    # Selected faces indices\n    faces_sel = np.arange(len(self.faces))\n    if selection is not None:\n        faces_sel = faces_sel[selection]\n\n    # bmesh edition\n    with self.bmesh() as bm:\n        #bm.verts.ensure_lookup_table()\n        bm.faces.ensure_lookup_table()\n\n        # select faces\n        start_faces = [bm.faces[i] for i in faces_sel]\n\n        res = {'top': [], 'side': []}\n\n        # bmesh.ops\n        d = bmesh.ops.extrude_discrete_faces(bm, faces=start_faces)\n        new_faces = d[\"faces\"]\n\n\n\n        # One direction per face\n        if offset is not None:\n            shape = np.broadcast_shapes(np.shape(offset), (len(new_faces), 3))\n            offsets = np.broadcast_to(offset, shape)*scale\n\n        # Loop on created faces\n        for i_face, face in enumerate(new_faces):\n            verts = face.verts\n            if offset is None:\n                ofs = face.normal*scale\n            else:\n                ofs = offsets[i_face]\n\n            bmesh.ops.translate(bm, verts=list(verts), vec=ofs)\n\n            res['top'].append(face.index)\n            for e in face.edges:\n                assert(len(e.link_faces) == 2)\n                if e.link_faces[0].index == face.index:\n                    res['side'].append(e.link_faces[1].index)\n                else:\n                    res['side'].append(e.link_faces[0].index)\n\n    return res\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_loop","title":"extrude_loop","text":"<pre><code>extrude_loop(loop, offset, close=False, clockwise=False, **attributes)\n</code></pre> <p>Extrude a loop of vertices.</p> Arguments <pre><code>- loop (array of ints) : vertex indices\n- offset (float = 1) : multiplicator of the direction vector\n- direction (vector = None) : extrusion direction, normal if None\n- clockwise (bool=False) : faces orientation\n- attributes : attribute for the new geometry\n</code></pre> <p>Returns:</p> Type Description <code>    - dictionnary of the created geometry : vertex indices, face indices</code> Source code in <code>npblender/mesh.py</code> <pre><code>def extrude_loop(self, loop, offset, close=False, clockwise=False, **attributes):\n    \"\"\" Extrude a loop of vertices.\n\n    Arguments\n    ---------\n        - loop (array of ints) : vertex indices\n        - offset (float = 1) : multiplicator of the direction vector\n        - direction (vector = None) : extrusion direction, normal if None\n        - clockwise (bool=False) : faces orientation\n        - attributes : attribute for the new geometry\n\n    Returns\n    -------\n        - dictionnary of the created geometry : vertex indices, face indices\n    \"\"\"\n    loop = np.atleast_1d(loop)\n    if len(loop) &lt; 2:\n        return None\n\n    verts = self.points.position[loop]\n    try:\n        new_verts = verts + offset\n    except Exception as e:\n        raise AttributeError(\n            f\"Extrude&gt; Offset argument must be a single vector or an array of {len(verts)} vectors, not {np.shape(offset)}.\"\n            )\n\n    indices = np.append(loop, len(self.points) + np.arange(len(new_verts)))\n    gc = grid_corners(len(verts), 2, row_first=True, close_x=close, clockwise=clockwise)\n    corners = indices[gc.ravel()]\n    uvmap = grid_uv_map(len(verts), 2, close_x=close, clockwise=clockwise).reshape(-1, 2)\n\n    return self.add_geometry(points=new_verts, corners=corners, faces=4, UVMap=uvmap)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_region","title":"extrude_region","text":"<pre><code>extrude_region(selection, offset=(0, 0, 1), dissolve=False)\n</code></pre> <p>Extrude individual faces.</p> Arguments <pre><code>- selection : indices of the faces to extrude\n- offset (vector = (0, 0, 1)) : the extrusion vector\n- dissolve (bool = True) : remove starting faces\n</code></pre> <p>Returns:</p> Type Description <code>    - dictionnary : 'top' : extruded faces, 'side' : extruded side faces</code> Source code in <code>npblender/mesh.py</code> <pre><code>def extrude_region(self, selection, offset=(0, 0, 1), dissolve=False):\n    \"\"\" Extrude individual faces.\n\n    Arguments\n    ---------\n        - selection : indices of the faces to extrude\n        - offset (vector = (0, 0, 1)) : the extrusion vector\n        - dissolve (bool = True) : remove starting faces\n\n    Returns\n    -------\n        - dictionnary : 'top' : extruded faces, 'side' : extruded side faces\n    \"\"\"\n\n    # Selected faces indices\n    faces_sel = np.arange(len(self.faces))\n    if selection is not None:\n        faces_sel = faces_sel[selection]\n\n    # bmesh edition\n    with self.bmesh() as bm:\n        #bm.verts.ensure_lookup_table()\n        bm.faces.ensure_lookup_table()\n\n        # select faces\n        start_faces = [bm.faces[i] for i in faces_sel]\n\n        res = {'top': [], 'side': []}\n\n\n        # Extrusion\n        d = bmesh.ops.extrude_face_region(\n            bm, \n            geom                      = start_faces,\n            #edges_exclude            = set(),\n            #use_keep_orig            = False,\n            #use_normal_flip          = False,\n            #use_normal_from_adjacent = False,\n            #use_dissolve_ortho_edges = False,\n            #use_select_history       = False,\n            )\n\n        # Move new vectors\n        extruded_geom = d[\"geom\"]\n        new_verts = [ele for ele in extruded_geom if isinstance(ele, bmesh.types.BMVert)]\n        new_faces = [ele for ele in extruded_geom if isinstance(ele, bmesh.types.BMFace)]\n\n        bmesh.ops.translate(bm, verts=new_verts, vec=list(offset))\n\n        # ===== Result\n        for face in new_faces:\n            res['top'].append(face.index)\n            for e in face.edges:\n                assert(len(e.link_faces) == 2)\n                if e.link_faces[0].index == face.index:\n                    res['side'].append(e.link_faces[1].index)\n                else:\n                    res['side'].append(e.link_faces[0].index)\n\n        # ===== Dissolve extruded faces\n        if dissolve:\n            bm.faces.ensure_lookup_table()\n            del_faces = [bm.faces[i] for i in faces_sel]\n\n            bmesh.ops.delete(bm, geom=del_faces, context='FACES')                   \n\n    return res\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_vertices","title":"extrude_vertices","text":"<pre><code>extrude_vertices(selection, offset, **attributes)\n</code></pre> <p>Extrude individual vertices</p> Arguments <pre><code>- selection (selector) : points selection, all if None\n- offset (vector or array of vectors) : extrusion vector\n- attributes (dict) : points attributes\n</code></pre> <p>Returns:</p> Type Description <code>    - dictionnary of the created geometry : vertex indices, face indices</code> Source code in <code>npblender/mesh.py</code> <pre><code>def extrude_vertices(self, selection, offset, **attributes):\n    \"\"\" Extrude individual vertices\n\n    Arguments\n    ---------\n        - selection (selector) : points selection, all if None\n        - offset (vector or array of vectors) : extrusion vector\n        - attributes (dict) : points attributes\n\n    Returns\n    -------\n        - dictionnary of the created geometry : vertex indices, face indices\n    \"\"\"\n    inds = np.arange(len(self.points))\n    if selection is not None:\n        inds = inds[selection]\n\n    pos = self.points.position[inds] + offset\n    new_inds = np.arange(len(pos)) + len(self.points)\n    edges = edges_between(inds, new_inds)\n\n    return self.add_geometry(points=pos, edges=edges.reshape(-1, 2), **attributes)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.faces_neighbors","title":"faces_neighbors","text":"<pre><code>faces_neighbors()\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def faces_neighbors(self):\n\n    offset = 0\n    neighbors = []\n\n    with self.bmesh() as bm:           \n        bm.faces.ensure_lookup_table()\n\n        for face in bm.faces:\n            ns = set()\n            for edge in face.edges:\n                ns = ns.union([edge.link_faces[0].index, edge.link_faces[1].index])\n            ns.remove(face.index)\n            neighbors.append(list(ns))\n\n    return neighbors\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.fill_cap","title":"fill_cap","text":"<pre><code>fill_cap(loop, mode='NGON', center=None, segments=1, clockwise=False, **attributes)\n</code></pre> <p>Fill a cap between an existing loop</p> <p>For NGON mode, center is not required. For FANS mode, a center point is required: - if center is None, it is computed as the center of the loop - if center is an int, it is the index of the point to use - otherwise, the center is considered as the point to use</p> Arguments <ul> <li>loop (array of ints) : the circle loop</li> <li>mode (FillCap = 'NGON') : NGON or FANS</li> <li>center (point index or point or None) : center of the cap</li> <li>clockwise (bool = False) : order of the corners in the loop</li> <li>indexing (str = 'ij') : indexing of the points</li> <li>attributes (dict) : attributes to add to the mesh (see Geometry.add_geometry(</li> </ul> Source code in <code>npblender/mesh.py</code> <pre><code>def fill_cap(self, loop, mode='NGON', center=None, segments=1, clockwise=False, **attributes):\n    \"\"\" Fill a cap between an existing loop\n\n    For NGON mode, center is not required.\n    For FANS mode, a center point is required:\n    - if center is None, it is computed as the center of the loop\n    - if center is an int, it is the index of the point to use\n    - otherwise, the center is considered as the point to use\n\n    Arguments\n    ---------\n    - loop (array of ints) : the circle loop\n    - mode (FillCap = 'NGON') : NGON or FANS\n    - center (point index or point or None) : center of the cap\n    - clockwise (bool = False) : order of the corners in the loop\n    - indexing (str = 'ij') : indexing of the points\n    - attributes (dict) : attributes to add to the mesh (see Geometry.add_geometry(\n    \"\"\"\n    if mode == 'NONE':\n        # To have en empty dict\n        return self.add_geometry()\n\n    elif mode == 'NGON':\n        return self.add_geometry(corners=loop, faces=len(loop), UVMap=self.disk_uv_map(len(loop), mode='NGON', clockwise=clockwise), **attributes)\n\n    elif mode == 'FANS':\n\n        if center is None:\n            verts = self.points.position[loop]\n            center = np.average(verts, axis=0)\n            center_index = len(self.points)\n            cind = self.add_points(center)\n\n        elif isinstance(center, (int, np.int32, np.int64)):\n            center_index = center\n            cind = [center_index]\n\n        else:\n            center_index = len(self.points)\n            cind = self.add_points(center)\n\n        indices = np.append(loop, center_index)\n\n        topo = fans_corners(len(loop), close=True, clockwise=clockwise).ravel()\n\n        corners = indices[topo]\n        uv_map = disk_uv_map(len(loop), mode='FANS', clockwise=clockwise).reshape(-1, 2)\n\n        added = self.add_geometry(corners=corners, faces=3, UVMap=uv_map, **attributes)\n        added['points'] = np.asarray(cind)\n\n        # More than one segments\n\n        if segments &gt; 1:\n            self.split_edges(loop, center_index, cuts=segments - 1)\n\n        return added\n\n    assert(False)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef from_dict(cls, d):\n    mesh = cls()\n    mesh.materials  = d['materials']\n    mesh.points     = Vertex.from_dict(d['points'])\n    mesh.corners    = Corner.from_dict(d['corners'])\n    mesh.faces      = Face.from_dict(d['faces'])\n    mesh.edges      = Edge.from_dict(d['edges'])\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_mesh","title":"from_mesh  <code>classmethod</code>","text":"<pre><code>from_mesh(other, points=None, faces=None, edges=None)\n</code></pre> <p>Create a Mesh from another mesh.</p> Arguments <pre><code>- other (Mesh) : the mesh to copy\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef from_mesh(cls, other, points=None, faces=None, edges=None):\n    \"\"\" Create a Mesh from another mesh.\n\n    Arguments\n    ---------\n        - other (Mesh) : the mesh to copy\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    mesh = cls(materials=other.materials)\n    mesh.points  = Vertex(other.points,  mode='COPY')\n    mesh.corners = Corner(other.corners, mode='COPY')\n    mesh.faces   = Face(other.faces,   mode='COPY')\n    mesh.edges   = Edge(other.edges,    mode='COPY')\n\n    if points is None:\n        points_mask = None\n    else:\n        points_mask = np.ones(len(mesh.points), dtype=bool)\n        points_mask[points] = False\n\n    if faces is None:\n        faces_mask = None\n    else:\n        faces_mask = np.ones(len(mesh.faces), dtype=bool)\n        faces_mask[faces] = False\n\n    if edges is None:\n        edges_mask = None\n    else:\n        edges_mask = np.ones(len(mesh.edges), dtype=bool)\n        edges_mask[edges] = False\n\n    mesh.delete_vertices(points=points_mask, faces=faces_mask, edges=edges_mask)\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_mesh_data","title":"from_mesh_data  <code>classmethod</code>","text":"<pre><code>from_mesh_data(data)\n</code></pre> <p>Initialize the geometry from a Blender Mesh</p> Arguments <pre><code>- mesh (Blender Mesh instance) : the mesh to load\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef from_mesh_data(cls, data):\n    \"\"\" Initialize the geometry from a Blender Mesh\n\n    Arguments\n    ---------\n        - mesh (Blender Mesh instance) : the mesh to load\n    \"\"\"\n\n    from . import blender\n\n    bl_mesh = blender.get_mesh(data)\n\n    mesh = cls()\n\n    # ----- Materials\n\n    mesh.materials = [None if mat is None else mat.name for mat in bl_mesh.materials]\n\n    # ----- Vertices\n\n    n = len(bl_mesh.vertices)\n    if n != 0:\n        # Positions will be read as position attribute\n        mesh.points.resize(n)\n\n    # ----- Corners\n\n    n = len(bl_mesh.polygons)\n    if n != 0:\n        a = np.empty(len(bl_mesh.loops), bint)\n        bl_mesh.loops.foreach_get(\"vertex_index\", a)\n        mesh.corners.append(vertex_index=a)\n\n        a = np.empty(len(bl_mesh.polygons), bint)\n        bl_mesh.polygons.foreach_get(\"loop_total\", a)\n        mesh.faces.append_sizes(a)\n\n        del a\n\n    # ----- Edges\n\n    if len(bl_mesh.edges):\n        n = len(bl_mesh.edges)\n        a = np.empty(2*n, bint)\n        bl_mesh.edges.foreach_get(\"vertices\", a)\n        a = np.reshape(a, (n, 2))\n        mesh.edges.append(vertex0=a[:, 0], vertex1=a[:, 1])\n\n        del a\n\n        mesh.edges.remove_face_edges(mesh.faces.get_edges(mesh.corners))\n\n    # ----- Attributes\n\n    mesh.points.from_bl_attributes(bl_mesh.attributes)\n    mesh.corners.from_bl_attributes(bl_mesh.attributes)\n    mesh.faces.from_bl_attributes(bl_mesh.attributes)\n    mesh.edges.from_bl_attributes(bl_mesh.attributes)\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_model","title":"from_model  <code>classmethod</code>","text":"<pre><code>from_model(model, materials=None)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef from_model(cls, model, materials=None):\n\n    if isinstance(model, (str, bpy.types.Object)):\n        mesh = cls.from_object(model, evaluated=True)\n\n    elif isinstance(model, dict):\n        mesh = cls.from_dict(model)\n\n    elif isinstance(model, Mesh):\n        mesh = cls.from_mesh(model)\n\n    elif isinstance(model, bpy.types.Mesh):\n        mesh = cls.from_mesh_data(model)\n\n    else:\n        raise Exception(f\"Mesh.from_model: 'model' type is not valid: {type(model)}\")\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_object","title":"from_object  <code>classmethod</code>","text":"<pre><code>from_object(obj, evaluated=False)\n</code></pre> <p>Create a Mesh from an existing object.</p> Arguments <pre><code>- obj (str or Blender object) : the object to initialize from\n- evaluated (bool = False) : object modified by the modifiers if True, raw vertices otherwise\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef from_object(cls, obj, evaluated=False):\n    \"\"\" Create a Mesh from an existing object.\n\n    Arguments\n    ---------\n        - obj (str or Blender object) : the object to initialize from\n        - evaluated (bool = False) : object modified by the modifiers if True, raw vertices otherwise\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    from . import blender\n\n    if evaluated:\n        depsgraph = bpy.context.evaluated_depsgraph_get()\n        object_eval = blender.get_object(obj).evaluated_get(depsgraph)\n        return cls.FromMeshData(object_eval.data)\n\n    else:\n        return cls.from_mesh_data(blender.get_object(obj).data)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_cubic_envelop","title":"get_cubic_envelop","text":"<pre><code>get_cubic_envelop()\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def get_cubic_envelop(self):\n    from . mesh import Mesh\n\n    size = self.bounding_box_dims\n    return Mesh.cube(size=size, materials=getattr(self, \"materials\", None))\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_faces_position","title":"get_faces_position","text":"<pre><code>get_faces_position(selection=None)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def get_faces_position(self, selection=None):\n    if selection is None:\n        return self.faces[selection].get_position(self.corners, self.points)\n    else:\n        return self.faces[selection].get_position(self.corners, self.points)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_islands","title":"get_islands","text":"<pre><code>get_islands()\n</code></pre> <p>Get an island id per face.</p> Source code in <code>npblender/mesh.py</code> <pre><code>def get_islands(self):\n    \"\"\" Get an island id per face.\n    \"\"\"\n    from collections import deque\n\n    nfaces = len(self.faces)\n    if not nfaces:\n        return []\n\n    islands = np.full(nfaces, -1, dtype=np.int32)\n    cur_island = -1\n\n    passed = np.zeros(nfaces, dtype=bool)\n\n    with self.bmesh() as bm:\n        bm.faces.ensure_lookup_table()\n        bm.edges.ensure_lookup_table()\n\n        for f in bm.faces:\n            # Already visited\n            if islands[f.index] &gt;= 0:\n                continue\n\n            # New island index\n            cur_island += 1\n\n            q = deque([f])\n            while q:\n                cur = q.popleft()\n\n                # Part of the current island\n                islands[cur.index] = cur_island\n\n                # No infinite loop\n                passed[cur.index] = True\n\n                # Loop on the edges\n                for e in cur.edges:                                               \n                    # Loop on the edge faces\n                    for nb in e.link_faces:\n                        if passed[nb.index]:\n                            continue\n                        passed[nb.index] = True\n\n                        if islands[nb.index] &lt; 0:\n                            q.append(nb)\n\n\n    return islands\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_material_index","title":"get_material_index","text":"<pre><code>get_material_index(mat_name)\n</code></pre> <p>Return the index of a material name.</p> <p>If the material doesn't exist, it is created</p> Arguments <pre><code>- mat_name (str) : material name\n</code></pre> <p>Returns:</p> Type Description <code>    - int : index of the material name in the materials list</code> Source code in <code>npblender/geometry.py</code> <pre><code>def get_material_index(self, mat_name):\n    \"\"\" Return the index of a material name.\n\n    If the material doesn't exist, it is created\n\n    Arguments\n    ---------\n        - mat_name (str) : material name\n\n    Returns\n    -------\n        - int : index of the material name in the materials list\n    \"\"\"\n\n    if mat_name in self.materials:\n        return self.materials.index(mat_name)\n    else:\n        self.materials.append(mat_name)\n        return len(self.materials)-1\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_points_selection","title":"get_points_selection","text":"<pre><code>get_points_selection()\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def get_points_selection(self):\n    return slice(None)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.grid","title":"grid  <code>classmethod</code>","text":"<pre><code>grid(size_x=1, size_y=1, vertices_x=3, vertices_y=3, materials=None)\n</code></pre> <p>Create a Grid.</p> <p>[!IMPORTANT] Grid is created with indexing = 'ij': shape = (resolution x, resolution y)</p> Arguments <pre><code>- size_x (float=1) : size along x\n_ size_y (float=1) : size along y\n- vertices_x (int=3) : number of vertices along x\n- vertices_y (int=3) : number of vertices along y\n- materials (list of strs = None) : materials list\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef grid(cls, size_x=1, size_y=1, vertices_x=3, vertices_y=3, materials=None):\n    \"\"\" Create a Grid.\n\n    &gt; [!IMPORTANT]\n    &gt; Grid is created with indexing = 'ij': shape = (resolution x, resolution y)\n\n    Arguments\n    ---------\n        - size_x (float=1) : size along x\n        _ size_y (float=1) : size along y\n        - vertices_x (int=3) : number of vertices along x\n        - vertices_y (int=3) : number of vertices along y\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    nx = max(2, vertices_x)\n    ny = max(2, vertices_y)\n\n    topo = grid_corners(nx, ny).ravel()\n\n    # ----------------------------------------------------------------------------------------------------\n    # Base grid for points and uvs\n\n    x, y = np.meshgrid(\n        np.linspace(-size_x/2, size_x/2, nx, dtype=bfloat), \n        np.linspace(-size_y/2, size_y/2, ny, dtype=bfloat), \n        indexing='ij')\n    x, y = x.ravel(), y.ravel()\n\n    # ----------------------------------------------------------------------------------------------------\n    # Let 's build the grid\n\n    points = np.stack((x, y, np.zeros_like(x)), axis=-1)\n    corners = np.arange(len(points))[topo]\n    faces = 4\n    uvmap = grid_uv_map(nx, ny).reshape(-1, 2)\n\n    return cls(points, corners, faces, materials=materials, UVMap=uvmap)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.icosphere","title":"icosphere  <code>classmethod</code>","text":"<pre><code>icosphere(radius=1, subdivisions=2, materials=None)\n</code></pre> <p>Create a IcoSphere.</p> <p>Blender constructor for a IcoSphere.</p> Arguments <pre><code>- radius (float=1.) : radius\n- subdivisions (int=2) : number subdivisions\n- materials (list of strs = None) : materials list\n- transformation (Transformations = None) : the transformation to apply\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef icosphere(cls, radius=1, subdivisions=2, materials=None):\n    \"\"\" Create a IcoSphere.\n\n    Blender constructor for a IcoSphere.\n\n    Arguments\n    ---------\n        - radius (float=1.) : radius\n        - subdivisions (int=2) : number subdivisions\n        - materials (list of strs = None) : materials list\n        - transformation (Transformations = None) : the transformation to apply\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    subdivisions = min(10, subdivisions)\n\n    mesh = cls(materials=materials)\n    with mesh.bmesh() as bm:\n        bmesh.ops.create_icosphere(bm, subdivisions=subdivisions, radius=radius, calc_uvs=True)\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.inset_faces","title":"inset_faces","text":"<pre><code>inset_faces(selection, thickness=0.1, depth=0.0, use_even_offset=True, use_relative_offset=False)\n</code></pre> <p>Extrude individual faces.</p> <p>If offset is None, faces are extruder along their normal</p> Arguments <p>selection : selection on faces     indices of the faces to inset thickness : float     Inset thickness. depth : float     Inset depth (extrusion). use_even_offset : bool     Keep consistent thickness. use_relative_offset : bool     Offset relative to face size.</p> <p>Returns:</p> Type Description <code>dict with:</code> <p>'faces' : list of new inset faces</p> Source code in <code>npblender/mesh.py</code> <pre><code>def inset_faces(self, selection, thickness=0.1, depth=0.0, use_even_offset=True, use_relative_offset=False):\n    \"\"\" Extrude individual faces.\n\n    If offset is None, faces are extruder along their normal\n\n    Arguments\n    ---------\n    selection : selection on faces\n        indices of the faces to inset\n    thickness : float\n        Inset thickness.\n    depth : float\n        Inset depth (extrusion).\n    use_even_offset : bool\n        Keep consistent thickness.\n    use_relative_offset : bool\n        Offset relative to face size.\n\n    Returns\n    -------\n    dict with:\n        'faces' : list of new inset faces\n    \"\"\"\n\n    # Selected faces indices\n    faces_sel = np.arange(len(self.faces))\n    if selection is not None:\n        faces_sel = faces_sel[selection]\n\n    # bmesh edition\n    with self.bmesh() as bm:\n        bm.faces.ensure_lookup_table()\n\n        # select faces\n        start_faces = [bm.faces[i] for i in faces_sel]\n\n        res = {'top': [], 'side': []}\n\n        # bmesh.ops\n        d = bmesh.ops.inset_individual(\n            bm,\n            faces               = start_faces,\n            thickness           = thickness,\n            depth               = depth,\n            use_even_offset     = use_even_offset,\n            use_relative_offset = use_relative_offset,\n        )\n\n        res = {\n            'top': faces_sel,\n            'side': [face.index for face in d[\"faces\"]]\n        }\n\n    return res\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.join","title":"join","text":"<pre><code>join(*others)\n</code></pre> <p>Join other Meshes.</p> Arguments <pre><code>- others (Mesh) : the Mesh to append\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def join(self, *others):\n    \"\"\" Join other Meshes.\n\n    Arguments\n    ---------\n        - others (Mesh) : the Mesh to append\n    \"\"\"\n    for other in others:\n\n        # ----------------------------------------------------------------------------------------------------\n        # Vertices\n\n        v_ofs = len(self.points)\n        self.points.extend(other.points)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Corners\n\n        c_ofs = len(self.corners)\n        self.corners.extend(other.corners)\n        if len(self.corners):\n            self.corners.vertex_index[c_ofs:] += v_ofs\n\n        # ----------------------------------------------------------------------------------------------------\n        # Faces\n\n        f_ofs = len(self.faces)\n        self.faces.extend(other.faces)\n        if len(self.faces):\n            self.faces.loop_start[f_ofs:] += c_ofs\n\n        # ----------------------------------------------------------------------------------------------------\n        # Edges\n\n        e_ofs = len(self.edges)\n        self.edges.extend(other.edges)\n        if len(self.edges):\n            self.edges.vertex0[e_ofs:] += v_ofs\n            self.edges.vertex1[e_ofs:] += v_ofs\n\n        # ----- Materials\n\n        remap = np.array([self.get_material_index(mat_name) for mat_name in other.materials])\n        if len(remap)&gt;0:\n            self.faces.material_index[f_ofs:] = remap[other.faces.material_index]\n\n    return self\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other, **kwargs)\n</code></pre> <p>Capture the attributes from another geometry.</p> <p>Other can be a different geometry, in that case, only domains with the same name are captured. kwargs allows to filter the domains to capture:</p> <pre><code>mesh.join_attributes(other_mesh, faces=False)\nmesh.join_attributes(curve)\n</code></pre> <p>Returns:     - self</p> Source code in <code>npblender/geometry.py</code> <pre><code>def join_attributes(self, other, **kwargs):\n    \"\"\" Capture the attributes from another geometry.\n\n    Other can be a different geometry, in that case, only domains with the same name are captured.\n    kwargs allows to filter the domains to capture:\n\n    ```python\n    mesh.join_attributes(other_mesh, faces=False)\n    mesh.join_attributes(curve)\n    ```\n\n    Returns:\n        - self\n    \"\"\"\n    if other is None:\n        return self\n\n    for name in self.domain_names:\n        if name in other.domain_names and kwargs.get(name, True):\n            getattr(self, name).join_fields(getattr(other, name))\n\n    return self\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.join_geometry","title":"join_geometry","text":"<pre><code>join_geometry(points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs)\n</code></pre> <p>Join geometry defined by components.</p> <p>The geometry passed in argument is consistent and doesn't refer to existing vertices. It is used to build an independant mesh which is then joined. See 'add_geometry' which, on the contrary, can refer to existing vertices.</p> <p>Returns:</p> Type Description <code>    - self</code> Source code in <code>npblender/mesh.py</code> <pre><code>def join_geometry(self, points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs):\n    \"\"\" Join geometry defined by components.\n\n    The geometry passed in argument is consistent and doesn't refer to existing vertices. It is used\n    to build an independant mesh which is then joined.\n    See 'add_geometry' which, on the contrary, can refer to existing vertices.\n\n    Returns\n    -------\n        - self\n    \"\"\"\n    mesh = Mesh(attr_from=self)\n    mesh.add_geometry(\n        points=points, \n        corners=corners, \n        faces=faces, \n        edges=edges,\n        **attrs)\n    self.join(mesh)\n    return self\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.line","title":"line  <code>classmethod</code>","text":"<pre><code>line(start=(0, 0, 0), end=(0, 0, 1), segments=1, materials=None)\n</code></pre> <p>Create a mesh with lines between the given positions.</p> Arguments <pre><code>- start (vertex =(0, 0, 0) : position of the start of the lines\n- end (vertex=(0, 0, 1) : position of the end of the lines\n- count (int=2) : number of points in the line\n</code></pre> <p>Returns:</p> Type Description <code>    - mesh (Mesh) : the mesh</code> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef line(cls, start=(0, 0, 0), end=(0, 0, 1), segments=1, materials=None):\n    \"\"\" Create a mesh with lines between the given positions.\n\n    Arguments\n    ---------\n        - start (vertex =(0, 0, 0) : position of the start of the lines\n        - end (vertex=(0, 0, 1) : position of the end of the lines\n        - count (int=2) : number of points in the line\n\n    Returns\n    -------\n        - mesh (Mesh) : the mesh\n    \"\"\"\n    segments = max(1, segments)\n\n    start = np.asarray(start, dtype=bfloat)\n    end   = np.asarray(end, dtype=bfloat)\n\n    pos = np.linspace(start, end, segments + 1) # shape (segments, n points, 3)\n\n    if len(pos.shape) == 2:\n        edges = border_edges(np.arange(segments))\n    else:\n        shape = pos.shape[:-1]\n        n = int(np.prod(shape))\n        edges = col_edges(np.arange(n).reshape(shape))\n\n    return cls(points=pos.reshape(-1, 3), edges=edges.reshape(-1, 2), materials=materials)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.load_models","title":"load_models  <code>staticmethod</code>","text":"<pre><code>load_models(*specs)\n</code></pre> <p>Load a geometry or geometries from specifications.</p> <p>The specs can be:     - a Blender collection     - a Blender object     - a Geometry</p> Arguments <pre><code>- specs (list of objects / collections) : the models to load\n</code></pre> <p>Returns:</p> Type Description <code>    - list of geometries</code> Source code in <code>npblender/geometry.py</code> <pre><code>@staticmethod\ndef load_models(*specs):\n    \"\"\" Load a geometry or geometries from specifications.\n\n    The specs can be:\n        - a Blender collection\n        - a Blender object\n        - a Geometry\n\n    Arguments\n    ---------\n        - specs (list of objects / collections) : the models to load\n\n    Returns\n    -------\n        - list of geometries\n    \"\"\"\n\n    from .mesh import Mesh\n    from .curve import Curve\n\n    models = []\n\n    for spec in specs:\n        # A list\n        if isinstance(spec, (list, tuple)):\n            models.extend(Geometry.load_models(*spec))\n            continue\n\n        # A collection\n        coll = blender.get_collection(spec, halt=False)\n        if coll is not None:\n            for obj in coll.objects:\n                geo = Geometry.load_object(obj)\n                if isinstance(geo, (Mesh, Curve)):\n                    models.append(geo)\n            continue\n\n        # An object\n        obj = blender.get_object(spec, halt=False)\n        if obj is not None:\n            geo = Geometry.load_object(obj)\n            if isinstance(geo, (Mesh, Curve)):\n                models.append(geo)\n            continue\n\n        # A valid geometry\n        if type(spec).__name__ in ['Mesh', 'Curve']:\n            models.append(spec)\n            continue\n\n        raise ValueError(f\"Unknown model (type '{type(spec)}'): {spec}\")\n\n    return models\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.load_object","title":"load_object  <code>staticmethod</code>","text":"<pre><code>load_object(name)\n</code></pre> <p>Load a Blender object and returns either a Mesh or a Curve.</p> Arguments <pre><code>- name (str or bpy.types.Object) : the object to load\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh or Curve</code> Source code in <code>npblender/geometry.py</code> <pre><code>@staticmethod\ndef load_object(name):\n    \"\"\" Load a Blender object and returns either a Mesh or a Curve.\n\n    Arguments\n    ---------\n        - name (str or bpy.types.Object) : the object to load\n\n    Returns\n    -------\n        - Mesh or Curve\n    \"\"\"\n\n    from .mesh import Mesh\n    from .curve import Curve\n\n    obj = blender.getobject(name)\n    if obj is None:\n        return None\n\n    if isinstance(obj.data, bpy.types.Mesh):\n        return Mesh.from_object(obj)\n\n    elif isinstance(obj.data, bpy.types.Curve):\n        return Curve.from_object(obj)\n\n    else:\n        raise Exception(f\"Geometry.load_object error: impossible to load the objet '{obj.name}' of type '{type(obj.data).__name__}'\")\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.monkey","title":"monkey  <code>classmethod</code>","text":"<pre><code>monkey(materials=None)\n</code></pre> <p>Create a Monkey.</p> Arguments <pre><code>- materials (list of strs = None) : materials list\n</code></pre> <p>Returns:</p> Type Description <code>    - MeshBuilder</code> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef monkey(cls, materials=None):\n    \"\"\" Create a Monkey.\n\n    Arguments\n    ---------\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - MeshBuilder\n    \"\"\"\n    mesh = cls(materials=materials)\n    with mesh.bmesh() as bm:\n        bmesh.ops.create_monkey(bm)\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.multiply","title":"multiply","text":"<pre><code>multiply(count, in_place=True)\n</code></pre> <p>Duplicate the geometry.</p> <p>Multiplying is a way to efficiently duplicate the geometry a great number of times. Once duplicated, the vertices can be reshapped to address each instance individually.</p> <pre><code>count = 16\n\ncube = Mesh.Cube() * count\n\n# Shape the points as 16 blocks of 8 vertices\npoints = np.reshape(cube.points.position, (16, 8, 3))\n\n# Place the cubes in a circle\nags = np.linspace(0, 2*np.pi, count, endpoint=False)\npoints[..., 0] += 6 * np.cos(ags)[:, None]\npoints[..., 1] += 6 * np.sin(ags)[:, None]\n\ncube.to_object(\"Cubes\")\n</code></pre> Arguments <pre><code>- count (int=10) : number of instances\n- attributes (name=value) : value for named attributes\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code> Source code in <code>npblender/mesh.py</code> <pre><code>def multiply(self, count, in_place=True):\n    \"\"\" Duplicate the geometry.\n\n    Multiplying is a way to efficiently duplicate the geometry a great number of times.\n    Once duplicated, the vertices can be reshapped to address each instance individually.\n\n    ``` python\n    count = 16\n\n    cube = Mesh.Cube() * count\n\n    # Shape the points as 16 blocks of 8 vertices\n    points = np.reshape(cube.points.position, (16, 8, 3))\n\n    # Place the cubes in a circle\n    ags = np.linspace(0, 2*np.pi, count, endpoint=False)\n    points[..., 0] += 6 * np.cos(ags)[:, None]\n    points[..., 1] += 6 * np.sin(ags)[:, None]\n\n    cube.to_object(\"Cubes\")\n    ```\n\n    Arguments\n    ---------\n        - count (int=10) : number of instances\n        - attributes (name=value) : value for named attributes\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    # ----------------------------------------------------------------------------------------------------\n    # Checks and simple cases\n\n    if not isinstance(count, (int, np.int32, np.int64)):\n        raise Exception(f\"A Mesh can be multiplied only by an int, not '{count}'\")\n\n    if count == 0:\n        return None\n\n    if count == 1:\n        if in_place:\n            return self\n        else:\n            return type(self).from_mesh(self)\n\n    if not in_place:\n        return type(self).from_mesh(self).multiply(count, in_place=True)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Vertices\n\n    nverts = len(self.points)\n    self.points.multiply(count)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Corners\n\n    ncorners = len(self.corners)\n    self.corners.multiply(count)\n    self.corners.vertex_index += np.repeat(np.arange(count)*nverts, ncorners)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Faces\n\n    self.faces.multiply(count)\n    self.faces.update_loop_start()\n\n    # ----------------------------------------------------------------------------------------------------\n    # Edges\n\n    nedges = len(self.edges)\n    self.edges.multiply(count)\n    ofs = np.repeat(np.arange(count)*nverts, nedges)\n    self.edges.vertex0 += ofs\n    self.edges.vertex1 += ofs\n\n    return self\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.object","title":"object","text":"<pre><code>object(index=0, readonly=True)\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>@contextmanager\ndef object(self, index=0, readonly=True):\n\n    import bpy\n    from . import blender\n\n    temp_name = index if isinstance(index, str) else f\"BPBL Temp {index}\"\n\n    ctx = bpy.context\n\n    old_sel = [obj.name for obj in bpy.data.objects if obj.select_get()]\n    old_active = ctx.view_layer.objects.active\n    if old_active is None:\n        old_active_name = None\n    else:\n        old_active_name = old_active.name\n\n    bpy.ops.object.select_all(action='DESELECT')        \n\n    obj = self.to_object(temp_name)\n    obj.select_set(True)\n    bpy.context.view_layer.objects.active = obj        \n\n    yield obj\n\n    # ===== Returns from context\n\n    if not readonly:\n        self.capture(type(self).from_object(obj))\n\n    blender.delete_object(obj)\n\n    bpy.ops.object.select_all(action='DESELECT')        \n    for name in old_sel:\n        obj = bpy.data.objects.get(name)\n        if obj is not None:\n            obj.select_set(True)\n\n    if old_active_name is not None:\n        bpy.context.view_layer.objects.active = bpy.data.objects.get(old_active_name)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.points_cloud","title":"points_cloud  <code>classmethod</code>","text":"<pre><code>points_cloud(points=None, materials=None)\n</code></pre> <p>Create a mesh with points at the given positions.</p> Arguments <pre><code>- position (shaped array (?, 3)=(0, 0, 0) : position of the points\n</code></pre> <p>Returns:</p> Type Description <code>    - mesh (Mesh) : the mesh</code> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef points_cloud(cls, points=None, materials=None):\n    \"\"\" Create a mesh with points at the given positions.\n\n    Arguments\n    ---------\n        - position (shaped array (?, 3)=(0, 0, 0) : position of the points\n\n    Returns\n    -------\n        - mesh (Mesh) : the mesh\n    \"\"\"\n    return cls(points=points, materials=materials)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.pyramid","title":"pyramid  <code>classmethod</code>","text":"<pre><code>pyramid(size=1, materials=None)\n</code></pre> <p>Create a Pyramid.</p> Arguments <pre><code>- size (float=1.) : size\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef pyramid(cls, size=1, materials=None):\n    \"\"\" Create a Pyramid.\n\n    Arguments\n    ---------\n        - size (float=1.) : size\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    return cls.cone(vertices=3, radius_bottom=size*0.8660254037844386, depth=size, materials=materials)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.remove_doubles","title":"remove_doubles","text":"<pre><code>remove_doubles(dist=0.001)\n</code></pre> <p>Remove doubles.</p> <p>Arguments:     - dist (float=0.001) : maximum distance between vertices to merge.</p> Source code in <code>npblender/mesh.py</code> <pre><code>def remove_doubles(self, dist=.001):\n    \"\"\" Remove doubles.\n\n    Arguments:\n        - dist (float=0.001) : maximum distance between vertices to merge.\n    \"\"\"\n    with self.bmesh() as bm:\n        bmesh.ops.remove_doubles(bm, verts=bm.verts, dist=dist)\n\n    return self\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.rotate","title":"rotate","text":"<pre><code>rotate(rotation, pivot=None)\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def rotate(self, rotation, pivot=None):\n    return self.transformation(rotation=rotation, pivot=pivot)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.separate_faces","title":"separate_faces","text":"<pre><code>separate_faces(groups=None)\n</code></pre> <p>Split faces into isolated islands</p> Arguments <ul> <li>groups (list of ints):     group ids of faces</li> </ul> Source code in <code>npblender/mesh.py</code> <pre><code>def separate_faces(self, groups=None):\n    \"\"\" Split faces into isolated islands\n\n    Arguments\n    ---------\n    - groups (list of ints):\n        group ids of faces\n    \"\"\"\n\n    mesh = Mesh(materials=self.materials)\n    attr_names = [name for name in self.faces.actual_names if name not in ['loop_total', 'loop_start']]\n\n    # ---------------------------------------------------------------------------\n    # No group: each face becomes an island\n    # ---------------------------------------------------------------------------\n\n    if groups is None:\n        attrs = {name: self.faces[name] for name in attr_names}\n        return Mesh(attr_from=self).join_geometry(\n            points = self.points.position[self.corners.vertex_index],\n            corners = np.arange(len(self.corners)),\n            faces = self.faces.loop_total,\n            **attrs,\n        )\n\n    # ---------------------------------------------------------------------------\n    # Faces are grouped with groupds IDs\n    # ---------------------------------------------------------------------------\n\n    groups = np.asarray(groups)\n    if groups.shape != (len(self.faces),)   :\n        raise ValueError(f\"The 'groups' argument must be a index per face with a length of {len(self.faces)}.\")\n\n    ugroups, rev_index = np.unique(groups, return_inverse=True)\n    for group in ugroups:\n        faces = self.faces[ugroups[rev_index] == group]\n        attrs = {name: faces[name] for name in attr_names}\n\n        corners = self.corners[faces.get_corner_indices()]\n        uniques, new_corners = np.unique(corners.vertex_index, return_inverse=True)\n        mesh.join(Mesh(attr_from=self).join_geometry(\n            points = self.points.position[uniques],\n            corners = new_corners,\n            faces = faces.loop_total,\n            **attrs,\n        ))\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.simplified","title":"simplified","text":"<pre><code>simplified(scale, dist=0.001)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def simplified(self, scale, dist=.001):\n\n    copy = Mesh.from_mesh(self)\n    copy.remove_doubles(dist=dist/scale)\n\n    if len(copy.points) &lt; 8:\n        copy = self.get_cubic_envelop()\n\n    return copy\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.solidify","title":"solidify","text":"<pre><code>solidify(thickness=0.01, offset=-1)\n</code></pre> <p>Boolean difference with another MeshBuilder.</p> <p>The methods uses the Solidify Modifier</p> <pre><code>glass = Mesh.Circle(segments=128)\nglass.extrude_faces(0, -.01)\nglass.extrude_faces(0, -2)\nglass.extrude_faces(0, -.01)\n\nglass.points.translate((0, 0, 2))\n\nglass = glass.solidify(thickness=.1)\n\nglass.to_object(\"Solidify\", shade_smooth=True)\n</code></pre> Arguments <pre><code>- thickness (float=.01) : thickness\n- offset (float=-1) : offset\n</code></pre> <p>Returns:</p> Type Description <code>    - MeshBuilder : the result of the solidify operation</code> Source code in <code>npblender/mesh.py</code> <pre><code>def solidify(self, thickness=.01, offset=-1):\n    \"\"\" Boolean difference with another MeshBuilder.\n\n    The methods uses the Solidify Modifier\n\n    ``` python\n    glass = Mesh.Circle(segments=128)\n    glass.extrude_faces(0, -.01)\n    glass.extrude_faces(0, -2)\n    glass.extrude_faces(0, -.01)\n\n    glass.points.translate((0, 0, 2))\n\n    glass = glass.solidify(thickness=.1)\n\n    glass.to_object(\"Solidify\", shade_smooth=True)\n    ```\n\n    Arguments\n    ---------\n        - thickness (float=.01) : thickness\n        - offset (float=-1) : offset\n\n    Returns\n    -------\n        - MeshBuilder : the result of the solidify operation\n    \"\"\"\n\n    with self.object() as obj:\n        mod = obj.modifiers.new(\"Solidify\", 'SOLIDIFY')\n\n        mod.thickness       = thickness\n        mod.use_even_offset = True\n        mod.offset          = offset\n\n        # Apply modifier\n        bpy.ops.object.modifier_apply(modifier=mod.name)\n\n        mesh = Mesh.from_object(obj)\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.solidify_socle","title":"solidify_socle","text":"<pre><code>solidify_socle(shape, z=0, bottom_material_index=0)\n</code></pre> <p>The mesh is supposed to be a grid.</p> <p>The socle is buit by extruding the external edges to the value z.</p> Arguments <ul> <li>shape (tuple of ints) : the grid shade</li> <li>z (float) : socle base z</li> <li>bottom_material_index (int = 0) : base face material index</li> <li>attributes (dict) : attributes to faces</li> </ul> <p>Returns:</p> Type Description <code>- bottom face index (int) : the index of bottom face</code> Source code in <code>npblender/mesh.py</code> <pre><code>def solidify_socle(self, shape, z=0, bottom_material_index=0):\n    \"\"\" The mesh is supposed to be a grid.\n\n    The socle is buit by extruding the external edges to the value z.\n\n    Arguments\n    ---------\n    - shape (tuple of ints) : the grid shade\n    - z (float) : socle base z\n    - bottom_material_index (int = 0) : base face material index\n    - attributes (dict) : attributes to faces\n\n    Returns\n    -------\n    - bottom face index (int) : the index of bottom face\n    \"\"\"\n\n    n = shape[0]*shape[1]\n    inds = np.arange(n).reshape(shape)\n\n    loop1 = np.append(inds[0, :-1], inds[:-1, -1])\n    loop1 = np.append(loop1, np.flip(inds[-1, 1:]))\n    loop1 = np.append(loop1, np.flip(inds[1:, 0]))\n\n    points = np.array(self.points.position[loop1])\n    points[:, 2] = z\n\n    loop0 = self.add_points(points)\n    res = self.add_geometry(corners=loop0) #, faces=len(loop0))\n\n    self.bridge_loops(loop0, loop1, close=True)\n\n    self.faces._ensure_optional_field(\"material_index\")\n    self.faces[res['faces']].material_index = bottom_material_index\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.split_edges","title":"split_edges","text":"<pre><code>split_edges(loop0, loop1, cuts=1)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def split_edges(self, loop0, loop1, cuts=1):\n\n    n0 = 1 if np.shape(loop0) == () else len(loop0)\n    n1 = 1 if np.shape(loop1) == () else len(loop1)\n    n = max(n0, n1)\n    if n0 == n:\n        loop0 = np.atleast_1d(loop0, dtype=bint)\n    else:\n        loop0 = np.ones(n, dtype=bint)*loop0\n\n    if n1 == n:\n        loop1 = np.atleast_1d(loop1, dtype=bint)\n    else:\n        loop1 = np.ones(n, dtype=bint)*loop1\n\n    to_select = np.stack([np.minimum(loop0, loop1), np.maximum(loop0, loop1)], axis=-1)  # shape (p, 2)\n    with self.bmesh() as bm:\n\n        edges, verts_indices = self._bm_edges(bm)\n\n        # select edges in to_select\n        dtype = np.dtype([('a', bint), ('b', bint)])\n        edges_view = verts_indices.view(dtype)\n        to_select_view = to_select.view(dtype)\n\n        # selection mask\n        mask = np.isin(edges_view.ravel(), to_select_view.ravel())\n\n        edges_to_cut = list(edges[mask])\n\n        if len(edges_to_cut) == 0:\n            return\n\n        # Edges subidivision\n        bmesh.ops.subdivide_edges(\n            bm,\n            edges=edges_to_cut,\n            cuts=cuts,\n            use_grid_fill=False\n        )\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_curve_REVIEW","title":"to_curve_REVIEW","text":"<pre><code>to_curve_REVIEW()\n</code></pre> <p>Convert mesh to curve</p> <p>Simple conversion when edges domain is defined</p> Source code in <code>npblender/mesh.py</code> <pre><code>def to_curve_REVIEW(self):\n    \"\"\" &gt; Convert mesh to curve\n\n    Simple conversion when edges domain is defined\n    \"\"\"\n\n    from npblender import Curve\n\n    if self._edges is None:\n        return None\n\n    splines = []\n    for edge in self.edges:\n        v0, v1 = edge.vertex0, edge.vertex1\n\n        ok = False\n        for spline in splines:\n            if spline[0] == spline[-1]:\n                continue\n\n            if v0 == spline[0]:\n                spline.insert(0, v1)\n                ok = True\n            elif v0 == spline[-1]:\n                spline.append(v1)\n                ok = True\n\n            elif v1 == spline[0]:\n                spline.insert(0, v0)\n                ok = True\n            elif v1 == spline[-1]:\n                spline.append(v0)\n                ok = True\n\n        if not ok:\n            splines.append([v0, v1])\n\n    curve = Curve()\n    for spline in splines:\n        cyclic = spline[0] == spline[-1]\n        if cyclic:\n            spline = spline[:-1]\n\n        curve.add(self.points.position[spline], curve_type='POLY', cyclic=cyclic)\n\n    return curve\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def to_dict(self):\n    return {\n        'geometry':     'Mesh',\n        'materials' :   self.materials,\n        'points':       self.points.to_dict(),\n        'corners':      self.corners.to_dict(),\n        'faces':        self.faces.to_dict(),\n        'edges':        self.edges.to_dict(),\n        }\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_mesh_data","title":"to_mesh_data","text":"<pre><code>to_mesh_data(data)\n</code></pre> <p>Write the geometry into a Blender Mesh</p> Arguments <pre><code>- mesh (Blender Mesh instance) : the mesh to write\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def to_mesh_data(self, data):\n    \"\"\" Write the geometry into a Blender Mesh\n\n    Arguments\n    ---------\n        - mesh (Blender Mesh instance) : the mesh to write\n    \"\"\"\n\n    from npblender import blender\n\n    bl_mesh = blender.get_data(data)\n    bl_mesh.clear_geometry()\n\n    # ----------------------------------------------------------------------------------------------------\n    # Materials\n\n    bl_mesh.materials.clear()\n    for mat_name in self.materials:\n        if mat_name is not None:\n            bl_mesh.materials.append(bpy.data.materials.get(mat_name))\n\n    # ----------------------------------------------------------------------------------------------------\n    # Vertices\n\n    points = self.points.ravel()\n    if len(points):\n        bl_mesh.vertices.add(len(points))\n\n    # ----------------------------------------------------------------------------------------------------\n    # Corners\n\n    corners = self.corners.ravel()\n    if len(corners):\n        bl_mesh.loops.add(len(corners))\n        bl_mesh.loops.foreach_set(\"vertex_index\", blender.int_array(corners.vertex_index))\n\n    # ----------------------------------------------------------------------------------------------------\n    # Faces\n\n    faces = self.faces.ravel()\n    if len(faces):\n        bl_mesh.polygons.add(len(faces))\n        bl_mesh.polygons.foreach_set(\"loop_start\", blender.int_array(faces.loop_start))\n        bl_mesh.polygons.foreach_set(\"loop_total\", blender.int_array(faces.loop_total))\n\n    # ----------------------------------------------------------------------------------------------------\n    # Edges\n\n    edges = self.edges.ravel()\n    if len(self.edges):\n        # edges to add\n        add_edges = self.edges.vertices\n\n        # edges have been created by faces\n        if len(faces):\n            bl_mesh.update()\n\n            cur_n = len(bl_mesh.edges)\n            if cur_n &gt; 0:\n                a = np.empty((cur_n, 2), dtype=bint)\n                bl_mesh.edges.foreach_get('vertices', a.ravel())\n\n            add_edges = np.append(a, add_edges, axis=0)\n\n        # add the edges\n        n = len(edges)\n        bl_mesh.edges.add(n)\n\n        bl_mesh.edges.foreach_set('vertices', add_edges.ravel())\n\n    # ----------------------------------------------------------------------------------------------------\n    # Attributes\n\n    attributes = data.attributes\n\n    points.to_bl_attributes(attributes, update=False)\n    corners.to_bl_attributes(attributes, update=False)\n    faces.to_bl_attributes(attributes, update=False)\n    edges.to_bl_attributes(attributes, update=False)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Update\n\n    bl_mesh.update()\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_object","title":"to_object","text":"<pre><code>to_object(obj, shade_smooth=None, shapekeys=None, collection=None)\n</code></pre> <p>Create or update a blender object.</p> <p>The method 'to_object' creates the whole geometry. It creates a new object if it doesn't already exist. If the object exists, it must be a mesh, there is no object type conversion.</p> <p>Once the object is created, use the method 'update_object' to change the vertices.</p> Arguments <pre><code>- obj (str or Blender object) : the object the create\n</code></pre> <p>Returns:</p> Type Description <code>    - Blender mesh object</code> Source code in <code>npblender/mesh.py</code> <pre><code>def to_object(self, obj, shade_smooth=None, shapekeys=None, collection=None):\n    \"\"\" Create or update a blender object.\n\n    The method 'to_object' creates the whole geometry. It creates a new object if it doesn't already exist.\n    If the object exists, it must be a mesh, there is no object type conversion.\n\n    Once the object is created, use the method 'update_object' to change the vertices.\n\n    Arguments\n    ---------\n        - obj (str or Blender object) : the object the create\n\n    Returns\n    -------\n        - Blender mesh object\n    \"\"\"\n\n    from npblender import blender\n\n    res = blender.create_mesh_object(obj, collection=collection)\n    self.to_mesh_data(res.data)\n\n    if shade_smooth is not None:\n        res.data.polygons.foreach_set('use_smooth', [shade_smooth]*len(res.data.polygons))\n\n    if shapekeys is not None:\n        if shapekeys is not None:\n            if isinstance(shapekeys, ShapeKeys):\n                shapekeys.to_mesh_object(obj)\n            else:\n                for sks in shapekeys:\n                    sks.to_mesh_object(obj)\n\n    return res\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.torus","title":"torus  <code>classmethod</code>","text":"<pre><code>torus(major_segments=48, minor_segments=12, major_radius=1.0, minor_radius=0.25, materials=None)\n</code></pre> <p>Create a Torus.</p> Arguments <pre><code>- major_segments (int=48) : number of segments for the major radius\n- minor_segments (int=12) : number of segments for the minor radius\n- major_radius (float=1.) : major radius\n- minor_radius (float=.25) : minor radius\n- materials (list of strs = None) : materials list\n- transformation (Transformations = None) : the transformation to apply\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef torus(cls, major_segments=48, minor_segments=12, major_radius=1., minor_radius=0.25, materials=None):\n    \"\"\" Create a Torus.\n\n    Arguments\n    ---------\n        - major_segments (int=48) : number of segments for the major radius\n        - minor_segments (int=12) : number of segments for the minor radius\n        - major_radius (float=1.) : major radius\n        - minor_radius (float=.25) : minor radius\n        - materials (list of strs = None) : materials list\n        - transformation (Transformations = None) : the transformation to apply\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    # Major backbone\n    maj_ag = np.linspace(0, 2*np.pi, major_segments, endpoint=False, dtype=bfloat) + np.pi # + pi to match blender uv\n\n    x = major_radius*np.cos(maj_ag)\n    y = major_radius*np.sin(maj_ag)\n    zeros = np.zeros_like(x)\n\n    transfos = Transformation.from_components(\n        translation=np.stack((x, y, zeros), axis=-1), \n        rotation=Rotation.from_euler(np.stack((zeros, zeros, maj_ag), axis=-1)),\n    )\n\n    # Minor section\n    min_ag = np.linspace(0, 2*np.pi, minor_segments, endpoint=False, dtype=bfloat) + np.pi # + pi to match blender uv\n    x = minor_radius*np.cos(min_ag)\n    z = minor_radius*np.sin(min_ag)\n    y = np.zeros_like(x)\n\n    circle = np.stack((x, y, z), axis=-1)\n\n    # Transform the circle\n    points = transfos[:, None] @ circle\n\n    # Generate the faces\n    corners = grid_corners(major_segments, minor_segments, close_x=True, close_y=True)\n\n    # Get the uv map\n    uvmap = grid_uv_map(major_segments + 1, minor_segments + 1)\n\n    return cls(points=points.reshape(-1, 3), corners=corners.ravel(), faces=4, UVMap=uvmap.reshape(-1, 2), materials=materials)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.transform","title":"transform","text":"<pre><code>transform(transformation)\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def transform(self, transformation):\n    return self.transformation(rotation=transformation)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.transformation","title":"transformation","text":"<pre><code>transformation(rotation=None, scale=None, translation=None, pivot=None)\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def transformation(self, rotation=None, scale=None, translation=None, pivot=None):\n\n    # Curve splines can be a subset of the points \n    pts_sel = self.get_points_selection()\n    pos = self.points.position[pts_sel]\n    npoints = len(pos)\n    all_vecs = [pos]\n\n    has_handles = \"handle_left\" in self.points.actual_names\n    if has_handles:\n        left = self.points.handle_left[pts_sel]\n        right = self.points.handle_right[pts_sel]\n        all_vecs.extend([left, right])\n\n    # First pivot\n    if pivot is not None:\n        pivot = np.asarray(pivot)\n        pivot_shape = self._check_transformation_shape(pivot.shape[:-1], npoints, label=\"Pivot\")\n        for v in all_vecs:\n            v.reshape(pivot_shape)[:] -= pivot\n\n    # Scale\n    if scale is not None:\n        scale = np.asarray(scale)\n        scale_shape = self._check_transformation_shape(scale.shape[:-1], npoints, label=\"Scale\")\n        for v in all_vecs:\n            v.reshape(scale_shape)[:] *= scale\n\n    # Rotation\n    if rotation is not None:\n        rot_shape = self._check_transformation_shape(rotation.shape, npoints, label=\"Rotation\")\n        for v in all_vecs:\n            v.reshape(rot_shape)[:] = rotation @ v.reshape(rot_shape)\n\n    # Pivot back\n    if pivot is not None:\n        for v in all_vecs:\n            v.reshape(pivot_shape)[:] += pivot\n\n    # Translation\n    if translation is not None:\n        translation = np.asarray(translation)\n        tr_shape = self._check_transformation_shape(translation.shape[:-1], npoints, label=\"Pivot\")\n        for v in all_vecs:\n            v.reshape(tr_shape)[:] += translation\n\n    # Back\n    self.points[pts_sel].position = pos\n    if has_handles:\n        self.points[pts_sel].handle_left = all_vecs[1]\n        self.points[pts_sel].handle_right = all_vecs[2]\n\n    return self\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.translate","title":"translate","text":"<pre><code>translate(translation)\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def translate(self, translation):\n    return self.transformation(translation=translation)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.triangulate","title":"triangulate","text":"<pre><code>triangulate(selection=None)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def triangulate(self, selection=None):\n\n    faces_sel = np.arange(len(self.faces))\n    if selection is not None:\n        faces_sel = faces_sel[selection]\n\n    if len(faces_sel) == 0:\n        return\n\n    copy = Mesh.from_mesh(self)\n\n    with copy.bmesh(readonly = False) as bm:\n        bm.faces.ensure_lookup_table()\n        faces = [bm.faces[i] for i in faces_sel]\n\n        bmesh.ops.triangulate(bm, faces=faces)\n\n    return copy\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.uvsphere","title":"uvsphere  <code>classmethod</code>","text":"<pre><code>uvsphere(segments=32, rings=16, radius=1, materials=None)\n</code></pre> <p>Create a uv sphere.</p> Arguments <pre><code>- segments (int=32) : number of segments\n- rings (int=16) : number of rings\n- radius (float=1.) : radius\n- materials (list of strs = None) : materials list\n- transformation (Transformations = None) : the transformation to apply\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef uvsphere(cls, segments=32, rings=16, radius=1, materials=None):\n    \"\"\" Create a uv sphere.\n\n    Arguments\n    ---------\n        - segments (int=32) : number of segments\n        - rings (int=16) : number of rings\n        - radius (float=1.) : radius\n        - materials (list of strs = None) : materials list\n        - transformation (Transformations = None) : the transformation to apply\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    mesh = cls(materials=materials)\n    with mesh.bmesh() as bm:\n        bmesh.ops.create_uvsphere(bm, u_segments=segments, v_segments=rings, radius=radius, calc_uvs=True)\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.vectors_field","title":"vectors_field  <code>classmethod</code>","text":"<pre><code>vectors_field(locations, vectors, radius=0.05, scale_length=1.0, angle=24.0, segments=8, head=None, adjust_norm=None, materials=None)\n</code></pre> <p>Create an arrow at each location corresponding to the vectors.</p> <p>The arrow length is equal to the corresponding vector lengths. The arrow radius is constant and equal to the value passe in argument for lengths greater that the argument scale_length. When the length is less than this value, the arrow is scaled down.</p> <p>Use the adjust_norm argument to transform the vector lengths to arrows lengths.</p> Arguments <pre><code>- locations (array of 3-vectors) : vectors locations\n- vectors (array of 3 vectors) : vectors to visualize\n- radius (float = .05) : arrow radius\n- angle (float = 24) : head radius in degrees\n- segments (int = 8) : number of segments for the section\n- head (mesh = None) : mesh model for the head. Create a cone if None\n- adjust_norm (max length or function = None) : max arrow length or function transforming\n    the vector length into arrow length\n- scale_length (float = 1.) : arrow length below which the arrow radius is scaled\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh Object</code> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef vectors_field(cls, locations, vectors, radius=.05, scale_length=1., angle=24., segments=8, head=None, adjust_norm=None, materials=None):\n    \"\"\" Create an arrow at each location corresponding to the vectors.\n\n    The arrow length is equal to the corresponding vector lengths.\n    The arrow radius is constant and equal to the value passe in argument for lengths greater that\n    the argument scale_length. When the length is less than this value, the arrow is scaled down.\n\n    Use the adjust_norm argument to transform the vector lengths to arrows lengths.\n\n    Arguments\n    ---------\n        - locations (array of 3-vectors) : vectors locations\n        - vectors (array of 3 vectors) : vectors to visualize\n        - radius (float = .05) : arrow radius\n        - angle (float = 24) : head radius in degrees\n        - segments (int = 8) : number of segments for the section\n        - head (mesh = None) : mesh model for the head. Create a cone if None\n        - adjust_norm (max length or function = None) : max arrow length or function transforming\n            the vector length into arrow length\n        - scale_length (float = 1.) : arrow length below which the arrow radius is scaled\n\n    Returns\n    -------\n        - Mesh Object\n    \"\"\"\n    locations = np.atleast_2d(locations)\n    vectors = np.atleast_2d(vectors)\n\n    # ---------------------------------------------------------------------------\n    # Vector lengths\n    # ---------------------------------------------------------------------------\n\n    n = len(locations)\n\n    lengths = np.linalg.norm(vectors, axis=-1)\n    is_null = lengths &lt; .00001\n    lengths[is_null] = 1\n    v_dir = vectors / lengths[:, None]\n    if type(adjust_norm).__name__ == 'function':\n        lengths = adjust_norm(lengths)\n    elif adjust_norm is not None:\n        lengths = np.minimum(adjust_norm, lengths)\n    lengths[is_null] = 0\n    vectors = v_dir*lengths[:, None]\n\n    # ---------------------------------------------------------------------------\n    # Arrow head\n    # ---------------------------------------------------------------------------\n\n    head_radius = 3*radius\n    head_height = head_radius/np.tan(np.radians(angle))\n\n    if head is None:\n        cone = cls.cone(\n            vertices = segments, \n            side_segments = 1, \n            fill_segments = 1, \n            radius_top = 0, \n            radius_bottom = head_radius, \n            depth = head_height, \n            fill_type = 'FANS', \n            materials = materials)\n        cone.points[-1].z += head_height/10\n    else:\n        cone = head\n        head_height = cone.bounding_box_dims[2]\n\n    # Head top point is z=0\n    v0, v1 = cone.bounding_box\n    cone.points.z -= v1[2]\n\n    # ---------------------------------------------------------------------------\n    # Small arrows: Vectors whose length &lt; min_length\n    # ---------------------------------------------------------------------------\n\n    # Minimum length\n    # Below this length, the arrow is scaled\n\n    min_length = 2*head_height\n\n    # Small and long arrows if any\n    small_arrows = cls()\n    long_arrows = cls()\n\n    small = lengths &lt; min_length\n    nsmalls = np.sum(small)\n\n    if nsmalls:\n        # shaft height = head height\n        cyl_height = min_length/2 + .01\n        arrow = cls.cylinder(vertices=segments, side_segments=1, radius=radius, depth=cyl_height, materials=materials)\n        arrow.points.z += cyl_height/2\n\n        # Join the head\n        c = cls.from_mesh(cone)\n        c.points.z += min_length\n\n        arrow.join(c)\n\n        # Duplicate the geometry            \n        small_arrows = arrow*nsmalls\n        small_arrows.points.reshape(nsmalls, len(arrow.points))\n\n        # Rotate, scale and translate\n        lg = lengths[small]\n        scale = np.stack((np.ones_like(lg), np.ones_like(lg), lg), axis=-1)\n        small_arrows.transformation(\n            rotation = Rotation.look_at((0, 0, 1), vectors[small])[:, None], \n            scale = scale[:, None], \n            translation = locations[small, None],\n            )\n        small_arrows.points.reshape(-1)\n\n\n    # ---------------------------------------------------------------------------\n    # Long arrows\n    # ---------------------------------------------------------------------------\n\n    long = np.logical_not(small)\n    nlongs = len(locations) - nsmalls\n    if nlongs:\n\n        # Shaft model with a normalized height = 1\n        shaft = cls.cylinder(vertices=segments, side_segments=1, radius=radius, depth=1, materials=materials)\n        shaft.points.z += .5\n\n        # We duplicate and transform the shafts with a scale long z\n        long_arrows = shaft*nlongs\n        long_arrows.points.reshape(nlongs, len(shaft.points))\n\n        lg = lengths[long] - head_height + .01\n        scale = np.stack((np.ones_like(lg), np.ones_like(lg), lg), axis=-1)\n        long_arrows.transformation(\n            rotation = Rotation.look_at((0, 0, 1), vectors[long])[:, None], \n            scale = scale[:, None], \n            translation = locations[long, None],\n            )\n        long_arrows.points.reshape(-1)\n\n        # We duplicate and tranform the heads with no scale\n        heads = cone*nlongs\n        heads.points.reshape(nlongs, len(cone.points))\n        heads.transformation(\n            rotation = Rotation.look_at((0, 0, 1), vectors[long])[:, None], \n            translation = locations[long, None] + vectors[long, None],\n            )\n        heads.points.reshape(-1)\n\n        long_arrows.join(heads)\n\n    # Let's join the result\n    arrows = cls()\n    arrows.join(small_arrows, long_arrows)\n\n    return arrows\n</code></pre>"}]}