{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"npblender","text":"<p>Numpy for Blender</p> <p>Doc in progress....</p> <p>Update soon :) (this is a test for the workflow)</p>"},{"location":"api/","title":"R\u00e9f\u00e9rence API","text":""},{"location":"api/#npblender.Camera","title":"<code>Camera</code>","text":"Source code in <code>npblender/camera.py</code> <pre><code>class Camera:\n\n    VISIBLE   = 0\n    BACK_FACE = 1\n\n    BEHIND    = 2\n    LEFT      = 3\n    RIGHT     = 4\n    BELOW     = 5\n    ABOVE     = 6\n    SLICE_END = 7\n\n    DISTANCE = 0\n    SIZE     = 1\n\n    def __init__(self, camera=None):\n\n        if camera is None or camera == True:\n            self._bcamera = None\n\n        elif isinstance(camera, str):\n            self._bcamera = bpy.data.objects[camera]\n\n        else:\n            assert(isinstance(camera.data, bpy.types.Camera))\n            self._bcamera = camera\n\n\n    def __str__(self):\n        return f\"&lt;Camera '{self.bcamera.name}': focal: {np.degrees(self.focal_angle):.1f}\u00b0, resolution: ({self.resolution_x}, {self.resolution_y})&gt;\"\n\n    # ----------------------------------------------------------------------------------------------------\n    # The Blender camera\n    # ----------------------------------------------------------------------------------------------------\n\n    @property\n    def bcamera(self):\n        if self._bcamera is None:\n            return bpy.context.scene.camera\n        else:\n            return self._bcamera\n\n    # ----------------------------------------------------------------------------------------------------\n    # Camera world location\n    # ----------------------------------------------------------------------------------------------------\n\n    @property\n    def location(self):\n        return self.bcamera.matrix_world.translation\n\n    # ----------------------------------------------------------------------------------------------------\n    # Focal angle of the camera\n    # ----------------------------------------------------------------------------------------------------\n\n    @property\n    def focal_angle(self):\n        return self.bcamera.data.angle\n\n    # ----------------------------------------------------------------------------------------------------\n    # Clip\n    # ----------------------------------------------------------------------------------------------------\n\n    @property\n    def clip_start(self):\n        return self.bcamera.data.clip_start\n\n    @property\n    def clip_end(self):\n        return self.bcamera.data.clip_end\n\n    # ----------------------------------------------------------------------------------------------------\n    # Normalized vector representing the direction of the camera\n    # ----------------------------------------------------------------------------------------------------\n\n    @property\n    def direction(self):\n        return (self.bcamera.matrix_world @ Vector((0, 0, -1, 0))).resized(3).normalized()\n\n    # ----------------------------------------------------------------------------------------------------\n    # Scene resolution\n    # ----------------------------------------------------------------------------------------------------\n\n    @property\n    def resolution_x(self):\n        render = bpy.context.scene.render\n        return render.resolution_x * render.pixel_aspect_x\n\n    @property\n    def resolution_y(self):\n        render = bpy.context.scene.render\n        return render.resolution_y * render.pixel_aspect_y\n\n    @property\n    def resolution(self):\n        if self.bcamera.data.sensor_fit == 'VERTICAL':\n            return self.resolution_y\n        else:\n            return self.resolution_x\n\n    # ----------------------------------------------------------------------------------------------------\n    # Number of pixels per meter function of the distance\n    # ----------------------------------------------------------------------------------------------------\n\n    def pixels_per_meter(self, distances):\n        \"\"\" Returns the number of pixels per meter given the distances\n\n        Arguments\n        ---------\n        - distances (array of floats) : the distances\n\n        Returns\n        -------\n        - array of floats : the size of a meter in pixels\n        \"\"\"\n        cam_data = self.bcamera.data\n\n        # Focal and sensor in mm\n        focal_mm = cam_data.lens\n        sensor_fit = cam_data.sensor_fit\n\n        if sensor_fit == 'VERTICAL':\n            sensor_mm = cam_data.sensor_height\n            res_px = self.resolution_y\n        else:  # 'HORIZONTAL' or 'AUTO'\n            sensor_mm = cam_data.sensor_width\n            res_px = self.resolution_x\n\n        # Focal in pixels\n        focal_px = (focal_mm / sensor_mm) * res_px\n\n        # Meter size\n        size_in_pixels = focal_px / distances\n\n        return size_in_pixels    \n\n    # ----------------------------------------------------------------------------------------------------\n    # Distance of a location to the camera\n    # ----------------------------------------------------------------------------------------------------\n\n    def distance(self, location):\n\n        if isinstance(location, Vector) or np.shape(location) == (3,):\n            return (self.location - Vector(location)).length\n\n        else:\n            return np.linalg.norm(location - self.location, axis=-1)\n\n    # ====================================================================================================\n    # Compute visibility, distance and apparent size\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Visible points\n    # ----------------------------------------------------------------------------------------------------\n\n    def visible_points(self, verts, radius=0., margin=0., normals=None, return_proj=False):\n        \"\"\" Compute the visibility of vertices.\n\n        For each vertex, the following values are computed:\n        - visible : vertex is visible (all bools below are False)\n        - behind : vertex is behind the visible rectangle\n        - left : vertex is left to the visible rectangle\n        - right : vertex if right to the visible rectangle\n        - above : vertex is above the visible rectangle\n        - below : vertex is below the visible rectangle\n        - back : normal points outards\n        - distance : distance to the camera\n        - size : apparent size (based on radius)\n\n        Arguments\n        ---------\n            - verts (array of vectors) : vertex locations\n            - radius (array of floats or float = 0.) : size at the locations\n            - margin (float, default=0.) : margin factor around the camera\n            - normals (array of vectors = None) : normal pointing outwards are not visible\n\n        Returns\n        -------\n            - couple of arrays : array[n, 7] of bools, array[n, 2] of floats\n        \"\"\"\n\n        # ----------------------------------------------------------------------------------------------------\n        # Resulting arrays\n\n        #count = np.size(verts)//3\n        #vis  = np.zeros((count, 7), dtype=bool)\n        #dist = np.zeros((count, 2), dtype=float)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Current camera object\n\n        camera = self.bcamera\n\n        # ----------------------------------------------------------------------------------------------------\n        # The projection rectangle\n        # The plane is horizontal. All z&lt;0 are identical\n        # View frame corners are returned in the order:\n        # - top-right\n        # - bottom-right\n        # - bottom-left\n        # - top-left        \n\n        c0, c1, c2, c3 = camera.data.view_frame(scene=bpy.context.scene)\n\n        cam_x0, cam_y0 = c2.x - margin, c2.y - margin\n        cam_x1, cam_y1 = c0.x + margin, c0.y + margin\n        cam_z = c0.z\n\n        if False:\n            print(\"-\"*80)\n            print(\"view_frame\", c0, c1, c2, c3)\n            print(f\"CAMERA SHAPE: plane z = {cam_z:.1f}\")\n            print(f\"   x: {cam_x0:5.1f} {cam_x1:5.1f}\")\n            print(f\"   y: {cam_y0:5.1f} {cam_y1:5.1f}\")\n            print()\n\n        # ----------------------------------------------------------------------------------------------------\n        # Camera rotation matrix\n\n        M = np.array(camera.matrix_world.inverted(), dtype=np.float32)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Prepare arguments\n\n        count  = np.size(verts)//3\n        verts  = np.reshape(verts, (count, 3)).astype(np.float32)\n        if not isinstance(radius, np.ndarray):\n            radius = np.full(count, radius, dtype=np.float32)\n        if normals is not None:\n            normals = np.resize(normals, (count, 3)).astype(np.float32)\n        cam_loc = np.array(self.location, dtype=np.float32)\n\n        if USE_JIT:\n            vis, dist, pts = camera_projection_jit(M, cam_z, cam_x0, cam_x1, cam_y0, cam_y1, verts, radius, cam_loc, normals)\n        else:\n            vis, dist, pts = camera_projection(M, cam_z, cam_x0, cam_x1, cam_y0, cam_y1, verts, radius, cam_loc, normals)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Return visibility and distances\n\n        if return_proj:\n            return vis, dist, pts\n        else:\n            return vis, dist\n\n    # ----------------------------------------------------------------------------------------------------\n    # Visible edges\n    # ----------------------------------------------------------------------------------------------------\n\n    def visible_edges(self, mesh, radius=0., margin=0.):\n        \"\"\" Mesh edges visibility\n\n        The visibility of each point is computed with the given radius.\n        An edge is considered invisible if both points are hidden for the same reason:\n        both are left to the camera, or right, or behind...\n\n        In the other case, the edge is considered as visible.\n\n        Arguments\n        ---------\n        mesh : Mesh\n            The mesh with points and edges\n        radius : float\n            The radius of the camera\n        margin : float\n            The margin of the camera\n\n        Returns\n        -------\n        vis : array (n) of bools\n            The visibility of each edge\n        size : array (n) of floats\n            The size of the projected edges\n        \"\"\"\n\n        v_vis, v_dist, proj = self.visible_points(mesh.points.position, radius=radius, margin=margin, return_proj=True)\n        edge0 = mesh.edges.vertex0\n        edge1 = mesh.edges.vertex1\n\n        diff_side = np.logical_and(v_vis[edge0, :], v_vis[edge1, :])\n        vis = ~np.any(diff_side[:, 2:7], axis=1)\n\n        size = np.linalg.norm(proj[edge1] - proj[edge0], axis=1)\n\n        return vis, size\n\n    # ----------------------------------------------------------------------------------------------------\n    # Visible faces\n    # ----------------------------------------------------------------------------------------------------\n\n    def visible_faces(self, mesh, margin=0., back_face_culling=False):\n        \"\"\" Mesh faces visibility\n\n        A face is considered invisible if all its points are hidden for the same reason:\n        all are left to the camera, or right, or behind...\n\n        Arguments\n        ---------\n        mesh : Mesh\n            The mesh with points and faces\n        margin : float\n            The margin of the camera\n        back_face_culling : bool\n            If True, the back face is not considered as visible\n\n        Returns\n        -------\n        vis : array (n) of bools\n            The visibility of each face\n        size : array (n) of floats\n            The size of the projected faces\n        proj : array (n, 3) of floats\n            The projected position of each face\n        \"\"\"\n\n        # ----- Number of faces to analyze\n\n        count = len(mesh.faces)\n        if count == 0:\n            return np.zeros(0, bool), np.zeros(0, float), np.zeros(0, float)\n\n        # ----- Project the points\n\n        v_vis, v_dist, proj = self.visible_points(mesh.points.position, margin=margin, return_proj=True)\n\n        # ----- Back face culling : normal centered on the face position\n\n        if back_face_culling:\n            n_vis, _ = self.visible_points(mesh.faces.position, margin=margin, normals=mesh.faces.normal)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Loop on the faces\n\n        vis_faces = np.zeros(count, bool)\n        size = np.zeros(count, float)\n        for i_face, face in enumerate(mesh.faces):\n\n            # ----- Nothing to do if back face\n\n            if back_face_culling:\n                if not n_vis[i_face, self.BACK_FACE]:\n                    continue\n\n            # ----- Visibility of corners : (n, 7)\n\n            index = face.loop_start\n            n = face.loop_total\n\n            c_vis = v_vis[mesh.corners.vertex_index[index:index + n]]\n            diff_side = np.all(c_vis, axis=0)\n\n            vis_faces[i_face] = ~np.any(diff_side[1:self.SLICE_END])\n\n            if False:\n                print(\"Camera c_vis\\n\", c_vis)\n                print(\"Camera diff_side\\n\", diff_side)\n                print(\"Camera vis_faces\\n\", vis_faces)\n\n            # ----- Face Size\n\n            f_proj = proj[mesh.corners.vertex_index[index:index + n]]\n            xmin, xmax = np.min(f_proj, axis=0), np.max(f_proj, axis=0)\n            size[i_face] = np.linalg.norm(xmax - xmin)\n\n        return vis_faces, size, proj\n\n    # ----------------------------------------------------------------------------------------------------\n    # Visible islands\n    # ----------------------------------------------------------------------------------------------------\n\n    def visible_islands(self, mesh, islands, attribute=\"Island\", margin=0.):\n        \"\"\" Mesh islands visibility\n\n        Islands are defined by an integer.\n\n        Visibility is computed with the position and size of the islands\n\n        Arguments\n        ---------\n        mesh : Mesh\n            The mesh with points and faces\n        islands: array of ints\n            One identifier per island\n        attribute: attribute name\n            The attribute name to use for the islands\n        margin : float\n            The margin of the camera\n\n        Returns\n        -------\n            - couple of arrays : array[n, 7] of bools, array[n, 2] of floats\n        \"\"\"\n\n        # ----- Number of islands to analyze\n\n        count = len(islands)\n        if count == 0:\n            return np.zeros(0, bool), np.zeros(0, float), np.zeros(0, float)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Loop on the islands\n\n        positions = np.zeros((count, 3), float)\n        radius = np.zeros(count, float)\n        size = np.zeros(count)\n        for i_island, island in enumerate(islands):\n\n            sel = mesh.points.attributes[attribute] == island\n            pts = mesh.points[sel].position\n\n            vmin, vmax = np.min(pts, axis=0), np.max(pts, axis=0)\n            pos = (vmin + vmax) / 2\n            r = np.linalg.norm(vmax - vmin) / 2\n\n            positions[i_island] = pos\n            radius[i_island] = r\n\n        # ----- Let' go\n\n        return self.visible_points(positions, radius, margin=margin)\n\n    # ====================================================================================================\n    # Scaling\n    # ====================================================================================================\n\n    def distance_for_scale(self, size_max, scale=1.0, margin=0.0, fit_axis=\"auto\"):\n        \"\"\"\n        Compute:\n        - d0: distance at which an unscaled object of real size `size_max` exactly fits\n                the camera frame along `fit_axis` (largest dimension touches the borders).\n        - d : distance such that the UNscaled object at distance d has the same apparent size\n                as the SCALED object (size_max * scale) at distance d0. (i.e. d = d0 / scale)\n        - meters_per_pixel: world-space length at distance d that projects to exactly 1 pixel\n                (so two vertices closer than this fall onto the same pixel).\n\n        Parameters\n        ----------\n        size_max : float\n            Largest real dimension of the mesh (Blender units).\n        scale : float\n            Geometry scale (&gt; 0) applied at distance d0.\n        margin : float, optional\n            Extra margin around the frame (same convention as elsewhere).\n        fit_axis : {\"auto\", \"width\", \"height\"}\n            Which frame span to use to define \"exactly fits\".\n            - \"auto\": min(width, height)\n            - \"width\": frame width\n            - \"height\": frame height\n\n        Returns\n        -------\n        d : float\n            Distance where the UNscaled object matches the apparent size\n            of the SCALED one at d0 (d = d0 / scale).\n        meters_per_pixel : float\n            World-space size corresponding to 1 pixel at distance d.\n\n        Notes\n        -----\n        - Uses Blender's view_frame on plane z = cam_z.\n        width  = cam_x1 - cam_x0\n        height = cam_y1 - cam_y0\n        - Perspective: apparent_size \u221d size / distance\n        equality \u21d2 size_max / d = (size_max * scale) / d0 \u21d2 d = d0 / scale.\n        \"\"\"\n        if scale &lt;= 0:\n            raise ValueError(\"`scale` must be &gt; 0.\")\n\n        camera = self.bcamera\n        c0, c1, c2, c3 = camera.data.view_frame(scene=bpy.context.scene)\n\n        cam_x0, cam_y0 = c2.x - margin, c2.y - margin\n        cam_x1, cam_y1 = c0.x + margin, c0.y + margin\n        cam_z = c0.z  # typically negative in Blender\n\n        frame_w = (cam_x1 - cam_x0)\n        frame_h = (cam_y1 - cam_y0)\n\n        if fit_axis == \"width\":\n            frame_span = frame_w\n        elif fit_axis == \"height\":\n            frame_span = frame_h\n        else:  # \"auto\"\n            frame_span = frame_w if frame_w &lt; frame_h else frame_h\n\n        if frame_span &lt;= 0:\n            raise RuntimeError(\"Invalid camera frame span (width/height &lt;= 0).\")\n\n        # d0: unchanged logic \u2014 object (unscaled) exactly fits the frame\n        d0 = (-cam_z) * float(size_max) / float(frame_span)\n\n        # Distance so that UNscaled@d matches SCALED@d0\n        d = d0 / float(scale)\n\n        # Pixel size at distance d:\n        # pixels_per_meter(d) -&gt; px/m, so 1 px corresponds to 1 / (px/m) meters\n        px_per_m = float(self.pixels_per_meter(d))\n        meters_per_pixel = 1.0 / px_per_m if px_per_m &gt; 0.0 else float(\"inf\")\n\n        return d, meters_per_pixel\n</code></pre>"},{"location":"api/#npblender.Camera.distance_for_scale","title":"<code>distance_for_scale(size_max, scale=1.0, margin=0.0, fit_axis='auto')</code>","text":"<p>Compute: - d0: distance at which an unscaled object of real size <code>size_max</code> exactly fits         the camera frame along <code>fit_axis</code> (largest dimension touches the borders). - d : distance such that the UNscaled object at distance d has the same apparent size         as the SCALED object (size_max * scale) at distance d0. (i.e. d = d0 / scale) - meters_per_pixel: world-space length at distance d that projects to exactly 1 pixel         (so two vertices closer than this fall onto the same pixel).</p>"},{"location":"api/#npblender.Camera.distance_for_scale--parameters","title":"Parameters","text":"<p>size_max : float     Largest real dimension of the mesh (Blender units). scale : float     Geometry scale (&gt; 0) applied at distance d0. margin : float, optional     Extra margin around the frame (same convention as elsewhere). fit_axis : {\"auto\", \"width\", \"height\"}     Which frame span to use to define \"exactly fits\".     - \"auto\": min(width, height)     - \"width\": frame width     - \"height\": frame height</p>"},{"location":"api/#npblender.Camera.distance_for_scale--returns","title":"Returns","text":"<p>d : float     Distance where the UNscaled object matches the apparent size     of the SCALED one at d0 (d = d0 / scale). meters_per_pixel : float     World-space size corresponding to 1 pixel at distance d.</p>"},{"location":"api/#npblender.Camera.distance_for_scale--notes","title":"Notes","text":"<ul> <li>Uses Blender's view_frame on plane z = cam_z. width  = cam_x1 - cam_x0 height = cam_y1 - cam_y0</li> <li>Perspective: apparent_size \u221d size / distance equality \u21d2 size_max / d = (size_max * scale) / d0 \u21d2 d = d0 / scale.</li> </ul> Source code in <code>npblender/camera.py</code> <pre><code>def distance_for_scale(self, size_max, scale=1.0, margin=0.0, fit_axis=\"auto\"):\n    \"\"\"\n    Compute:\n    - d0: distance at which an unscaled object of real size `size_max` exactly fits\n            the camera frame along `fit_axis` (largest dimension touches the borders).\n    - d : distance such that the UNscaled object at distance d has the same apparent size\n            as the SCALED object (size_max * scale) at distance d0. (i.e. d = d0 / scale)\n    - meters_per_pixel: world-space length at distance d that projects to exactly 1 pixel\n            (so two vertices closer than this fall onto the same pixel).\n\n    Parameters\n    ----------\n    size_max : float\n        Largest real dimension of the mesh (Blender units).\n    scale : float\n        Geometry scale (&gt; 0) applied at distance d0.\n    margin : float, optional\n        Extra margin around the frame (same convention as elsewhere).\n    fit_axis : {\"auto\", \"width\", \"height\"}\n        Which frame span to use to define \"exactly fits\".\n        - \"auto\": min(width, height)\n        - \"width\": frame width\n        - \"height\": frame height\n\n    Returns\n    -------\n    d : float\n        Distance where the UNscaled object matches the apparent size\n        of the SCALED one at d0 (d = d0 / scale).\n    meters_per_pixel : float\n        World-space size corresponding to 1 pixel at distance d.\n\n    Notes\n    -----\n    - Uses Blender's view_frame on plane z = cam_z.\n    width  = cam_x1 - cam_x0\n    height = cam_y1 - cam_y0\n    - Perspective: apparent_size \u221d size / distance\n    equality \u21d2 size_max / d = (size_max * scale) / d0 \u21d2 d = d0 / scale.\n    \"\"\"\n    if scale &lt;= 0:\n        raise ValueError(\"`scale` must be &gt; 0.\")\n\n    camera = self.bcamera\n    c0, c1, c2, c3 = camera.data.view_frame(scene=bpy.context.scene)\n\n    cam_x0, cam_y0 = c2.x - margin, c2.y - margin\n    cam_x1, cam_y1 = c0.x + margin, c0.y + margin\n    cam_z = c0.z  # typically negative in Blender\n\n    frame_w = (cam_x1 - cam_x0)\n    frame_h = (cam_y1 - cam_y0)\n\n    if fit_axis == \"width\":\n        frame_span = frame_w\n    elif fit_axis == \"height\":\n        frame_span = frame_h\n    else:  # \"auto\"\n        frame_span = frame_w if frame_w &lt; frame_h else frame_h\n\n    if frame_span &lt;= 0:\n        raise RuntimeError(\"Invalid camera frame span (width/height &lt;= 0).\")\n\n    # d0: unchanged logic \u2014 object (unscaled) exactly fits the frame\n    d0 = (-cam_z) * float(size_max) / float(frame_span)\n\n    # Distance so that UNscaled@d matches SCALED@d0\n    d = d0 / float(scale)\n\n    # Pixel size at distance d:\n    # pixels_per_meter(d) -&gt; px/m, so 1 px corresponds to 1 / (px/m) meters\n    px_per_m = float(self.pixels_per_meter(d))\n    meters_per_pixel = 1.0 / px_per_m if px_per_m &gt; 0.0 else float(\"inf\")\n\n    return d, meters_per_pixel\n</code></pre>"},{"location":"api/#npblender.Camera.pixels_per_meter","title":"<code>pixels_per_meter(distances)</code>","text":"<p>Returns the number of pixels per meter given the distances</p>"},{"location":"api/#npblender.Camera.pixels_per_meter--arguments","title":"Arguments","text":"<ul> <li>distances (array of floats) : the distances</li> </ul>"},{"location":"api/#npblender.Camera.pixels_per_meter--returns","title":"Returns","text":"<ul> <li>array of floats : the size of a meter in pixels</li> </ul> Source code in <code>npblender/camera.py</code> <pre><code>def pixels_per_meter(self, distances):\n    \"\"\" Returns the number of pixels per meter given the distances\n\n    Arguments\n    ---------\n    - distances (array of floats) : the distances\n\n    Returns\n    -------\n    - array of floats : the size of a meter in pixels\n    \"\"\"\n    cam_data = self.bcamera.data\n\n    # Focal and sensor in mm\n    focal_mm = cam_data.lens\n    sensor_fit = cam_data.sensor_fit\n\n    if sensor_fit == 'VERTICAL':\n        sensor_mm = cam_data.sensor_height\n        res_px = self.resolution_y\n    else:  # 'HORIZONTAL' or 'AUTO'\n        sensor_mm = cam_data.sensor_width\n        res_px = self.resolution_x\n\n    # Focal in pixels\n    focal_px = (focal_mm / sensor_mm) * res_px\n\n    # Meter size\n    size_in_pixels = focal_px / distances\n\n    return size_in_pixels    \n</code></pre>"},{"location":"api/#npblender.Camera.visible_edges","title":"<code>visible_edges(mesh, radius=0.0, margin=0.0)</code>","text":"<p>Mesh edges visibility</p> <p>The visibility of each point is computed with the given radius. An edge is considered invisible if both points are hidden for the same reason: both are left to the camera, or right, or behind...</p> <p>In the other case, the edge is considered as visible.</p>"},{"location":"api/#npblender.Camera.visible_edges--arguments","title":"Arguments","text":"<p>mesh : Mesh     The mesh with points and edges radius : float     The radius of the camera margin : float     The margin of the camera</p>"},{"location":"api/#npblender.Camera.visible_edges--returns","title":"Returns","text":"<p>vis : array (n) of bools     The visibility of each edge size : array (n) of floats     The size of the projected edges</p> Source code in <code>npblender/camera.py</code> <pre><code>def visible_edges(self, mesh, radius=0., margin=0.):\n    \"\"\" Mesh edges visibility\n\n    The visibility of each point is computed with the given radius.\n    An edge is considered invisible if both points are hidden for the same reason:\n    both are left to the camera, or right, or behind...\n\n    In the other case, the edge is considered as visible.\n\n    Arguments\n    ---------\n    mesh : Mesh\n        The mesh with points and edges\n    radius : float\n        The radius of the camera\n    margin : float\n        The margin of the camera\n\n    Returns\n    -------\n    vis : array (n) of bools\n        The visibility of each edge\n    size : array (n) of floats\n        The size of the projected edges\n    \"\"\"\n\n    v_vis, v_dist, proj = self.visible_points(mesh.points.position, radius=radius, margin=margin, return_proj=True)\n    edge0 = mesh.edges.vertex0\n    edge1 = mesh.edges.vertex1\n\n    diff_side = np.logical_and(v_vis[edge0, :], v_vis[edge1, :])\n    vis = ~np.any(diff_side[:, 2:7], axis=1)\n\n    size = np.linalg.norm(proj[edge1] - proj[edge0], axis=1)\n\n    return vis, size\n</code></pre>"},{"location":"api/#npblender.Camera.visible_faces","title":"<code>visible_faces(mesh, margin=0.0, back_face_culling=False)</code>","text":"<p>Mesh faces visibility</p> <p>A face is considered invisible if all its points are hidden for the same reason: all are left to the camera, or right, or behind...</p>"},{"location":"api/#npblender.Camera.visible_faces--arguments","title":"Arguments","text":"<p>mesh : Mesh     The mesh with points and faces margin : float     The margin of the camera back_face_culling : bool     If True, the back face is not considered as visible</p>"},{"location":"api/#npblender.Camera.visible_faces--returns","title":"Returns","text":"<p>vis : array (n) of bools     The visibility of each face size : array (n) of floats     The size of the projected faces proj : array (n, 3) of floats     The projected position of each face</p> Source code in <code>npblender/camera.py</code> <pre><code>def visible_faces(self, mesh, margin=0., back_face_culling=False):\n    \"\"\" Mesh faces visibility\n\n    A face is considered invisible if all its points are hidden for the same reason:\n    all are left to the camera, or right, or behind...\n\n    Arguments\n    ---------\n    mesh : Mesh\n        The mesh with points and faces\n    margin : float\n        The margin of the camera\n    back_face_culling : bool\n        If True, the back face is not considered as visible\n\n    Returns\n    -------\n    vis : array (n) of bools\n        The visibility of each face\n    size : array (n) of floats\n        The size of the projected faces\n    proj : array (n, 3) of floats\n        The projected position of each face\n    \"\"\"\n\n    # ----- Number of faces to analyze\n\n    count = len(mesh.faces)\n    if count == 0:\n        return np.zeros(0, bool), np.zeros(0, float), np.zeros(0, float)\n\n    # ----- Project the points\n\n    v_vis, v_dist, proj = self.visible_points(mesh.points.position, margin=margin, return_proj=True)\n\n    # ----- Back face culling : normal centered on the face position\n\n    if back_face_culling:\n        n_vis, _ = self.visible_points(mesh.faces.position, margin=margin, normals=mesh.faces.normal)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Loop on the faces\n\n    vis_faces = np.zeros(count, bool)\n    size = np.zeros(count, float)\n    for i_face, face in enumerate(mesh.faces):\n\n        # ----- Nothing to do if back face\n\n        if back_face_culling:\n            if not n_vis[i_face, self.BACK_FACE]:\n                continue\n\n        # ----- Visibility of corners : (n, 7)\n\n        index = face.loop_start\n        n = face.loop_total\n\n        c_vis = v_vis[mesh.corners.vertex_index[index:index + n]]\n        diff_side = np.all(c_vis, axis=0)\n\n        vis_faces[i_face] = ~np.any(diff_side[1:self.SLICE_END])\n\n        if False:\n            print(\"Camera c_vis\\n\", c_vis)\n            print(\"Camera diff_side\\n\", diff_side)\n            print(\"Camera vis_faces\\n\", vis_faces)\n\n        # ----- Face Size\n\n        f_proj = proj[mesh.corners.vertex_index[index:index + n]]\n        xmin, xmax = np.min(f_proj, axis=0), np.max(f_proj, axis=0)\n        size[i_face] = np.linalg.norm(xmax - xmin)\n\n    return vis_faces, size, proj\n</code></pre>"},{"location":"api/#npblender.Camera.visible_islands","title":"<code>visible_islands(mesh, islands, attribute='Island', margin=0.0)</code>","text":"<p>Mesh islands visibility</p> <p>Islands are defined by an integer.</p> <p>Visibility is computed with the position and size of the islands</p>"},{"location":"api/#npblender.Camera.visible_islands--arguments","title":"Arguments","text":"<p>mesh : Mesh     The mesh with points and faces islands: array of ints     One identifier per island attribute: attribute name     The attribute name to use for the islands margin : float     The margin of the camera</p>"},{"location":"api/#npblender.Camera.visible_islands--returns","title":"Returns","text":"<pre><code>- couple of arrays : array[n, 7] of bools, array[n, 2] of floats\n</code></pre> Source code in <code>npblender/camera.py</code> <pre><code>def visible_islands(self, mesh, islands, attribute=\"Island\", margin=0.):\n    \"\"\" Mesh islands visibility\n\n    Islands are defined by an integer.\n\n    Visibility is computed with the position and size of the islands\n\n    Arguments\n    ---------\n    mesh : Mesh\n        The mesh with points and faces\n    islands: array of ints\n        One identifier per island\n    attribute: attribute name\n        The attribute name to use for the islands\n    margin : float\n        The margin of the camera\n\n    Returns\n    -------\n        - couple of arrays : array[n, 7] of bools, array[n, 2] of floats\n    \"\"\"\n\n    # ----- Number of islands to analyze\n\n    count = len(islands)\n    if count == 0:\n        return np.zeros(0, bool), np.zeros(0, float), np.zeros(0, float)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Loop on the islands\n\n    positions = np.zeros((count, 3), float)\n    radius = np.zeros(count, float)\n    size = np.zeros(count)\n    for i_island, island in enumerate(islands):\n\n        sel = mesh.points.attributes[attribute] == island\n        pts = mesh.points[sel].position\n\n        vmin, vmax = np.min(pts, axis=0), np.max(pts, axis=0)\n        pos = (vmin + vmax) / 2\n        r = np.linalg.norm(vmax - vmin) / 2\n\n        positions[i_island] = pos\n        radius[i_island] = r\n\n    # ----- Let' go\n\n    return self.visible_points(positions, radius, margin=margin)\n</code></pre>"},{"location":"api/#npblender.Camera.visible_points","title":"<code>visible_points(verts, radius=0.0, margin=0.0, normals=None, return_proj=False)</code>","text":"<p>Compute the visibility of vertices.</p> <p>For each vertex, the following values are computed: - visible : vertex is visible (all bools below are False) - behind : vertex is behind the visible rectangle - left : vertex is left to the visible rectangle - right : vertex if right to the visible rectangle - above : vertex is above the visible rectangle - below : vertex is below the visible rectangle - back : normal points outards - distance : distance to the camera - size : apparent size (based on radius)</p>"},{"location":"api/#npblender.Camera.visible_points--arguments","title":"Arguments","text":"<pre><code>- verts (array of vectors) : vertex locations\n- radius (array of floats or float = 0.) : size at the locations\n- margin (float, default=0.) : margin factor around the camera\n- normals (array of vectors = None) : normal pointing outwards are not visible\n</code></pre>"},{"location":"api/#npblender.Camera.visible_points--returns","title":"Returns","text":"<pre><code>- couple of arrays : array[n, 7] of bools, array[n, 2] of floats\n</code></pre> Source code in <code>npblender/camera.py</code> <pre><code>def visible_points(self, verts, radius=0., margin=0., normals=None, return_proj=False):\n    \"\"\" Compute the visibility of vertices.\n\n    For each vertex, the following values are computed:\n    - visible : vertex is visible (all bools below are False)\n    - behind : vertex is behind the visible rectangle\n    - left : vertex is left to the visible rectangle\n    - right : vertex if right to the visible rectangle\n    - above : vertex is above the visible rectangle\n    - below : vertex is below the visible rectangle\n    - back : normal points outards\n    - distance : distance to the camera\n    - size : apparent size (based on radius)\n\n    Arguments\n    ---------\n        - verts (array of vectors) : vertex locations\n        - radius (array of floats or float = 0.) : size at the locations\n        - margin (float, default=0.) : margin factor around the camera\n        - normals (array of vectors = None) : normal pointing outwards are not visible\n\n    Returns\n    -------\n        - couple of arrays : array[n, 7] of bools, array[n, 2] of floats\n    \"\"\"\n\n    # ----------------------------------------------------------------------------------------------------\n    # Resulting arrays\n\n    #count = np.size(verts)//3\n    #vis  = np.zeros((count, 7), dtype=bool)\n    #dist = np.zeros((count, 2), dtype=float)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Current camera object\n\n    camera = self.bcamera\n\n    # ----------------------------------------------------------------------------------------------------\n    # The projection rectangle\n    # The plane is horizontal. All z&lt;0 are identical\n    # View frame corners are returned in the order:\n    # - top-right\n    # - bottom-right\n    # - bottom-left\n    # - top-left        \n\n    c0, c1, c2, c3 = camera.data.view_frame(scene=bpy.context.scene)\n\n    cam_x0, cam_y0 = c2.x - margin, c2.y - margin\n    cam_x1, cam_y1 = c0.x + margin, c0.y + margin\n    cam_z = c0.z\n\n    if False:\n        print(\"-\"*80)\n        print(\"view_frame\", c0, c1, c2, c3)\n        print(f\"CAMERA SHAPE: plane z = {cam_z:.1f}\")\n        print(f\"   x: {cam_x0:5.1f} {cam_x1:5.1f}\")\n        print(f\"   y: {cam_y0:5.1f} {cam_y1:5.1f}\")\n        print()\n\n    # ----------------------------------------------------------------------------------------------------\n    # Camera rotation matrix\n\n    M = np.array(camera.matrix_world.inverted(), dtype=np.float32)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Prepare arguments\n\n    count  = np.size(verts)//3\n    verts  = np.reshape(verts, (count, 3)).astype(np.float32)\n    if not isinstance(radius, np.ndarray):\n        radius = np.full(count, radius, dtype=np.float32)\n    if normals is not None:\n        normals = np.resize(normals, (count, 3)).astype(np.float32)\n    cam_loc = np.array(self.location, dtype=np.float32)\n\n    if USE_JIT:\n        vis, dist, pts = camera_projection_jit(M, cam_z, cam_x0, cam_x1, cam_y0, cam_y1, verts, radius, cam_loc, normals)\n    else:\n        vis, dist, pts = camera_projection(M, cam_z, cam_x0, cam_x1, cam_y0, cam_y1, verts, radius, cam_loc, normals)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Return visibility and distances\n\n    if return_proj:\n        return vis, dist, pts\n    else:\n        return vis, dist\n</code></pre>"},{"location":"api/#npblender.Cloud","title":"<code>Cloud</code>","text":"<p>               Bases: <code>Geometry</code></p> <p>Cloud Geometry class representing a collection of points with various attributes.</p> <p>This class provides methods to create, manipulate, and transform point clouds, including loading from and saving to Blender data structures, combining multiple clouds, and generating point distributions in various shapes (line, arc, circle, rectangle, pie, disk, cylinder, sphere, dome, cube, ball).</p> <p>Attributes:</p> Name Type Description <code>points</code> <code>Point</code> <p>The vertices of the cloud with associated attributes.</p> <p>Methods:</p> Name Description <code>from_geometry</code> <p>Create a Cloud from another geometry with points.</p> <code>from_cloud</code> <p>Synonym for from_geometry.</p> <code>capture</code> <p>Capture data from another Cloud instance.</p> <code>from_data</code> <p>Initialize from Blender Mesh or PointCloud data.</p> <code>to_data</code> <p>Write the cloud geometry into a Blender Mesh.</p> <code>from_object</code> <p>Create a Cloud from a Blender object.</p> <code>to_object</code> <p>Create or update a Blender object with the cloud data.</p> <code>object</code> <p>Context manager for temporary Blender object editing.</p> <code>join</code> <p>Join other Clouds into this one.</p> <code>transform, translate, scale</code> <p>Geometric transformations.</p> <code>Various distribution methods</code> <p>line_dist, arc_dist, circle_dist, rect_dist, pie_dist, disk_dist, cylinder_dist, sphere_dist, dome_dist, cube_dist, ball_dist for generating points in shapes.</p> Source code in <code>npblender/cloud.py</code> <pre><code>class Cloud(Geometry):\n    \"\"\"\n    Cloud Geometry class representing a collection of points with various attributes.\n\n    This class provides methods to create, manipulate, and transform point clouds, including\n    loading from and saving to Blender data structures, combining multiple clouds, and generating\n    point distributions in various shapes (line, arc, circle, rectangle, pie, disk, cylinder, sphere,\n    dome, cube, ball).\n\n    Attributes:\n        points (Point): The vertices of the cloud with associated attributes.\n\n    Methods:\n        from_geometry: Create a Cloud from another geometry with points.\n        from_cloud: Synonym for from_geometry.\n        capture: Capture data from another Cloud instance.\n        from_data: Initialize from Blender Mesh or PointCloud data.\n        to_data: Write the cloud geometry into a Blender Mesh.\n        from_object: Create a Cloud from a Blender object.\n        to_object: Create or update a Blender object with the cloud data.\n        object: Context manager for temporary Blender object editing.\n        join: Join other Clouds into this one.\n        transform, translate, scale: Geometric transformations.\n        Various distribution methods: line_dist, arc_dist, circle_dist, rect_dist, pie_dist, disk_dist,\n            cylinder_dist, sphere_dist, dome_dist, cube_dist, ball_dist for generating points in shapes.\n    \"\"\"\n\n\n    def __init__(self, points=None, attr_from=None, **attrs):\n        \"\"\" Cloud Geometry.\n\n        Initialize a Cloud geometry object.\n\n        Parameters\n        ----------\n        points : array-like of vectors, optional\n            The vertices of the cloud geometry. Default is None.\n        attr_from : optional\n            An optional source from which to join attributes.\n        **attrs : dict\n            Additional geometry attributes to be added.\n\n        Notes\n        -----\n        - Initializes an empty geometry with a Point container.\n        - Joins attributes from `attr_from` if provided.\n        - Appends given points and attributes to the geometry.\n        \"\"\"\n\n        self.points = Point()\n        self.join_attributes(attr_from)\n\n        if points is not None:\n            self.points.append(position=points, **attrs)\n\n    # ====================================================================================================\n    # Dump\n    # ====================================================================================================\n\n    def __str__(self):\n        return f\"&lt;Mesh: points {len(self.points)}, corners {len(self.corners)}, faces {len(self.faces)}, edges {len(self.edges)}&gt;\"\n\n    def __repr__(self):\n        s = \"Mesh:\\n   \" + \"\\n   \".join([str(self.points), str(self.corners), str(self.faces)])\n        return s\n\n    # ====================================================================================================\n    # Serialization\n    # ====================================================================================================\n\n    def to_dict(self):\n        return {\n            'geometry': 'Cloud',\n            'points':    self.points.to_dict(),\n            }\n\n    @classmethod\n    def from_dict(cls, d):\n        cloud = cls()\n        cloud.points = Point.from_dict(d['points'])\n        return cloud\n\n    # ====================================================================================================\n    # Clear the geometry\n    # ====================================================================================================\n\n    def clear_geometry(self):\n        \"\"\" Clear the geometry.\n\n        Delete all the content.\n        \"\"\"\n        self.points.clear()\n\n    # ====================================================================================================\n    # From another geometry with points\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Copy\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def from_geometry(cls, other, selection=None):\n        \"\"\" Create a Cloud from another gemetry with points domain.\n\n        Arguments\n        ---------\n            - other (Geometry) : the geometry to copy\n            - selection (selection) : a valid selection on points\n\n        Returns\n        -------\n            - Cloud\n        \"\"\"\n\n        points = getattr(other, 'points')\n        if points is None:\n            raise ValueError(f\"from_geometry&gt; {type(other)} has no points.\")\n\n        cloud = cls()\n        cloud.points = Point(points,  mode='COPY')\n\n        if selection is not None:\n            points_mask = np.ones(len(cloud.points), dtype=bool)\n            points_mask[selection] = False\n\n            cloud.points.delete(points_mask)\n\n        return cloud\n\n    # ----------------------------------------------------------------------------------------------------\n    # Synonym\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def from_cloud(cls, other, selection=None):\n        return cls.from_geometry(other, selection)\n\n\n    # ----------------------------------------------------------------------------------------------------\n    # Capture another Mesh\n    # ----------------------------------------------------------------------------------------------------\n\n    def capture(self, other):\n        \"\"\" Capture the data of another Mesh.\n\n        Arguments\n        ---------\n            - other (Cloud) : the mesh to capture\n\n        Returns\n        -------\n            - self\n        \"\"\"\n        self.points  = other.points\n\n    # ====================================================================================================\n    # Blender Interface\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # From Mesh data\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def from_data(cls, data):\n        \"\"\" Initialize the geometry from a Blender data (Mesh or PointCloud)\n\n        Arguments\n        ---------\n            - data (Blender Mesh or PointCloud) : the data to load\n        \"\"\"\n\n        import bpy\n        from . import blender\n\n        data = blender.get_data(data)\n\n        cloud = cls()\n\n        if isinstance(data, bpy.types.Mesh):\n\n            n = len(data.vertices)\n            if n != 0:\n                cloud.points.resize(n)\n\n            cloud.points.from_bl_attributes(data.attributes)\n\n        elif isinstance(data, bpy.types.PointCloud):\n\n            n = len(data.points)\n            if n != 0:\n                cloud.points.add(n)\n\n            cloud.points.from_bl_attributes(data.attributes)\n\n        else:\n            raise ValueError(f\"Cloud.from_data&gt; data type {type(date).__name__} not supported yet\")\n\n        return cloud\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # To data\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def to_data(self, data):\n        \"\"\" Write the geometry into a Blender Mesh\n\n        &gt; [!CAUTION]:\n        &gt; to_data creates a blender Mesh, not PointCloud since the pyton API doesn't allow to dynamically\n        &gt; change the number of points\n\n        Arguments\n        ---------\n            - mesh (Blender Mesh instance) : the mesh to write\n        \"\"\"\n\n        from . import blender\n\n        bl_mesh = blender.get_data(data)\n        bl_mesh.clear_geometry()\n\n        bl_mesh.materials.clear()\n\n        # ----------------------------------------------------------------------------------------------------\n        # Vertices\n\n        if len(self.points):\n            bl_mesh.vertices.add(len(self.points))\n\n        # ----------------------------------------------------------------------------------------------------\n        # Attributes\n\n        attributes = data.attributes\n\n        self.points.to_bl_attributes(attributes, update=False)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Update\n\n        bl_mesh.update()\n\n    # ----------------------------------------------------------------------------------------------------\n    # Initialize from an object\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def from_object(cls, obj, evaluated=False):\n        \"\"\" Create a Mesh from an existing object.\n\n        Arguments\n        ---------\n            - obj (str or Blender object) : the object to initialize from\n            - evaluated (bool = False) : object modified by the modifiers if True, raw vertices otherwise\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n\n        from . import blender\n\n        if evaluated:\n            depsgraph = bpy.context.evaluated_depsgraph_get()\n            object_eval = blender.get_object(obj).evaluated_get(depsgraph)\n            return cls.from_data(object_eval.data)\n\n        else:\n            return cls.from_data(blender.get_object(obj).data)\n\n    # ----------------------------------------------------------------------------------------------------\n    # To blender object\n    # ----------------------------------------------------------------------------------------------------\n\n    def to_object(self, obj, point_cloud=False, collection=None):\n        \"\"\" Create or update a blender object.\n\n        By default, a mesh object is created. If as_point_cloud is True, the object is the converted\n        to a PointCloud object.\n\n        Arguments\n        ---------\n            - obj (str or Blender object) : the object the create\n            - point_cloud (bool = False) : the object is a PointCloud object if True\n            - collection (str or Blender collection) : the collection to add the object to\n\n        Returns\n        -------\n            - Blender Mesh or PointCloud object\n        \"\"\"\n\n        from . import blender\n\n        obj = blender.create_mesh_object(obj, collection=collection, halt=False)\n        self.to_data(obj.data)\n\n        if point_cloud:\n            blender.mesh_to_point_cloud(obj)\n\n        return obj\n\n    # ====================================================================================================\n    # Object edition\n    # ====================================================================================================\n\n    @contextmanager\n    def object(self, index=0, as_point_cloud=True, readonly=True):\n\n        temp_name = index if isinstance(index, str) else f\"BPBL Temp Mesh {index}\"\n\n        ctx = bpy.context\n\n        old_sel = [obj.name for obj in bpy.data.objects if obj.select_get()]\n        old_active = ctx.view_layer.objects.active\n        if old_active is None:\n            old_active_name = None\n        else:\n            old_active_name = old_active.name\n\n        bpy.ops.object.select_all(action='DESELECT')        \n\n        obj = self.to_object(temp_name, as_point_cloud=as_point_cloud)\n        obj.select_set(True)\n        bpy.context.view_layer.objects.active = obj        \n\n        yield obj\n\n        if not readonly:\n            self.capture(Mesh.from_object(obj))\n\n        blender.delete_object(obj)\n\n        bpy.ops.object.select_all(action='DESELECT')        \n        for name in old_sel:\n            obj = bpy.data.objects.get(name)\n            if obj is not None:\n                obj.select_set(True)\n\n        if old_active_name is not None:\n            bpy.context.view_layer.objects.active = bpy.data.objects.get(old_active_name)\n\n    # ====================================================================================================\n    # Combining\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Join other clouds\n    # ----------------------------------------------------------------------------------------------------\n\n    def join(self, *others):\n        \"\"\" Join other clouds.\n\n        Arguments\n        ---------\n            - other (Mesh) : the Meshes to append\n        \"\"\"\n        for other in others:\n            self.points.extend(other.points)\n\n        return self\n\n    # =============================================================================================================================\n    # Transformation\n    # =============================================================================================================================\n\n    def transform(self, transfo):\n        self.points.position = transfo @ self.points.position\n        return self\n\n    def translate(self, translation):\n        self.points.position += translation\n        return self\n\n    def scale(self, scale, pivot=None):\n        if pivot is not None:\n            self.points.position -= pivot\n        self.points.position *= scale\n        if pivot is not None:\n            self.points.position += pivot\n\n        return self\n\n    # ====================================================================================================\n    # Distributions\n    # ====================================================================================================\n\n    @classmethod\n    def line_dist(cls, point0=(-1, -1, -1), point1=(1, 1, 1), count=10, density=None, seed=None):\n        cloud = cls()\n        cloud.points.new_vector('tangent')\n        d = distribs.line_dist(point0, point1, count, density, seed)\n        cloud.points.append(position=d['points'], tangent=d['tangents'])\n        return cloud\n\n    @classmethod\n    def arc_dist(\n        cls,\n        radius=1.0,\n        scale=None,\n        center=(0, 0, 0),\n        arc_center=0.0,\n        arc_angle=PI/2,\n        use_vonmises=False,\n        count=10,\n        density=None,\n        seed=None,\n    ):\n        cloud = cls()\n        cloud.points.new_vector('tangent')\n        cloud.points.new_float('angle')\n        d = distribs.arc_dist(\n            radius, scale, center, arc_center, arc_angle, use_vonmises, count, density, seed\n        )\n        cloud.points.append(position=d['points'], tangent=d['tangents'], angle=d['angles'])\n        return cloud\n\n    @classmethod\n    def circle_dist(\n        cls,\n        radius=1.0,\n        scale=None,\n        center=(0, 0, 0),\n        count=10,\n        density=None,\n        seed=None,\n    ):\n        cloud = cls()\n        cloud.points.new_vector('tangent')\n        cloud.points.new_float('angle')\n        d = distribs.circle_dist(radius, scale, center, count, density, seed)\n        cloud.points.append(position=d['points'], tangent=d['tangents'], angle=d['angles'])\n        return cloud\n\n    @classmethod\n    def rect_dist(cls, a=1, b=1, center=(0, 0, 0), count=10, density=None, seed=None):\n        cloud = cls()\n        d = distribs.rect_dist(a, b, center, count, density, seed)\n        cloud.points.append(position=d['points'])\n        return cloud\n\n\n    @classmethod\n    def pie_dist(\n        cls,\n        radius=1,\n        outer_radius=None,\n        center=(0, 0, 0),\n        pie_center=0.,\n        pie_angle=PI/2,\n        use_vonmises=False,\n        count=10,\n        density=None,\n        seed=None\n    ):\n        cloud = cls()\n        cloud.points.new_vector('tangent')\n        cloud.points.new_float('angle')\n        d = distribs.pie_dist(\n            radius, outer_radius, center, pie_center, pie_angle, use_vonmises, count, density, seed\n        )\n        cloud.points.append(position=d['points'], tangent=d['tangents'], angle=d['angles'])\n        return cloud\n\n    @classmethod\n    def disk_dist(cls, radius=1, outer_radius=None, center=(0, 0, 0), count=10, density=None, seed=None):\n        cloud = cls()\n        cloud.points.new_vector('tangent')\n        cloud.points.new_float('angle')\n        d = distribs.disk_dist(\n            radius, outer_radius, center, count, density, seed\n        )\n        cloud.points.append(position=d['points'], tangent=d['tangents'], angle=d['angles'])\n        return cloud\n\n    @classmethod\n    def cylinder_dist(\n        cls,\n        radius=1.0,\n        scale=None,\n        height=1.0,\n        center=(0, 0, 0),\n        arc_center=0.0,\n        arc_angle=TAU,\n        use_vonmises=False,\n        count=10,\n        density=None,\n        seed=None,\n    ):\n        cloud = cls()\n        cloud.points.new_vector('normal')\n        cloud.points.new_vector('tangent')\n        cloud.points.new_float('angle')\n        d = distribs.cylinder_dist(\n            radius, scale, height, center, arc_center, arc_angle, use_vonmises, count, density, seed\n        )\n        cloud.points.append(position=d['points'], normal=d['normals'], tangent=d['tangents'], angle=d['angles'])\n        return cloud\n\n\n    @classmethod\n    def sphere_dist(\n        cls,\n        radius=1.0,\n        scale=None,\n        center=(0, 0, 0),\n        count=10,\n        density=None,\n        seed=None\n    ):\n        cloud = cls()\n        cloud.points.new_vector('normal')\n        cloud.points.new_float('theta')\n        cloud.points.new_float('phi')\n        d = distribs.sphere_dist(radius, scale, center, count, density, seed)\n        cloud.points.append(position=d['points'], normal=d['normals'], theta=d['thetas'], phi=d['phis'])\n        return cloud\n\n    @classmethod\n    def dome_dist(\n        cls,\n        radius=1.0,\n        scale=None,\n        axis=(0, 0, 1),\n        angle=np.pi / 2,\n        use_vonmises=False,\n        center=(0, 0, 0),\n        count=10,\n        density=None,\n        seed=None\n    ):\n        cloud = cls()\n        cloud.points.new_vector('normal')\n        d = distribs.dome_dist(\n            radius, scale, axis, angle, use_vonmises, center, count, density, seed\n        )\n        cloud.points.append(position=d['points'], normal=d['normals'])\n        return cloud\n\n\n    @classmethod\n    def cube_dist(cls, size=1, center=(0, 0, 0), count=10, density=None, seed=None):\n        return cls(distribs.cube_dist(size, center, count, density, seed)['points'])\n\n    @classmethod\n    def ball_dist(\n        cls,\n        radius=1.0,\n        axis=(0, 0, 1),\n        angle=np.pi,\n        use_vonmises=False,\n        center=(0, 0, 0),\n        count=10,\n        density=None,\n        scale=None,\n        seed=None,\n        **kwargs\n    ):\n        cloud = cls()\n        cloud.points.new_vector('normal')        \n        d = distribs.ball_dist(\n            radius, axis, angle, use_vonmises, center, count, density, scale, seed, **kwargs)\n        cloud.points.append(position=d['points'], normal=d['normals'])\n        return cloud\n\n    # ====================================================================================================\n    # Tests\n    # ====================================================================================================\n\n    def _test_distribs():\n\n        rng = np.random.default_rng(0)\n\n        cloud = Cloud()\n\n        for i, dist_name in enumerate([\n            \"line_dist\", \"arc_dist\", \"circle_dist\", \"rect_dist\", \"pie_dist\", \"disk_dist\", \n            \"cylinder_dist\", \"sphere_dist\", \"dome_dist\", \"cube_dist\", \"ball_dist\"]):\n\n            f = getattr(Cloud, dist_name)\n            cl = f(density=100, seed=rng)\n            cl.points.x += i*3\n            cloud.join(cl)\n\n        cloud.to_object(\"Distributions\")\n</code></pre>"},{"location":"api/#npblender.Cloud.__init__","title":"<code>__init__(points=None, attr_from=None, **attrs)</code>","text":"<p>Cloud Geometry.</p> <p>Initialize a Cloud geometry object.</p>"},{"location":"api/#npblender.Cloud.__init__--parameters","title":"Parameters","text":"<p>points : array-like of vectors, optional     The vertices of the cloud geometry. Default is None. attr_from : optional     An optional source from which to join attributes. **attrs : dict     Additional geometry attributes to be added.</p>"},{"location":"api/#npblender.Cloud.__init__--notes","title":"Notes","text":"<ul> <li>Initializes an empty geometry with a Point container.</li> <li>Joins attributes from <code>attr_from</code> if provided.</li> <li>Appends given points and attributes to the geometry.</li> </ul> Source code in <code>npblender/cloud.py</code> <pre><code>def __init__(self, points=None, attr_from=None, **attrs):\n    \"\"\" Cloud Geometry.\n\n    Initialize a Cloud geometry object.\n\n    Parameters\n    ----------\n    points : array-like of vectors, optional\n        The vertices of the cloud geometry. Default is None.\n    attr_from : optional\n        An optional source from which to join attributes.\n    **attrs : dict\n        Additional geometry attributes to be added.\n\n    Notes\n    -----\n    - Initializes an empty geometry with a Point container.\n    - Joins attributes from `attr_from` if provided.\n    - Appends given points and attributes to the geometry.\n    \"\"\"\n\n    self.points = Point()\n    self.join_attributes(attr_from)\n\n    if points is not None:\n        self.points.append(position=points, **attrs)\n</code></pre>"},{"location":"api/#npblender.Cloud.capture","title":"<code>capture(other)</code>","text":"<p>Capture the data of another Mesh.</p>"},{"location":"api/#npblender.Cloud.capture--arguments","title":"Arguments","text":"<pre><code>- other (Cloud) : the mesh to capture\n</code></pre>"},{"location":"api/#npblender.Cloud.capture--returns","title":"Returns","text":"<pre><code>- self\n</code></pre> Source code in <code>npblender/cloud.py</code> <pre><code>def capture(self, other):\n    \"\"\" Capture the data of another Mesh.\n\n    Arguments\n    ---------\n        - other (Cloud) : the mesh to capture\n\n    Returns\n    -------\n        - self\n    \"\"\"\n    self.points  = other.points\n</code></pre>"},{"location":"api/#npblender.Cloud.clear_geometry","title":"<code>clear_geometry()</code>","text":"<p>Clear the geometry.</p> <p>Delete all the content.</p> Source code in <code>npblender/cloud.py</code> <pre><code>def clear_geometry(self):\n    \"\"\" Clear the geometry.\n\n    Delete all the content.\n    \"\"\"\n    self.points.clear()\n</code></pre>"},{"location":"api/#npblender.Cloud.from_data","title":"<code>from_data(data)</code>  <code>classmethod</code>","text":"<p>Initialize the geometry from a Blender data (Mesh or PointCloud)</p>"},{"location":"api/#npblender.Cloud.from_data--arguments","title":"Arguments","text":"<pre><code>- data (Blender Mesh or PointCloud) : the data to load\n</code></pre> Source code in <code>npblender/cloud.py</code> <pre><code>@classmethod\ndef from_data(cls, data):\n    \"\"\" Initialize the geometry from a Blender data (Mesh or PointCloud)\n\n    Arguments\n    ---------\n        - data (Blender Mesh or PointCloud) : the data to load\n    \"\"\"\n\n    import bpy\n    from . import blender\n\n    data = blender.get_data(data)\n\n    cloud = cls()\n\n    if isinstance(data, bpy.types.Mesh):\n\n        n = len(data.vertices)\n        if n != 0:\n            cloud.points.resize(n)\n\n        cloud.points.from_bl_attributes(data.attributes)\n\n    elif isinstance(data, bpy.types.PointCloud):\n\n        n = len(data.points)\n        if n != 0:\n            cloud.points.add(n)\n\n        cloud.points.from_bl_attributes(data.attributes)\n\n    else:\n        raise ValueError(f\"Cloud.from_data&gt; data type {type(date).__name__} not supported yet\")\n\n    return cloud\n</code></pre>"},{"location":"api/#npblender.Cloud.from_geometry","title":"<code>from_geometry(other, selection=None)</code>  <code>classmethod</code>","text":"<p>Create a Cloud from another gemetry with points domain.</p>"},{"location":"api/#npblender.Cloud.from_geometry--arguments","title":"Arguments","text":"<pre><code>- other (Geometry) : the geometry to copy\n- selection (selection) : a valid selection on points\n</code></pre>"},{"location":"api/#npblender.Cloud.from_geometry--returns","title":"Returns","text":"<pre><code>- Cloud\n</code></pre> Source code in <code>npblender/cloud.py</code> <pre><code>@classmethod\ndef from_geometry(cls, other, selection=None):\n    \"\"\" Create a Cloud from another gemetry with points domain.\n\n    Arguments\n    ---------\n        - other (Geometry) : the geometry to copy\n        - selection (selection) : a valid selection on points\n\n    Returns\n    -------\n        - Cloud\n    \"\"\"\n\n    points = getattr(other, 'points')\n    if points is None:\n        raise ValueError(f\"from_geometry&gt; {type(other)} has no points.\")\n\n    cloud = cls()\n    cloud.points = Point(points,  mode='COPY')\n\n    if selection is not None:\n        points_mask = np.ones(len(cloud.points), dtype=bool)\n        points_mask[selection] = False\n\n        cloud.points.delete(points_mask)\n\n    return cloud\n</code></pre>"},{"location":"api/#npblender.Cloud.from_object","title":"<code>from_object(obj, evaluated=False)</code>  <code>classmethod</code>","text":"<p>Create a Mesh from an existing object.</p>"},{"location":"api/#npblender.Cloud.from_object--arguments","title":"Arguments","text":"<pre><code>- obj (str or Blender object) : the object to initialize from\n- evaluated (bool = False) : object modified by the modifiers if True, raw vertices otherwise\n</code></pre>"},{"location":"api/#npblender.Cloud.from_object--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/cloud.py</code> <pre><code>@classmethod\ndef from_object(cls, obj, evaluated=False):\n    \"\"\" Create a Mesh from an existing object.\n\n    Arguments\n    ---------\n        - obj (str or Blender object) : the object to initialize from\n        - evaluated (bool = False) : object modified by the modifiers if True, raw vertices otherwise\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    from . import blender\n\n    if evaluated:\n        depsgraph = bpy.context.evaluated_depsgraph_get()\n        object_eval = blender.get_object(obj).evaluated_get(depsgraph)\n        return cls.from_data(object_eval.data)\n\n    else:\n        return cls.from_data(blender.get_object(obj).data)\n</code></pre>"},{"location":"api/#npblender.Cloud.join","title":"<code>join(*others)</code>","text":"<p>Join other clouds.</p>"},{"location":"api/#npblender.Cloud.join--arguments","title":"Arguments","text":"<pre><code>- other (Mesh) : the Meshes to append\n</code></pre> Source code in <code>npblender/cloud.py</code> <pre><code>def join(self, *others):\n    \"\"\" Join other clouds.\n\n    Arguments\n    ---------\n        - other (Mesh) : the Meshes to append\n    \"\"\"\n    for other in others:\n        self.points.extend(other.points)\n\n    return self\n</code></pre>"},{"location":"api/#npblender.Cloud.to_data","title":"<code>to_data(data)</code>","text":"<p>Write the geometry into a Blender Mesh</p> <p>[!CAUTION]: to_data creates a blender Mesh, not PointCloud since the pyton API doesn't allow to dynamically change the number of points</p>"},{"location":"api/#npblender.Cloud.to_data--arguments","title":"Arguments","text":"<pre><code>- mesh (Blender Mesh instance) : the mesh to write\n</code></pre> Source code in <code>npblender/cloud.py</code> <pre><code>def to_data(self, data):\n    \"\"\" Write the geometry into a Blender Mesh\n\n    &gt; [!CAUTION]:\n    &gt; to_data creates a blender Mesh, not PointCloud since the pyton API doesn't allow to dynamically\n    &gt; change the number of points\n\n    Arguments\n    ---------\n        - mesh (Blender Mesh instance) : the mesh to write\n    \"\"\"\n\n    from . import blender\n\n    bl_mesh = blender.get_data(data)\n    bl_mesh.clear_geometry()\n\n    bl_mesh.materials.clear()\n\n    # ----------------------------------------------------------------------------------------------------\n    # Vertices\n\n    if len(self.points):\n        bl_mesh.vertices.add(len(self.points))\n\n    # ----------------------------------------------------------------------------------------------------\n    # Attributes\n\n    attributes = data.attributes\n\n    self.points.to_bl_attributes(attributes, update=False)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Update\n\n    bl_mesh.update()\n</code></pre>"},{"location":"api/#npblender.Cloud.to_object","title":"<code>to_object(obj, point_cloud=False, collection=None)</code>","text":"<p>Create or update a blender object.</p> <p>By default, a mesh object is created. If as_point_cloud is True, the object is the converted to a PointCloud object.</p>"},{"location":"api/#npblender.Cloud.to_object--arguments","title":"Arguments","text":"<pre><code>- obj (str or Blender object) : the object the create\n- point_cloud (bool = False) : the object is a PointCloud object if True\n- collection (str or Blender collection) : the collection to add the object to\n</code></pre>"},{"location":"api/#npblender.Cloud.to_object--returns","title":"Returns","text":"<pre><code>- Blender Mesh or PointCloud object\n</code></pre> Source code in <code>npblender/cloud.py</code> <pre><code>def to_object(self, obj, point_cloud=False, collection=None):\n    \"\"\" Create or update a blender object.\n\n    By default, a mesh object is created. If as_point_cloud is True, the object is the converted\n    to a PointCloud object.\n\n    Arguments\n    ---------\n        - obj (str or Blender object) : the object the create\n        - point_cloud (bool = False) : the object is a PointCloud object if True\n        - collection (str or Blender collection) : the collection to add the object to\n\n    Returns\n    -------\n        - Blender Mesh or PointCloud object\n    \"\"\"\n\n    from . import blender\n\n    obj = blender.create_mesh_object(obj, collection=collection, halt=False)\n    self.to_data(obj.data)\n\n    if point_cloud:\n        blender.mesh_to_point_cloud(obj)\n\n    return obj\n</code></pre>"},{"location":"api/#npblender.Corner","title":"<code>Corner</code>","text":"<p>               Bases: <code>Domain</code></p> <p>Corner domain stores a vertex index for face descriptions.</p> <p>This domain is specific to Mesh geometry. It keeps a pointer to the Mesh POINT domain.</p>"},{"location":"api/#npblender.Corner--attributes","title":"Attributes","text":"<pre><code>- vertex_index (int) : vertex index in the points array\n- UVMap (float2, optional) : UV Map coordinates\n</code></pre> Source code in <code>npblender/domain.py</code> <pre><code>class Corner(Domain):\n    \"\"\" Corner domain stores a vertex index for face descriptions.\n\n    This domain is specific to Mesh geometry.\n    It keeps a pointer to the Mesh POINT domain.\n\n    Attributes\n    ----------\n        - vertex_index (int) : vertex index in the points array\n        - UVMap (float2, optional) : UV Map coordinates\n    \"\"\"\n\n    domain_name = 'CORNER'\n\n    def declare_attributes(self):\n        self.new_int('vertex_index', transfer=False, transdom=False)\n        self.new_vector2('UVMap', (0, 0), optional=True, transfer=True, transdom=False)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Check\n    # ----------------------------------------------------------------------------------------------------\n\n    def check(self, count, halt=True):\n        if not len(self):\n            return True\n\n        if np.max(self.vertex_index) &gt; count:\n            msg = f\"Corner check fail: {np.max(self.vertex_index)=}, {count=}\"\n            if halt:\n                raise RuntimeError(msg)\n            else:\n                print(msg)\n                return False\n        return True\n\n    # ====================================================================================================\n    # Methods\n    # ====================================================================================================\n\n    def new_uvmap(self, name, value=None):\n        self.new_vector2(name)\n        if value is not None:\n            self[name] = value\n\n    # ====================================================================================================\n    # Compute attribute on points\n    # ====================================================================================================\n\n    def compute_attribute_on_points(self, attr, points):\n\n        @njit(cache=True)\n        def _to_points(vertex_index, source, res):\n            npoints = res.shape[0]\n            ncorners = vertex_index.shape[0]\n\n            count = np.zeros(npoints, dtype=np.int32)\n            for icorner in range(ncorners):\n                s = source[icorner]\n\n                ipoint = vertex_index[icorner]\n                res[ipoint] += s\n                count[ipoint] += 1\n\n            trailing = 1\n            for d in range(1, res.ndim):\n                trailing *= res.shape[d]\n\n            R2 = res.reshape((npoints, trailing))\n            for ipoint in range(npoints):\n                c = count[ipoint]\n                if c &gt; 0:\n                    inv = 1.0 / c\n                    for j in range(trailing):\n                        R2[ipoint, j] *= inv\n\n            return res  \n\n        attr, item_shape = self._check_attribute_to_compute(attr)\n        res = np.zeros((len(points),) + item_shape, dtype=attr.dtype)\n        return _to_points(self.vertex_index, attr, res)                \n</code></pre>"},{"location":"api/#npblender.Curve","title":"<code>Curve</code>","text":"<p>               Bases: <code>Geometry</code></p> Source code in <code>npblender/curve.py</code> <pre><code>class Curve(Geometry):\n\n    domain_names = [\"points\", \"splines\"]\n\n    def __init__(self, points=None, splines=None, curve_type=POLY, materials=None, attr_from=None, **attrs):\n        \"\"\" Curve Geometry.\n\n        Arguments\n        ---------\n            - points (array of vectors = None) : the vertices\n            - splines (array of ints = None) : sizes\n            - curve_type (array onf ints) : curve types\n            - materials (str or list of strs = None) : list of materials used in the geometry\n            - **attrs (dict) : other geometry attributes\n        \"\"\"\n        # ----- The materials\n        if materials is None:\n            self.materials = []\n        elif isinstance(materials, str):\n            self.materials = [materials]\n        else:\n            self.materials = [mat for mat in materials]\n\n        # ----- The two domains are already built\n        # can be a view on a larger curve\n        if ( points is not None and isinstance(points, ControlPoint) and\n             splines is not None and isinstance(splines, Spline) ):\n            self.points = points\n            self.splines = splines\n            self.is_view = np.sum(self.splines.loop_total) != len(self.points)\n            return\n\n        self.is_view = False\n\n        # ----- Initialize empty domains\n\n        self.points  = ControlPoint()\n        self.splines = Spline()\n\n        self.join_attributes(attr_from)\n\n        # ----- Add geometry\n        self.add_splines(points, splines, curve_type=curve_type, **attrs)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Utilities\n    # ----------------------------------------------------------------------------------------------------\n\n    def get_points_selection(self):\n        \"\"\" Get selection on points associated to the splines.\n\n        If the Curve is not a view on splines, if return [:], otherwise\n        it returns a selection on the points.\n\n        Returns\n        -------\n            - sel (slice) : indices of splines points\n        \"\"\"\n        if not self.is_view:\n            return slice(None)\n\n        all_indices = np.arange(len(self.points))\n        sel = np.zeros(len(self.points), dtype=bool)\n\n        totals, rev_index = np.unique(self.splines.loop_total, return_inverse=True)\n        for index, total in enumerate(totals):\n            indices = self.splines.loop_total[rev_index == index][None, :] + np.arange(total)\n            sel[indices.flatten()] = True\n\n        return sel\n\n    def no_view(self):\n        \"\"\"\n        Materialize a view-curve into a standalone curve (deep copy of splines and points),\n        preserving all point-domain fields (handles, custom attrs, ...).\n        \"\"\"\n        if not self.is_view:\n            return self\n\n        import numpy as np\n\n        # 1) Copy splines domain (owning copy)\n        splines = Spline(self.splines, mode='COPY')\n\n        # 2) Build a single flat index of point rows, bucketed by loop_total (N)\n        lt = splines.loop_total\n        ls = splines.loop_start\n\n        uniq_N = np.unique(lt)\n        idx_blocks = []\n        for N in uniq_N:\n            N = int(N)\n            if N &lt;= 0:\n                continue\n            sel = (lt == N)\n            if not np.any(sel):\n                continue\n            starts = ls[sel]                                   # (B,)\n            idx = starts[:, None] + np.arange(N, dtype=np.int64)  # (B, N)\n            idx_blocks.append(idx.reshape(-1))                 # (B*N,)\n\n        if idx_blocks:\n            idx_all = np.concatenate(idx_blocks, axis=0)\n            # 3) Slice the point FieldArray to keep all fields aligned\n            points = ControlPoint(self.points, mode='COPY', selector=idx_all)  # owning copy\n        else:\n            points = ControlPoint()                       # empty\n\n        # 4) Assign back and normalize bookkeeping\n        self.points = points\n        self.splines = splines.update_loop_start()\n        self.is_view = False\n        return self\n\n    def check(self, title=\"Mesh Check\", halt=True):\n        ok = self.splines.check(halt=False)\n        if ok:\n            return True\n        elif halt:\n            raise Exception(f\"{title} check failed\")\n        else:\n            print(f\"{title} check failed\")\n\n    def __str__(self):\n        scount = f\"{len(self.splines)} spline{'s' if len(self.splines) &gt; 1 else ''}\"\n        sview = f\"view {np.sum(self.splines.loop_total)}/{len(self.points)}\" if self.is_view else f\"{len(self.points)}\"\n        return f\"&lt;Curve: {scount}, {sview} points.&gt;\"\n\n    def __repr__(self):\n\n        max_n = 10\n\n        scount = f\"{len(self.splines)} spline{'s' if len(self.splines) &gt; 1 else ''}\"\n        sview = f\"view {np.sum(self.splines.loop_total)}/{len(self.points)}\" if self.is_view else f\"{len(self.points)}\"\n\n        s = f\"&lt;Curve: {scount}, {sview} points:\\n\"\n        if self.splines.is_scalar:\n            s += (f\"{'BEZIER' if self.splines.curve_type == 0 else 'POLY  '}, \"\n                f\"{'Cyclic' if self.splines.cyclic else 'Open  '}, \"\n                f\"{self.splines.loop_total:3d} points, \"\n                \"f[{self.splines.loop_start:3d}:]\\n\")\n        else:\n            for i in range(min(max_n, len(self.splines))):\n                s += (f\" {i}: {'BEZIER' if self.splines.curve_type[i] == 0 else 'POLY  '}, \"\n                    f\"{'Cyclic' if self.splines.cyclic[i] else 'Open  '}, \"\n                    f\"{self.splines.loop_total[i]:3d} points, \"\n                    f\"[{self.splines.loop_start[i]:3d}:]\\n\")\n            if len(self.splines) &gt; max_n:\n                s += \" ...\"\n        return s + \"&gt;\"\n\n\n    # ====================================================================================================\n    # Serialization\n    # ====================================================================================================\n\n    def to_dict(self):\n        self.no_view()\n        return {\n            'geometry':     'Curve',\n            'materials' :   self.materials,\n            'points':       self.points.to_dict(),\n            'splines':      self.splines.to_dict(),\n            }\n\n    @classmethod\n    def from_dict(cls, d):\n        curve = cls()\n        curve.materials  = d['materials']\n        curve.points     = ControlPoint.from_dict(d['points'])\n        curve.splines    = Spline.from_dict(d['splines'])\n        return curve\n\n    # ====================================================================================================\n    # Clear the geometry\n    # ====================================================================================================\n\n    def clear(self):\n        \"\"\" Clear the geometry\n        \"\"\"\n        self.no_view()\n\n        self.points.clear()\n        self.splines.clear()\n\n    # ====================================================================================================\n    # From another Curve\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Copy\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def from_curve(cls, other, points=None, splines=None):\n        \"\"\" Create a Curve from another curve.\n\n        Arguments\n        ---------\n            - other (Mesh) : the mesh to copy\n            - points (selector = None) : points selection\n            - splines (selector = None) : splines selection\n\n        Returns\n        -------\n            - Curve\n        \"\"\"\n\n        curve = cls(materials=other.materials)\n        curve.points  = ControlPoint(other.points,  mode='COPY')\n        curve.splines = Spline(other.splines, mode='COPY')\n\n        if points is None:\n            points_mask = None\n        else:\n            points_mask = np.ones(len(curve.points), dtype=bool)\n            points_mask[points] = False\n\n        if splines is None:\n            splines_mask = None\n        else:\n            splines_mask = np.ones(len(curve.splines), dtype=bool)\n            splines_mask[splines] = False\n\n        curve.delete_points(points=points_mask, splines=splines_mask)\n\n        return curve\n\n    # ----------------------------------------------------------------------------------------------------\n    # Capture another Curve\n    # ----------------------------------------------------------------------------------------------------\n\n    def capture(self, other):\n        \"\"\" Capture the data of another Curve.\n\n        Arguments\n        ---------\n            - other (Curve) : the mesh to capture\n\n        Returns\n        -------\n            - self\n        \"\"\"\n\n        self.materials = other.materials\n\n        self.is_view = other.is_view\n        self.points  = other.points\n        self.splines = other.splines\n\n    # ====================================================================================================\n    # Interface with Blender\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Initialize from Blender Curve data\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def from_curve_data(cls, data):\n        \"\"\" Initialize the geometry from a Blender Curve\n\n        Arguments\n        ---------\n            - data (Blender Curve instance) : the curve to load\n        \"\"\"\n\n        def read_point_attr(coll, attr, dtype, shape):\n            n = len(coll)\n            a = np.empty((n,) + shape, dtype=dtype)\n            coll.foreach_get(attr, a.ravel())\n            return a\n\n        bl_splines = data.splines\n        nsplines = len(bl_splines)\n        curve = cls()\n        curve.splines.resize(nsplines)\n\n        # ----- Read the spline attributes\n\n        a = np.empty(nsplines, int)\n        for name, key in [('material_index', 'material_index'), ('resolution_u', 'resolution')]:\n            bl_splines.foreach_get(name, a)\n            setattr(curve.splines, key, a)\n\n        a = np.empty(nsplines, bool)\n        for name, key in [('use_cyclic_u', 'cyclic')]:\n            bl_splines.foreach_get(name, a)\n            setattr(curve.splines, key, a)\n\n        # ----- Read the points\n\n        for i_spline, bl_spline in enumerate(data.splines):\n\n            if bl_spline.type == 'POLY':\n                stype = 1\n            elif bl_spline.type == 'NURBS':\n                stype = 2\n            else:\n                stype = 0\n\n            curve.splines[i_spline].curve_type = stype\n\n            if stype == 0:\n                coll = bl_spline.bezier_points\n                attrs = {\n                    'position'          : read_point_attr(coll, 'co',                bfloat, (3,)),\n                    'handle_left'       : read_point_attr(coll, 'handle_left',       bfloat, (3,)),\n                    'handle_right'      : read_point_attr(coll, 'handle_right',      bfloat, (3,)),\n                    'handle_type_left'  : read_point_attr(coll, 'handle_left_type',  bint,   ()),\n                    'handle_type_right' : read_point_attr(coll, 'handle_right_type', bint,   ()),\n                    'radius'            : read_point_attr(coll, 'radius',            bfloat, ()),\n                    'tilt'              : read_point_attr(coll, 'tilt',              bfloat, ()),\n                }\n                curve.splines[i_spline].loop_start = len(curve.points)\n                curve.splines[i_spline].loop_total = len(coll)\n                curve.points.append(**attrs)\n\n            else:\n                coll = bl_spline.points\n                points4 = read_point_attr(coll, 'co', bfloat, (4,))\n                attrs = {\n                    'radius'  : read_point_attr(coll, 'radius',            bfloat, ()),\n                    'tilt'    : read_point_attr(coll, 'tilt',              bfloat, ()),\n                }\n                curve.splines[i_spline].loop_start = len(curve.points)\n                curve.splines[i_spline].loop_total = len(coll)\n                curve.points.append(position=points4[:, :3], w=points4[:, 3], **attrs)\n\n        return curve\n\n    # ----------------------------------------------------------------------------------------------------\n    # Write curve data\n    # ----------------------------------------------------------------------------------------------------\n\n    def to_curve_data(self, data):\n        \"\"\" Initialize the geometry from a Blender Curve\n\n        Arguments\n        ---------\n            - data (Blender Curve instance) : the curve to load\n        \"\"\"\n        self.no_view()\n\n        bl_splines = data.splines\n        bl_splines.clear()\n\n        for i_spline, (curve_type, loop_start, loop_total) in enumerate(zip(\n            self.splines.curve_type,\n            self.splines.loop_start,\n            self.splines.loop_total,\n        )):\n\n            if curve_type == 0:\n                bl_spline = bl_splines.new('BEZIER')\n                coll = bl_spline.bezier_points\n\n                coll.add(loop_total - len(coll))\n\n                a = self.points.position[loop_start:loop_start+loop_total]\n                coll.foreach_set('co', a.ravel())\n\n                attrs = [\n                    'handle_left', \n                    'handle_right', \n                    ('handle_type_left', 'handle_left_type'),\n                    ('handle_type_right', 'handle_right_type'),\n                    'radius', \n                    'tilt',\n                    ]\n\n            else:\n                if curve_type == 1:\n                    bl_spline = bl_splines.new('POLY')\n                else:            \n                    bl_spline = bl_splines.new('NURBS')\n\n                coll = bl_spline.points\n                coll.add(loop_total - len(coll))\n\n                p4 = np.empty((loop_total, 4), dtype=bfloat)\n                p4[:, :3] = self.points.position[loop_start:loop_start+loop_total]\n                p4[:, 3] = self.points.w[loop_start:loop_start+loop_total]\n\n                coll.foreach_set('co', p4.ravel())\n\n                attrs = ['radius', 'tilt', 'weight']\n\n\n            for attr in attrs:\n\n                if isinstance(attr, str):\n                    field_name = attr\n                    attr_name = attr\n                else:\n                    field_name = attr[0]\n                    attr_name = attr[1]\n\n                a = getattr(self.points, field_name)[loop_start:loop_start+loop_total]\n                coll.foreach_set(attr_name, a.ravel())\n\n        # Spline attrixbxutes\n\n        a = self.splines.material_index\n        bl_splines.foreach_set('material_index', a)\n\n        a = self.splines.resolution\n        bl_splines.foreach_set('resolution_u', a)\n\n        a = self.splines.cyclic\n        bl_splines.foreach_set('use_cyclic_u', a)\n\n    # ----------------------------------------------------------------------------------------------------\n    # From object\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def from_object(cls, obj, evaluated=False):\n        \"\"\" Create a Curve from an existing curve.\n\n        Arguments\n        ---------\n            - obj (str or Blender object) : the object to initialize from\n            - evaluated (bool = False) : object modified by the modifiers if True, raw vertices otherwise\n\n        Returns\n        -------\n            - Curve\n        \"\"\"\n\n        if evaluated:\n            depsgraph = bpy.context.evaluated_depsgraph_get()\n            object_eval = blender.get_object(obj).evaluated_get(depsgraph)\n            return cls.from_curve_data(object_eval.data)\n\n        else:\n            return cls.from_curve_data(blender.get_object(obj).data)\n\n    # ----------------------------------------------------------------------------------------------------\n    # To object\n    # ----------------------------------------------------------------------------------------------------\n\n    def to_object(self, obj, collection=None):\n        \"\"\" Create or update a blender object.\n\n        The method 'to_object' creates the whole geometry. It creates a new object if it doesn't already exist.\n        If the object exists, it must be a curve, there is no object type conversion.\n\n        Once the object is created, use the method 'update_object' to change the vertices.\n\n        Arguments\n        ---------\n            - obj (str or Blender object) : the object the create\n\n        Returns\n        -------\n            - Blender curve object\n        \"\"\"\n        curve = blender.create_curve_object(obj, collection=collection)\n        self.to_curve_data(curve.data)\n\n        return curve\n\n    # ----------------------------------------------------------------------------------------------------\n    # Blender data context manager\n    # ----------------------------------------------------------------------------------------------------\n\n    @contextmanager\n    def blender_data(self, readonly=False):\n        \"\"\" Acces to Blender Curve API.\n\n        Transfer the geometry to a temporay Blender Curve.\n        The example below use a blender Mesh to get the normals.\n\n        ``` python\n        curve = Curve.Spiral()\n\n        with curve.blender_data() as bcurve:\n            print(\"Number of points\", len(bcurve.splines[0].points))\n\n        # &gt; Number of points 65\n        ```\n\n        Arguments\n        ---------\n            - readonly (bool=False) : don't read back the geometry if not modified\n\n        Returns\n        -------\n            - Blender Mesh\n        \"\"\"\n        data = bpy.data.curves.get(DATA_TEMP_NAME)\n        if data is None:\n            data = bpy.data.curves.new(DATA_TEMP_NAME, type='CURVE')\n\n        self.to_curve_data(data)\n\n        yield data\n\n        # ----- Back\n\n        if not readonly:\n            self.capture(Curve.FromCurveData(data))   \n\n    # ====================================================================================================\n    # Add splines\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Extract attributes per domain\n    # ----------------------------------------------------------------------------------------------------\n\n    def _attributes_per_domain(self, **attrs):\n\n        dispatched = {\n            'points'  : {},\n            'splines' : {},\n            }\n\n        for k, v in attrs.items():\n            count = 0\n\n            if k in self.points.all_names:\n                dispatched['points'][k] = v\n                count += 1\n\n            if k in self.splines.all_names:\n                dispatched['corners'][k] = v\n                count += 1\n\n            if count == 0:\n                raise AttributeError(f\"Unknown curve attribute '{k}'.\"\n                                     \"- points:  {self.points.all_names}\\n\"\n                                     \"- splines: {self.splines.all_names}\\n\"\n                                     )\n\n            if count &gt; 1:\n                raise AttributeError(f\"Curve attribute '{k}' is ambigous, it belongs to more than one domain (count).\"\n                                     \"- points:  {self.points.all_names}\\n\"\n                                     \"- splines: {self.splines.all_names}\\n\"\n                                     )\n        return dispatched\n\n    # ----------------------------------------------------------------------------------------------------\n    # Check consistency between points shape and spline sizes\n    # ----------------------------------------------------------------------------------------------------\n\n    def _check_points_splines_args(self, points, splines):\n\n        points = np.asarray(points)\n\n        if len(points.shape) == 2:\n            if splines is None:\n                splines = [len(points)]\n\n            elif isinstance(splines, (int, np.int32, np.int64)):\n                if len(points) % splines != 0:\n                    raise ValueError(f\"splines length ({splines}) is not a divider of the number of points ({len(points)}).\")\n\n                nsplines = len(points) // splines\n                #splines = [splines]*nsplines\n                points = points.reshape(nsplines, splines, points.shape[-1])\n\n            elif hasattr(splines, '__len__'):\n                if np.sum(splines) != len(points):\n                    raise ValueError(f\"The sum of spline lengths {np.sum(splines)} doesn't match the number of points {len(points)}.\")\n\n        elif len(points.shape) == 3:\n            if splines is not None and splines != points.shape[1]:\n                raise ValueError(\n                    f\"Points arguments is an array of {len(points)} splines of {points.shape[1]} points each, \"\n                    f\"splines argument must be None or {points.shape[1]}, not {splines}\")\n\n            splines = points.shape[1]\n\n        else:\n            raise ValueError(f\"Points argument must be an array of points, shape {points.shape} is not valid.\")\n\n        return points, splines\n\n    # ----------------------------------------------------------------------------------------------------\n    # Compute Bezier handles\n    # ----------------------------------------------------------------------------------------------------\n\n    @staticmethod\n    def compute_bezier_handles(points, cyclic=False, eps=1e-6):\n        \"\"\"\n        Compute cubic Bezier handles (left/right) from anchors using Catmull-Rom style tangents.\n\n        Parameters\n        ----------\n        points : (N,3) or (B,N,3) float32/float64\n            OPEN storage (no duplicated first point).\n        cyclic : bool\n            If True, wrap neighbors; else use one-sided differences at ends.\n        eps : float\n            Small epsilon to guard against zero-length tangents.\n\n        Returns\n        -------\n        left, right : same shape as `points`\n            left[i]  = P[i] - T[i] * (len_in[i]  / 3)\n            right[i] = P[i] + T[i] * (len_out[i] / 3)\n            with len_in = ||P[i] - P[i-1]|| and len_out = ||P[i+1] - P[i]|| (wrapped if cyclic).\n        \"\"\"\n        P = np.asarray(points)\n        single = (P.ndim == 2)\n        if single:\n            P = P[None, ...]  # (1,N,3)\n\n        B, N, C = P.shape\n        if N == 0:\n            L = np.empty_like(P)\n            R = np.empty_like(P)\n            return (L[0], R[0]) if single else (L, R)\n        if N == 1:\n            # With a single point, handles equal the point\n            L = P.copy()\n            R = P.copy()\n            return (L[0], R[0]) if single else (L, R)\n\n        # Neighbors (OPEN). Use roll for cyclic, clamp edges for non-cyclic.\n        if cyclic:\n            P_prev = np.roll(P, 1, axis=1)    # P[i-1]\n            P_next = np.roll(P, -1, axis=1)   # P[i+1]\n        else:\n            P_prev = np.concatenate([P[:, :1, :],  P[:, :-1, :]], axis=1)  # [P0, P0..P_{N-2}]\n            P_next = np.concatenate([P[:, 1:, :],  P[:, -1:, :]], axis=1)  # [P1..P_{N-1}, P_{N-1}]\n\n        # Catmull-Rom style tangent (centered diff), then normalize\n        der = 0.5 * (P_next - P_prev)                         # (B,N,3)\n        n = np.linalg.norm(der, axis=-1, keepdims=True)       # (B,N,1)\n        n = np.maximum(n, eps)\n        T = der / n                                           # unit tangents\n\n        # Segment lengths in/out\n        d_out = np.linalg.norm(P_next - P, axis=-1, keepdims=True)  # |P[i+1]-P[i]|\n        d_in  = np.linalg.norm(P - P_prev, axis=-1, keepdims=True)  # |P[i]-P[i-1]|\n\n        # Handles: linear-preserving scale (len/3)\n        L = P - T * (d_in  / 3.0)\n        R = P + T * (d_out / 3.0)\n\n        if single:\n            return L[0], R[0]\n        return L, R\n\n\n    def _compute_bezier_handles_OLD(cls, points, cyclic=False):\n\n        single = len(points.shape) == 2\n        if single:\n            points = points[None]\n\n        # ----- Add the first point at the end if cyclic\n\n        count = points.shape[1]\n        if cyclic:\n            count += 1\n            points = np.append(points, [points[:,0]], axis=1)\n\n        # ----- Compute the control points\n\n        der = np.empty_like(points)\n        der[:, 1:-1] = points[:, 2:]  - points[:, :-2]\n        der[:,  0]   = (points[:,  1] - points[:, 0])/2\n        der[:, -1]   = (points[:, -1] - points[:, -2])/2\n\n        nrm = np.linalg.norm(der, axis=-1)\n        nrm[abs(nrm) &lt; 0.001] = 1.\n        der /= nrm[:, :, None]\n\n        dists = np.linalg.norm(points[:, 1:] - points[:, :-1], axis=-1)[:, :, None]\n\n        # Left handles\n        lefts = points.copy()\n        lefts[:, 1:] -= der[:, 1:]*dists/3\n        lefts[:, 0]  -= der[:, 0]*dists[:, 0]/3\n\n        # Right handles\n        rights = points.copy()\n        rights[:, :-1] += der[:, :-1]*dists/3\n        rights[:, -1]  += der[:, -1]*dists[:, -1]/3\n\n        # ----- Returns the result\n\n        if cyclic:\n            if single:\n                return np.array(lefts[0, :-1]), np.array(rights[0, :-1])\n            else:\n                return np.array(lefts[:, :-1]), np.array(rights[:, :-1])\n        else:\n            if single:\n                return lefts[0], rights[0]\n            else:\n                return lefts, rights\n\n    # ----------------------------------------------------------------------------------------------------\n    # Add Bezier\n    # ----------------------------------------------------------------------------------------------------\n\n    def add_bezier(self,\n                   points, \n                   splines = None, \n                   handle_left = None, \n                   handle_right = None, \n                   cyclic = False,\n                   **attrs):\n        \"\"\" Add Bezier splines\n\n        The arguments 'splines' gives the length(s) of the bezier spline(s). If None:\n        - the number of points is taken (one spline is added)\n        - points.shape[1] is taken if the shape of points is (m, , 3)\n\n        handle_left and handle_right must have the same shape as points if provided.\n        If they aren't provided, they are computed.\n\n        Arguments\n        ---------\n        - points (array (n, 3) or (m, n, 3) of vectors) : the points of the curves\n        - splines (int or array of ints = None) : spline or splines length\n        - handle_left (same shape as points = None) : left handles\n        - handle_right (same shape as points = None) : right handles\n        - cyclic (bool = False) : whether the curve is cyclic or not\n        - attrs (dict) : spline and/or points attributes\n\n        Returns\n        -------\n        - dict ('points': added points indices, 'splines': added splines indices)\n        \"\"\"\n        self.no_view()\n\n        if points is None:\n            return {'points': [], 'splines': []}\n\n        # ----- handle_left and handle_right shapes must match points shape\n\n        if handle_left is not None and np.shape(handle_left) != np.shape(points):\n            raise ValueError(\"add_bezier&gt; handle_left and points shapes must match.\")\n\n        if handle_right is not None and np.shape(handle_right) != np.shape(points):\n            raise ValueError(\"add_bezier&gt; handle_right and points shapes must match.\")\n\n        # ----- Make sure args are consistent\n\n        points, splines = self._check_points_splines_args(points, splines)\n        if points.shape[-1] != 3:\n            raise ValueError(\"add_bezier&gt; points must be an array of 3D vectors.\")\n\n        # ----- Dispatch attributes\n\n        disp_attrs = self._attributes_per_domain(**attrs)\n        added = {}\n\n        # ----- A stack of splines\n\n        if len(points.shape) == 3:\n\n            if handle_left is None or handle_right is None:\n                h_left, h_right = self.compute_bezier_handles(points, cyclic=disp_attrs.get('cyclic', False))\n                if handle_left is None:\n                    handle_left = h_left\n                if handle_right is None:\n                    handle_right = h_right\n\n            if np.shape(handle_left) != points.shape or np.shape(handle_right) != points.shape:\n                raise ValueError(\n                    f\"add_bezier&gt; handle_left ({np.shape(handle_left)}) and handle_right \"\n                    f\"({np.shape(handle_right)}) must have the same shape as points  ({np.shape(points)}).\")\n\n            shape = points.shape[:-1]\n            n = int(np.prod(shape))\n            p_attrs = {}\n            for name, value in disp_attrs['points'].items():\n                sh = self.points._infos[name]['shape']\n                if sh == ():\n                    p_attrs[name] = np.broadcast_to(value, shape).ravel()\n                else:\n                    p_attrs[name] = np.broadcast_to(value, shape + sh).reshape((n,) + sh )\n\n            added['points'] = self.points.append(\n                position = points.reshape(-1, 3),\n                handle_left = handle_left.reshape(-1, 3),\n                handle_right = handle_right.reshape(-1, 3),\n                **p_attrs,\n                #**{name: [value] for name, value in disp_attrs['points'].items()},\n                )\n\n            # Add the splines (splines argument is an int)\n            added['splines'] = self.splines.append_sizes([splines]*len(points), curve_type=BEZIER, cyclic=cyclic, **disp_attrs['splines'])\n\n        # ----- A series of splines\n\n        else:\n            cur_points = len(self.points)\n\n            offset = 0\n            h_left, h_right = None, None\n            for size, cycl in zip(splines, np.broadcast_to(cyclic, len(splines))):\n\n                pts = points[offset:offset + size]\n\n                # Compute handles\n                if handle_left is None or handle_right is None:\n                    h_left, h_right = self.compute_bezier_handles(pts, cyclic=cycl)\n                hl = h_left if handle_left is None else handle_left[offset:offset + size]\n                hr = h_right if handle_right is None else handle_right[offset:offset + size]\n\n                # Append points\n                new_points = self.points.append(position=pts, handle_left=hl, handle_right=hr, **disp_attrs['points'])\n\n                # Next\n                offset += size\n\n            added['points']= np.arange(cur_points, len(self.points))\n\n            # Add the splines (splines argument is an array of ints)\n            added['splines'] = self.splines.append_sizes(splines, curve_type=BEZIER, cyclic=cyclic, **disp_attrs['splines'])\n\n        return added\n\n    # ----------------------------------------------------------------------------------------------------\n    # Add Bezier\n    # ----------------------------------------------------------------------------------------------------\n\n    def add_poly(self,\n                   points, \n                   splines = None,\n                   curve_type = POLY,\n                   cyclic = False,\n                   w = 1.,\n                   **attrs):\n        \"\"\" Add Poly or Nurbs splines\n\n        The arguments 'splines' gives the length(s) of the spline(s). If None:\n        - the number of points is taken (one spline is added)\n        - points.shape[1] is taken if the shape of points is (m, , 3)\n\n        Non bezeier splines use 4D points. If the provided vectors are 4D, the argument w\n        is ignored.\n\n        Arguments\n        ---------\n        - points (array (n, 3 or 4) or (m, n, 3 or 4) of vectors) : the points of the curves\n        - splines (int or array of ints = None) : spline or splines length\n        - cyclic (bool = False) : whether the curve is cyclic or not\n        - w (float) : w value, ignored if points are 4D\n        - attrs (dict) : spline and/or points attributes\n\n        Returns\n        -------\n        - dict ('points': added points indices, 'splines': added splines indices)\n        \"\"\"\n        self.no_view()\n\n        if points is None:\n            return {'points': [], 'splines': []}\n\n        # ----- Make sure args are consistent\n\n        points, splines = self._check_points_splines_args(points, splines)\n        if points.shape[-1] not in (3, 4):\n            raise ValueError(\"add_poly&gt; points must be an array of 3D or 4D vectors.\")\n\n        # ----- Dispatch attributes\n\n        disp_attrs = self._attributes_per_domain(**attrs)\n        added = {}\n\n        # ----- A stack of splines\n\n        if len(points.shape) == 3:\n\n            position = points[..., :3]\n            if points.shape[-1] == 4:\n                w = points[..., 3].ravel()\n\n            shape = points.shape[:-1]\n            n = int(np.prod(shape))\n            p_attrs = {}\n            for name, value in disp_attrs['points'].items():\n                sh = self.points._infos[name]['shape']\n                if sh == ():\n                    p_attrs[name] = np.broadcast_to(value, shape).ravel()\n                else:\n                    p_attrs[name] = np.broadcast_to(value, shape + sh).reshape((n,) + sh )\n\n            # Add the points\n            added['points'] = self.points.append(\n                position = position.reshape(-1, 3),\n                w = w,\n                #**{name: [value] for name, value in disp_attrs['points'].items()},\n                **p_attrs,\n                )\n\n            # Add the splines (splines argument is an int)\n            added['splines'] = self.splines.append_sizes([splines]*len(points), curve_type=curve_type, cyclic=cyclic, **disp_attrs['splines'])\n\n        # ----- A series of splines\n\n        else:\n            # Add the points\n            position = points[:, :3]\n            if points.shape[-1] == 4:\n                w = points[:, 3]\n            else:\n                w = np.broadcast_to(w, len(points))\n\n            added['points'] = self.points.append(\n                position = position,\n                w = w,\n                **disp_attrs['points'],\n            )\n\n            # Add the splines (splines argument is an array of ints)\n            added['splines'] = self.splines.append_sizes(splines, curve_type=curve_type, cyclic=cyclic, **disp_attrs['splines'])\n\n        return added    \n\n    # ----------------------------------------------------------------------------------------------------\n    # Add splines\n    # ----------------------------------------------------------------------------------------------------\n\n    def add_splines(self, points=None, splines=None, curve_type=POLY, **attrs):\n        \"\"\" Add splines\n        \"\"\"\n        self.no_view()\n\n        if hasattr(curve_type, '__len__'):\n            raise ValueError(\"Curve add_splines&gt; curve_type must be a single value in (BEZIER, POLY, NURBS), not a list.\\ncurve_type: {curve_type}\")\n\n        if curve_type == BEZIER:\n            return self.add_bezier(points, splines=splines, **attrs)\n        else:\n            return self.add_poly(points, splines=splines, curve_type=curve_type, **attrs)\n\n    # ====================================================================================================\n    # Delete\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Delete points\n    # ----------------------------------------------------------------------------------------------------\n\n    def delete_points(self, points=None, splines=None):\n        \"\"\"Delete points.\n\n        Arguments\n        ---------\n            points : points selection, optional\n                Points indices to delete directly.\n            splines : splines selection, optional\n                Splines owning vertices to delete.\n        \"\"\"\n        self.no_view()\n\n        del_points = np.zeros(len(self.points), dtype=bool)\n        if points is not None:\n            del_points[points] = True\n\n        del_splines = np.zeros(len(self.splines), dtype=bool)\n        if splines is not None:\n            del_splines[splines] = True\n\n        new_total = self.splines.loop_total\n        for i_spline, (loop_start, loop_total) in enumerate(zip(self.splines.loop_start, self.splines.loop_total)):\n\n            if del_splines[i_spline]:\n                del_points[loop_start:loop_start+loop_total] = True\n\n            else:\n                n = np.sum(del_points[loop_start:loop_start+loop_total])\n                if n == loop_total:\n                    del_splines[i_spline] = True\n                else:\n                    new_total[i_spline] = loop_total - n\n\n        self.points.delete(del_points)\n        self.splines.delete(del_splines)\n        self.splines.update_loop_start()\n\n        return self\n\n    # ----------------------------------------------------------------------------------------------------\n    # Delete splines\n    # ----------------------------------------------------------------------------------------------------\n\n    def delete_splines(self, splines=None):\n        \"\"\"Delete splines.\n\n        Arguments\n        ---------\n            splines : splines selection, optional\n                Splines owning vertices to delete.\n        \"\"\"\n        self.no_view()\n\n        return self.delete_points(splines=splines)\n\n    # ====================================================================================================\n    # Combining\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Join other curves\n    # ----------------------------------------------------------------------------------------------------\n\n    def join(self, *others):\n        \"\"\" Join other Curves.\n\n        Arguments\n        ---------\n            - others (Curve) : the curves to append\n        \"\"\"\n        self.no_view()\n\n        for other in others:\n            other.no_view()\n\n            # Splines\n\n            pts_offset = len(self.points)\n            self.points.extend(other.points)\n\n            spl_offset = len(self.splines)\n            self.splines.extend(other.splines)\n            self.splines[spl_offset:].loop_start += pts_offset\n\n            # Materials\n\n            remap = np.array([self.get_material_index(mat_name) for mat_name in other.materials])\n            if len(remap):\n                self.splines.material_index[spl_offset:] = remap[other.splines.material_index]\n\n        return self\n\n    # ----------------------------------------------------------------------------------------------------\n    # Multiply\n    # ----------------------------------------------------------------------------------------------------\n\n    def multiply(self, count, in_place=True):\n        \"\"\" Duplicate the geometry.\n\n        Multiplying is a way to efficiently duplicate the geometry a great number of times.\n        Once duplicated, the points can be reshapped to address each instance individually.\n\n        ``` python\n        count = 16\n\n        cube = Mesh.Cube() * count\n\n        # Shape the points as 16 blocks of 8 vertices\n        points = np.reshape(cube.points.position, (16, 8, 3))\n\n        # Place the cubes in a circle\n        ags = np.linspace(0, 2*np.pi, count, endpoint=False)\n        points[..., 0] += 6 * np.cos(ags)[:, None]\n        points[..., 1] += 6 * np.sin(ags)[:, None]\n\n        cube.to_object(\"Cubes\")\n        ```\n\n        Arguments\n        ---------\n            - count (int=10) : number of instances\n            - attributes (name=value) : value for named attributes\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n        self.no_view()\n\n        # ----------------------------------------------------------------------------------------------------\n        # Checks and simple cases\n\n        if not isinstance(count, (int, np.int32, np.int64)):\n            raise Exception(f\"A Mesh can be multiplied only by an int, not '{count}'\")\n\n        if count == 0:\n            return None\n\n        if count == 1:\n            if in_place:\n                return self\n            else:\n                return type(self).from_curve(self)\n\n        if not in_place:\n            return type(self).from_curve(self).multiply(count, in_place=True)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Points\n\n        nverts = len(self.points)\n        self.points.multiply(count)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Splines\n\n        self.splines.multiply(count)\n        self.splines.update_loop_start()\n\n        return self\n\n    # ----------------------------------------------------------------------------------------------------\n    # Operators\n    # ----------------------------------------------------------------------------------------------------\n\n    def __mul__(self, count):\n        return self.multiply(count, in_place=False)\n\n    def __imul__(self, count):\n        return self.multiply(count, in_place=True)\n\n    # ====================================================================================================\n    # Evaluation\n    # ====================================================================================================\n\n    @property\n    def length(self):\n        return splinemaths.length_curve(self)\n\n    def evaluate(self, t):\n        return splinemaths.evaluate_curve(self, t)\n\n    def tangent(self, t, normalize=True):\n        return splinemaths.tangent_curve(self, t, normalize=normalize)\n\n    def sample_attributes(self, t, names=None, cubic=False):\n        return splinemaths.sample_attributes_curve(self, t, names=names, cubic=cubic)\n\n    # ====================================================================================================\n    # Operations on splines\n    # ====================================================================================================\n\n    def __len__(self):\n        return len(self.splines)\n\n    def __getitem__(self, index):\n        splines = self.splines[index]\n        if splines is None:\n            raise IndexError(f\"Curve index is not valid on curve {self}, index:\\n{index}\")\n        return Curve(points=self.points, splines=splines.no_scalar())\n\n    def select(self, indices):\n        \"\"\"Explicit alias for subsetting splines; same semantics as curve[indices].\"\"\"\n        return self[indices]   \n\n    # ====================================================================================================\n    # Loop on buckets\n    # ====================================================================================================\n\n    def for_each_bucket(self, func):\n        \"\"\"\n        Iterate over homogeneous spline buckets and call `func` once per bucket.\n\n        Bucketing key:\n        (curve_type, N, cyclic, resolution)    # resolution only relevant for BEZIER\n\n        Parameters\n        ----------\n        func : callable\n            Signature:\n                func(curve, curve_type, loop_total, is_cyclic, resolution=None) -&gt; any\n            - `curve` is a Curve view on self .\n            - `curve_type` is the spline type.\n            - `loop_total` is the number of points in the spline.\n            - `is_cyclic` is True if the spline is cyclic.\n            - `resolution` is the resolution of the loop, or None if the spline is not Bezier.\n\n        Yields\n        ------\n        (indices, result)\n            indices : list[int]\n                Spline indices for this bucket, in stacking order.\n            result : any\n                Whatever `func` returned for this bucket.\n        \"\"\"\n        spl = self.splines\n        if len(spl) == 0:\n            return\n\n        # Build buckets keyed by (type, N, cyclic, resolution_or_None)\n        buckets = {}\n        for index, (ctype, N, cyc) in enumerate(zip(spl.curve_type, spl.loop_total, spl.cyclic)):\n            if ctype == BEZIER:\n                resol = spl.resolution[index]\n                key = (ctype, N, cyc, resol)\n            else:\n                key = (ctype, N, cyc, None)\n            buckets.setdefault(key, []).append(index)\n\n        # Iterate buckets and call user function once per bucket\n        for (ctype, N, cyc, resol), idxs in buckets.items():\n            result = func(self[idxs], ctype, N, cyc, resol)\n            yield idxs, result\n\n    # ====================================================================================================\n    # Conversions\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # To poly\n    # ----------------------------------------------------------------------------------------------------\n\n    def to_poly(self, resolution=None):\n        \"\"\" Convert the splines to Poly splines.\n\n        If resolution is None:\n        - `splines.resolution` is used to split Bezier segments\n        - poly lines are left unchanged\n\n        If resolution is not None, all splines are resampled using this value\n\n        Arguments:\n        ---------\n            resolution (int):          Poly resolution, use spline resolution for Bezier if None.\n        \"\"\"\n\n        if resolution is not None:\n            resolution = max(2, resolution)\n\n        attr_names = self.points.transdom_names\n        attr_names.extend(['w', 'tilt'])\n\n        def _to_poly(curve, ctype, loop_total, is_cyclic, resol=None):\n\n            if resolution is None:\n                if ctype == POLY:\n                    return curve.no_view()\n\n                r = max(1, int(resol))\n\n                if is_cyclic:\n                    t = np.linspace(0, 1, loop_total*r, endpoint=False, dtype=bfloat)\n                else:\n                    t = np.linspace(0, 1, (loop_total - 1)*r + 1, endpoint=True, dtype=bfloat)\n            else:\n                if ctype == POLY and resolution == loop_total:\n                    return curve.no_view()\n\n                t = np.linspace(0, 1, resolution, endpoint=not is_cyclic, dtype=bfloat)\n\n            pos = curve.evaluate(t).reshape(-1, 3)\n            attrs = {}\n            for k, v in curve.sample_attributes(t, names=attr_names, cubic=ctype==BEZIER).items():\n                field_shape = curve.points.get_field_shape(k)\n                if field_shape == ():\n                    attrs[k] = v.flatten()\n                else:\n                    attrs[k] = v.reshape((-1,) + field_shape)\n\n            points = ControlPoint(position=pos, attr_from=self.points, **attrs)\n            splines = Spline(curve.splines)\n            splines.curve_type = POLY\n            splines.loop_total = len(t)\n            splines.update_loop_start()\n\n            new_curve = Curve(points=points, splines=splines)\n            new_curve.is_view=False\n            return new_curve\n\n        new_curve = Curve(materials=self.materials)\n        for _, c in self.for_each_bucket(_to_poly):\n            new_curve.splines.extend(c.splines)\n            new_curve.points.extend(c.points)\n\n        new_curve.splines.update_loop_start()\n        return new_curve\n\n    # ----------------------------------------------------------------------------------------------------\n    # To Bezier\n    # ----------------------------------------------------------------------------------------------------\n\n    def to_bezier(self, control_count=None, resolution=16):\n        \"\"\"Convert splines to Bezier splines (OPEN storage).\n\n        Parameters\n        ----------\n        control_count : int or None\n            Number of anchor points to generate per spline. If None, keep current loop_total.\n            For cyclic splines, anchors are sampled on [0,1) (no duplicate). For non-cyclic, on [0,1].\n        resolution : int\n            Per-segment resolution to write into `splines.resolution` (&gt;=1).\n        \"\"\"\n        resolution = max(1, int(resolution))\n\n        attr_names = self.points.transdom_names\n        attr_names.extend(['tilt'])\n\n        def _to_bezier(curve, ctype, loop_total, is_cyclic, _resol=None):\n\n            if ctype == BEZIER and control_count is None:\n                return curve.no_view()\n\n            # Decide target anchor count N for this bucket\n            N = int(control_count) if control_count is not None else int(loop_total)\n            if N &lt;= 0:\n                # build empty bucket preserving schema\n                pts = ControlPoint()\n                spl = Spline(curve.splines)\n                spl.curve_type = BEZIER\n                spl.loop_total = 0\n                spl.resolution = resolution\n                spl.update_loop_start()\n                out = Curve(points=pts, splines=spl)\n                out.is_view = False\n                return out\n\n            # Parameter grid for anchors\n            t = np.linspace(0.0, 1.0, N, endpoint=not is_cyclic, dtype=bfloat)\n\n            # Evaluate anchors\n            P = curve.evaluate(t)                  # (S, N, 3) or (S,3) if N==1\n            if P.ndim == 2:\n                P = P[:, None, :]                  # (S,1,3) uniformize\n\n            # Compute handles from anchors (Catmull-Rom style tangents, linear-preserving scale)\n            L, R = Curve.compute_bezier_handles(P, cyclic=is_cyclic)  # (S,N,3) each\n\n            # Flatten (S,N,3) \u2192 (S*N,3)\n            P_flat = P.reshape(-1, 3)\n            L_flat = L.reshape(-1, 3)\n            R_flat = R.reshape(-1, 3)\n\n            # Sample additional point attributes at anchors\n            attrs = {}\n            for k, v in curve.sample_attributes(t, name=attr_names, cubic=(ctype == BEZIER)).items():\n                field_shape = curve.points.get_field_shape(k)  # e.g. (), (D,), (H,W), ...\n                if field_shape == ():\n                    attrs[k] = v.reshape(-1)\n                else:\n                    attrs[k] = v.reshape((-1,) + field_shape)\n\n            # Build new domains for this bucket\n            points = ControlPoint(position=P_flat,\n                                    handle_left=L_flat,\n                                    handle_right=R_flat,\n                                    attr_from = self.points,\n                                    **attrs)\n\n            splines = Spline(curve.splines)  # copy bucket rows\n            splines.curve_type = BEZIER\n            splines.loop_total = N\n            splines.resolution = resolution\n            splines.update_loop_start()\n\n            out = Curve(points=points, splines=splines)\n            out.is_view = False\n            return out\n\n        # Aggregate all buckets into a fresh curve (materials kept)\n        new_curve = Curve(materials=self.materials)\n        for _, c in self.for_each_bucket(_to_bezier):\n            new_curve.splines.extend(c.splines, join_fields=False)\n            new_curve.points.extend(c.points,   join_fields=False)\n\n        new_curve.splines.update_loop_start()\n        new_curve.splines.resolution = resolution\n        return new_curve\n\n    # ----------------------------------------------------------------------------------------------------\n    # To mesh\n    # ----------------------------------------------------------------------------------------------------\n\n    def to_mesh(self, profile=None, caps=True, use_radius=True, camera_culling=False):\n        \"\"\" &gt; Transform curve to mesh\n\n        If profile is None, the mesh contains only edges\n        otherwise they are ignored\n\n        Arguments\n        ---------\n        - profile (Curve = None) : profile curve\n        - caps (bool = True) : use caps\n        - use_radius (bool = True) : use the radius as a scale for profile\n\n        Returns\n        -------\n        - Mesh\n        \"\"\"\n\n        from . camera import Camera\n        from . mesh import Mesh\n        from .maths.topology import grid_corners, grid_uv_map, disk_uv_map\n\n        if camera_culling != False:\n            camera = Camera(camera_culling)\n            camera_culling = True\n\n        # Circle as default profile\n        if profile is None:\n            profile_size = .001\n        else:\n            full_prof_mesh = profile[0].to_mesh()\n            full_prof_pts = full_prof_mesh.points.position\n            full_nprof = len(full_prof_pts)\n            prof_closed = profile.splines.cyclic[0]\n            profile_size = profile.max_size\n\n        # ---------------------------------------------------------------------------\n        # Add a set of splines of the same type, number of points and cyclic\n        # ---------------------------------------------------------------------------\n\n        def _to_mesh(curve, ctype, N, cyclic, resol, profile_scale=None):\n\n            if ctype == BEZIER:\n                curve = curve.to_poly()\n                N = curve.splines.loop_total[0]\n            else:\n                curve.no_view()\n\n            mesh = Mesh()\n\n            # Number of splines and points\n            nsplines = len(curve.splines)\n            npoints = len(curve.points)\n\n            # ---------------------------------------------------------------------------\n            # No profile : we simply build edges\n            # ---------------------------------------------------------------------------\n\n            if profile is None:\n\n                # Create mesh points\n                mesh.add_points(curve.points.position)\n\n                # Transfer trans domain attributes\n                mesh.points.transfer_attributes(curve.points)\n\n                # Edges\n                inds = np.arange(npoints).reshape(nsplines, N)\n                if cyclic:\n                    edges = np.empty((nsplines, N, 2), dtype=bint)\n                    edges[:, :-1, 0] = inds[:, :-1]\n                    edges[:, :-1, 1] = inds[:, 1:]\n                    edges[:, -1, 0] = inds[:, -1]\n                    edges[:, -1, 1] = inds[:, 0]\n                else:\n                    edges = np.empty((nsplines, N-1, 2), dtype=bint)\n                    edges[..., 0] = inds[:, :-1]\n                    edges[..., 1] = inds[:, 1:]\n\n                edges = edges.reshape(-1, 2)\n                mesh.edges.append(vertex0=edges[..., 0], vertex1=edges[..., 1])\n\n                return mesh\n\n            # ---------------------------------------------------------------------------\n            # We have a profile\n            # ---------------------------------------------------------------------------\n\n            ok_caps = caps and not cyclic and prof_closed\n\n            # Let's adapt to the scale\n            if profile_scale is None:\n                nprof = full_nprof\n                prof_mesh = full_prof_mesh\n            else:\n                nprof = max(4, int(profile_scale*full_nprof))\n                prof_mesh = profile[0].to_poly(nprof).to_mesh()\n                ok_caps = ok_caps and (profile_scale &gt; .8)\n\n            # One profile per center\n            all_points = np.empty((nsplines, N, nprof, 3), dtype=bfloat)\n            all_points[...] = prof_mesh.points.position\n\n            # Radius\n            if use_radius:\n                all_points *= curve.points.radius.reshape(nsplines, N, 1, 1)\n\n            # Orientation along the tangent\n            t = np.linspace(0, 1, N, endpoint=not cyclic)\n            tangent = curve.tangent(t, normalize=True) # (nsplines, N, 3)\n\n            rot = Rotation.look_at((0, 0, 1), tangent, up=(0, 1, 0), normalized=True) # (nsplines, N, 3)\n\n            # Tilt\n            euler = np.zeros((npoints, 3), dtype=bfloat)\n            euler[:, 2] = curve.points.tilt\n            tilt = Rotation.from_euler(euler.reshape(nsplines, N, 3))\n            rot = rot @ tilt\n\n            # Rotation\n            all_points = rot[:, :, None] @ all_points\n\n            # Translation\n            all_points += curve.points.position.reshape(nsplines, N, 1, 3)\n\n            all_points = all_points.reshape(-1, 3)\n\n            mesh.add_points(all_points)\n\n            # Transfer trans domain attributes\n            mesh.points.transfer_attributes(curve.points, shape=(nsplines, N, nprof), other_shape=(nsplines, N, 1))\n            mesh.points.transfer_attributes(profile.points, shape=(nsplines, N, nprof), other_shape=(1, 1, nprof))\n\n            # Grid corners\n            corners = grid_corners(N, nprof, row_first=False, close_x=cyclic, close_y=prof_closed, clockwise=True).flatten()\n            ncorners = len(corners)\n            corners = np.tile(corners, nsplines) + np.repeat(np.arange(nsplines, dtype=bint)*(nprof*N), ncorners)\n\n            bbox = [0, 0, 1, .499] if ok_caps else [0, 0, 1, 1]\n            uvmap = grid_uv_map(N, nprof, close_x=cyclic, close_y=prof_closed, clockwise=False, bbox=bbox).reshape(-1, 2)\n            uvmap = np.tile(uvmap, (nsplines, 1))\n\n            mesh.add_geometry(corners=corners.flatten(), faces=4, UVMap=uvmap)\n\n            #Caps\n            if ok_caps:\n                inds = np.arange(len(all_points)).reshape(nsplines, N, nprof)\n\n                cap_inds = np.flip(inds[:, 0], axis=-1)\n                uvmap = disk_uv_map(nprof, mode='NGON', clockwise=True, bbox=[0, .5, .5, 1]).reshape(-1, 2)\n                uvmap = np.tile(uvmap, (nsplines, 1))\n                mesh.add_geometry(corners=cap_inds.flatten(), faces=nprof, UVMap=uvmap)\n\n                cap_inds = inds[:, -1]\n                uvmap = disk_uv_map(nprof, mode='NGON', clockwise=False, bbox=[.5, .5, 1, 1]).reshape(-1, 2)\n                uvmap = np.tile(uvmap, (nsplines, 1))\n                mesh.add_geometry(corners=cap_inds.flatten(), faces=nprof, UVMap=uvmap)\n\n            return mesh\n\n        # ---------------------------------------------------------------------------\n        # Add a set of splines of the same type, number of points and cyclic\n        # ---------------------------------------------------------------------------\n\n        def _cam_culling(curve, ctype, N, cyclic, resol):\n\n            if ctype == BEZIER:\n                curve = curve.to_poly()\n                N = curve.splines.loop_total[0]\n            else:\n                curve.no_view()\n\n            # No camera culling, this is simple\n            if not camera_culling:\n                return _to_mesh(curve, ctype, N, cyclic, resol)\n\n            mesh = Mesh()\n\n            # Visible points\n            vis, dist = camera.visible_points(curve.points.position, radius=profile_size)\n            vis = vis[:, camera.VISIBLE]\n\n            # Spline is visible if any point is visible\n            sel = np.any(vis.reshape(-1, N), axis=1)\n            curve = curve[sel].no_view()\n            if len(curve) == 0:\n                return mesh\n\n            # One p_size per spline\n            p_size = dist[:, camera.SIZE].reshape(-1, N)[sel][:, 0]\n\n            # On distance per spline\n            dist = dist[:, camera.DISTANCE].reshape(-1, N)[sel][:, 0]\n\n            # Curve length\n            length = curve.length\n\n            # profile_size is seen as p_size, ratio = p_size/profile_size\n            #ratio = p_size/profile_size\n            #app_length = ratio*length\n            app_length = length*camera.pixels_per_meter(dist)\n\n            # around 5 pixel per segment\n            npix = np.clip(app_length/5, 4, N).astype(int)\n\n            # We loop per npix\n            new_Ns, rev_index = np.unique(npix, return_inverse=True)\n            for i_new, new_N in enumerate(new_Ns):\n                c = curve[rev_index == i_new].no_view().to_poly(new_N)\n                mesh.join(_to_mesh(c, POLY, new_N, cyclic, resol, profile_scale=new_N/N))\n\n            # Done !!!\n            return mesh\n\n        # ---------------------------------------------------------------------------\n        # Main\n        # ---------------------------------------------------------------------------\n\n        mesh = Mesh()\n        for _, m in self.for_each_bucket(_cam_culling):\n            mesh.join(m)\n\n        return mesh    \n\n    # ====================================================================================================\n    # Primitives\n    # ====================================================================================================\n\n    @classmethod\n    def bezier_circle(cls):\n        return cls(\n            points = [[-1.,  0.,  0.], [ 0.,  1.,  0.], [ 1.,  0.,  0.], [ 0., -1.,  0.]],\n            curve_type = BEZIER, \n            cyclic = True,\n            handle_left = [[-1., -0.55212522,  0.], [-0.55212522,  1.,  0.], [ 1.,  0.55212522,  0.], [ 0.55212522, -1.,  0.]],\n            handle_right = [[-1.,  0.55212522,  0.], [ 0.55212522,  1.,  0. ],[ 1., -0.55212522,  0.], [-0.55212522, -1.,  0.]],\n        )\n\n    @classmethod\n    def circle(cls, resolution=32, radius=1.):\n        ags = np.linspace(0, 2*np.pi, resolution, endpoint=False)\n        return cls(\n            points = np.stack((radius*np.cos(ags), radius*np.sin(ags), np.zeros(resolution, float)), axis=-1),\n            curve_type = POLY, \n            cyclic = True,\n        )\n\n    @classmethod\n    def arc(cls, resolution=16, radius=1., start_angle=0., sweep_angle=7*np.pi/4, connect_center=False, invert_arc=False):\n        ag0, ag1 = (start_angle + sweep_angle - 2*np.pi, start_angle) if invert_arc else (start_angle, start_angle + sweep_angle)\n        ags = np.linspace(ag0, ag1, resolution)\n        points = np.stack((radius*np.cos(ags), radius*np.sin(ags), np.zeros(resolution, float)), axis=-1)\n        if connect_center:\n            points = np.append(points, [(0, 0, 0)], axis=0)\n\n        return cls(\n            points = points, \n            curve_type = POLY,\n            cyclic = connect_center,\n            )\n\n    @classmethod\n    def bezier_segment(cls, resolution=16, start=(-1, 0, 0), start_handle=(-.5, .5, 0), end_handle=(0, 0, 0), end=(1, 0, 0)):\n        points = np.array([start, end])\n        return cls(\n            points = points,\n            curve_type = BEZIER,\n            handle_left  = [2*points[0] - start_handle, end_handle],\n            handle_right = [start_handle, 2*points[1] - end_handle],\n        )\n\n    @classmethod\n    def line(cls, start=(0, 0, 0), end=(0, 0, 1), resolution=2):\n        resolution = max(2, resolution)\n        start = np.asarray(start)\n        end = np.asarray(end)\n        points = np.linspace(start, end, resolution)\n        if len(points.shape) == 3:\n            points = points.transpose(1, 0, 2)\n\n        return cls(\n            points = points.reshape(-1, 3),\n            splines = resolution,\n            curve_type = POLY,\n        )\n\n    @classmethod\n    def spiral(cls, resolution=32, rotations=2., start_radius=1., end_radius=2., height=2., reverse=False):\n        count = 1 + int(rotations*resolution)\n        # Reverse is strangely trigonometric!\n        ags = np.linspace(0, 2*np.pi*rotations, count) * (1 if reverse else -1)\n        rs  = np.linspace(start_radius, end_radius, count)\n        return cls(\n            points = np.stack((rs*np.cos(ags), rs*np.sin(ags), np.linspace(0, height, count)), axis=-1),\n            curve_type = POLY,\n        )\n\n    @classmethod\n    def quadratic_bezier(cls, resolution=16, start=(-1, 0, 0), middle=(0, 2, 0), end=(1, 0, 0)):\n        raise Exception(f\"Not implemented yet\")\n\n    @classmethod\n    def quadrilateral(cls, width=2., height=2.):\n        return cls(\n            points = [(-width/2, -height/2, 0), (width/2, -height/2, 0), (width/2, height/2, 0), (-width/2, height/2, 0)],\n            curve_type = POLY,\n            cyclic = True,\n        )\n\n    @classmethod\n    def star(cls, points=8, inner_radius=1, outer_radius=2, twist=0.):\n\n        points = max(3, points)\n        ag = np.linspace(0, 2*np.pi, points, endpoint=False)\n\n        vs = np.zeros((points, 2, 3), float)\n        vs[:, 0, 0] = np.cos(ag)\n        vs[:, 0, 1] = np.sin(ag)\n        vs[:, 1, :2] = inner_radius * vs[:, 0, :2]\n        vs[:, 0, :2] *= outer_radius\n\n        rot = np.pi/points + twist\n        M = np.zeros((2, 2), float)\n        M[0, 0] = np.cos(rot)\n        M[1, 1] = M[0, 0]\n        M[1, 0] = np.sin(rot)\n        M[0, 1] = -M[1, 0]\n\n        vs[:, 1, :2] = np.einsum('...ij, ...j', M[None], vs[:, 1, :2])\n\n        return cls(\n            points = np.reshape(vs, (2*points, 3)),\n            curve_type = POLY,\n            cyclic = True,\n        )\n\n    @classmethod\n    def xyfunction(cls, func, x0=0., x1=1., resolution=100, materials=None):\n        x = np.linspace(x0, x1, resolution, dtype=bfloat)\n        y = func(x)\n        return cls(points=np.stack((x, y, np.zeros_like(x)), axis=-1), materials=materials)\n</code></pre>"},{"location":"api/#npblender.Curve.__init__","title":"<code>__init__(points=None, splines=None, curve_type=POLY, materials=None, attr_from=None, **attrs)</code>","text":"<p>Curve Geometry.</p>"},{"location":"api/#npblender.Curve.__init__--arguments","title":"Arguments","text":"<pre><code>- points (array of vectors = None) : the vertices\n- splines (array of ints = None) : sizes\n- curve_type (array onf ints) : curve types\n- materials (str or list of strs = None) : list of materials used in the geometry\n- **attrs (dict) : other geometry attributes\n</code></pre> Source code in <code>npblender/curve.py</code> <pre><code>def __init__(self, points=None, splines=None, curve_type=POLY, materials=None, attr_from=None, **attrs):\n    \"\"\" Curve Geometry.\n\n    Arguments\n    ---------\n        - points (array of vectors = None) : the vertices\n        - splines (array of ints = None) : sizes\n        - curve_type (array onf ints) : curve types\n        - materials (str or list of strs = None) : list of materials used in the geometry\n        - **attrs (dict) : other geometry attributes\n    \"\"\"\n    # ----- The materials\n    if materials is None:\n        self.materials = []\n    elif isinstance(materials, str):\n        self.materials = [materials]\n    else:\n        self.materials = [mat for mat in materials]\n\n    # ----- The two domains are already built\n    # can be a view on a larger curve\n    if ( points is not None and isinstance(points, ControlPoint) and\n         splines is not None and isinstance(splines, Spline) ):\n        self.points = points\n        self.splines = splines\n        self.is_view = np.sum(self.splines.loop_total) != len(self.points)\n        return\n\n    self.is_view = False\n\n    # ----- Initialize empty domains\n\n    self.points  = ControlPoint()\n    self.splines = Spline()\n\n    self.join_attributes(attr_from)\n\n    # ----- Add geometry\n    self.add_splines(points, splines, curve_type=curve_type, **attrs)\n</code></pre>"},{"location":"api/#npblender.Curve.add_bezier","title":"<code>add_bezier(points, splines=None, handle_left=None, handle_right=None, cyclic=False, **attrs)</code>","text":"<p>Add Bezier splines</p> <p>The arguments 'splines' gives the length(s) of the bezier spline(s). If None: - the number of points is taken (one spline is added) - points.shape[1] is taken if the shape of points is (m, , 3)</p> <p>handle_left and handle_right must have the same shape as points if provided. If they aren't provided, they are computed.</p>"},{"location":"api/#npblender.Curve.add_bezier--arguments","title":"Arguments","text":"<ul> <li>points (array (n, 3) or (m, n, 3) of vectors) : the points of the curves</li> <li>splines (int or array of ints = None) : spline or splines length</li> <li>handle_left (same shape as points = None) : left handles</li> <li>handle_right (same shape as points = None) : right handles</li> <li>cyclic (bool = False) : whether the curve is cyclic or not</li> <li>attrs (dict) : spline and/or points attributes</li> </ul>"},{"location":"api/#npblender.Curve.add_bezier--returns","title":"Returns","text":"<ul> <li>dict ('points': added points indices, 'splines': added splines indices)</li> </ul> Source code in <code>npblender/curve.py</code> <pre><code>def add_bezier(self,\n               points, \n               splines = None, \n               handle_left = None, \n               handle_right = None, \n               cyclic = False,\n               **attrs):\n    \"\"\" Add Bezier splines\n\n    The arguments 'splines' gives the length(s) of the bezier spline(s). If None:\n    - the number of points is taken (one spline is added)\n    - points.shape[1] is taken if the shape of points is (m, , 3)\n\n    handle_left and handle_right must have the same shape as points if provided.\n    If they aren't provided, they are computed.\n\n    Arguments\n    ---------\n    - points (array (n, 3) or (m, n, 3) of vectors) : the points of the curves\n    - splines (int or array of ints = None) : spline or splines length\n    - handle_left (same shape as points = None) : left handles\n    - handle_right (same shape as points = None) : right handles\n    - cyclic (bool = False) : whether the curve is cyclic or not\n    - attrs (dict) : spline and/or points attributes\n\n    Returns\n    -------\n    - dict ('points': added points indices, 'splines': added splines indices)\n    \"\"\"\n    self.no_view()\n\n    if points is None:\n        return {'points': [], 'splines': []}\n\n    # ----- handle_left and handle_right shapes must match points shape\n\n    if handle_left is not None and np.shape(handle_left) != np.shape(points):\n        raise ValueError(\"add_bezier&gt; handle_left and points shapes must match.\")\n\n    if handle_right is not None and np.shape(handle_right) != np.shape(points):\n        raise ValueError(\"add_bezier&gt; handle_right and points shapes must match.\")\n\n    # ----- Make sure args are consistent\n\n    points, splines = self._check_points_splines_args(points, splines)\n    if points.shape[-1] != 3:\n        raise ValueError(\"add_bezier&gt; points must be an array of 3D vectors.\")\n\n    # ----- Dispatch attributes\n\n    disp_attrs = self._attributes_per_domain(**attrs)\n    added = {}\n\n    # ----- A stack of splines\n\n    if len(points.shape) == 3:\n\n        if handle_left is None or handle_right is None:\n            h_left, h_right = self.compute_bezier_handles(points, cyclic=disp_attrs.get('cyclic', False))\n            if handle_left is None:\n                handle_left = h_left\n            if handle_right is None:\n                handle_right = h_right\n\n        if np.shape(handle_left) != points.shape or np.shape(handle_right) != points.shape:\n            raise ValueError(\n                f\"add_bezier&gt; handle_left ({np.shape(handle_left)}) and handle_right \"\n                f\"({np.shape(handle_right)}) must have the same shape as points  ({np.shape(points)}).\")\n\n        shape = points.shape[:-1]\n        n = int(np.prod(shape))\n        p_attrs = {}\n        for name, value in disp_attrs['points'].items():\n            sh = self.points._infos[name]['shape']\n            if sh == ():\n                p_attrs[name] = np.broadcast_to(value, shape).ravel()\n            else:\n                p_attrs[name] = np.broadcast_to(value, shape + sh).reshape((n,) + sh )\n\n        added['points'] = self.points.append(\n            position = points.reshape(-1, 3),\n            handle_left = handle_left.reshape(-1, 3),\n            handle_right = handle_right.reshape(-1, 3),\n            **p_attrs,\n            #**{name: [value] for name, value in disp_attrs['points'].items()},\n            )\n\n        # Add the splines (splines argument is an int)\n        added['splines'] = self.splines.append_sizes([splines]*len(points), curve_type=BEZIER, cyclic=cyclic, **disp_attrs['splines'])\n\n    # ----- A series of splines\n\n    else:\n        cur_points = len(self.points)\n\n        offset = 0\n        h_left, h_right = None, None\n        for size, cycl in zip(splines, np.broadcast_to(cyclic, len(splines))):\n\n            pts = points[offset:offset + size]\n\n            # Compute handles\n            if handle_left is None or handle_right is None:\n                h_left, h_right = self.compute_bezier_handles(pts, cyclic=cycl)\n            hl = h_left if handle_left is None else handle_left[offset:offset + size]\n            hr = h_right if handle_right is None else handle_right[offset:offset + size]\n\n            # Append points\n            new_points = self.points.append(position=pts, handle_left=hl, handle_right=hr, **disp_attrs['points'])\n\n            # Next\n            offset += size\n\n        added['points']= np.arange(cur_points, len(self.points))\n\n        # Add the splines (splines argument is an array of ints)\n        added['splines'] = self.splines.append_sizes(splines, curve_type=BEZIER, cyclic=cyclic, **disp_attrs['splines'])\n\n    return added\n</code></pre>"},{"location":"api/#npblender.Curve.add_poly","title":"<code>add_poly(points, splines=None, curve_type=POLY, cyclic=False, w=1.0, **attrs)</code>","text":"<p>Add Poly or Nurbs splines</p> <p>The arguments 'splines' gives the length(s) of the spline(s). If None: - the number of points is taken (one spline is added) - points.shape[1] is taken if the shape of points is (m, , 3)</p> <p>Non bezeier splines use 4D points. If the provided vectors are 4D, the argument w is ignored.</p>"},{"location":"api/#npblender.Curve.add_poly--arguments","title":"Arguments","text":"<ul> <li>points (array (n, 3 or 4) or (m, n, 3 or 4) of vectors) : the points of the curves</li> <li>splines (int or array of ints = None) : spline or splines length</li> <li>cyclic (bool = False) : whether the curve is cyclic or not</li> <li>w (float) : w value, ignored if points are 4D</li> <li>attrs (dict) : spline and/or points attributes</li> </ul>"},{"location":"api/#npblender.Curve.add_poly--returns","title":"Returns","text":"<ul> <li>dict ('points': added points indices, 'splines': added splines indices)</li> </ul> Source code in <code>npblender/curve.py</code> <pre><code>def add_poly(self,\n               points, \n               splines = None,\n               curve_type = POLY,\n               cyclic = False,\n               w = 1.,\n               **attrs):\n    \"\"\" Add Poly or Nurbs splines\n\n    The arguments 'splines' gives the length(s) of the spline(s). If None:\n    - the number of points is taken (one spline is added)\n    - points.shape[1] is taken if the shape of points is (m, , 3)\n\n    Non bezeier splines use 4D points. If the provided vectors are 4D, the argument w\n    is ignored.\n\n    Arguments\n    ---------\n    - points (array (n, 3 or 4) or (m, n, 3 or 4) of vectors) : the points of the curves\n    - splines (int or array of ints = None) : spline or splines length\n    - cyclic (bool = False) : whether the curve is cyclic or not\n    - w (float) : w value, ignored if points are 4D\n    - attrs (dict) : spline and/or points attributes\n\n    Returns\n    -------\n    - dict ('points': added points indices, 'splines': added splines indices)\n    \"\"\"\n    self.no_view()\n\n    if points is None:\n        return {'points': [], 'splines': []}\n\n    # ----- Make sure args are consistent\n\n    points, splines = self._check_points_splines_args(points, splines)\n    if points.shape[-1] not in (3, 4):\n        raise ValueError(\"add_poly&gt; points must be an array of 3D or 4D vectors.\")\n\n    # ----- Dispatch attributes\n\n    disp_attrs = self._attributes_per_domain(**attrs)\n    added = {}\n\n    # ----- A stack of splines\n\n    if len(points.shape) == 3:\n\n        position = points[..., :3]\n        if points.shape[-1] == 4:\n            w = points[..., 3].ravel()\n\n        shape = points.shape[:-1]\n        n = int(np.prod(shape))\n        p_attrs = {}\n        for name, value in disp_attrs['points'].items():\n            sh = self.points._infos[name]['shape']\n            if sh == ():\n                p_attrs[name] = np.broadcast_to(value, shape).ravel()\n            else:\n                p_attrs[name] = np.broadcast_to(value, shape + sh).reshape((n,) + sh )\n\n        # Add the points\n        added['points'] = self.points.append(\n            position = position.reshape(-1, 3),\n            w = w,\n            #**{name: [value] for name, value in disp_attrs['points'].items()},\n            **p_attrs,\n            )\n\n        # Add the splines (splines argument is an int)\n        added['splines'] = self.splines.append_sizes([splines]*len(points), curve_type=curve_type, cyclic=cyclic, **disp_attrs['splines'])\n\n    # ----- A series of splines\n\n    else:\n        # Add the points\n        position = points[:, :3]\n        if points.shape[-1] == 4:\n            w = points[:, 3]\n        else:\n            w = np.broadcast_to(w, len(points))\n\n        added['points'] = self.points.append(\n            position = position,\n            w = w,\n            **disp_attrs['points'],\n        )\n\n        # Add the splines (splines argument is an array of ints)\n        added['splines'] = self.splines.append_sizes(splines, curve_type=curve_type, cyclic=cyclic, **disp_attrs['splines'])\n\n    return added    \n</code></pre>"},{"location":"api/#npblender.Curve.add_splines","title":"<code>add_splines(points=None, splines=None, curve_type=POLY, **attrs)</code>","text":"<p>Add splines</p> Source code in <code>npblender/curve.py</code> <pre><code>def add_splines(self, points=None, splines=None, curve_type=POLY, **attrs):\n    \"\"\" Add splines\n    \"\"\"\n    self.no_view()\n\n    if hasattr(curve_type, '__len__'):\n        raise ValueError(\"Curve add_splines&gt; curve_type must be a single value in (BEZIER, POLY, NURBS), not a list.\\ncurve_type: {curve_type}\")\n\n    if curve_type == BEZIER:\n        return self.add_bezier(points, splines=splines, **attrs)\n    else:\n        return self.add_poly(points, splines=splines, curve_type=curve_type, **attrs)\n</code></pre>"},{"location":"api/#npblender.Curve.blender_data","title":"<code>blender_data(readonly=False)</code>","text":"<p>Acces to Blender Curve API.</p> <p>Transfer the geometry to a temporay Blender Curve. The example below use a blender Mesh to get the normals.</p> <pre><code>curve = Curve.Spiral()\n\nwith curve.blender_data() as bcurve:\n    print(\"Number of points\", len(bcurve.splines[0].points))\n\n# &gt; Number of points 65\n</code></pre>"},{"location":"api/#npblender.Curve.blender_data--arguments","title":"Arguments","text":"<pre><code>- readonly (bool=False) : don't read back the geometry if not modified\n</code></pre>"},{"location":"api/#npblender.Curve.blender_data--returns","title":"Returns","text":"<pre><code>- Blender Mesh\n</code></pre> Source code in <code>npblender/curve.py</code> <pre><code>@contextmanager\ndef blender_data(self, readonly=False):\n    \"\"\" Acces to Blender Curve API.\n\n    Transfer the geometry to a temporay Blender Curve.\n    The example below use a blender Mesh to get the normals.\n\n    ``` python\n    curve = Curve.Spiral()\n\n    with curve.blender_data() as bcurve:\n        print(\"Number of points\", len(bcurve.splines[0].points))\n\n    # &gt; Number of points 65\n    ```\n\n    Arguments\n    ---------\n        - readonly (bool=False) : don't read back the geometry if not modified\n\n    Returns\n    -------\n        - Blender Mesh\n    \"\"\"\n    data = bpy.data.curves.get(DATA_TEMP_NAME)\n    if data is None:\n        data = bpy.data.curves.new(DATA_TEMP_NAME, type='CURVE')\n\n    self.to_curve_data(data)\n\n    yield data\n\n    # ----- Back\n\n    if not readonly:\n        self.capture(Curve.FromCurveData(data))   \n</code></pre>"},{"location":"api/#npblender.Curve.capture","title":"<code>capture(other)</code>","text":"<p>Capture the data of another Curve.</p>"},{"location":"api/#npblender.Curve.capture--arguments","title":"Arguments","text":"<pre><code>- other (Curve) : the mesh to capture\n</code></pre>"},{"location":"api/#npblender.Curve.capture--returns","title":"Returns","text":"<pre><code>- self\n</code></pre> Source code in <code>npblender/curve.py</code> <pre><code>def capture(self, other):\n    \"\"\" Capture the data of another Curve.\n\n    Arguments\n    ---------\n        - other (Curve) : the mesh to capture\n\n    Returns\n    -------\n        - self\n    \"\"\"\n\n    self.materials = other.materials\n\n    self.is_view = other.is_view\n    self.points  = other.points\n    self.splines = other.splines\n</code></pre>"},{"location":"api/#npblender.Curve.clear","title":"<code>clear()</code>","text":"<p>Clear the geometry</p> Source code in <code>npblender/curve.py</code> <pre><code>def clear(self):\n    \"\"\" Clear the geometry\n    \"\"\"\n    self.no_view()\n\n    self.points.clear()\n    self.splines.clear()\n</code></pre>"},{"location":"api/#npblender.Curve.compute_bezier_handles","title":"<code>compute_bezier_handles(points, cyclic=False, eps=1e-06)</code>  <code>staticmethod</code>","text":"<p>Compute cubic Bezier handles (left/right) from anchors using Catmull-Rom style tangents.</p>"},{"location":"api/#npblender.Curve.compute_bezier_handles--parameters","title":"Parameters","text":"<p>points : (N,3) or (B,N,3) float32/float64     OPEN storage (no duplicated first point). cyclic : bool     If True, wrap neighbors; else use one-sided differences at ends. eps : float     Small epsilon to guard against zero-length tangents.</p>"},{"location":"api/#npblender.Curve.compute_bezier_handles--returns","title":"Returns","text":"<p>left, right : same shape as <code>points</code>     left[i]  = P[i] - T[i] * (len_in[i]  / 3)     right[i] = P[i] + T[i] * (len_out[i] / 3)     with len_in = ||P[i] - P[i-1]|| and len_out = ||P[i+1] - P[i]|| (wrapped if cyclic).</p> Source code in <code>npblender/curve.py</code> <pre><code>@staticmethod\ndef compute_bezier_handles(points, cyclic=False, eps=1e-6):\n    \"\"\"\n    Compute cubic Bezier handles (left/right) from anchors using Catmull-Rom style tangents.\n\n    Parameters\n    ----------\n    points : (N,3) or (B,N,3) float32/float64\n        OPEN storage (no duplicated first point).\n    cyclic : bool\n        If True, wrap neighbors; else use one-sided differences at ends.\n    eps : float\n        Small epsilon to guard against zero-length tangents.\n\n    Returns\n    -------\n    left, right : same shape as `points`\n        left[i]  = P[i] - T[i] * (len_in[i]  / 3)\n        right[i] = P[i] + T[i] * (len_out[i] / 3)\n        with len_in = ||P[i] - P[i-1]|| and len_out = ||P[i+1] - P[i]|| (wrapped if cyclic).\n    \"\"\"\n    P = np.asarray(points)\n    single = (P.ndim == 2)\n    if single:\n        P = P[None, ...]  # (1,N,3)\n\n    B, N, C = P.shape\n    if N == 0:\n        L = np.empty_like(P)\n        R = np.empty_like(P)\n        return (L[0], R[0]) if single else (L, R)\n    if N == 1:\n        # With a single point, handles equal the point\n        L = P.copy()\n        R = P.copy()\n        return (L[0], R[0]) if single else (L, R)\n\n    # Neighbors (OPEN). Use roll for cyclic, clamp edges for non-cyclic.\n    if cyclic:\n        P_prev = np.roll(P, 1, axis=1)    # P[i-1]\n        P_next = np.roll(P, -1, axis=1)   # P[i+1]\n    else:\n        P_prev = np.concatenate([P[:, :1, :],  P[:, :-1, :]], axis=1)  # [P0, P0..P_{N-2}]\n        P_next = np.concatenate([P[:, 1:, :],  P[:, -1:, :]], axis=1)  # [P1..P_{N-1}, P_{N-1}]\n\n    # Catmull-Rom style tangent (centered diff), then normalize\n    der = 0.5 * (P_next - P_prev)                         # (B,N,3)\n    n = np.linalg.norm(der, axis=-1, keepdims=True)       # (B,N,1)\n    n = np.maximum(n, eps)\n    T = der / n                                           # unit tangents\n\n    # Segment lengths in/out\n    d_out = np.linalg.norm(P_next - P, axis=-1, keepdims=True)  # |P[i+1]-P[i]|\n    d_in  = np.linalg.norm(P - P_prev, axis=-1, keepdims=True)  # |P[i]-P[i-1]|\n\n    # Handles: linear-preserving scale (len/3)\n    L = P - T * (d_in  / 3.0)\n    R = P + T * (d_out / 3.0)\n\n    if single:\n        return L[0], R[0]\n    return L, R\n</code></pre>"},{"location":"api/#npblender.Curve.delete_points","title":"<code>delete_points(points=None, splines=None)</code>","text":"<p>Delete points.</p>"},{"location":"api/#npblender.Curve.delete_points--arguments","title":"Arguments","text":"<pre><code>points : points selection, optional\n    Points indices to delete directly.\nsplines : splines selection, optional\n    Splines owning vertices to delete.\n</code></pre> Source code in <code>npblender/curve.py</code> <pre><code>def delete_points(self, points=None, splines=None):\n    \"\"\"Delete points.\n\n    Arguments\n    ---------\n        points : points selection, optional\n            Points indices to delete directly.\n        splines : splines selection, optional\n            Splines owning vertices to delete.\n    \"\"\"\n    self.no_view()\n\n    del_points = np.zeros(len(self.points), dtype=bool)\n    if points is not None:\n        del_points[points] = True\n\n    del_splines = np.zeros(len(self.splines), dtype=bool)\n    if splines is not None:\n        del_splines[splines] = True\n\n    new_total = self.splines.loop_total\n    for i_spline, (loop_start, loop_total) in enumerate(zip(self.splines.loop_start, self.splines.loop_total)):\n\n        if del_splines[i_spline]:\n            del_points[loop_start:loop_start+loop_total] = True\n\n        else:\n            n = np.sum(del_points[loop_start:loop_start+loop_total])\n            if n == loop_total:\n                del_splines[i_spline] = True\n            else:\n                new_total[i_spline] = loop_total - n\n\n    self.points.delete(del_points)\n    self.splines.delete(del_splines)\n    self.splines.update_loop_start()\n\n    return self\n</code></pre>"},{"location":"api/#npblender.Curve.delete_splines","title":"<code>delete_splines(splines=None)</code>","text":"<p>Delete splines.</p>"},{"location":"api/#npblender.Curve.delete_splines--arguments","title":"Arguments","text":"<pre><code>splines : splines selection, optional\n    Splines owning vertices to delete.\n</code></pre> Source code in <code>npblender/curve.py</code> <pre><code>def delete_splines(self, splines=None):\n    \"\"\"Delete splines.\n\n    Arguments\n    ---------\n        splines : splines selection, optional\n            Splines owning vertices to delete.\n    \"\"\"\n    self.no_view()\n\n    return self.delete_points(splines=splines)\n</code></pre>"},{"location":"api/#npblender.Curve.for_each_bucket","title":"<code>for_each_bucket(func)</code>","text":"<p>Iterate over homogeneous spline buckets and call <code>func</code> once per bucket.</p> <p>Bucketing key: (curve_type, N, cyclic, resolution)    # resolution only relevant for BEZIER</p>"},{"location":"api/#npblender.Curve.for_each_bucket--parameters","title":"Parameters","text":"<p>func : callable     Signature:         func(curve, curve_type, loop_total, is_cyclic, resolution=None) -&gt; any     - <code>curve</code> is a Curve view on self .     - <code>curve_type</code> is the spline type.     - <code>loop_total</code> is the number of points in the spline.     - <code>is_cyclic</code> is True if the spline is cyclic.     - <code>resolution</code> is the resolution of the loop, or None if the spline is not Bezier.</p>"},{"location":"api/#npblender.Curve.for_each_bucket--yields","title":"Yields","text":"<p>(indices, result)     indices : list[int]         Spline indices for this bucket, in stacking order.     result : any         Whatever <code>func</code> returned for this bucket.</p> Source code in <code>npblender/curve.py</code> <pre><code>def for_each_bucket(self, func):\n    \"\"\"\n    Iterate over homogeneous spline buckets and call `func` once per bucket.\n\n    Bucketing key:\n    (curve_type, N, cyclic, resolution)    # resolution only relevant for BEZIER\n\n    Parameters\n    ----------\n    func : callable\n        Signature:\n            func(curve, curve_type, loop_total, is_cyclic, resolution=None) -&gt; any\n        - `curve` is a Curve view on self .\n        - `curve_type` is the spline type.\n        - `loop_total` is the number of points in the spline.\n        - `is_cyclic` is True if the spline is cyclic.\n        - `resolution` is the resolution of the loop, or None if the spline is not Bezier.\n\n    Yields\n    ------\n    (indices, result)\n        indices : list[int]\n            Spline indices for this bucket, in stacking order.\n        result : any\n            Whatever `func` returned for this bucket.\n    \"\"\"\n    spl = self.splines\n    if len(spl) == 0:\n        return\n\n    # Build buckets keyed by (type, N, cyclic, resolution_or_None)\n    buckets = {}\n    for index, (ctype, N, cyc) in enumerate(zip(spl.curve_type, spl.loop_total, spl.cyclic)):\n        if ctype == BEZIER:\n            resol = spl.resolution[index]\n            key = (ctype, N, cyc, resol)\n        else:\n            key = (ctype, N, cyc, None)\n        buckets.setdefault(key, []).append(index)\n\n    # Iterate buckets and call user function once per bucket\n    for (ctype, N, cyc, resol), idxs in buckets.items():\n        result = func(self[idxs], ctype, N, cyc, resol)\n        yield idxs, result\n</code></pre>"},{"location":"api/#npblender.Curve.from_curve","title":"<code>from_curve(other, points=None, splines=None)</code>  <code>classmethod</code>","text":"<p>Create a Curve from another curve.</p>"},{"location":"api/#npblender.Curve.from_curve--arguments","title":"Arguments","text":"<pre><code>- other (Mesh) : the mesh to copy\n- points (selector = None) : points selection\n- splines (selector = None) : splines selection\n</code></pre>"},{"location":"api/#npblender.Curve.from_curve--returns","title":"Returns","text":"<pre><code>- Curve\n</code></pre> Source code in <code>npblender/curve.py</code> <pre><code>@classmethod\ndef from_curve(cls, other, points=None, splines=None):\n    \"\"\" Create a Curve from another curve.\n\n    Arguments\n    ---------\n        - other (Mesh) : the mesh to copy\n        - points (selector = None) : points selection\n        - splines (selector = None) : splines selection\n\n    Returns\n    -------\n        - Curve\n    \"\"\"\n\n    curve = cls(materials=other.materials)\n    curve.points  = ControlPoint(other.points,  mode='COPY')\n    curve.splines = Spline(other.splines, mode='COPY')\n\n    if points is None:\n        points_mask = None\n    else:\n        points_mask = np.ones(len(curve.points), dtype=bool)\n        points_mask[points] = False\n\n    if splines is None:\n        splines_mask = None\n    else:\n        splines_mask = np.ones(len(curve.splines), dtype=bool)\n        splines_mask[splines] = False\n\n    curve.delete_points(points=points_mask, splines=splines_mask)\n\n    return curve\n</code></pre>"},{"location":"api/#npblender.Curve.from_curve_data","title":"<code>from_curve_data(data)</code>  <code>classmethod</code>","text":"<p>Initialize the geometry from a Blender Curve</p>"},{"location":"api/#npblender.Curve.from_curve_data--arguments","title":"Arguments","text":"<pre><code>- data (Blender Curve instance) : the curve to load\n</code></pre> Source code in <code>npblender/curve.py</code> <pre><code>@classmethod\ndef from_curve_data(cls, data):\n    \"\"\" Initialize the geometry from a Blender Curve\n\n    Arguments\n    ---------\n        - data (Blender Curve instance) : the curve to load\n    \"\"\"\n\n    def read_point_attr(coll, attr, dtype, shape):\n        n = len(coll)\n        a = np.empty((n,) + shape, dtype=dtype)\n        coll.foreach_get(attr, a.ravel())\n        return a\n\n    bl_splines = data.splines\n    nsplines = len(bl_splines)\n    curve = cls()\n    curve.splines.resize(nsplines)\n\n    # ----- Read the spline attributes\n\n    a = np.empty(nsplines, int)\n    for name, key in [('material_index', 'material_index'), ('resolution_u', 'resolution')]:\n        bl_splines.foreach_get(name, a)\n        setattr(curve.splines, key, a)\n\n    a = np.empty(nsplines, bool)\n    for name, key in [('use_cyclic_u', 'cyclic')]:\n        bl_splines.foreach_get(name, a)\n        setattr(curve.splines, key, a)\n\n    # ----- Read the points\n\n    for i_spline, bl_spline in enumerate(data.splines):\n\n        if bl_spline.type == 'POLY':\n            stype = 1\n        elif bl_spline.type == 'NURBS':\n            stype = 2\n        else:\n            stype = 0\n\n        curve.splines[i_spline].curve_type = stype\n\n        if stype == 0:\n            coll = bl_spline.bezier_points\n            attrs = {\n                'position'          : read_point_attr(coll, 'co',                bfloat, (3,)),\n                'handle_left'       : read_point_attr(coll, 'handle_left',       bfloat, (3,)),\n                'handle_right'      : read_point_attr(coll, 'handle_right',      bfloat, (3,)),\n                'handle_type_left'  : read_point_attr(coll, 'handle_left_type',  bint,   ()),\n                'handle_type_right' : read_point_attr(coll, 'handle_right_type', bint,   ()),\n                'radius'            : read_point_attr(coll, 'radius',            bfloat, ()),\n                'tilt'              : read_point_attr(coll, 'tilt',              bfloat, ()),\n            }\n            curve.splines[i_spline].loop_start = len(curve.points)\n            curve.splines[i_spline].loop_total = len(coll)\n            curve.points.append(**attrs)\n\n        else:\n            coll = bl_spline.points\n            points4 = read_point_attr(coll, 'co', bfloat, (4,))\n            attrs = {\n                'radius'  : read_point_attr(coll, 'radius',            bfloat, ()),\n                'tilt'    : read_point_attr(coll, 'tilt',              bfloat, ()),\n            }\n            curve.splines[i_spline].loop_start = len(curve.points)\n            curve.splines[i_spline].loop_total = len(coll)\n            curve.points.append(position=points4[:, :3], w=points4[:, 3], **attrs)\n\n    return curve\n</code></pre>"},{"location":"api/#npblender.Curve.from_object","title":"<code>from_object(obj, evaluated=False)</code>  <code>classmethod</code>","text":"<p>Create a Curve from an existing curve.</p>"},{"location":"api/#npblender.Curve.from_object--arguments","title":"Arguments","text":"<pre><code>- obj (str or Blender object) : the object to initialize from\n- evaluated (bool = False) : object modified by the modifiers if True, raw vertices otherwise\n</code></pre>"},{"location":"api/#npblender.Curve.from_object--returns","title":"Returns","text":"<pre><code>- Curve\n</code></pre> Source code in <code>npblender/curve.py</code> <pre><code>@classmethod\ndef from_object(cls, obj, evaluated=False):\n    \"\"\" Create a Curve from an existing curve.\n\n    Arguments\n    ---------\n        - obj (str or Blender object) : the object to initialize from\n        - evaluated (bool = False) : object modified by the modifiers if True, raw vertices otherwise\n\n    Returns\n    -------\n        - Curve\n    \"\"\"\n\n    if evaluated:\n        depsgraph = bpy.context.evaluated_depsgraph_get()\n        object_eval = blender.get_object(obj).evaluated_get(depsgraph)\n        return cls.from_curve_data(object_eval.data)\n\n    else:\n        return cls.from_curve_data(blender.get_object(obj).data)\n</code></pre>"},{"location":"api/#npblender.Curve.get_points_selection","title":"<code>get_points_selection()</code>","text":"<p>Get selection on points associated to the splines.</p> <p>If the Curve is not a view on splines, if return [:], otherwise it returns a selection on the points.</p>"},{"location":"api/#npblender.Curve.get_points_selection--returns","title":"Returns","text":"<pre><code>- sel (slice) : indices of splines points\n</code></pre> Source code in <code>npblender/curve.py</code> <pre><code>def get_points_selection(self):\n    \"\"\" Get selection on points associated to the splines.\n\n    If the Curve is not a view on splines, if return [:], otherwise\n    it returns a selection on the points.\n\n    Returns\n    -------\n        - sel (slice) : indices of splines points\n    \"\"\"\n    if not self.is_view:\n        return slice(None)\n\n    all_indices = np.arange(len(self.points))\n    sel = np.zeros(len(self.points), dtype=bool)\n\n    totals, rev_index = np.unique(self.splines.loop_total, return_inverse=True)\n    for index, total in enumerate(totals):\n        indices = self.splines.loop_total[rev_index == index][None, :] + np.arange(total)\n        sel[indices.flatten()] = True\n\n    return sel\n</code></pre>"},{"location":"api/#npblender.Curve.join","title":"<code>join(*others)</code>","text":"<p>Join other Curves.</p>"},{"location":"api/#npblender.Curve.join--arguments","title":"Arguments","text":"<pre><code>- others (Curve) : the curves to append\n</code></pre> Source code in <code>npblender/curve.py</code> <pre><code>def join(self, *others):\n    \"\"\" Join other Curves.\n\n    Arguments\n    ---------\n        - others (Curve) : the curves to append\n    \"\"\"\n    self.no_view()\n\n    for other in others:\n        other.no_view()\n\n        # Splines\n\n        pts_offset = len(self.points)\n        self.points.extend(other.points)\n\n        spl_offset = len(self.splines)\n        self.splines.extend(other.splines)\n        self.splines[spl_offset:].loop_start += pts_offset\n\n        # Materials\n\n        remap = np.array([self.get_material_index(mat_name) for mat_name in other.materials])\n        if len(remap):\n            self.splines.material_index[spl_offset:] = remap[other.splines.material_index]\n\n    return self\n</code></pre>"},{"location":"api/#npblender.Curve.multiply","title":"<code>multiply(count, in_place=True)</code>","text":"<p>Duplicate the geometry.</p> <p>Multiplying is a way to efficiently duplicate the geometry a great number of times. Once duplicated, the points can be reshapped to address each instance individually.</p> <pre><code>count = 16\n\ncube = Mesh.Cube() * count\n\n# Shape the points as 16 blocks of 8 vertices\npoints = np.reshape(cube.points.position, (16, 8, 3))\n\n# Place the cubes in a circle\nags = np.linspace(0, 2*np.pi, count, endpoint=False)\npoints[..., 0] += 6 * np.cos(ags)[:, None]\npoints[..., 1] += 6 * np.sin(ags)[:, None]\n\ncube.to_object(\"Cubes\")\n</code></pre>"},{"location":"api/#npblender.Curve.multiply--arguments","title":"Arguments","text":"<pre><code>- count (int=10) : number of instances\n- attributes (name=value) : value for named attributes\n</code></pre>"},{"location":"api/#npblender.Curve.multiply--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/curve.py</code> <pre><code>def multiply(self, count, in_place=True):\n    \"\"\" Duplicate the geometry.\n\n    Multiplying is a way to efficiently duplicate the geometry a great number of times.\n    Once duplicated, the points can be reshapped to address each instance individually.\n\n    ``` python\n    count = 16\n\n    cube = Mesh.Cube() * count\n\n    # Shape the points as 16 blocks of 8 vertices\n    points = np.reshape(cube.points.position, (16, 8, 3))\n\n    # Place the cubes in a circle\n    ags = np.linspace(0, 2*np.pi, count, endpoint=False)\n    points[..., 0] += 6 * np.cos(ags)[:, None]\n    points[..., 1] += 6 * np.sin(ags)[:, None]\n\n    cube.to_object(\"Cubes\")\n    ```\n\n    Arguments\n    ---------\n        - count (int=10) : number of instances\n        - attributes (name=value) : value for named attributes\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    self.no_view()\n\n    # ----------------------------------------------------------------------------------------------------\n    # Checks and simple cases\n\n    if not isinstance(count, (int, np.int32, np.int64)):\n        raise Exception(f\"A Mesh can be multiplied only by an int, not '{count}'\")\n\n    if count == 0:\n        return None\n\n    if count == 1:\n        if in_place:\n            return self\n        else:\n            return type(self).from_curve(self)\n\n    if not in_place:\n        return type(self).from_curve(self).multiply(count, in_place=True)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Points\n\n    nverts = len(self.points)\n    self.points.multiply(count)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Splines\n\n    self.splines.multiply(count)\n    self.splines.update_loop_start()\n\n    return self\n</code></pre>"},{"location":"api/#npblender.Curve.no_view","title":"<code>no_view()</code>","text":"<p>Materialize a view-curve into a standalone curve (deep copy of splines and points), preserving all point-domain fields (handles, custom attrs, ...).</p> Source code in <code>npblender/curve.py</code> <pre><code>def no_view(self):\n    \"\"\"\n    Materialize a view-curve into a standalone curve (deep copy of splines and points),\n    preserving all point-domain fields (handles, custom attrs, ...).\n    \"\"\"\n    if not self.is_view:\n        return self\n\n    import numpy as np\n\n    # 1) Copy splines domain (owning copy)\n    splines = Spline(self.splines, mode='COPY')\n\n    # 2) Build a single flat index of point rows, bucketed by loop_total (N)\n    lt = splines.loop_total\n    ls = splines.loop_start\n\n    uniq_N = np.unique(lt)\n    idx_blocks = []\n    for N in uniq_N:\n        N = int(N)\n        if N &lt;= 0:\n            continue\n        sel = (lt == N)\n        if not np.any(sel):\n            continue\n        starts = ls[sel]                                   # (B,)\n        idx = starts[:, None] + np.arange(N, dtype=np.int64)  # (B, N)\n        idx_blocks.append(idx.reshape(-1))                 # (B*N,)\n\n    if idx_blocks:\n        idx_all = np.concatenate(idx_blocks, axis=0)\n        # 3) Slice the point FieldArray to keep all fields aligned\n        points = ControlPoint(self.points, mode='COPY', selector=idx_all)  # owning copy\n    else:\n        points = ControlPoint()                       # empty\n\n    # 4) Assign back and normalize bookkeeping\n    self.points = points\n    self.splines = splines.update_loop_start()\n    self.is_view = False\n    return self\n</code></pre>"},{"location":"api/#npblender.Curve.select","title":"<code>select(indices)</code>","text":"<p>Explicit alias for subsetting splines; same semantics as curve[indices].</p> Source code in <code>npblender/curve.py</code> <pre><code>def select(self, indices):\n    \"\"\"Explicit alias for subsetting splines; same semantics as curve[indices].\"\"\"\n    return self[indices]   \n</code></pre>"},{"location":"api/#npblender.Curve.to_bezier","title":"<code>to_bezier(control_count=None, resolution=16)</code>","text":"<p>Convert splines to Bezier splines (OPEN storage).</p>"},{"location":"api/#npblender.Curve.to_bezier--parameters","title":"Parameters","text":"<p>control_count : int or None     Number of anchor points to generate per spline. If None, keep current loop_total.     For cyclic splines, anchors are sampled on [0,1) (no duplicate). For non-cyclic, on [0,1]. resolution : int     Per-segment resolution to write into <code>splines.resolution</code> (&gt;=1).</p> Source code in <code>npblender/curve.py</code> <pre><code>def to_bezier(self, control_count=None, resolution=16):\n    \"\"\"Convert splines to Bezier splines (OPEN storage).\n\n    Parameters\n    ----------\n    control_count : int or None\n        Number of anchor points to generate per spline. If None, keep current loop_total.\n        For cyclic splines, anchors are sampled on [0,1) (no duplicate). For non-cyclic, on [0,1].\n    resolution : int\n        Per-segment resolution to write into `splines.resolution` (&gt;=1).\n    \"\"\"\n    resolution = max(1, int(resolution))\n\n    attr_names = self.points.transdom_names\n    attr_names.extend(['tilt'])\n\n    def _to_bezier(curve, ctype, loop_total, is_cyclic, _resol=None):\n\n        if ctype == BEZIER and control_count is None:\n            return curve.no_view()\n\n        # Decide target anchor count N for this bucket\n        N = int(control_count) if control_count is not None else int(loop_total)\n        if N &lt;= 0:\n            # build empty bucket preserving schema\n            pts = ControlPoint()\n            spl = Spline(curve.splines)\n            spl.curve_type = BEZIER\n            spl.loop_total = 0\n            spl.resolution = resolution\n            spl.update_loop_start()\n            out = Curve(points=pts, splines=spl)\n            out.is_view = False\n            return out\n\n        # Parameter grid for anchors\n        t = np.linspace(0.0, 1.0, N, endpoint=not is_cyclic, dtype=bfloat)\n\n        # Evaluate anchors\n        P = curve.evaluate(t)                  # (S, N, 3) or (S,3) if N==1\n        if P.ndim == 2:\n            P = P[:, None, :]                  # (S,1,3) uniformize\n\n        # Compute handles from anchors (Catmull-Rom style tangents, linear-preserving scale)\n        L, R = Curve.compute_bezier_handles(P, cyclic=is_cyclic)  # (S,N,3) each\n\n        # Flatten (S,N,3) \u2192 (S*N,3)\n        P_flat = P.reshape(-1, 3)\n        L_flat = L.reshape(-1, 3)\n        R_flat = R.reshape(-1, 3)\n\n        # Sample additional point attributes at anchors\n        attrs = {}\n        for k, v in curve.sample_attributes(t, name=attr_names, cubic=(ctype == BEZIER)).items():\n            field_shape = curve.points.get_field_shape(k)  # e.g. (), (D,), (H,W), ...\n            if field_shape == ():\n                attrs[k] = v.reshape(-1)\n            else:\n                attrs[k] = v.reshape((-1,) + field_shape)\n\n        # Build new domains for this bucket\n        points = ControlPoint(position=P_flat,\n                                handle_left=L_flat,\n                                handle_right=R_flat,\n                                attr_from = self.points,\n                                **attrs)\n\n        splines = Spline(curve.splines)  # copy bucket rows\n        splines.curve_type = BEZIER\n        splines.loop_total = N\n        splines.resolution = resolution\n        splines.update_loop_start()\n\n        out = Curve(points=points, splines=splines)\n        out.is_view = False\n        return out\n\n    # Aggregate all buckets into a fresh curve (materials kept)\n    new_curve = Curve(materials=self.materials)\n    for _, c in self.for_each_bucket(_to_bezier):\n        new_curve.splines.extend(c.splines, join_fields=False)\n        new_curve.points.extend(c.points,   join_fields=False)\n\n    new_curve.splines.update_loop_start()\n    new_curve.splines.resolution = resolution\n    return new_curve\n</code></pre>"},{"location":"api/#npblender.Curve.to_curve_data","title":"<code>to_curve_data(data)</code>","text":"<p>Initialize the geometry from a Blender Curve</p>"},{"location":"api/#npblender.Curve.to_curve_data--arguments","title":"Arguments","text":"<pre><code>- data (Blender Curve instance) : the curve to load\n</code></pre> Source code in <code>npblender/curve.py</code> <pre><code>def to_curve_data(self, data):\n    \"\"\" Initialize the geometry from a Blender Curve\n\n    Arguments\n    ---------\n        - data (Blender Curve instance) : the curve to load\n    \"\"\"\n    self.no_view()\n\n    bl_splines = data.splines\n    bl_splines.clear()\n\n    for i_spline, (curve_type, loop_start, loop_total) in enumerate(zip(\n        self.splines.curve_type,\n        self.splines.loop_start,\n        self.splines.loop_total,\n    )):\n\n        if curve_type == 0:\n            bl_spline = bl_splines.new('BEZIER')\n            coll = bl_spline.bezier_points\n\n            coll.add(loop_total - len(coll))\n\n            a = self.points.position[loop_start:loop_start+loop_total]\n            coll.foreach_set('co', a.ravel())\n\n            attrs = [\n                'handle_left', \n                'handle_right', \n                ('handle_type_left', 'handle_left_type'),\n                ('handle_type_right', 'handle_right_type'),\n                'radius', \n                'tilt',\n                ]\n\n        else:\n            if curve_type == 1:\n                bl_spline = bl_splines.new('POLY')\n            else:            \n                bl_spline = bl_splines.new('NURBS')\n\n            coll = bl_spline.points\n            coll.add(loop_total - len(coll))\n\n            p4 = np.empty((loop_total, 4), dtype=bfloat)\n            p4[:, :3] = self.points.position[loop_start:loop_start+loop_total]\n            p4[:, 3] = self.points.w[loop_start:loop_start+loop_total]\n\n            coll.foreach_set('co', p4.ravel())\n\n            attrs = ['radius', 'tilt', 'weight']\n\n\n        for attr in attrs:\n\n            if isinstance(attr, str):\n                field_name = attr\n                attr_name = attr\n            else:\n                field_name = attr[0]\n                attr_name = attr[1]\n\n            a = getattr(self.points, field_name)[loop_start:loop_start+loop_total]\n            coll.foreach_set(attr_name, a.ravel())\n\n    # Spline attrixbxutes\n\n    a = self.splines.material_index\n    bl_splines.foreach_set('material_index', a)\n\n    a = self.splines.resolution\n    bl_splines.foreach_set('resolution_u', a)\n\n    a = self.splines.cyclic\n    bl_splines.foreach_set('use_cyclic_u', a)\n</code></pre>"},{"location":"api/#npblender.Curve.to_mesh","title":"<code>to_mesh(profile=None, caps=True, use_radius=True, camera_culling=False)</code>","text":"<p>Transform curve to mesh</p> <p>If profile is None, the mesh contains only edges otherwise they are ignored</p>"},{"location":"api/#npblender.Curve.to_mesh--arguments","title":"Arguments","text":"<ul> <li>profile (Curve = None) : profile curve</li> <li>caps (bool = True) : use caps</li> <li>use_radius (bool = True) : use the radius as a scale for profile</li> </ul>"},{"location":"api/#npblender.Curve.to_mesh--returns","title":"Returns","text":"<ul> <li>Mesh</li> </ul> Source code in <code>npblender/curve.py</code> <pre><code>def to_mesh(self, profile=None, caps=True, use_radius=True, camera_culling=False):\n    \"\"\" &gt; Transform curve to mesh\n\n    If profile is None, the mesh contains only edges\n    otherwise they are ignored\n\n    Arguments\n    ---------\n    - profile (Curve = None) : profile curve\n    - caps (bool = True) : use caps\n    - use_radius (bool = True) : use the radius as a scale for profile\n\n    Returns\n    -------\n    - Mesh\n    \"\"\"\n\n    from . camera import Camera\n    from . mesh import Mesh\n    from .maths.topology import grid_corners, grid_uv_map, disk_uv_map\n\n    if camera_culling != False:\n        camera = Camera(camera_culling)\n        camera_culling = True\n\n    # Circle as default profile\n    if profile is None:\n        profile_size = .001\n    else:\n        full_prof_mesh = profile[0].to_mesh()\n        full_prof_pts = full_prof_mesh.points.position\n        full_nprof = len(full_prof_pts)\n        prof_closed = profile.splines.cyclic[0]\n        profile_size = profile.max_size\n\n    # ---------------------------------------------------------------------------\n    # Add a set of splines of the same type, number of points and cyclic\n    # ---------------------------------------------------------------------------\n\n    def _to_mesh(curve, ctype, N, cyclic, resol, profile_scale=None):\n\n        if ctype == BEZIER:\n            curve = curve.to_poly()\n            N = curve.splines.loop_total[0]\n        else:\n            curve.no_view()\n\n        mesh = Mesh()\n\n        # Number of splines and points\n        nsplines = len(curve.splines)\n        npoints = len(curve.points)\n\n        # ---------------------------------------------------------------------------\n        # No profile : we simply build edges\n        # ---------------------------------------------------------------------------\n\n        if profile is None:\n\n            # Create mesh points\n            mesh.add_points(curve.points.position)\n\n            # Transfer trans domain attributes\n            mesh.points.transfer_attributes(curve.points)\n\n            # Edges\n            inds = np.arange(npoints).reshape(nsplines, N)\n            if cyclic:\n                edges = np.empty((nsplines, N, 2), dtype=bint)\n                edges[:, :-1, 0] = inds[:, :-1]\n                edges[:, :-1, 1] = inds[:, 1:]\n                edges[:, -1, 0] = inds[:, -1]\n                edges[:, -1, 1] = inds[:, 0]\n            else:\n                edges = np.empty((nsplines, N-1, 2), dtype=bint)\n                edges[..., 0] = inds[:, :-1]\n                edges[..., 1] = inds[:, 1:]\n\n            edges = edges.reshape(-1, 2)\n            mesh.edges.append(vertex0=edges[..., 0], vertex1=edges[..., 1])\n\n            return mesh\n\n        # ---------------------------------------------------------------------------\n        # We have a profile\n        # ---------------------------------------------------------------------------\n\n        ok_caps = caps and not cyclic and prof_closed\n\n        # Let's adapt to the scale\n        if profile_scale is None:\n            nprof = full_nprof\n            prof_mesh = full_prof_mesh\n        else:\n            nprof = max(4, int(profile_scale*full_nprof))\n            prof_mesh = profile[0].to_poly(nprof).to_mesh()\n            ok_caps = ok_caps and (profile_scale &gt; .8)\n\n        # One profile per center\n        all_points = np.empty((nsplines, N, nprof, 3), dtype=bfloat)\n        all_points[...] = prof_mesh.points.position\n\n        # Radius\n        if use_radius:\n            all_points *= curve.points.radius.reshape(nsplines, N, 1, 1)\n\n        # Orientation along the tangent\n        t = np.linspace(0, 1, N, endpoint=not cyclic)\n        tangent = curve.tangent(t, normalize=True) # (nsplines, N, 3)\n\n        rot = Rotation.look_at((0, 0, 1), tangent, up=(0, 1, 0), normalized=True) # (nsplines, N, 3)\n\n        # Tilt\n        euler = np.zeros((npoints, 3), dtype=bfloat)\n        euler[:, 2] = curve.points.tilt\n        tilt = Rotation.from_euler(euler.reshape(nsplines, N, 3))\n        rot = rot @ tilt\n\n        # Rotation\n        all_points = rot[:, :, None] @ all_points\n\n        # Translation\n        all_points += curve.points.position.reshape(nsplines, N, 1, 3)\n\n        all_points = all_points.reshape(-1, 3)\n\n        mesh.add_points(all_points)\n\n        # Transfer trans domain attributes\n        mesh.points.transfer_attributes(curve.points, shape=(nsplines, N, nprof), other_shape=(nsplines, N, 1))\n        mesh.points.transfer_attributes(profile.points, shape=(nsplines, N, nprof), other_shape=(1, 1, nprof))\n\n        # Grid corners\n        corners = grid_corners(N, nprof, row_first=False, close_x=cyclic, close_y=prof_closed, clockwise=True).flatten()\n        ncorners = len(corners)\n        corners = np.tile(corners, nsplines) + np.repeat(np.arange(nsplines, dtype=bint)*(nprof*N), ncorners)\n\n        bbox = [0, 0, 1, .499] if ok_caps else [0, 0, 1, 1]\n        uvmap = grid_uv_map(N, nprof, close_x=cyclic, close_y=prof_closed, clockwise=False, bbox=bbox).reshape(-1, 2)\n        uvmap = np.tile(uvmap, (nsplines, 1))\n\n        mesh.add_geometry(corners=corners.flatten(), faces=4, UVMap=uvmap)\n\n        #Caps\n        if ok_caps:\n            inds = np.arange(len(all_points)).reshape(nsplines, N, nprof)\n\n            cap_inds = np.flip(inds[:, 0], axis=-1)\n            uvmap = disk_uv_map(nprof, mode='NGON', clockwise=True, bbox=[0, .5, .5, 1]).reshape(-1, 2)\n            uvmap = np.tile(uvmap, (nsplines, 1))\n            mesh.add_geometry(corners=cap_inds.flatten(), faces=nprof, UVMap=uvmap)\n\n            cap_inds = inds[:, -1]\n            uvmap = disk_uv_map(nprof, mode='NGON', clockwise=False, bbox=[.5, .5, 1, 1]).reshape(-1, 2)\n            uvmap = np.tile(uvmap, (nsplines, 1))\n            mesh.add_geometry(corners=cap_inds.flatten(), faces=nprof, UVMap=uvmap)\n\n        return mesh\n\n    # ---------------------------------------------------------------------------\n    # Add a set of splines of the same type, number of points and cyclic\n    # ---------------------------------------------------------------------------\n\n    def _cam_culling(curve, ctype, N, cyclic, resol):\n\n        if ctype == BEZIER:\n            curve = curve.to_poly()\n            N = curve.splines.loop_total[0]\n        else:\n            curve.no_view()\n\n        # No camera culling, this is simple\n        if not camera_culling:\n            return _to_mesh(curve, ctype, N, cyclic, resol)\n\n        mesh = Mesh()\n\n        # Visible points\n        vis, dist = camera.visible_points(curve.points.position, radius=profile_size)\n        vis = vis[:, camera.VISIBLE]\n\n        # Spline is visible if any point is visible\n        sel = np.any(vis.reshape(-1, N), axis=1)\n        curve = curve[sel].no_view()\n        if len(curve) == 0:\n            return mesh\n\n        # One p_size per spline\n        p_size = dist[:, camera.SIZE].reshape(-1, N)[sel][:, 0]\n\n        # On distance per spline\n        dist = dist[:, camera.DISTANCE].reshape(-1, N)[sel][:, 0]\n\n        # Curve length\n        length = curve.length\n\n        # profile_size is seen as p_size, ratio = p_size/profile_size\n        #ratio = p_size/profile_size\n        #app_length = ratio*length\n        app_length = length*camera.pixels_per_meter(dist)\n\n        # around 5 pixel per segment\n        npix = np.clip(app_length/5, 4, N).astype(int)\n\n        # We loop per npix\n        new_Ns, rev_index = np.unique(npix, return_inverse=True)\n        for i_new, new_N in enumerate(new_Ns):\n            c = curve[rev_index == i_new].no_view().to_poly(new_N)\n            mesh.join(_to_mesh(c, POLY, new_N, cyclic, resol, profile_scale=new_N/N))\n\n        # Done !!!\n        return mesh\n\n    # ---------------------------------------------------------------------------\n    # Main\n    # ---------------------------------------------------------------------------\n\n    mesh = Mesh()\n    for _, m in self.for_each_bucket(_cam_culling):\n        mesh.join(m)\n\n    return mesh    \n</code></pre>"},{"location":"api/#npblender.Curve.to_object","title":"<code>to_object(obj, collection=None)</code>","text":"<p>Create or update a blender object.</p> <p>The method 'to_object' creates the whole geometry. It creates a new object if it doesn't already exist. If the object exists, it must be a curve, there is no object type conversion.</p> <p>Once the object is created, use the method 'update_object' to change the vertices.</p>"},{"location":"api/#npblender.Curve.to_object--arguments","title":"Arguments","text":"<pre><code>- obj (str or Blender object) : the object the create\n</code></pre>"},{"location":"api/#npblender.Curve.to_object--returns","title":"Returns","text":"<pre><code>- Blender curve object\n</code></pre> Source code in <code>npblender/curve.py</code> <pre><code>def to_object(self, obj, collection=None):\n    \"\"\" Create or update a blender object.\n\n    The method 'to_object' creates the whole geometry. It creates a new object if it doesn't already exist.\n    If the object exists, it must be a curve, there is no object type conversion.\n\n    Once the object is created, use the method 'update_object' to change the vertices.\n\n    Arguments\n    ---------\n        - obj (str or Blender object) : the object the create\n\n    Returns\n    -------\n        - Blender curve object\n    \"\"\"\n    curve = blender.create_curve_object(obj, collection=collection)\n    self.to_curve_data(curve.data)\n\n    return curve\n</code></pre>"},{"location":"api/#npblender.Curve.to_poly","title":"<code>to_poly(resolution=None)</code>","text":"<p>Convert the splines to Poly splines.</p> <p>If resolution is None: - <code>splines.resolution</code> is used to split Bezier segments - poly lines are left unchanged</p> <p>If resolution is not None, all splines are resampled using this value</p> <pre><code>resolution (int):          Poly resolution, use spline resolution for Bezier if None.\n</code></pre> Source code in <code>npblender/curve.py</code> <pre><code>def to_poly(self, resolution=None):\n    \"\"\" Convert the splines to Poly splines.\n\n    If resolution is None:\n    - `splines.resolution` is used to split Bezier segments\n    - poly lines are left unchanged\n\n    If resolution is not None, all splines are resampled using this value\n\n    Arguments:\n    ---------\n        resolution (int):          Poly resolution, use spline resolution for Bezier if None.\n    \"\"\"\n\n    if resolution is not None:\n        resolution = max(2, resolution)\n\n    attr_names = self.points.transdom_names\n    attr_names.extend(['w', 'tilt'])\n\n    def _to_poly(curve, ctype, loop_total, is_cyclic, resol=None):\n\n        if resolution is None:\n            if ctype == POLY:\n                return curve.no_view()\n\n            r = max(1, int(resol))\n\n            if is_cyclic:\n                t = np.linspace(0, 1, loop_total*r, endpoint=False, dtype=bfloat)\n            else:\n                t = np.linspace(0, 1, (loop_total - 1)*r + 1, endpoint=True, dtype=bfloat)\n        else:\n            if ctype == POLY and resolution == loop_total:\n                return curve.no_view()\n\n            t = np.linspace(0, 1, resolution, endpoint=not is_cyclic, dtype=bfloat)\n\n        pos = curve.evaluate(t).reshape(-1, 3)\n        attrs = {}\n        for k, v in curve.sample_attributes(t, names=attr_names, cubic=ctype==BEZIER).items():\n            field_shape = curve.points.get_field_shape(k)\n            if field_shape == ():\n                attrs[k] = v.flatten()\n            else:\n                attrs[k] = v.reshape((-1,) + field_shape)\n\n        points = ControlPoint(position=pos, attr_from=self.points, **attrs)\n        splines = Spline(curve.splines)\n        splines.curve_type = POLY\n        splines.loop_total = len(t)\n        splines.update_loop_start()\n\n        new_curve = Curve(points=points, splines=splines)\n        new_curve.is_view=False\n        return new_curve\n\n    new_curve = Curve(materials=self.materials)\n    for _, c in self.for_each_bucket(_to_poly):\n        new_curve.splines.extend(c.splines)\n        new_curve.points.extend(c.points)\n\n    new_curve.splines.update_loop_start()\n    return new_curve\n</code></pre>"},{"location":"api/#npblender.Edge","title":"<code>Edge</code>","text":"<p>               Bases: <code>Domain</code></p> <p>Edge domain.</p>"},{"location":"api/#npblender.Edge--attributes","title":"Attributes","text":"<pre><code>- vertex0 (int) : index of the first vertex\n- vertex1 (int) : index of the second vertex\n</code></pre> Source code in <code>npblender/domain.py</code> <pre><code>class Edge(Domain):\n    \"\"\" Edge domain.\n\n    Attributes\n    ---------\n        - vertex0 (int) : index of the first vertex\n        - vertex1 (int) : index of the second vertex\n    \"\"\"\n\n    domain_name = 'EDGE'\n\n    def declare_attributes(self):\n        self.new_int('vertex0', transfer=False, transdom=False)\n        self.new_int('vertex1', transfer=False, transdom=False)\n\n    @property\n    def vertices(self):\n        return np.stack((self.vertex0, self.vertex1), axis=-1)\n\n    @vertices.setter\n    def vertices(self, value):\n        if np.shape(value) == (2,):\n            self.vertex0 = value[0]\n            self.vertex1 = value[1]\n        else:\n            self.vertex0 = value[:, 0]\n            self.vertex1 = value[:, 1]\n\n    def check(self, count, halt=True):\n        if not len(self):\n            return True\n\n        if np.max(self.vertex0) &gt;= count or np.max(self.vertex1) &gt;= count:\n            msg = f\"Edge domain contains vertex index out of range: {np.max(self.vertex0)=}, {np.max(self.vertex0)=}, {count=}\"\n            if halt:\n                raise Exception(msg)\n            else:\n                print(msg)\n                return False\n\n        if np.any(self.vertex0 == self.vertex1):\n            msg = f\"Some edges use the same vertex ! {np.sum(self.vertex0 == self.vertex1)}\"\n            if halt:\n                raise Exception(msg)\n            else:\n                print(msg)\n                return False\n\n        return True\n\n\n    # ====================================================================================================\n    # Remove edges belonging to faces\n\n    def remove_face_edges(self, face_edges):\n\n        if not len(face_edges):\n            return\n\n        vertices = np.sort(self.vertices, axis=1)\n        face_edges = np.sort(face_edges, axis=1)\n\n        u_verts = vertices.view([('', vertices.dtype)] * 2)\n        u_faces = face_edges.view([('', face_edges.dtype)] * 2)\n\n        mask = np.isin(u_verts, u_faces).ravel()\n\n        self.delete(mask)\n\n    # ====================================================================================================\n    # Compute attribute on points\n    # ====================================================================================================\n\n    def compute_attribute_on_points(self, attr, points):\n\n        @njit(cache=True)\n        def _to_points(vertex0, vertex1, source, res):\n            npoints = res.shape[0]\n            nedges = vertex0.shape[0]\n\n            count = np.zeros(npoints, dtype=np.int32)\n            for iedge in range(nedges):\n                s = source[iedge]\n\n                ipoint = vertex0[iedge]\n                res[ipoint] += s\n                count[ipoint] += 1\n\n                ipoint = vertex1[iedge]\n                res[ipoint] += s\n                count[ipoint] += 1\n\n            trailing = 1\n            for d in range(1, res.ndim):\n                trailing *= res.shape[d]\n\n            R2 = res.reshape((npoints, trailing))\n            for ipoint in range(npoints):\n                c = count[ipoint]\n                if c &gt; 0:\n                    inv = 1.0 / c\n                    for j in range(trailing):\n                        R2[ipoint, j] *= inv\n\n            return res  \n\n        attr, item_shape = self._check_attribute_to_compute(attr)\n        res = np.zeros((len(points),) + item_shape, dtype=attr.dtype)\n        return _to_points(self.vertex0, self.vertex1, attr, res)                \n</code></pre>"},{"location":"api/#npblender.Face","title":"<code>Face</code>","text":"<p>               Bases: <code>FaceSplineDomain</code></p> Source code in <code>npblender/domain.py</code> <pre><code>class Face(FaceSplineDomain):\n\n    domain_name = 'FACE'\n\n    def declare_attributes(self):\n        super().declare_attributes()\n\n        self.new_bool('sharp_face', optional=True, transdom=False)\n\n    # ====================================================================================================\n    # Delete loops\n    # ====================================================================================================\n\n    def delete_loops(self, selection, corners):\n        corner_indices = self[selection].get_corner_indices()\n        self.delete(selection)\n        vert_indices = np.array(corners.vertex_index[corner_indices])\n        corners.delete(corner_indices)\n\n        return vert_indices\n\n    # ====================================================================================================\n    # Get edges\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Get the edges per face as start, count arrays\n    # ----------------------------------------------------------------------------------------------------\n\n    def get_face_edges(self, corners):\n        \"\"\" Return edge couples with ordered vertex indices par face.\n\n        The face edge couples can be accessed via loop_start and loop_total\n        \"\"\"\n\n        @njit(cache=True)\n        def _get_edges(loop_start, loop_total, vertex_index):\n\n            ncorners = vertex_index.shape[0]\n            edges =  np.empty((ncorners, 2), dtype=np.int32)\n\n            nfaces = loop_start.shape[0]\n            iedge = 0\n            for iface in range(nfaces):\n                start = loop_start[iface]\n                total = loop_total[iface]\n                for icorner in range(start, start + total):\n                    ipoint = vertex_index[icorner]\n                    if icorner == 0:\n                        iprec = vertex_index[start + total - 1]\n                    else:\n                        iprec = vertex_index[ipoint - 1]\n\n                    if iprec &lt; ipoint:\n                        edges[iedge, 0] = iprec\n                        edges[iedge, 1] = ipoint\n                    else:\n                        edges[iedge, 0] = ipoint\n                        edges[iedge, 1] = iprec\n                    iedge += 1\n\n            return edges\n\n        return _get_edges(self.loop_start, self.loop_total, corners.vertex_index)\n\n\n    # ----------------------------------------------------------------------------------------------------\n    # Get all the edges as ordered couples\n    # ----------------------------------------------------------------------------------------------------\n\n    def get_edges(self, corners):\n        \"\"\" Get all the edge couples of the faces.\n        \"\"\"        \n        edges = self.get_face_edges(corners)\n        return np.unique(edges, axis=0)\n\n    # ====================================================================================================\n    # Get position\n    # ====================================================================================================\n\n    def get_position(self, corners, points):\n        return points.compute_attribute_on_faces(\"position\", corners, self)\n\n    # ====================================================================================================\n    # Surfaces and normals\n    # ====================================================================================================\n\n    # ---------------------------------------------------------------------------\n    # Surface is computed by cross products of triangle. This also gives\n    # the normal to the face. The vector normal the length of which is the surface\n    # is called the \"surface vector\".\n\n    @staticmethod\n    def area_vect(vs, size, return_vector=True):\n        if size == 3:\n            sv = np.cross(\n                    vs[..., 1, :] - vs[..., 0, :],\n                    vs[..., 2, :] - vs[..., 0, :])\n\n        elif size == 4:\n            sv = (np.cross(\n                        vs[..., 1, :] - vs[..., 0, :],\n                        vs[..., 3, :] - vs[..., 0, :]\n                    ) +\n                    np.cross(\n                        vs[..., 3, :] - vs[..., 2, :],\n                        vs[..., 1, :] - vs[..., 2, :]\n                    ))\n\n        else:\n            sv = np.zeros((len(vs), 3), float)\n            for i in range(size-2):\n                sv += Face.surf_vect(vs[..., [0, i+1, i+2], :], 3)\n\n        if return_vector == 'AREA':\n            return np.linalg.norm(sv, axis=-1)/2\n\n        elif return_vector == 'NORMAL':\n            return sv / np.linalg.norm(sv, axis=-1)[:, None]\n\n        else:\n            return sv\n\n    def area_vectors(self, corners, points):\n        \"\"\" Compute the surfaces vectors\n\n        The surfaces are computed by cross products of triangles.\n        This also gives the normal to the face.\n        The normal vector normal the length of which is the surface\n        is called the *surface vector*.\n\n        Arguments\n        ---------\n            - faces (int or array of ints = None) : the faces\n\n        Returns\n        -------\n            - array of vectors of floats: The surfaces normals\n        \"\"\"\n\n        # Less efficient\n        if False and USE_JIT:\n            return area_vectors_jit(len(self), self.corners.points.position, self.corners.vertex_index, self.loop_start, self.loop_total)\n\n        # ---------------------------------------------------------------------------\n        # Compute the surface for faces of the same size\n\n        def surf_vect(vs, size):\n\n            if size == 3:\n                return np.cross(\n                        vs[...,1,:] - vs[..., 0,:],\n                        vs[...,2,:] - vs[..., 0,:])\n\n            elif size == 4:\n                return (np.cross(\n                            vs[...,1,:] - vs[..., 0, :],\n                            vs[...,3,:] - vs[..., 0, :]\n                        ) +\n                        np.cross(\n                            vs[...,3,:] - vs[..., 2, :],\n                            vs[...,1,:] - vs[..., 2, :]\n                        ))\n\n            else:\n                sv = np.zeros((len(vs), 3), float)\n                for i in range(size-2):\n                    sv += surf_vect(vs[..., [0, i+1, i+2], :], 3)\n                return sv\n\n        # ---------------------------------------------------------------------------\n        # The surfaces\n\n        area_vectors = np.zeros((len(self), 3), float)\n        for size, fcs in self.per_size().items():\n\n            f_ind = fcs['index']\n            c_ind = fcs['loop_index']\n\n            verts = points.position[corners.vertex_index[c_ind]]\n\n            area_vectors[f_ind] = surf_vect(verts, size)\n\n        return area_vectors\n\n    # ---------------------------------------------------------------------------\n    # Surfaces : norm of the perpendicular vectors\n\n    def area(self, corners, points):\n        \"\"\" Faces areas\n\n        Args:\n            verts (array (:, 3) of floats): The vertices\n\n        Returns:\n            array (len(self)) of floats: The surfaces\n        \"\"\"\n\n        return np.linalg.norm(self.area_vectors(corners, points), axis=-1)/2\n\n    # ---------------------------------------------------------------------------\n    # Normals : normalized surface vectors\n\n    def normal(self, corners, points):\n        \"\"\" Compute the normals\n\n        Args:\n            verts (array (:, 3) of floats): The vertices\n\n        Returns:\n            array (len(self), 3) of floats: The normals\n        \"\"\"\n\n        sv = self.area_vectors(corners, points)\n        return sv / np.linalg.norm(sv, axis=-1)[:, None]\n\n    # ---------------------------------------------------------------------------\n    # Centers of the faces\n\n    def position(self, corners, points):\n        \"\"\" Centers of the faces\n\n        Args:\n            verts (array (:, 3) of floats): The vertices\n\n        Returns:\n            array (len(self), 3) of floats: The centers\n        \"\"\"\n\n        centers = np.zeros((self.size, 3), float)\n        for size, fcs in self.sized_items().items():\n\n            f_ind = fcs['index']\n            c_ind = fcs['loop_index']\n\n            verts = self.corners.position[c_ind]\n\n            centers[f_ind] = np.average(verts, axis=1)\n\n        return centers\n\n    # ====================================================================================================\n    # Get surface as a dict\n\n    def get_surface(self, corners, points):\n\n        svs = self.area_vectors(corners, points)\n        assert(len(svs) == len(self))\n\n        areas2 = np.linalg.norm(svs, axis=-1)\n\n        surf  = {'normals': svs/areas2[:, None], 'areas': areas2/2}\n        surf['sizes'] = self.loop_total\n        surf['verts'] = points.position\n\n        return surf\n\n    # ====================================================================================================\n    # As a list of sequences\n\n    def sequences(self, corners):\n        inds = list(corners.vertex_index)\n        return [inds[lstart:lstart+ltotal] for (lstart, ltotal) in zip(self.loop_start, self.loop_total)]     \n\n    # ====================================================================================================\n    # Compute attribute on points\n    # ====================================================================================================\n\n    def compute_attribute_on_points(self, attr, corners, points):\n\n        @njit(cache=True)\n        def _to_points(loop_start, loop_total, vertex_index, source, res):\n            npoints = res.shape[0]\n            nfaces = loop_start.shape[0]\n\n            count = np.zeros(npoints, dtype=np.int32)\n            for iface in range(nfaces):\n                start = loop_start[iface]\n                total = loop_total[iface]\n                s = source[iface]\n                for icorner in range(start, start + total):\n                    ipoint = vertex_index[icorner]\n                    res[ipoint] += s\n                    count[ipoint] += 1\n\n            trailing = 1\n            for d in range(1, res.ndim):\n                trailing *= res.shape[d]\n\n            R2 = res.reshape((npoints, trailing))\n            for ipoint in range(npoints):\n                c = count[ipoint]\n                if c &gt; 0:\n                    inv = 1.0 / c\n                    for j in range(trailing):\n                        R2[ipoint, j] *= inv\n\n            return res  \n\n        attr, item_shape = self._check_attribute_to_compute(attr)\n        res = np.zeros((len(points),) + item_shape, dtype=attr.dtype)\n        return _to_points(self.loop_start, self.loop_total, corners.vertex_index, attr, res)                \n</code></pre>"},{"location":"api/#npblender.Face.area","title":"<code>area(corners, points)</code>","text":"<p>Faces areas</p> <p>Parameters:</p> Name Type Description Default <code>verts</code> <code>array</code> <p>, 3) of floats): The vertices</p> required <p>Returns:</p> Type Description <p>array (len(self)) of floats: The surfaces</p> Source code in <code>npblender/domain.py</code> <pre><code>def area(self, corners, points):\n    \"\"\" Faces areas\n\n    Args:\n        verts (array (:, 3) of floats): The vertices\n\n    Returns:\n        array (len(self)) of floats: The surfaces\n    \"\"\"\n\n    return np.linalg.norm(self.area_vectors(corners, points), axis=-1)/2\n</code></pre>"},{"location":"api/#npblender.Face.area_vectors","title":"<code>area_vectors(corners, points)</code>","text":"<p>Compute the surfaces vectors</p> <p>The surfaces are computed by cross products of triangles. This also gives the normal to the face. The normal vector normal the length of which is the surface is called the surface vector.</p>"},{"location":"api/#npblender.Face.area_vectors--arguments","title":"Arguments","text":"<pre><code>- faces (int or array of ints = None) : the faces\n</code></pre>"},{"location":"api/#npblender.Face.area_vectors--returns","title":"Returns","text":"<pre><code>- array of vectors of floats: The surfaces normals\n</code></pre> Source code in <code>npblender/domain.py</code> <pre><code>def area_vectors(self, corners, points):\n    \"\"\" Compute the surfaces vectors\n\n    The surfaces are computed by cross products of triangles.\n    This also gives the normal to the face.\n    The normal vector normal the length of which is the surface\n    is called the *surface vector*.\n\n    Arguments\n    ---------\n        - faces (int or array of ints = None) : the faces\n\n    Returns\n    -------\n        - array of vectors of floats: The surfaces normals\n    \"\"\"\n\n    # Less efficient\n    if False and USE_JIT:\n        return area_vectors_jit(len(self), self.corners.points.position, self.corners.vertex_index, self.loop_start, self.loop_total)\n\n    # ---------------------------------------------------------------------------\n    # Compute the surface for faces of the same size\n\n    def surf_vect(vs, size):\n\n        if size == 3:\n            return np.cross(\n                    vs[...,1,:] - vs[..., 0,:],\n                    vs[...,2,:] - vs[..., 0,:])\n\n        elif size == 4:\n            return (np.cross(\n                        vs[...,1,:] - vs[..., 0, :],\n                        vs[...,3,:] - vs[..., 0, :]\n                    ) +\n                    np.cross(\n                        vs[...,3,:] - vs[..., 2, :],\n                        vs[...,1,:] - vs[..., 2, :]\n                    ))\n\n        else:\n            sv = np.zeros((len(vs), 3), float)\n            for i in range(size-2):\n                sv += surf_vect(vs[..., [0, i+1, i+2], :], 3)\n            return sv\n\n    # ---------------------------------------------------------------------------\n    # The surfaces\n\n    area_vectors = np.zeros((len(self), 3), float)\n    for size, fcs in self.per_size().items():\n\n        f_ind = fcs['index']\n        c_ind = fcs['loop_index']\n\n        verts = points.position[corners.vertex_index[c_ind]]\n\n        area_vectors[f_ind] = surf_vect(verts, size)\n\n    return area_vectors\n</code></pre>"},{"location":"api/#npblender.Face.get_edges","title":"<code>get_edges(corners)</code>","text":"<p>Get all the edge couples of the faces.</p> Source code in <code>npblender/domain.py</code> <pre><code>def get_edges(self, corners):\n    \"\"\" Get all the edge couples of the faces.\n    \"\"\"        \n    edges = self.get_face_edges(corners)\n    return np.unique(edges, axis=0)\n</code></pre>"},{"location":"api/#npblender.Face.get_face_edges","title":"<code>get_face_edges(corners)</code>","text":"<p>Return edge couples with ordered vertex indices par face.</p> <p>The face edge couples can be accessed via loop_start and loop_total</p> Source code in <code>npblender/domain.py</code> <pre><code>def get_face_edges(self, corners):\n    \"\"\" Return edge couples with ordered vertex indices par face.\n\n    The face edge couples can be accessed via loop_start and loop_total\n    \"\"\"\n\n    @njit(cache=True)\n    def _get_edges(loop_start, loop_total, vertex_index):\n\n        ncorners = vertex_index.shape[0]\n        edges =  np.empty((ncorners, 2), dtype=np.int32)\n\n        nfaces = loop_start.shape[0]\n        iedge = 0\n        for iface in range(nfaces):\n            start = loop_start[iface]\n            total = loop_total[iface]\n            for icorner in range(start, start + total):\n                ipoint = vertex_index[icorner]\n                if icorner == 0:\n                    iprec = vertex_index[start + total - 1]\n                else:\n                    iprec = vertex_index[ipoint - 1]\n\n                if iprec &lt; ipoint:\n                    edges[iedge, 0] = iprec\n                    edges[iedge, 1] = ipoint\n                else:\n                    edges[iedge, 0] = ipoint\n                    edges[iedge, 1] = iprec\n                iedge += 1\n\n        return edges\n\n    return _get_edges(self.loop_start, self.loop_total, corners.vertex_index)\n</code></pre>"},{"location":"api/#npblender.Face.normal","title":"<code>normal(corners, points)</code>","text":"<p>Compute the normals</p> <p>Parameters:</p> Name Type Description Default <code>verts</code> <code>array</code> <p>, 3) of floats): The vertices</p> required <p>Returns:</p> Type Description <p>array (len(self), 3) of floats: The normals</p> Source code in <code>npblender/domain.py</code> <pre><code>def normal(self, corners, points):\n    \"\"\" Compute the normals\n\n    Args:\n        verts (array (:, 3) of floats): The vertices\n\n    Returns:\n        array (len(self), 3) of floats: The normals\n    \"\"\"\n\n    sv = self.area_vectors(corners, points)\n    return sv / np.linalg.norm(sv, axis=-1)[:, None]\n</code></pre>"},{"location":"api/#npblender.Face.position","title":"<code>position(corners, points)</code>","text":"<p>Centers of the faces</p> <p>Parameters:</p> Name Type Description Default <code>verts</code> <code>array</code> <p>, 3) of floats): The vertices</p> required <p>Returns:</p> Type Description <p>array (len(self), 3) of floats: The centers</p> Source code in <code>npblender/domain.py</code> <pre><code>def position(self, corners, points):\n    \"\"\" Centers of the faces\n\n    Args:\n        verts (array (:, 3) of floats): The vertices\n\n    Returns:\n        array (len(self), 3) of floats: The centers\n    \"\"\"\n\n    centers = np.zeros((self.size, 3), float)\n    for size, fcs in self.sized_items().items():\n\n        f_ind = fcs['index']\n        c_ind = fcs['loop_index']\n\n        verts = self.corners.position[c_ind]\n\n        centers[f_ind] = np.average(verts, axis=1)\n\n    return centers\n</code></pre>"},{"location":"api/#npblender.FieldArray","title":"<code>FieldArray</code>","text":"<p>               Bases: <code>object</code></p> <p>Dynamic structured array</p> <p>A structured array with cache management to optimize record appending.</p> Source code in <code>npblender/fieldarray.py</code> <pre><code>class FieldArray(object):\n\n    \"\"\" Dynamic structured array\n\n    A structured array with cache management to optimize record appending.\n    \"\"\"\n\n    __slots__ = ('_data', '_length', '_infos')\n\n    # Used by __setattr__\n    # Be sure to update this class property in child classes\n    # _slots = FieldArray._slots + (x, y, ...)\n    _slots = ('_data', '_length', '_infos')\n\n    # ====================================================================================================\n    # Initialization\n    # ====================================================================================================\n\n    def __init__(self, a=None, mode='COPY', selector=None):\n        \"\"\" Initialize the array with another array\n\n        Arguments\n        ---------\n        - a (array or FieldArray) : the array to initialize from\n        - mode (str in 'COPY', 'CAPTURE', 'EMPTY') : copy the content\n        - selector (Any = None) : a selector on data \n        \"\"\"\n\n        object.__setattr__(self, '_infos',  {})\n        object.__setattr__(self, '_length', 0)\n        object.__setattr__(self, '_data',   None)\n\n        if a is not None:\n\n            # Make sure it is an array\n            data = np.asarray(a)\n\n            # If we have a selector, we apply it in case names would be removed\n            if selector is not None:\n                try:\n                    data = data[selector]\n                except Exception as e:\n                    raise ValueError(f\"{type(self).__name__} init&gt; invalid selector({type(selector)}), {str(e)}\")\n\n                if isinstance(data, np.void):\n                    data = np.reshape(data, 1)\n\n            # Make sure we have names\n            if data.dtype.names is None:\n                raise ValueError(f\"{type(self).__name__} init&gt; input must be a structured array (selector={selector})\")\n\n            # Mode\n            if mode == 'COPY':\n                self._data = data.copy()\n            elif mode == 'CAPTURE':\n                self._data = data\n            elif mode == 'EMPTY':\n                self._data = np.zeros(0, dtype=data.dtype)\n            else:\n                raise ValueError(f\"{type(self).__name__} init&gt; mode must be in ('COPY', 'CAPTURE', 'EMPTY'), not '{mode}'\")\n\n            # Data can be a scalar with shape ()\n            if data.shape == ():\n                self._length = 1\n            else:\n                self._length = len(self._data)\n\n            # Build infos\n            if isinstance(a, FieldArray):\n                self._infos = {name: {**info} for name, info in a._infos.items()}\n\n            else:\n                self._infos = {}\n                for name in data.dtype.names:\n                    shape = data[name].shape\n                    if shape is not None:\n                        shape = shape[1:]\n                    self._infos[name] = {'dtype': data[name].dtype, 'shape': shape, 'default': 0, 'optional': False}\n\n\n    # ====================================================================================================\n    # Clone with another array\n    # ====================================================================================================\n\n    def clone(self, data):\n        fa = type(self)()\n        fa._data = data\n        fa._length = self._length\n        fa._infos = dict(self._infos)\n        return fa\n\n    # ====================================================================================================\n    # Shape management\n    # ====================================================================================================\n\n    @property\n    def is_shaped(self):\n        return len(self._data.shape) &gt; 1\n\n    def _check_no_shape(self, label=\"Operation\"):\n        if self.is_shaped:\n            raise Exception(f\"{label} can not be applied to a shaped array {self.shape}.\")\n        return True\n\n    @property\n    def shape(self):\n        if self.is_shaped:\n            return self._data.shape\n        elif self._data.shape == ():\n            return ()\n        else:\n            return (self._length,)\n\n    def no_scalar(self):\n        if self._data.shape == ():\n            self._data = np.reshape(self._data, (1,))\n        return self\n\n    @property\n    def is_scalar(self):\n        return self._data.shape == ()\n\n    @property\n    def _data_view(self):\n        if self._data is None:\n            return None\n        elif self.is_shaped or self._data.shape == ():\n            return self._data\n        else:\n            return self._data[:self._length]\n\n    # ====================================================================================================\n    # Utilities\n    # ====================================================================================================\n\n    def __len__(self):\n        if self._data is None:\n            raise ValueError(f\"{type(self).__name__} &gt; data is None.\")\n\n        if self._data.shape == ():\n            raise ValueError(f\"{type(self).__name__} &gt; data is scalar.\")\n\n        return len(self._data_view)\n\n    def __iter__(self):\n        if self.is_scalar:\n            raise Exception(f\"Impossible to iterate on a scalar array.\")\n        return (self[index] for index in range(len(self)))\n\n    def __contains__(self, item):\n        return item in self._data_view\n\n    def __array__(self, dtype=None):\n        \"\"\"Allow implicit conversion to np.ndarray\"\"\"\n        arr = self._data_view    \n        return arr.astype(dtype) if dtype else arr\n\n    def __str__(self):\n        if self._data is None:\n            return f\"&lt;{type(self).__name__} None&gt;\"\n\n        if self.is_shaped:\n            sh_str = f\"shape {self._data.shape}\"\n        else:\n            sh_str = \"scalar\" if self.is_scalar else len(self)\n        return f\"&lt;{type(self).__name__}: names: {self.all_names}, len: {sh_str} &gt;\"\n\n    def __repr__(self):\n        if self._data is None:\n            return \"&lt;{type(self).__name__}: empty&gt;\"\n\n        # Compute max length of original field names for alignment\n        max_len = max((len(name) for name in self._infos), default=0)\n\n        lines = [f\"&lt;{type(self).__name__}: len={self._length}, fields=[\"]\n        for name, info in self._infos.items():\n            dtype, shape = info['dtype'], info['shape']\n            type_str = FieldArray._dtype_name(dtype)\n\n            # Shape display\n            if shape:\n                type_str += f\"[{', '.join(map(str, shape))}]\"\n\n            # Extra info (e.g., default value)\n            default = info.get('default', None)\n            default_str = f\", default={default}\" if default is not None else \"\"\n\n            opt = info.get('optional', False)\n            opt_str = f\"O \" if opt else \"  \"\n\n            lines.append(f\"  '{name:&lt;{max_len}}' {opt_str}: {type_str}{default_str}\")\n\n        lines.append(\"]&gt;\")\n        return \"\\n\".join(lines)\n\n    # ====================================================================================================\n    # Fields\n    # ====================================================================================================\n\n    @staticmethod\n    def _dtype_name(dtype):\n        try:\n            dtype = np.dtype(dtype)\n            return dtype.name  # 'float32', 'int64', etc.\n        except TypeError:\n            return getattr(dtype, '__name__', str(dtype))\n\n    @staticmethod\n    def _normalize_shape(shape):\n        if shape is None:\n            return ()\n        if isinstance(shape, int):\n            return (shape,)\n        if isinstance(shape, (list, tuple)):\n            return tuple(int(d) for d in shape)\n        raise TypeError(f\"Shape must be int, tuple, list or None, got {type(shape)}\")\n\n    @property\n    def dtype(self):\n        \"\"\" Array structured dtype\n\n        Returns the dtype property of the structured array.\n        \"\"\"\n        if self._data is None:\n            return None\n        else:\n            return self._data.dtype\n\n    @property\n    def all_names(self):\n        \"\"\" Column names.\n\n        Returns all the field names, including optional ones.\n        \"\"\"\n        return list(self._infos.keys())\n\n    @property\n    def actual_names(self):\n        \"\"\" Column names.\n\n        Returns the actual field names, excluding optional fields.\n        \"\"\"\n        if self._data is None:\n            return []\n        else:\n            return self._data.dtype.names\n        #return s[name for name, infos in self._infos.items() if not infos.get('optional', False)]\n\n    def field_exists(self, name):\n        return name in self.all_names\n\n    def get_field_shape(self, name):\n        if name in self.all_names:\n            return self._infos[name]['shape']\n        else:\n            raise KeyError(f\"Attribute name '{name}' not found in {self}\")\n\n    def get_field_size(self, name):\n        return int(np.prod(self.get_field_shape(name)))\n\n    # ====================================================================================================\n    # Buffer management\n    # ====================================================================================================\n\n    def set_buffer_size(self, size):\n        if self._data.size &gt;= size:\n            return\n\n        new_data = np.empty(size, self._data.dtype)\n        if self._length:\n            new_data[:self._length] = self._data[:self._length].reshape(-1)\n        self._data = new_data\n\n    def _data_check(self, new_length):\n        size = self._data.size\n        if new_length &gt; size:\n            self.set_buffer_size(size=int(1.5*new_length))\n\n    def clear(self):\n        self._length = 0\n        self._data = self._data.reshape(-1)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Resize\n    # ----------------------------------------------------------------------------------------------------\n\n    def resize(self, shape):\n\n        if isinstance(shape, (int, np.int32, np.int64)):\n            shape = (shape,)\n        length = int(np.prod(shape))\n\n        if self.is_shaped:\n            self._data = self._data.reshape(-1)\n\n        self._data_check(length)\n        if length &gt; self._length:\n\n            # Fill with default is current length is null\n            if self._length == 0:\n                for name, info in self._infos.items():\n                    if not info.get('optional', False):\n                        self._data[name][self._length:length] = info.get('default', 0)\n\n            # Duplicate current content\n            else:\n                reps = (length - 1) // self._length\n                assert((reps+1)*self._length &gt;= length)\n                self._data[self._length:length] = np.tile(self._data[:self._length], reps)[:length - self._length]\n\n        self._length = length\n\n        if len(shape) &gt; 1:\n            self.reshape(shape)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Reshape\n    # ----------------------------------------------------------------------------------------------------\n\n    def reshape(self, *shape):\n\n        if len(shape) == 1 and isinstance(shape[0], (tuple, list)):\n            shape = tuple(shape[0])\n\n        if shape.count(-1) &gt; 1:\n            raise ValueError(f\"A shape can contain only one -1, not {shape}\")\n\n        known_size = 1\n        for s in shape:\n            if not isinstance(s, (int, np.int32, np.int64)):\n                raise TypeError(f\"All shape dimensions must be int, not {s} in {shape}\")\n            if s &lt; -1 or s == 0:\n                raise ValueError(\"Shape dimensions must be -1 or &gt; 0, not {s} in {shape}\")\n            if s != -1:\n                known_size *= s\n\n        ok = True\n        if -1 in shape:\n            ok = self._length % known_size == 0\n        else:\n            ok = self._length == known_size\n\n        if not ok:\n            raise ValueError(f\"Impossible to reshape array of length {self._length} to shape {shape}.\")\n\n        if len(shape) &gt; 1:\n            self._data = self._data[:self._length].reshape(shape)\n        else:\n            self._data = self._data.reshape(-1)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Ravel and flatten\n    # ----------------------------------------------------------------------------------------------------\n\n    def ravel(self):\n        if self.is_shaped:\n            return self.clone(self._data.ravel())\n        else:\n            return self\n\n    def flatten(self):\n        if self.is_shaped:\n            return self.clone(self._data.flatten())\n        else:\n            return self\n\n    # ====================================================================================================\n    # Items\n    # ====================================================================================================\n\n    def get(self, name, default=None):\n        \"\"\" Get attribute by name.\n\n        If name is not an actual field, return default value.\n        Name can be an array.\n        ``` python\n        pos = field_array.get(\"position\", (0, 0, 1))\n        pos = field_array.get([[0, 0, 1], [0, 0, 0]])\n        ```\n        \"\"\"\n        if isinstance(name, str):\n            if name in self._data.dtype.names:\n                return self[name]\n            else:\n                if default is None:\n                    return None\n                else:\n                    return np.asarray(default)\n        else:\n            if name is None:\n                return None\n            else:\n                return np.asarray(name)\n\n    def __getitem__(self, index):\n\n        # ---------------------------------------------------------------------------\n        # Index is a string, we return the array of the full content\n        # ---------------------------------------------------------------------------\n\n        if isinstance(index, str):\n            self._ensure_optional_field(index)\n            if self._data.shape == ():\n                return self._data[index]\n            else:\n                return self._data_view[index]\n\n        # ---------------------------------------------------------------------------\n        # Otherwise we return a FieldArray on the selection\n        # ---------------------------------------------------------------------------\n\n        else:\n            arr = self._data_view[index]\n            return type(self)(arr, mode='CAPTURE')\n\n    def __setitem__(self, index, value):\n\n        self._ensure_optional_field(index)\n        self._data_view[index] =np.asarray(value)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Names as attributes\n    # ----------------------------------------------------------------------------------------------------\n\n    def __getattr__(self, name):\n\n        if name in self._infos:\n            self._ensure_optional_field(name)\n\n            # Should never happen, but just in case...\n            if name not in self._data.dtype.names or name not in self._data_view.dtype.names:\n                raise AttributeError(\n                    f\"{type(self).__name__}&gt; impossible to create the field '{name}'.\"\n                    f\"\\n_infos: {[(n, info['optional']) for n, info in self._infos.items()]}\"\n                    f\"\\n_data: {self._data.dtype.names}\"\n                    f\"\\n_data_view: {self._data_view.dtype.names}\"\n                    )\n\n            return self._data_view[name]\n\n        raise AttributeError(f\"{type(self).__name__}&gt; no field named '{name}'\")\n\n    def __setattr__(self, name, value):\n\n        if name in self._slots or name in dir(self):\n            super().__setattr__(name, value)\n\n        elif name in self._infos:\n\n            self._ensure_optional_field(name)\n\n            if self.is_scalar:\n                self._data[name] = value\n            else:\n                self._data_view[name][:] = value\n\n        else:\n            raise AttributeError(\n                f\"{type(self).__name__}&gt; no field named '{name}'. Valid names are {self.all_names}.\\n\"\n                f\"Note that you can't use 'field_array[selection].{name} = ...' when optional field is not created yet.\"\n                )\n\n    # ----------------------------------------------------------------------------------------------------\n    # Sub\u2011selection\n    # ----------------------------------------------------------------------------------------------------\n\n    def filtered(self, selector, *, copy=False):\n        \"\"\"\n        Return a FieldArray containing only the selected records.\n\n        Parameters\n        ----------\n        selector : array\u2011like, slice or int\n            Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice.\n            It is applied to the current valid part of the buffer\n            (``self._data[:self._length]``).\n\n        copy : bool, optional\n            - False    (default) =&gt; the new array shares the same memory\n                                     (changes propagate both ways).\n            - True           =&gt; the data are physically copied.\n\n        Returns\n        -------\n        FieldArray\n            A new instance holding exactly ``len(selector)`` records and\n            inheriting the current field\u2011infos.\n        \"\"\"\n        if selector is None:\n            return self\n\n        if self._data is None or self._length == 0:\n            # Nothing to select \u2013 return an empty compatible array\n            return type(self)(self, copy='EMPTY')\n\n        # Apply the selector on the valid slice\n        #selected = self._data[:self._length][selector]\n\n        # Choose copy mode\n        mode = 'COPY' if copy else 'CAPTURE'\n\n        # Build the new instance\n        data = self._data_view[selector]\n\n        fa = type(self)(self, copy='EMPTY')\n        if copy:\n            fa._data = np.array(data)\n        else:\n            fa._data = data\n        return fa\n\n        return type(self)(self, mode=mode, selector=selector)\n\n    # ====================================================================================================\n    # Create fields\n    # ====================================================================================================\n\n    def check_fields(self, label=\"check\"):\n        msg = None\n        for name, info in self._infos.items():\n            if info['optional']:\n                if name in self._data.dtype.names:\n                    msg = f\"Attribute '{name}' is optional but exists in _data.\" \n                break\n\n            if name not in self._data.dtype.names:\n                msg = f\"Attribute '{name}' doesn't exist in _data.\"\n                break\n\n            if name not in self._data_view.dtype.names:\n                msg = f\"Attribute '{name}' doesn't exist in _data_view.\"\n                break\n\n        if msg is None:\n            print(f\"FieldArray fields checking ok ({label})\")\n            return True\n\n        raise Exception(f\"Error in FieldArray fields checking ({label}) : {msg}\")\n\n    def is_reserved_name(self, name):\n        return name in self._slots or hasattr(type(self), name)\n\n    def has_field(self, name: str) -&gt; bool:\n        return name in self._infos\n\n    # ----------------------------------------------------------------------------------------------------    \n    # Create a new field in _data\n    # ----------------------------------------------------------------------------------------------------\n\n    def _create_field_in_data(self, name):\n        \"\"\" Add actueally a field to the structured array.\n\n        The name argument must be a valid key in _infos\n\n        Arguments\n        ---------\n            - name (str) : field name\n        \"\"\"\n        infos = self._infos.get(name)\n        if infos is None:\n            raise ValueError(f\"new_field &gt; '{name}' is not in _infos.\")\n\n        # Field dtype\n        dtype, shape, default = infos['dtype'], infos['shape'], infos['default']\n        field_type = [(name, dtype) if shape is None else (name, dtype, shape)]\n\n        # Array new dtype\n        if self.dtype is None:\n            new_dtype = field_type\n        else:\n            new_dtype = self.dtype.descr + field_type\n\n        # New data\n        length = 10 if self._data is None else len(self._data)\n\n        new_data = np.zeros(length, new_dtype)\n        if self._length &gt; 0:\n            try:\n                new_data[name][:self._length] = default\n            except:\n                raise ValueError(f\"new_field &gt; impossible to set default value {default} to field '{name}'\")\n\n        # Copy existing data in new_data\n        if self._data is not None:\n            for fname in self._data.dtype.names:\n                new_data[fname] = self._data[fname]\n            del self._data\n\n        # Switch\n        self._data = new_data\n\n        # Update optional\n        self._infos[name]['optional'] = False\n\n    # ----------------------------------------------------------------------------------------------------    \n    # Declare a new field and create it if not optional\n    # ----------------------------------------------------------------------------------------------------\n\n    def new_field(self, name, dtype, shape=None, default=0, optional=False, **infos):\n        \"\"\" Add a field to the structured array.\n\n        Arguments\n        ---------\n            - name (str) : field name\n            - dtype (type) : a valid numpy dtype\n            - shape (tuple = None) : the shape of the field\n            - default (any = 0) : default value\n            - optional (bool = False) : the field is created only when accessed\n            - infos (dict) : field infos\n        \"\"\"\n        # Reserved name\n        if self.is_reserved_name(name):\n            raise ValueError(f\"new_field &gt; '{name}' is a reserved name.\")\n\n        # Already exists\n        if name in self._infos:\n            if (dtype != self._infos[name]['dtype'] or\n                shape != self._infos[name]['shape']):\n                raise ValueError(f\"new_field &gt; '{name}' is already defined.\")\n            return\n\n        # Declare in infos\n        self._infos[name] = {\n            'dtype'    : dtype,\n            'shape'    : FieldArray._normalize_shape(shape),\n            'default'  : default,\n            'optional' : optional,\n            **infos,\n            }\n\n        # Create if not optional\n        if not optional:\n            self._create_field_in_data(name)\n\n    # ----------------------------------------------------------------------------------------------------    \n    # Dynamically create optional field\n    # ----------------------------------------------------------------------------------------------------\n\n    def _ensure_optional_field(self, index):\n        if not isinstance(index, str):\n            return\n\n        if index not in self._infos:\n            raise IndexError(f\"FieldArray has no field named {index}\")\n\n        if self._infos[index]['optional']:\n            self._create_field_in_data(index)\n        else:\n            if index not in self._data.dtype.names:\n                raise IndexError(\n                    f\"Field '{index}' is not in _data. \"\n                    \"make sure not to create an optional field in a selection, or a ravel() view.\"\n                    )\n\n    # ----------------------------------------------------------------------------------------------------    \n    # Copy an existing field\n    # ----------------------------------------------------------------------------------------------------    \n\n    def copy_field(self, field_name: str, new_name: str, **infos):\n        \"\"\"\n        Duplicate an existing field under a new name, with optional metadata overrides.\n\n        Parameters\n        ----------\n        field_name : str\n            The name of the existing field to copy.\n\n        new_name : str\n            The name of the new field to create.\n\n        infos : keyword arguments\n            Optional metadata (e.g. default, unit, description...) to override\n            or supplement the original field's metadata.\n\n        Raises\n        ------\n        KeyError\n            If the source field does not exist.\n\n        ValueError\n            If the target name already exists or is reserved.\n        \"\"\"\n        # --- Validation -----------------------------------------------------\n        if field_name not in self.all_names:\n            raise KeyError(f\"copy_field &gt; unknown field '{field_name}'\")\n\n        if new_name in self.all_names:\n            raise ValueError(f\"copy_field &gt; '{new_name}' already exists\")\n\n        if self.is_reserved_name(new_name):\n            raise ValueError(f\"copy_field &gt; '{new_name}' is a reserved name\")\n\n        # --- Duplicate infos and create -------------------------------------\n        self._infos[new_name] = {**self._infos[field_name]}\n\n        if not self._infos[new_name]['optional']:\n            self._create_field_in_data(new_name)\n\n    # ----------------------------------------------------------------------------------------------------    \n    # Join fields from another FielArray\n    # ----------------------------------------------------------------------------------------------------    \n\n    def join_fields(self, other, exclude=[]):\n        \"\"\"\n        Add all missing fields from another FieldArray.\n\n        For every field in `other` that is not present in `self`, a new field is created\n        with the same dtype and shape, and initialized with its default value across all existing records.\n\n        Parameters\n        ----------\n        other : FieldArray\n            Another FieldArray instance whose fields will be checked for missing fields.\n\n        Returns\n        -------\n        self        \n        \"\"\"\n        if isinstance(other, FieldArray):\n            for name in other._infos:\n                if name in self._infos or name in exclude:\n                    continue\n\n                self._infos[name] = {**other._infos[name]}\n                if not self._infos[name]['optional']:\n                    self._create_field_in_data(name)\n\n        else:\n            for name in other.dtype.names:\n                if name in self._infos or name in exclude:\n                    continue\n\n                self.new_field(name, dtype=other[name].dtype, shape=other[name].shape)\n\n        return self\n\n    # ====================================================================================================\n    # add &amp; append\n    # ====================================================================================================\n\n    def add(self, count, **fields):\n        \"\"\" Add count records\n\n        New records are set with default values or values provided by the user in fields dict.\n\n        Parameters\n        ----------\n        count : int\n            Number of records to add.\n        fields : dict\n            Keyword arguments mapping field names to values.\n\n        \"\"\"\n        if count &lt;= 0:\n            return\n\n        self._check_no_shape(\"Add records\")\n\n        old_length = self._length\n        self.resize(self._length + count)\n        sl = slice(old_length, self._length)\n\n        for name, value in fields.items():\n            if name in self._infos:\n                self._ensure_optional_field(name)\n                self._data[name][sl] = value\n            else:\n                raise KeyError(f\"Attribute name '{name}' not found in {list(self._infos.keys())}\")\n\n        for name in self._data.dtype.names:\n            if name in fields:\n                continue\n            self._data[name][sl] = self._infos[name].get('default', 0)\n\n    def append(self, **fields):\n        \"\"\"\n        Append values to the structured array.\n\n        The number of records to append is determined by the number of fields provided in the fields\n        dictionary. The values of the fields are copied to the new records.\n\n        Parameters\n        ----------\n        fields : dict\n            Keyword arguments mapping field names to values.\n        \"\"\"\n        self._check_no_shape(\"Append\")\n\n        # Determine the number of items to append\n        count  = 0\n        arrays = {}\n        for name, value in fields.items():\n            if value is None:\n                continue\n\n            if name not in self._infos:\n                raise ValueError(f\"{type(self).__name__}.append &gt; Invalid field name: '{name}' not in {list(self._infos.keys())}\")\n\n            self._ensure_optional_field(name)\n\n            a = np.asarray(value)\n\n            # Argument is a scalar: can be broadcasted to whatever field\n            if np.shape(a) == ():\n                n = 1\n\n            # Argument is not scalar\n            else:\n                # Target item shape\n                shape = self._data.dtype[name].shape\n\n                # The argument is a single item value\n                if shape == a.shape:\n                    n = 1\n\n                # The target shape is a scalar\n                # The argument must be (n,)\n                elif shape == ():\n                    if len(a.shape) != 1:\n                        raise ValueError(f\"{type(self).__name__}.append &gt; Invalid shape for scalar field '{name}': {np.shape(a)} is not a 1D array\")\n                    n = len(a)\n\n                # The target shape is not a scalar\n                # The argument must be (n,) + shape\n                elif len(a.shape) != len(shape) + 1:\n                    raise ValueError(f\"{type(self).__name__}.append &gt; Invalid shape for field '{name}': {np.shape(a)} is not {str((-1,) + shape).replace('-1', 'n')}\") \n\n                # The target shape is a scalar\n                # The argument shape is (n,) + shape\n                else:\n                    n = len(a)\n\n            arrays[name] = a\n            if n &gt; count:\n                count = n\n\n        if count == 0:\n            return []\n\n        # Ensure the internal buffer is large enough\n        new_length = self._length + count\n        self._data_check(new_length)\n\n        # Assign values to the provided fields\n        for name, a in arrays.items():\n            self._data[name][self._length:new_length] = a\n\n        # Fill missing fields with default value\n        for name in self._data.dtype.names:\n            if name not in arrays:\n                self._data[name][self._length:new_length] = self._infos[name].get('default', 0)      \n\n        # To be returned\n        new_indices = np.arange(self._length, new_length)\n\n        # Update current length\n        self._length = new_length\n\n        # Return the indices of records appended\n        return new_indices\n\n    # ====================================================================================================\n    # Extend\n    # ====================================================================================================\n\n    def extend(self, other, join_fields=True):\n        \"\"\"\n        Append multiple records from another array or FieldArray.\n\n        Parameters\n        ----------\n        other : FieldArray or structured np.ndarray\n            The array of records to append. Must have named fields matching\n            a subset of the current array's fields.\n        \"\"\"\n        self._check_no_shape(\"Extend\")\n\n        if other is None:\n            return\n\n        # Accept both FieldArray and structured np.ndarray\n        data = np.asarray(other)\n\n        count = len(data)\n        if count == 0:\n            return\n\n        # No names\n        if data.dtype.names is None:\n            raise ValueError(f\"{type(self).__name__}.extend&gt; input must have named fields\")\n\n        # Join fields if required\n        if join_fields:\n            self.join_fields(other)\n\n        # Ensure all fields in 'data' are valid for this array\n        invalid = [name for name in data.dtype.names if name not in self.all_names]\n        if invalid:\n            raise ValueError(f\"extend &gt; input contains unknown field(s): {invalid}\")\n\n        # Resize buffer\n        new_length = self._length + count\n        self._data_check(new_length)\n\n        # Copy data field by field\n        for name in data.dtype.names:\n            self._ensure_optional_field(name)\n            self._data[name][self._length:new_length] = data[name]\n\n        # Fill missing fields with default value\n        for name in self.actual_names:\n            if name not in data.dtype.names:\n                self._data[name][self._length:new_length] = self._infos[name].get('default', 0)\n\n        self._length = new_length\n\n    # ====================================================================================================\n    # Multiply\n    # ====================================================================================================\n\n    def multiply(self, count: int):\n        \"\"\"\n        Duplicate the current records `count` times.\n\n        Parameters\n        ----------\n        count : int\n            Number of times to repeat the current records.\n\n        Notes\n        -----\n        This duplicates the current valid records (up to self._length).\n        If the array is empty or count &lt;= 1, nothing happens.\n\n        Example:\n        --------\n        If the array has 3 records and count == 4, the result will be:\n\n        [rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]\n        \"\"\"\n        if count &lt;= 1 or self._length == 0:\n            return\n\n        shape = self.shape\n\n        self.resize(count*self._length)\n\n        if len(shape) &gt; 1:\n            self.reshape((count,) + shape)\n\n        return self\n\n    # ====================================================================================================\n    # Delete items\n    # ====================================================================================================\n\n    def delete(self, index):\n        \"\"\"\n        Delete a selection of items from the array.\n\n        Parameters\n        ----------\n        index : int, slice, or array-like\n            The indices of the elements to delete from the current data.\n\n        Notes\n        -----\n        This operates only on the valid range `[0:self._length]`.\n        The internal buffer is preserved (no reallocation).\n        \"\"\"\n        self._check_no_shape(\"Delete\")\n\n        # Normalize the index to a boolean mask\n        mask = np.ones(self._length, dtype=bool)\n        mask[index] = False  # mark items to keep\n\n        kept = np.count_nonzero(mask)\n        if kept == self._length:\n            return  # nothing deleted\n        elif kept == 0:\n            self._length = 0\n            return\n\n        # Compact the buffer in-place\n        for name in self._data.dtype.names:\n            self._data[name][:kept] = self._data[name][:self._length][mask]\n\n        self._length = kept\n\n    # ====================================================================================================\n    # Serialization\n    # ====================================================================================================\n\n    def to_dict(self, *, copy: bool = True, with_infos: bool = True) -&gt; dict:\n        \"\"\"\n        Convert the array to a dictionary of fields or (field, infos) pairs.\n\n        Parameters\n        ----------\n        copy : bool, default=True\n            Whether to copy the arrays.\n\n        with_infos : bool, default=True\n            If True, return (array, infos) for each field.\n\n        Returns\n        -------\n        dict[str, array or (array, dict)]\n        \"\"\"\n        result = {}\n        valid_slice = slice(0, self._length)\n        for name, info in self._infos.items():\n            if info.get('optional', False):\n                arr = None\n            else:\n                arr = self._data[name][valid_slice]\n                arr = arr.copy() if copy else arr\n\n            result[name] = (arr, dict(info)) if with_infos else arr\n        return result\n\n    @classmethod\n    def from_dict(cls, data: dict):\n        \"\"\"\n        Build a FieldArray from a dictionary with field data and optional metadata.\n\n        Parameters\n        ----------\n        data : dict[str, array-like or (array, dict)]\n            Mapping field names to arrays or (array, infos). Infos must include NAME.\n\n        copy : bool, optional\n            Whether to copy the data. Default: True.\n\n        Returns\n        -------\n        FieldArray\n        \"\"\"\n        if not data:\n            raise ValueError(\"from_dict &gt; input dictionary is empty\")\n\n        arrays = {}\n        infos = {}\n        lengths = set()\n\n        for name, value in data.items():\n            if isinstance(value, tuple) and len(value) == 2 and isinstance(value[1], dict):\n                arr, arr_infos = value\n            else:\n                arr = np.asarray(value)\n                arr_infos = None\n\n            if arr is None:\n                if arr_infos is None:\n                    raise ValueError(f\"from_dict &gt; field '{name}' has no array, nor infos\")\n\n                arr_infos['optional'] = True\n\n            else:\n                arr = np.asarray(arr)\n                if arr_infos is None:\n                    arr_infos = {'dtype': arr.dtype, 'shape': arr.shape, 'default': 0, 'optional': False}\n                arrays[name] = arr\n                lengths.add(arr.shape[0])\n\n            infos[name] = arr_infos\n\n        if len(lengths) != 1:\n            raise ValueError(\"from_dict &gt; all fields must have the same number of records\")\n\n        n = lengths.pop()\n        descr = [\n            (name, arr.dtype.str, arr.shape[1:]) if arr.ndim &gt; 1 else (name, arr.dtype.str)\n            for name, arr in arrays.items()\n        ]\n\n        structured = np.empty(n, dtype=descr)\n        for name, arr in arrays.items():\n            structured[name] = arr\n\n        fa = cls(structured, mode='CAPTURE')\n        fa._infos.update(infos)\n\n        return fa\n\n    # ====================================================================================================\n    # Utility : as  kwargs arguments\n    # ====================================================================================================\n\n    def as_kwargs(self, selector=None, include=None, exclude=None):\n        \"\"\"\n        Return a dictionary of field values formatted as kwargs.\n\n        Parameters\n        ----------\n        selector : slice, int, list, or mask\n            Optional selection of elements to extract.\n\n        include : list[str], optional\n            List of field names (original or python names) to include.\n\n        exclude : list[str], optional\n            List of field names (original or python names) to exclude.\n\n        Returns\n        -------\n        dict\n            Mapping from python-safe field names to array values.\n        \"\"\"\n        exclude = set(exclude or [])\n        include = set(include) if include is not None else None\n\n        base = FieldArray(self[selector], mode='CAPTURE').to_dict(with_infos=False)\n        result = {}\n\n        for name, value in base.items():\n            if include and (name not in include):\n                continue\n            if name in exclude:\n                continue\n            result[name] = value\n\n        return result\n</code></pre>"},{"location":"api/#npblender.FieldArray.actual_names","title":"<code>actual_names</code>  <code>property</code>","text":"<p>Column names.</p> <p>Returns the actual field names, excluding optional fields.</p>"},{"location":"api/#npblender.FieldArray.all_names","title":"<code>all_names</code>  <code>property</code>","text":"<p>Column names.</p> <p>Returns all the field names, including optional ones.</p>"},{"location":"api/#npblender.FieldArray.dtype","title":"<code>dtype</code>  <code>property</code>","text":"<p>Array structured dtype</p> <p>Returns the dtype property of the structured array.</p>"},{"location":"api/#npblender.FieldArray.__array__","title":"<code>__array__(dtype=None)</code>","text":"<p>Allow implicit conversion to np.ndarray</p> Source code in <code>npblender/fieldarray.py</code> <pre><code>def __array__(self, dtype=None):\n    \"\"\"Allow implicit conversion to np.ndarray\"\"\"\n    arr = self._data_view    \n    return arr.astype(dtype) if dtype else arr\n</code></pre>"},{"location":"api/#npblender.FieldArray.__init__","title":"<code>__init__(a=None, mode='COPY', selector=None)</code>","text":"<p>Initialize the array with another array</p>"},{"location":"api/#npblender.FieldArray.__init__--arguments","title":"Arguments","text":"<ul> <li>a (array or FieldArray) : the array to initialize from</li> <li>mode (str in 'COPY', 'CAPTURE', 'EMPTY') : copy the content</li> <li>selector (Any = None) : a selector on data</li> </ul> Source code in <code>npblender/fieldarray.py</code> <pre><code>def __init__(self, a=None, mode='COPY', selector=None):\n    \"\"\" Initialize the array with another array\n\n    Arguments\n    ---------\n    - a (array or FieldArray) : the array to initialize from\n    - mode (str in 'COPY', 'CAPTURE', 'EMPTY') : copy the content\n    - selector (Any = None) : a selector on data \n    \"\"\"\n\n    object.__setattr__(self, '_infos',  {})\n    object.__setattr__(self, '_length', 0)\n    object.__setattr__(self, '_data',   None)\n\n    if a is not None:\n\n        # Make sure it is an array\n        data = np.asarray(a)\n\n        # If we have a selector, we apply it in case names would be removed\n        if selector is not None:\n            try:\n                data = data[selector]\n            except Exception as e:\n                raise ValueError(f\"{type(self).__name__} init&gt; invalid selector({type(selector)}), {str(e)}\")\n\n            if isinstance(data, np.void):\n                data = np.reshape(data, 1)\n\n        # Make sure we have names\n        if data.dtype.names is None:\n            raise ValueError(f\"{type(self).__name__} init&gt; input must be a structured array (selector={selector})\")\n\n        # Mode\n        if mode == 'COPY':\n            self._data = data.copy()\n        elif mode == 'CAPTURE':\n            self._data = data\n        elif mode == 'EMPTY':\n            self._data = np.zeros(0, dtype=data.dtype)\n        else:\n            raise ValueError(f\"{type(self).__name__} init&gt; mode must be in ('COPY', 'CAPTURE', 'EMPTY'), not '{mode}'\")\n\n        # Data can be a scalar with shape ()\n        if data.shape == ():\n            self._length = 1\n        else:\n            self._length = len(self._data)\n\n        # Build infos\n        if isinstance(a, FieldArray):\n            self._infos = {name: {**info} for name, info in a._infos.items()}\n\n        else:\n            self._infos = {}\n            for name in data.dtype.names:\n                shape = data[name].shape\n                if shape is not None:\n                    shape = shape[1:]\n                self._infos[name] = {'dtype': data[name].dtype, 'shape': shape, 'default': 0, 'optional': False}\n</code></pre>"},{"location":"api/#npblender.FieldArray.add","title":"<code>add(count, **fields)</code>","text":"<p>Add count records</p> <p>New records are set with default values or values provided by the user in fields dict.</p>"},{"location":"api/#npblender.FieldArray.add--parameters","title":"Parameters","text":"<p>count : int     Number of records to add. fields : dict     Keyword arguments mapping field names to values.</p> Source code in <code>npblender/fieldarray.py</code> <pre><code>def add(self, count, **fields):\n    \"\"\" Add count records\n\n    New records are set with default values or values provided by the user in fields dict.\n\n    Parameters\n    ----------\n    count : int\n        Number of records to add.\n    fields : dict\n        Keyword arguments mapping field names to values.\n\n    \"\"\"\n    if count &lt;= 0:\n        return\n\n    self._check_no_shape(\"Add records\")\n\n    old_length = self._length\n    self.resize(self._length + count)\n    sl = slice(old_length, self._length)\n\n    for name, value in fields.items():\n        if name in self._infos:\n            self._ensure_optional_field(name)\n            self._data[name][sl] = value\n        else:\n            raise KeyError(f\"Attribute name '{name}' not found in {list(self._infos.keys())}\")\n\n    for name in self._data.dtype.names:\n        if name in fields:\n            continue\n        self._data[name][sl] = self._infos[name].get('default', 0)\n</code></pre>"},{"location":"api/#npblender.FieldArray.append","title":"<code>append(**fields)</code>","text":"<p>Append values to the structured array.</p> <p>The number of records to append is determined by the number of fields provided in the fields dictionary. The values of the fields are copied to the new records.</p>"},{"location":"api/#npblender.FieldArray.append--parameters","title":"Parameters","text":"<p>fields : dict     Keyword arguments mapping field names to values.</p> Source code in <code>npblender/fieldarray.py</code> <pre><code>def append(self, **fields):\n    \"\"\"\n    Append values to the structured array.\n\n    The number of records to append is determined by the number of fields provided in the fields\n    dictionary. The values of the fields are copied to the new records.\n\n    Parameters\n    ----------\n    fields : dict\n        Keyword arguments mapping field names to values.\n    \"\"\"\n    self._check_no_shape(\"Append\")\n\n    # Determine the number of items to append\n    count  = 0\n    arrays = {}\n    for name, value in fields.items():\n        if value is None:\n            continue\n\n        if name not in self._infos:\n            raise ValueError(f\"{type(self).__name__}.append &gt; Invalid field name: '{name}' not in {list(self._infos.keys())}\")\n\n        self._ensure_optional_field(name)\n\n        a = np.asarray(value)\n\n        # Argument is a scalar: can be broadcasted to whatever field\n        if np.shape(a) == ():\n            n = 1\n\n        # Argument is not scalar\n        else:\n            # Target item shape\n            shape = self._data.dtype[name].shape\n\n            # The argument is a single item value\n            if shape == a.shape:\n                n = 1\n\n            # The target shape is a scalar\n            # The argument must be (n,)\n            elif shape == ():\n                if len(a.shape) != 1:\n                    raise ValueError(f\"{type(self).__name__}.append &gt; Invalid shape for scalar field '{name}': {np.shape(a)} is not a 1D array\")\n                n = len(a)\n\n            # The target shape is not a scalar\n            # The argument must be (n,) + shape\n            elif len(a.shape) != len(shape) + 1:\n                raise ValueError(f\"{type(self).__name__}.append &gt; Invalid shape for field '{name}': {np.shape(a)} is not {str((-1,) + shape).replace('-1', 'n')}\") \n\n            # The target shape is a scalar\n            # The argument shape is (n,) + shape\n            else:\n                n = len(a)\n\n        arrays[name] = a\n        if n &gt; count:\n            count = n\n\n    if count == 0:\n        return []\n\n    # Ensure the internal buffer is large enough\n    new_length = self._length + count\n    self._data_check(new_length)\n\n    # Assign values to the provided fields\n    for name, a in arrays.items():\n        self._data[name][self._length:new_length] = a\n\n    # Fill missing fields with default value\n    for name in self._data.dtype.names:\n        if name not in arrays:\n            self._data[name][self._length:new_length] = self._infos[name].get('default', 0)      \n\n    # To be returned\n    new_indices = np.arange(self._length, new_length)\n\n    # Update current length\n    self._length = new_length\n\n    # Return the indices of records appended\n    return new_indices\n</code></pre>"},{"location":"api/#npblender.FieldArray.as_kwargs","title":"<code>as_kwargs(selector=None, include=None, exclude=None)</code>","text":"<p>Return a dictionary of field values formatted as kwargs.</p>"},{"location":"api/#npblender.FieldArray.as_kwargs--parameters","title":"Parameters","text":"<p>selector : slice, int, list, or mask     Optional selection of elements to extract.</p> list[str], optional <p>List of field names (original or python names) to include.</p> list[str], optional <p>List of field names (original or python names) to exclude.</p>"},{"location":"api/#npblender.FieldArray.as_kwargs--returns","title":"Returns","text":"<p>dict     Mapping from python-safe field names to array values.</p> Source code in <code>npblender/fieldarray.py</code> <pre><code>def as_kwargs(self, selector=None, include=None, exclude=None):\n    \"\"\"\n    Return a dictionary of field values formatted as kwargs.\n\n    Parameters\n    ----------\n    selector : slice, int, list, or mask\n        Optional selection of elements to extract.\n\n    include : list[str], optional\n        List of field names (original or python names) to include.\n\n    exclude : list[str], optional\n        List of field names (original or python names) to exclude.\n\n    Returns\n    -------\n    dict\n        Mapping from python-safe field names to array values.\n    \"\"\"\n    exclude = set(exclude or [])\n    include = set(include) if include is not None else None\n\n    base = FieldArray(self[selector], mode='CAPTURE').to_dict(with_infos=False)\n    result = {}\n\n    for name, value in base.items():\n        if include and (name not in include):\n            continue\n        if name in exclude:\n            continue\n        result[name] = value\n\n    return result\n</code></pre>"},{"location":"api/#npblender.FieldArray.copy_field","title":"<code>copy_field(field_name, new_name, **infos)</code>","text":"<p>Duplicate an existing field under a new name, with optional metadata overrides.</p>"},{"location":"api/#npblender.FieldArray.copy_field--parameters","title":"Parameters","text":"<p>field_name : str     The name of the existing field to copy.</p> str <p>The name of the new field to create.</p> keyword arguments <p>Optional metadata (e.g. default, unit, description...) to override or supplement the original field's metadata.</p>"},{"location":"api/#npblender.FieldArray.copy_field--raises","title":"Raises","text":"<p>KeyError     If the source field does not exist.</p> <p>ValueError     If the target name already exists or is reserved.</p> Source code in <code>npblender/fieldarray.py</code> <pre><code>def copy_field(self, field_name: str, new_name: str, **infos):\n    \"\"\"\n    Duplicate an existing field under a new name, with optional metadata overrides.\n\n    Parameters\n    ----------\n    field_name : str\n        The name of the existing field to copy.\n\n    new_name : str\n        The name of the new field to create.\n\n    infos : keyword arguments\n        Optional metadata (e.g. default, unit, description...) to override\n        or supplement the original field's metadata.\n\n    Raises\n    ------\n    KeyError\n        If the source field does not exist.\n\n    ValueError\n        If the target name already exists or is reserved.\n    \"\"\"\n    # --- Validation -----------------------------------------------------\n    if field_name not in self.all_names:\n        raise KeyError(f\"copy_field &gt; unknown field '{field_name}'\")\n\n    if new_name in self.all_names:\n        raise ValueError(f\"copy_field &gt; '{new_name}' already exists\")\n\n    if self.is_reserved_name(new_name):\n        raise ValueError(f\"copy_field &gt; '{new_name}' is a reserved name\")\n\n    # --- Duplicate infos and create -------------------------------------\n    self._infos[new_name] = {**self._infos[field_name]}\n\n    if not self._infos[new_name]['optional']:\n        self._create_field_in_data(new_name)\n</code></pre>"},{"location":"api/#npblender.FieldArray.delete","title":"<code>delete(index)</code>","text":"<p>Delete a selection of items from the array.</p>"},{"location":"api/#npblender.FieldArray.delete--parameters","title":"Parameters","text":"<p>index : int, slice, or array-like     The indices of the elements to delete from the current data.</p>"},{"location":"api/#npblender.FieldArray.delete--notes","title":"Notes","text":"<p>This operates only on the valid range <code>[0:self._length]</code>. The internal buffer is preserved (no reallocation).</p> Source code in <code>npblender/fieldarray.py</code> <pre><code>def delete(self, index):\n    \"\"\"\n    Delete a selection of items from the array.\n\n    Parameters\n    ----------\n    index : int, slice, or array-like\n        The indices of the elements to delete from the current data.\n\n    Notes\n    -----\n    This operates only on the valid range `[0:self._length]`.\n    The internal buffer is preserved (no reallocation).\n    \"\"\"\n    self._check_no_shape(\"Delete\")\n\n    # Normalize the index to a boolean mask\n    mask = np.ones(self._length, dtype=bool)\n    mask[index] = False  # mark items to keep\n\n    kept = np.count_nonzero(mask)\n    if kept == self._length:\n        return  # nothing deleted\n    elif kept == 0:\n        self._length = 0\n        return\n\n    # Compact the buffer in-place\n    for name in self._data.dtype.names:\n        self._data[name][:kept] = self._data[name][:self._length][mask]\n\n    self._length = kept\n</code></pre>"},{"location":"api/#npblender.FieldArray.extend","title":"<code>extend(other, join_fields=True)</code>","text":"<p>Append multiple records from another array or FieldArray.</p>"},{"location":"api/#npblender.FieldArray.extend--parameters","title":"Parameters","text":"<p>other : FieldArray or structured np.ndarray     The array of records to append. Must have named fields matching     a subset of the current array's fields.</p> Source code in <code>npblender/fieldarray.py</code> <pre><code>def extend(self, other, join_fields=True):\n    \"\"\"\n    Append multiple records from another array or FieldArray.\n\n    Parameters\n    ----------\n    other : FieldArray or structured np.ndarray\n        The array of records to append. Must have named fields matching\n        a subset of the current array's fields.\n    \"\"\"\n    self._check_no_shape(\"Extend\")\n\n    if other is None:\n        return\n\n    # Accept both FieldArray and structured np.ndarray\n    data = np.asarray(other)\n\n    count = len(data)\n    if count == 0:\n        return\n\n    # No names\n    if data.dtype.names is None:\n        raise ValueError(f\"{type(self).__name__}.extend&gt; input must have named fields\")\n\n    # Join fields if required\n    if join_fields:\n        self.join_fields(other)\n\n    # Ensure all fields in 'data' are valid for this array\n    invalid = [name for name in data.dtype.names if name not in self.all_names]\n    if invalid:\n        raise ValueError(f\"extend &gt; input contains unknown field(s): {invalid}\")\n\n    # Resize buffer\n    new_length = self._length + count\n    self._data_check(new_length)\n\n    # Copy data field by field\n    for name in data.dtype.names:\n        self._ensure_optional_field(name)\n        self._data[name][self._length:new_length] = data[name]\n\n    # Fill missing fields with default value\n    for name in self.actual_names:\n        if name not in data.dtype.names:\n            self._data[name][self._length:new_length] = self._infos[name].get('default', 0)\n\n    self._length = new_length\n</code></pre>"},{"location":"api/#npblender.FieldArray.filtered","title":"<code>filtered(selector, *, copy=False)</code>","text":"<p>Return a FieldArray containing only the selected records.</p>"},{"location":"api/#npblender.FieldArray.filtered--parameters","title":"Parameters","text":"<p>selector : array\u2011like, slice or int     Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice.     It is applied to the current valid part of the buffer     (<code>self._data[:self._length]</code>).</p> bool, optional <ul> <li>False    (default) =&gt; the new array shares the same memory                          (changes propagate both ways).</li> <li>True           =&gt; the data are physically copied.</li> </ul>"},{"location":"api/#npblender.FieldArray.filtered--returns","title":"Returns","text":"<p>FieldArray     A new instance holding exactly <code>len(selector)</code> records and     inheriting the current field\u2011infos.</p> Source code in <code>npblender/fieldarray.py</code> <pre><code>def filtered(self, selector, *, copy=False):\n    \"\"\"\n    Return a FieldArray containing only the selected records.\n\n    Parameters\n    ----------\n    selector : array\u2011like, slice or int\n        Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice.\n        It is applied to the current valid part of the buffer\n        (``self._data[:self._length]``).\n\n    copy : bool, optional\n        - False    (default) =&gt; the new array shares the same memory\n                                 (changes propagate both ways).\n        - True           =&gt; the data are physically copied.\n\n    Returns\n    -------\n    FieldArray\n        A new instance holding exactly ``len(selector)`` records and\n        inheriting the current field\u2011infos.\n    \"\"\"\n    if selector is None:\n        return self\n\n    if self._data is None or self._length == 0:\n        # Nothing to select \u2013 return an empty compatible array\n        return type(self)(self, copy='EMPTY')\n\n    # Apply the selector on the valid slice\n    #selected = self._data[:self._length][selector]\n\n    # Choose copy mode\n    mode = 'COPY' if copy else 'CAPTURE'\n\n    # Build the new instance\n    data = self._data_view[selector]\n\n    fa = type(self)(self, copy='EMPTY')\n    if copy:\n        fa._data = np.array(data)\n    else:\n        fa._data = data\n    return fa\n\n    return type(self)(self, mode=mode, selector=selector)\n</code></pre>"},{"location":"api/#npblender.FieldArray.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Build a FieldArray from a dictionary with field data and optional metadata.</p>"},{"location":"api/#npblender.FieldArray.from_dict--parameters","title":"Parameters","text":"<p>data : dict[str, array-like or (array, dict)]     Mapping field names to arrays or (array, infos). Infos must include NAME.</p> bool, optional <p>Whether to copy the data. Default: True.</p>"},{"location":"api/#npblender.FieldArray.from_dict--returns","title":"Returns","text":"<p>FieldArray</p> Source code in <code>npblender/fieldarray.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict):\n    \"\"\"\n    Build a FieldArray from a dictionary with field data and optional metadata.\n\n    Parameters\n    ----------\n    data : dict[str, array-like or (array, dict)]\n        Mapping field names to arrays or (array, infos). Infos must include NAME.\n\n    copy : bool, optional\n        Whether to copy the data. Default: True.\n\n    Returns\n    -------\n    FieldArray\n    \"\"\"\n    if not data:\n        raise ValueError(\"from_dict &gt; input dictionary is empty\")\n\n    arrays = {}\n    infos = {}\n    lengths = set()\n\n    for name, value in data.items():\n        if isinstance(value, tuple) and len(value) == 2 and isinstance(value[1], dict):\n            arr, arr_infos = value\n        else:\n            arr = np.asarray(value)\n            arr_infos = None\n\n        if arr is None:\n            if arr_infos is None:\n                raise ValueError(f\"from_dict &gt; field '{name}' has no array, nor infos\")\n\n            arr_infos['optional'] = True\n\n        else:\n            arr = np.asarray(arr)\n            if arr_infos is None:\n                arr_infos = {'dtype': arr.dtype, 'shape': arr.shape, 'default': 0, 'optional': False}\n            arrays[name] = arr\n            lengths.add(arr.shape[0])\n\n        infos[name] = arr_infos\n\n    if len(lengths) != 1:\n        raise ValueError(\"from_dict &gt; all fields must have the same number of records\")\n\n    n = lengths.pop()\n    descr = [\n        (name, arr.dtype.str, arr.shape[1:]) if arr.ndim &gt; 1 else (name, arr.dtype.str)\n        for name, arr in arrays.items()\n    ]\n\n    structured = np.empty(n, dtype=descr)\n    for name, arr in arrays.items():\n        structured[name] = arr\n\n    fa = cls(structured, mode='CAPTURE')\n    fa._infos.update(infos)\n\n    return fa\n</code></pre>"},{"location":"api/#npblender.FieldArray.get","title":"<code>get(name, default=None)</code>","text":"<p>Get attribute by name.</p> <p>If name is not an actual field, return default value. Name can be an array.</p> <pre><code>pos = field_array.get(\"position\", (0, 0, 1))\npos = field_array.get([[0, 0, 1], [0, 0, 0]])\n</code></pre> Source code in <code>npblender/fieldarray.py</code> <pre><code>def get(self, name, default=None):\n    \"\"\" Get attribute by name.\n\n    If name is not an actual field, return default value.\n    Name can be an array.\n    ``` python\n    pos = field_array.get(\"position\", (0, 0, 1))\n    pos = field_array.get([[0, 0, 1], [0, 0, 0]])\n    ```\n    \"\"\"\n    if isinstance(name, str):\n        if name in self._data.dtype.names:\n            return self[name]\n        else:\n            if default is None:\n                return None\n            else:\n                return np.asarray(default)\n    else:\n        if name is None:\n            return None\n        else:\n            return np.asarray(name)\n</code></pre>"},{"location":"api/#npblender.FieldArray.join_fields","title":"<code>join_fields(other, exclude=[])</code>","text":"<p>Add all missing fields from another FieldArray.</p> <p>For every field in <code>other</code> that is not present in <code>self</code>, a new field is created with the same dtype and shape, and initialized with its default value across all existing records.</p>"},{"location":"api/#npblender.FieldArray.join_fields--parameters","title":"Parameters","text":"<p>other : FieldArray     Another FieldArray instance whose fields will be checked for missing fields.</p>"},{"location":"api/#npblender.FieldArray.join_fields--returns","title":"Returns","text":"<p>self</p> Source code in <code>npblender/fieldarray.py</code> <pre><code>def join_fields(self, other, exclude=[]):\n    \"\"\"\n    Add all missing fields from another FieldArray.\n\n    For every field in `other` that is not present in `self`, a new field is created\n    with the same dtype and shape, and initialized with its default value across all existing records.\n\n    Parameters\n    ----------\n    other : FieldArray\n        Another FieldArray instance whose fields will be checked for missing fields.\n\n    Returns\n    -------\n    self        \n    \"\"\"\n    if isinstance(other, FieldArray):\n        for name in other._infos:\n            if name in self._infos or name in exclude:\n                continue\n\n            self._infos[name] = {**other._infos[name]}\n            if not self._infos[name]['optional']:\n                self._create_field_in_data(name)\n\n    else:\n        for name in other.dtype.names:\n            if name in self._infos or name in exclude:\n                continue\n\n            self.new_field(name, dtype=other[name].dtype, shape=other[name].shape)\n\n    return self\n</code></pre>"},{"location":"api/#npblender.FieldArray.multiply","title":"<code>multiply(count)</code>","text":"<p>Duplicate the current records <code>count</code> times.</p>"},{"location":"api/#npblender.FieldArray.multiply--parameters","title":"Parameters","text":"<p>count : int     Number of times to repeat the current records.</p>"},{"location":"api/#npblender.FieldArray.multiply--notes","title":"Notes","text":"<p>This duplicates the current valid records (up to self._length). If the array is empty or count &lt;= 1, nothing happens.</p>"},{"location":"api/#npblender.FieldArray.multiply--example","title":"Example:","text":"<p>If the array has 3 records and count == 4, the result will be:</p> <p>[rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]</p> Source code in <code>npblender/fieldarray.py</code> <pre><code>def multiply(self, count: int):\n    \"\"\"\n    Duplicate the current records `count` times.\n\n    Parameters\n    ----------\n    count : int\n        Number of times to repeat the current records.\n\n    Notes\n    -----\n    This duplicates the current valid records (up to self._length).\n    If the array is empty or count &lt;= 1, nothing happens.\n\n    Example:\n    --------\n    If the array has 3 records and count == 4, the result will be:\n\n    [rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]\n    \"\"\"\n    if count &lt;= 1 or self._length == 0:\n        return\n\n    shape = self.shape\n\n    self.resize(count*self._length)\n\n    if len(shape) &gt; 1:\n        self.reshape((count,) + shape)\n\n    return self\n</code></pre>"},{"location":"api/#npblender.FieldArray.new_field","title":"<code>new_field(name, dtype, shape=None, default=0, optional=False, **infos)</code>","text":"<p>Add a field to the structured array.</p>"},{"location":"api/#npblender.FieldArray.new_field--arguments","title":"Arguments","text":"<pre><code>- name (str) : field name\n- dtype (type) : a valid numpy dtype\n- shape (tuple = None) : the shape of the field\n- default (any = 0) : default value\n- optional (bool = False) : the field is created only when accessed\n- infos (dict) : field infos\n</code></pre> Source code in <code>npblender/fieldarray.py</code> <pre><code>def new_field(self, name, dtype, shape=None, default=0, optional=False, **infos):\n    \"\"\" Add a field to the structured array.\n\n    Arguments\n    ---------\n        - name (str) : field name\n        - dtype (type) : a valid numpy dtype\n        - shape (tuple = None) : the shape of the field\n        - default (any = 0) : default value\n        - optional (bool = False) : the field is created only when accessed\n        - infos (dict) : field infos\n    \"\"\"\n    # Reserved name\n    if self.is_reserved_name(name):\n        raise ValueError(f\"new_field &gt; '{name}' is a reserved name.\")\n\n    # Already exists\n    if name in self._infos:\n        if (dtype != self._infos[name]['dtype'] or\n            shape != self._infos[name]['shape']):\n            raise ValueError(f\"new_field &gt; '{name}' is already defined.\")\n        return\n\n    # Declare in infos\n    self._infos[name] = {\n        'dtype'    : dtype,\n        'shape'    : FieldArray._normalize_shape(shape),\n        'default'  : default,\n        'optional' : optional,\n        **infos,\n        }\n\n    # Create if not optional\n    if not optional:\n        self._create_field_in_data(name)\n</code></pre>"},{"location":"api/#npblender.FieldArray.to_dict","title":"<code>to_dict(*, copy=True, with_infos=True)</code>","text":"<p>Convert the array to a dictionary of fields or (field, infos) pairs.</p>"},{"location":"api/#npblender.FieldArray.to_dict--parameters","title":"Parameters","text":"<p>copy : bool, default=True     Whether to copy the arrays.</p> bool, default=True <p>If True, return (array, infos) for each field.</p>"},{"location":"api/#npblender.FieldArray.to_dict--returns","title":"Returns","text":"<p>dict[str, array or (array, dict)]</p> Source code in <code>npblender/fieldarray.py</code> <pre><code>def to_dict(self, *, copy: bool = True, with_infos: bool = True) -&gt; dict:\n    \"\"\"\n    Convert the array to a dictionary of fields or (field, infos) pairs.\n\n    Parameters\n    ----------\n    copy : bool, default=True\n        Whether to copy the arrays.\n\n    with_infos : bool, default=True\n        If True, return (array, infos) for each field.\n\n    Returns\n    -------\n    dict[str, array or (array, dict)]\n    \"\"\"\n    result = {}\n    valid_slice = slice(0, self._length)\n    for name, info in self._infos.items():\n        if info.get('optional', False):\n            arr = None\n        else:\n            arr = self._data[name][valid_slice]\n            arr = arr.copy() if copy else arr\n\n        result[name] = (arr, dict(info)) if with_infos else arr\n    return result\n</code></pre>"},{"location":"api/#npblender.Geometry","title":"<code>Geometry</code>","text":"Source code in <code>npblender/geometry.py</code> <pre><code>class Geometry:\n\n    # Overriden by Mesh and Curve\n    domain_names = [\"points\"]\n\n    # ====================================================================================================\n    # From a dict\n    # ====================================================================================================\n\n    @classmethod\n    def from_dict(cls, d):\n        from .mesh import Mesh\n        from .curve import Curve\n        from .cloud import Cloud\n        from .instances import Instances, Meshes\n\n        if d['geometry'] == 'Mesh':\n            return Mesh.from_dict(d)\n        elif d['geometry'] == 'Curve':\n            return Curve.from_dict(d)\n        elif d['geometry'] == 'Cloud':\n            return Cloud.from_dict(d)\n        elif d['geometry'] == 'Instances':\n            return Instances.from_dict(d)\n        elif d['geometry'] == 'Meshes':\n            return Meshes.from_dict(d)\n        else:\n            raise ValueError(f\"Unknown geometry {d['geometry']}\")\n\n    # ====================================================================================================\n    # Copy attributes definition\n    # ====================================================================================================\n\n    def join_attributes(self, other, **kwargs):\n        \"\"\" Capture the attributes from another geometry.\n\n        Other can be a different geometry, in that case, only domains with the same name are captured.\n        kwargs allows to filter the domains to capture:\n\n        ```python\n        mesh.join_attributes(other_mesh, faces=False)\n        mesh.join_attributes(curve)\n        ```\n\n        Returns:\n            - self\n        \"\"\"\n        if other is None:\n            return self\n\n        for name in self.domain_names:\n            if name in other.domain_names and kwargs.get(name, True):\n                getattr(self, name).join_fields(getattr(other, name))\n\n        return self\n\n    # ====================================================================================================\n    # Compute an attribute of a domain to another domain\n    # ====================================================================================================\n\n    def compute_attribute_on_domain(self, domain_from, attr, domain_to):\n\n        if domain_from == domain_to:\n            return attr\n\n        if (domain_from not in self.domain_names) or (domain_to not in self.domain_names):\n            raise AttributeError(\n                f\"The geometry '{type(self).__name__}' doesn't have domains '{domain_from}' and '{domain_to}'.\\n\"\n                f\"Valid domains are: {self.domain_names}.\"\n                )\n\n        if domain_from == 'points':\n            if domain_to == 'faces':\n                return self.points.compute_attribute_on_faces(attr, self.corners, self.faces)\n            elif domain_to == 'edges':\n                return self.points.compute_attribute_on_edges(attr, self.edges)\n            elif domain_to == 'corners':\n                return self.points.compute_attribute_on_corners(attr, self.corners)\n            elif domain_to == 'splines':\n                return self.points.compute_attribute_on_splines(attr, self.splines)\n\n        elif domain_from == 'faces':\n            if domain_to == 'points':\n                return self.faces.compute_attribute_on_points(attr, self.corners, self.points)\n            elif domain_to == 'edges':\n                pass\n            elif domain_to == 'corners':\n                pass\n\n        elif domain_from == 'edges':\n            if domain_to == 'points':\n                return self.edges.compute_attribute_on_points(attr, self.points)\n            elif domain_to == 'faces':\n                pass\n            elif domain_to == 'corners':\n                pass\n\n        elif domain_from == 'corners':\n            if domain_to == 'points':\n                return self.corners.compute_attribute_on_points(attr, self.points)\n            elif domain_to == 'faces':\n                pass\n            elif domain_to == 'edges':\n                pass\n\n        elif domain_from == 'splines':\n            if domain_to == 'points':\n                return self.splines.compute_attribute_on_points(attr, self.points)\n\n        raise Exception(\n            f\"Sorry, computing attribue from '{domain_from}' to '{domain_to}' is not implemented yet.\")\n\n\n\n    def compute_attribute_on_domain_OLD(self, attr_name, domain_name):\n\n        from numba import njit, prange\n\n        # ---------------------------------------------------------------------------\n        # Faces to points\n\n        @njit(cache=True)\n        def _faces_to_points(loop_start, loop_total, vertex_index, source, res):\n            V = res.shape[0]\n            F = loop_start.shape[0]\n\n            count = np.zeros(V, dtype=np.int32)\n            for f in range(F):\n                s, t, val = loop_start[f], loop_total[f], source[f]\n                for k in range(t):\n                    v = vertex_index[s + k]\n                    res[v] += val\n                    count[v] += 1\n\n            trailing = 1\n            for d in range(1, res.ndim):\n                trailing *= res.shape[d]\n\n            R2 = res.reshape((V, trailing))\n            for v in range(V):\n                c = count[v]\n                if c &gt; 0:\n                    inv = 1.0 / c\n                    for j in range(trailing):\n                        R2[v, j] *= inv\n\n            return res\n\n        # ---------------------------------------------------------------------------\n        # Points to faces\n\n        @njit(cache=True)\n        def _points_to_faces(loop_start, loop_total, vertex_index, source, res):\n            F = loop_start.shape[0]\n\n            for f in range(F):\n                s = loop_start[f]\n                t = loop_total[f]\n                for k in range(t):\n                    v = vertex_index[s + k]\n                    res[f] += source[v]\n                inv = 1.0 / t\n                res[f] *= inv\n\n            return res\n\n        # ---------------------------------------------------------------------------\n        # Get the source domain for attribute\n        # ---------------------------------------------------------------------------\n\n        source_domain_name = None\n        for name in self.domain_names:\n            source_domain = getattr(self, name)\n            if attr_name in source_domain._infos:\n                source_domain_name = name\n                break\n\n        if source_domain_name is None:\n            raise AttributeError(f\"No domain has an attribute named '{attr_name}'\")\n\n        # ---------------------------------------------------------------------------\n        # Prepare\n        # ---------------------------------------------------------------------------\n\n        domain_name = domain_name.lower()\n\n        source = source_domain[attr_name]\n\n        # Source = Target domain\n        if domain_name == source_domain_name:\n            return source\n\n        # Resulting array\n        item_shape = source_domain._infos[attr_name]['shape']\n        target_domain = getattr(self, domain_name)\n        res = np.zeros((len(target_domain),) + item_shape, dtype=source.dtype)\n        count = None\n\n        # ---------------------------------------------------------------------------\n        # Different cases\n        # ---------------------------------------------------------------------------\n\n        # Faces to points\n        if source_domain_name == 'faces' and domain_name == 'points':\n            if True:\n                res = _faces_to_points(\n                    np.ascontiguousarray(self.faces.loop_start, dtype=np.int32),\n                    np.ascontiguousarray(self.faces.loop_total, dtype=np.int32),\n                    np.ascontiguousarray(self.corners.vertex_index, dtype=np.int32),\n                    np.ascontiguousarray(source, dtype=source.dtype),\n                    np.ascontiguousarray(res, dtype=res.dtype),\n                )\n\n            else:\n                count = np.zeros(len(target_domain), dtype=int)\n                for loop_start, loop_total, val in zip(self.faces.loop_start, self.faces.loop_total, source):\n                    corners = self.corners.vertex_index[loop_start:loop_start+loop_total]\n                    res[corners] += val\n                    count[corners] += 1\n\n        # Points to faces\n        elif source_domain_name == 'points' and domain_name == 'faces':\n            if True:\n                res = _points_to_faces(\n                    np.ascontiguousarray(self.faces.loop_start, dtype=np.int32),\n                    np.ascontiguousarray(self.faces.loop_total, dtype=np.int32),\n                    np.ascontiguousarray(self.corners.vertex_index, dtype=np.int32),\n                    np.ascontiguousarray(source, dtype=source.dtype),\n                    np.ascontiguousarray(res, dtype=res.dtype),\n                )\n            else:\n                for i_face, (loop_start, loop_total) in enumerate(zip(self.faces.loop_start, self.faces.loop_total)):\n                    corners = self.corners[loop_start:loop_start+loop_total]\n                    res[i_face] = np.average(source[corners], axis=0)\n\n        # Edges to points\n        elif source_domain_name == 'edges' and domain_name == 'points':\n            count = np.zeros(len(target_domain), dtype=int)\n            for v0, v1, value in zip(self.edges.vertex0, self.edges.vertex1, source):\n                res[v0] += value\n                res[v1] += value\n                count[v0] += 1\n                count[v1] += 1\n\n        # Points to edges\n        elif source_domain_name == 'points' and domain_name == 'edges':\n            for i_edge, (v0, v1) in enumerate(zip(self.edges.vertex0, self.edges.vertex1)):\n                res[i_edge] = (source[v0] + source[v1])/2\n\n        # Splines to points\n        elif source_domain_name == 'splines' and domain_name == 'points':\n            for loop_start, loop_total, val in zip(self.faces.loop_start, self.faces.loop_total, source):\n                res[loop_start:loop_start+loop_total] = val\n\n        # Points to splines\n        elif source_domain_name == 'points' and domain_name == 'splines':\n            for i_spline, (loop_start, loop_total) in enumerate(zip(self.faces.loop_start, self.faces.loop_total)):\n                res[i_spline] = np.average(source[loop_start:loop_start+loop_total], axis=0)\n\n        # Not implemented\n        else:\n            raise Exception(f\"Sorry: compute_attribute from '{source_domain_name}' to '{domain_name}' domains is not implemented yet.\")\n\n        # ---------------------------------------------------------------------------\n        # Finalization\n        # ---------------------------------------------------------------------------\n\n        if count is not None:\n            if len(item_shape) == 1:\n                count = count[:, None]\n            elif len(item_shape) == 2:\n                count = count[:, None, None]\n\n            res = res/count\n\n        return res\n\n    # ====================================================================================================\n    # Check geometry consistency\n    # ====================================================================================================\n\n    def check(self, title=\"Geometry Check\", halt=True):\n        return True\n\n    # ====================================================================================================\n    # Load a Mesh or a Curve\n    # ====================================================================================================\n\n    @staticmethod\n    def load_object(name):\n        \"\"\" Load a Blender object and returns either a Mesh or a Curve.\n\n        Arguments\n        ---------\n            - name (str or bpy.types.Object) : the object to load\n\n        Returns\n        -------\n            - Mesh or Curve\n        \"\"\"\n\n        from .mesh import Mesh\n        from .curve import Curve\n\n        obj = blender.getobject(name)\n        if obj is None:\n            return None\n\n        if isinstance(obj.data, bpy.types.Mesh):\n            return Mesh.from_object(obj)\n\n        elif isinstance(obj.data, bpy.types.Curve):\n            return Curve.from_object(obj)\n\n        else:\n            raise Exception(f\"Geometry.load_object error: impossible to load the objet '{obj.name}' of type '{type(obj.data).__name__}'\")\n\n    # ====================================================================================================\n    # Load a Mesh or a Curve\n    # ====================================================================================================\n\n    @staticmethod\n    def load_models(*specs):\n        \"\"\" Load a geometry or geometries from specifications.\n\n        The specs can be:\n            - a Blender collection\n            - a Blender object\n            - a Geometry\n\n        Arguments\n        ---------\n            - specs (list of objects / collections) : the models to load\n\n        Returns\n        -------\n            - list of geometries\n        \"\"\"\n\n        from .mesh import Mesh\n        from .curve import Curve\n\n        models = []\n\n        for spec in specs:\n            # A list\n            if isinstance(spec, (list, tuple)):\n                models.extend(Geometry.load_models(*spec))\n                continue\n\n            # A collection\n            coll = blender.get_collection(spec, halt=False)\n            if coll is not None:\n                for obj in coll.objects:\n                    geo = Geometry.load_object(obj)\n                    if isinstance(geo, (Mesh, Curve)):\n                        models.append(geo)\n                continue\n\n            # An object\n            obj = blender.get_object(spec, halt=False)\n            if obj is not None:\n                geo = Geometry.load_object(obj)\n                if isinstance(geo, (Mesh, Curve)):\n                    models.append(geo)\n                continue\n\n            # A valid geometry\n            if type(spec).__name__ in ['Mesh', 'Curve']:\n                models.append(spec)\n                continue\n\n            raise ValueError(f\"Unknown model (type '{type(spec)}'): {spec}\")\n\n        return models\n\n    # ====================================================================================================\n    # Object edition\n    # ====================================================================================================\n\n    @contextmanager\n    def object(self, index=0, readonly=True):\n\n        import bpy\n        from . import blender\n\n        temp_name = index if isinstance(index, str) else f\"BPBL Temp {index}\"\n\n        ctx = bpy.context\n\n        old_sel = [obj.name for obj in bpy.data.objects if obj.select_get()]\n        old_active = ctx.view_layer.objects.active\n        if old_active is None:\n            old_active_name = None\n        else:\n            old_active_name = old_active.name\n\n        bpy.ops.object.select_all(action='DESELECT')        \n\n        obj = self.to_object(temp_name)\n        obj.select_set(True)\n        bpy.context.view_layer.objects.active = obj        \n\n        yield obj\n\n        # ===== Returns from context\n\n        if not readonly:\n            self.capture(type(self).from_object(obj))\n\n        blender.delete_object(obj)\n\n        bpy.ops.object.select_all(action='DESELECT')        \n        for name in old_sel:\n            obj = bpy.data.objects.get(name)\n            if obj is not None:\n                obj.select_set(True)\n\n        if old_active_name is not None:\n            bpy.context.view_layer.objects.active = bpy.data.objects.get(old_active_name)\n\n    # ====================================================================================================\n    # Material\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Index from material name\n    # ----------------------------------------------------------------------------------------------------\n\n    def get_material_index(self, mat_name):\n        \"\"\" Return the index of a material name.\n\n        If the material doesn't exist, it is created\n\n        Arguments\n        ---------\n            - mat_name (str) : material name\n\n        Returns\n        -------\n            - int : index of the material name in the materials list\n        \"\"\"\n\n        if mat_name in self.materials:\n            return self.materials.index(mat_name)\n        else:\n            self.materials.append(mat_name)\n            return len(self.materials)-1\n\n    # ----------------------------------------------------------------------------------------------------\n    # Add a material or a list of materials\n    # ----------------------------------------------------------------------------------------------------\n\n    def add_materials(self, materials):\n        \"\"\" Add a materials list to the existing one.\n\n        If a material already exist, it is not added another time.\n\n        Arguments\n        ---------\n            - materials (list of strs) : the list of materials to append.\n        \"\"\"\n        if isinstance(materials, str):\n            self.materials.append(materials)\n        else:\n            self.materials.extend(materials)\n\n    # ====================================================================================================\n    # Transformation\n    # ====================================================================================================\n\n    def get_points_selection(self):\n        return slice(None)\n\n    def _check_transformation_shape(self, t_shape, npoints, label=\"Transformation\"):\n        if t_shape == ():\n            return (npoints, 3)\n\n        elif len(t_shape) == 1:\n            if t_shape[0] in [1, npoints]:\n                return (npoints, 3)\n\n        else:\n            n = int(np.prod(t_shape))\n            if npoints % n == 0:\n                return t_shape[:-1] + (-1, 3)\n\n        raise AttributeError(f\"{label} shape {t_shape} is not valid to transform {npoints} points.\")\n\n    # ----------------------------------------------------------------------------------------------------\n    # Apply one or more basic transformation\n    # ----------------------------------------------------------------------------------------------------\n\n    def transformation(self, rotation=None, scale=None, translation=None, pivot=None):\n\n        # Curve splines can be a subset of the points \n        pts_sel = self.get_points_selection()\n        pos = self.points.position[pts_sel]\n        npoints = len(pos)\n        all_vecs = [pos]\n\n        has_handles = \"handle_left\" in self.points.actual_names\n        if has_handles:\n            left = self.points.handle_left[pts_sel]\n            right = self.points.handle_right[pts_sel]\n            all_vecs.extend([left, right])\n\n        # First pivot\n        if pivot is not None:\n            pivot = np.asarray(pivot)\n            pivot_shape = self._check_transformation_shape(pivot.shape[:-1], npoints, label=\"Pivot\")\n            for v in all_vecs:\n                v.reshape(pivot_shape)[:] -= pivot\n\n        # Scale\n        if scale is not None:\n            scale = np.asarray(scale)\n            scale_shape = self._check_transformation_shape(scale.shape[:-1], npoints, label=\"Scale\")\n            for v in all_vecs:\n                v.reshape(scale_shape)[:] *= scale\n\n        # Rotation\n        if rotation is not None:\n            rot_shape = self._check_transformation_shape(rotation.shape, npoints, label=\"Rotation\")\n            for v in all_vecs:\n                v.reshape(rot_shape)[:] = rotation @ v.reshape(rot_shape)\n\n        # Pivot back\n        if pivot is not None:\n            for v in all_vecs:\n                v.reshape(pivot_shape)[:] += pivot\n\n        # Translation\n        if translation is not None:\n            translation = np.asarray(translation)\n            tr_shape = self._check_transformation_shape(translation.shape[:-1], npoints, label=\"Pivot\")\n            for v in all_vecs:\n                v.reshape(tr_shape)[:] += translation\n\n        # Back\n        self.points[pts_sel].position = pos\n        if has_handles:\n            self.points[pts_sel].handle_left = all_vecs[1]\n            self.points[pts_sel].handle_right = all_vecs[2]\n\n        return self\n\n    def translate(self, translation):\n        return self.transformation(translation=translation)\n\n    def apply_scale(self, scale, pivot=None):\n        return self.transformation(scale=scale, pivot=pivot)\n\n    def rotate(self, rotation, pivot=None):\n        return self.transformation(rotation=rotation, pivot=pivot)\n\n    def transform(self, transformation):\n        return self.transformation(rotation=transformation)\n\n    # ====================================================================================================\n    # Envelop\n    # ====================================================================================================\n\n    @property\n    def bounding_box(self):\n        pos = self.points.position\n        if len(pos):\n            return np.min(pos, axis=0), np.max(pos, axis=0)\n        else:\n            return np.zeros(3, float), np.zeros(3, float)\n\n    @property\n    def bounding_box_dims(self):\n        v0, v1 = self.bounding_box\n        return v1 - v0\n\n    @property\n    def max_size(self):\n        return max(self.bounding_box_dims)\n\n    def get_cubic_envelop(self):\n        from . mesh import Mesh\n\n        size = self.bounding_box_dims\n        return Mesh.cube(size=size, materials=getattr(self, \"materials\", None))\n</code></pre>"},{"location":"api/#npblender.Geometry.add_materials","title":"<code>add_materials(materials)</code>","text":"<p>Add a materials list to the existing one.</p> <p>If a material already exist, it is not added another time.</p>"},{"location":"api/#npblender.Geometry.add_materials--arguments","title":"Arguments","text":"<pre><code>- materials (list of strs) : the list of materials to append.\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def add_materials(self, materials):\n    \"\"\" Add a materials list to the existing one.\n\n    If a material already exist, it is not added another time.\n\n    Arguments\n    ---------\n        - materials (list of strs) : the list of materials to append.\n    \"\"\"\n    if isinstance(materials, str):\n        self.materials.append(materials)\n    else:\n        self.materials.extend(materials)\n</code></pre>"},{"location":"api/#npblender.Geometry.get_material_index","title":"<code>get_material_index(mat_name)</code>","text":"<p>Return the index of a material name.</p> <p>If the material doesn't exist, it is created</p>"},{"location":"api/#npblender.Geometry.get_material_index--arguments","title":"Arguments","text":"<pre><code>- mat_name (str) : material name\n</code></pre>"},{"location":"api/#npblender.Geometry.get_material_index--returns","title":"Returns","text":"<pre><code>- int : index of the material name in the materials list\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def get_material_index(self, mat_name):\n    \"\"\" Return the index of a material name.\n\n    If the material doesn't exist, it is created\n\n    Arguments\n    ---------\n        - mat_name (str) : material name\n\n    Returns\n    -------\n        - int : index of the material name in the materials list\n    \"\"\"\n\n    if mat_name in self.materials:\n        return self.materials.index(mat_name)\n    else:\n        self.materials.append(mat_name)\n        return len(self.materials)-1\n</code></pre>"},{"location":"api/#npblender.Geometry.join_attributes","title":"<code>join_attributes(other, **kwargs)</code>","text":"<p>Capture the attributes from another geometry.</p> <p>Other can be a different geometry, in that case, only domains with the same name are captured. kwargs allows to filter the domains to capture:</p> <pre><code>mesh.join_attributes(other_mesh, faces=False)\nmesh.join_attributes(curve)\n</code></pre> <p>Returns:</p> Type Description <ul> <li>self</li> </ul> Source code in <code>npblender/geometry.py</code> <pre><code>def join_attributes(self, other, **kwargs):\n    \"\"\" Capture the attributes from another geometry.\n\n    Other can be a different geometry, in that case, only domains with the same name are captured.\n    kwargs allows to filter the domains to capture:\n\n    ```python\n    mesh.join_attributes(other_mesh, faces=False)\n    mesh.join_attributes(curve)\n    ```\n\n    Returns:\n        - self\n    \"\"\"\n    if other is None:\n        return self\n\n    for name in self.domain_names:\n        if name in other.domain_names and kwargs.get(name, True):\n            getattr(self, name).join_fields(getattr(other, name))\n\n    return self\n</code></pre>"},{"location":"api/#npblender.Geometry.load_models","title":"<code>load_models(*specs)</code>  <code>staticmethod</code>","text":"<p>Load a geometry or geometries from specifications.</p> The specs can be <ul> <li>a Blender collection</li> <li>a Blender object</li> <li>a Geometry</li> </ul>"},{"location":"api/#npblender.Geometry.load_models--arguments","title":"Arguments","text":"<pre><code>- specs (list of objects / collections) : the models to load\n</code></pre>"},{"location":"api/#npblender.Geometry.load_models--returns","title":"Returns","text":"<pre><code>- list of geometries\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>@staticmethod\ndef load_models(*specs):\n    \"\"\" Load a geometry or geometries from specifications.\n\n    The specs can be:\n        - a Blender collection\n        - a Blender object\n        - a Geometry\n\n    Arguments\n    ---------\n        - specs (list of objects / collections) : the models to load\n\n    Returns\n    -------\n        - list of geometries\n    \"\"\"\n\n    from .mesh import Mesh\n    from .curve import Curve\n\n    models = []\n\n    for spec in specs:\n        # A list\n        if isinstance(spec, (list, tuple)):\n            models.extend(Geometry.load_models(*spec))\n            continue\n\n        # A collection\n        coll = blender.get_collection(spec, halt=False)\n        if coll is not None:\n            for obj in coll.objects:\n                geo = Geometry.load_object(obj)\n                if isinstance(geo, (Mesh, Curve)):\n                    models.append(geo)\n            continue\n\n        # An object\n        obj = blender.get_object(spec, halt=False)\n        if obj is not None:\n            geo = Geometry.load_object(obj)\n            if isinstance(geo, (Mesh, Curve)):\n                models.append(geo)\n            continue\n\n        # A valid geometry\n        if type(spec).__name__ in ['Mesh', 'Curve']:\n            models.append(spec)\n            continue\n\n        raise ValueError(f\"Unknown model (type '{type(spec)}'): {spec}\")\n\n    return models\n</code></pre>"},{"location":"api/#npblender.Geometry.load_object","title":"<code>load_object(name)</code>  <code>staticmethod</code>","text":"<p>Load a Blender object and returns either a Mesh or a Curve.</p>"},{"location":"api/#npblender.Geometry.load_object--arguments","title":"Arguments","text":"<pre><code>- name (str or bpy.types.Object) : the object to load\n</code></pre>"},{"location":"api/#npblender.Geometry.load_object--returns","title":"Returns","text":"<pre><code>- Mesh or Curve\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>@staticmethod\ndef load_object(name):\n    \"\"\" Load a Blender object and returns either a Mesh or a Curve.\n\n    Arguments\n    ---------\n        - name (str or bpy.types.Object) : the object to load\n\n    Returns\n    -------\n        - Mesh or Curve\n    \"\"\"\n\n    from .mesh import Mesh\n    from .curve import Curve\n\n    obj = blender.getobject(name)\n    if obj is None:\n        return None\n\n    if isinstance(obj.data, bpy.types.Mesh):\n        return Mesh.from_object(obj)\n\n    elif isinstance(obj.data, bpy.types.Curve):\n        return Curve.from_object(obj)\n\n    else:\n        raise Exception(f\"Geometry.load_object error: impossible to load the objet '{obj.name}' of type '{type(obj.data).__name__}'\")\n</code></pre>"},{"location":"api/#npblender.Instances","title":"<code>Instances</code>","text":"<p>               Bases: <code>Geometry</code></p> Source code in <code>npblender/instances.py</code> <pre><code>class Instances(Geometry):\n\n    def __init__(self, points=None, models=None, model_index=None, attr_from=None, **attributes):\n        \"\"\" Create new instances.\n\n        Arguments\n        ---------\n            - points (array of vectors = None) : instances locations\n            - models (geometry or list of geometries = None) : the geometries to instantiate\n            - model_index (int = 0) : model index of instances\n            - **attributes (dict) : other geometry attributes\n        \"\"\"\n        self.points  = Point()\n        self.join_attributes(attr_from)\n\n        if models is None:\n            self.models = []\n        else:\n            self.models = self.load_models(models)\n        self.low_resols = []\n\n        self.points.append(position=points, model_index=model_index, **attributes)\n\n    def check(self, title=\"Instances Check\", halt=True):\n        n = np.max(self.points.model_index)\n        if n &gt;= len(self.models):\n            print(title)\n            print(f\"Model index {n} greater than the number {len(self.models)} of models.\")\n            if halt:\n                assert(False)\n            return False\n        return True\n\n    def __str__(self):\n        return f\"&lt;Instances: {len(self)}, models: {len(self.models)}&gt;\"\n\n    def __len__(self):\n        return len(self.points)\n\n    # =============================================================================================================================\n    # Serialization\n    # =============================================================================================================================\n\n    def to_dict(self):\n        return {\n            'geometry':   'Instances',\n            'points':     self.points.to_dict(),\n            'models':     [model.to_dict() for model in self.models],\n            'low_resols': [[lr.to_dict() for lr in low_resol] for low_resol in self.low_resols]\n            }\n\n    @classmethod\n    def from_dict(cls, d):\n        insts = cls()\n        insts.points     = Point.from_dict(d['points'])\n        insts.models     = [Geometry.from_dict(model) for model in d['models']]\n        insts.low_resols = [[Geometry.from_dict(lrd) for lrd in low_resol_dict] for low_resol_dict in d['low_resols']]\n\n        return insts    \n\n    # ====================================================================================================\n    # Low scale models\n    # ====================================================================================================\n\n    def add_low_resol(self, dist, models):\n\n        ls_models = self.load_models(models)\n        if len(ls_models) != len(self.models):\n            raise ValueError(\n                f\"Instances.add_low_resol: the number of low scale models ({len(ls_models)}) \"\n                f\"is not equal to the number of models ({len(self.models)})\")\n\n        self.low_resols.append({\"dist\": dist, \"models\": ls_models})\n\n    def compute_low_resols(self, start_scale=.1, scale=.8, detail=1.):\n\n        from .camera import Camera\n        from .mesh import Mesh\n        from .curve import Curve\n\n        cam = Camera()\n\n        scale = np.clip(scale, .01, .99)\n\n        # Start scale\n        cur_scale = min(start_scale, 1.)\n\n        for _ in range(10):\n            max_count = None\n            min_dist = None\n            ls_models = []\n            for model in self.models:\n                d, ps = cam.distance_for_scale(model.max_size, scale=cur_scale)\n                if min_dist is None:\n                    min_dist = d\n                else:\n                    min_dist = min(d, min_dist)\n\n                if isinstance(model, Mesh):\n                    ls_models.append(model.simplified(cur_scale, ps/detail))\n                    if max_count is None:\n                        max_count = len(ls_models[-1].points)\n                    else:\n                        max_count = max(max_count, len(ls_models[-1].points))\n                else:\n                    ls_models.append(Curve.from_curve(model))\n\n            self.add_low_resol(min_dist, ls_models)\n            cur_scale *= scale\n\n            if max_count is None or max_count &lt;= 8:\n                break\n\n    def _sort_low_resols(self):\n\n        dist = np.array([item['dist'] for item in self.low_resols])\n        s = np.flip(np.argsort(dist))\n\n        return dist[s], [self.low_resols[i]['models'] for i in s]\n\n    # ====================================================================================================\n    # To Blender objects\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Realize as Mesh and Curve\n    # ----------------------------------------------------------------------------------------------------\n\n    def realize(self, camera_culling=False):\n\n        from . mesh import Mesh\n        from . curve import Curve\n        from . camera import Camera\n\n        # ---------------------------------------------------------------------------\n        # Camera\n        # ---------------------------------------------------------------------------\n\n        if camera_culling == False:\n            camera = None\n        else:\n            camera = Camera(camera_culling)\n            camera_culling = True\n\n        if camera_culling:\n            mdl_radius = np.zeros(len(self.models), bfloat)\n            for i, model in enumerate(self.models):\n                vmin = np.min(model.points.position, axis=0)\n                vmax = np.max(model.points.position, axis=0)\n                mdl_radius[i] = max(vmax[0] - vmin[0], vmax[1] - vmin[1], vmax[2] - vmin[2])\n\n            vis, dist = camera.visible_points(self.points.position, radius=mdl_radius[self.points.model_index])\n\n            vis = vis[:, camera.VISIBLE]\n            dist = dist[:, camera.DISTANCE]\n\n            if len(self.low_resols):\n                ls_dist, ls_all_models = self._sort_low_resols()\n\n        mesh  = Mesh()\n        curve = Curve()\n        insts = self.points\n\n        # ---------------------------------------------------------------------------\n        # Add a model on a selection\n        # ---------------------------------------------------------------------------\n\n        def _add_model(sel, model):\n\n            n = np.sum(sel)\n            if n == 0:\n                return\n\n            # --------------------------------------------------\n            # Instantiate the model\n            # --------------------------------------------------\n\n            geo = model*n\n\n            # --------------------------------------------------\n            # Transformation\n            # --------------------------------------------------\n\n            pts = insts[sel]\n\n            if \"scale\" in self.points.actual_names:\n                scale = pts.scale[:, None]\n            else:\n                scale = None\n\n            if self.points.has_rotation:\n                rot = pts.rotation[:, None]\n            else:\n                rot = None\n\n            geo.transformation(rotation=rot, scale=scale, translation=pts.position[:, None])\n\n            # --------------------------------------------------\n            # Add to realized geometry\n            # --------------------------------------------------\n\n            if type(model).__name__ == 'Mesh':\n                mesh.join(geo)\n\n            elif type(model).__name__ == 'Curve':\n                curve.join(geo)\n\n            else:\n                raise TypeError(f\"Instances.realize&gt; Unsupported model type: '{type(model)}'\")\n\n        # ---------------------------------------------------------------------------\n        # Loop on models\n        # ---------------------------------------------------------------------------\n\n        for model_index, model in enumerate(self.models):\n\n            # Selection on instances of the current model\n            sel = insts.model_index == model_index\n\n            # Visible instances\n            if camera_culling:\n                sel = np.logical_and(sel, vis)\n\n            # Low scale\n            if camera_culling and len(self.low_resols):\n                for d, ls_models in zip(ls_dist, ls_all_models):\n                    sel_dist = dist &gt; d\n                    ls_sel = np.logical_and(sel, sel_dist)\n                    _add_model(ls_sel, ls_models[model_index])\n                    sel = np.logical_and(sel, np.logical_not(sel_dist))\n\n            # Normal scale\n            _add_model(sel, model)\n\n        return {\n            'mesh': mesh if len(mesh.points) else None,\n            'curve': curve if len(curve.points) else None,\n            }\n\n    # ----------------------------------------------------------------------------------------------------\n    # To object\n    # ----------------------------------------------------------------------------------------------------\n\n    def to_object(self, name, profile=None, caps=True, use_radius=True, shade_smooth=True, camera_culling=False):\n\n        # Realize to mesh and curve\n        geos = self.realize(camera_culling=camera_culling)\n\n        # Curve to mesh\n        if geos['curve'] is not None and ((profile is not None) or camera_culling):\n            meshed = geos['curve'].to_mesh(profile=profile, caps=caps, use_radius=use_radius, camera_culling=camera_culling)\n            if geos['mesh'] is None:\n                geos['mesh'] = meshed\n            else:\n                geos['mesh'].join(meshed)\n            geos['curve'] = None\n\n        # Geometries to objects\n        both = (geos['mesh'] is not None) and (geos['curve'] is not None)\n\n        objects = {}\n\n        if geos['mesh'] is not None:\n            suffix = \" - (M)\" if both else \"\"\n            objects['mesh'] = geos['mesh'].to_object(f\"{name}{suffix}\", shade_smooth=shade_smooth)\n\n        if geos['curve'] is not None:\n            if both:\n                suffix = \" - (C)\" if both else \"\"\n            objects['curve'] = geos['curve'].to_object(f\"{name}{suffix}\")\n\n        return objects\n\n    # ====================================================================================================\n    # Dump \n    # ====================================================================================================\n\n    def models_to_object(self, name=\"Models\"):\n        from .mesh import Mesh\n        from .curve import Curve\n\n        mesh = Mesh()\n\n        if len(self.low_resols):\n            _, lr_all_models = self._sort_low_resols()\n\n        x = 0.\n        for i_model, model in enumerate(self.models):\n            bbox = model.bounding_box_dims\n\n            if isinstance(model, Mesh):\n                m = Mesh.from_mesh(model)\n            else:\n                m = model.to_mesh()\n\n            m.translate((x, 0, 0))\n            mesh.join(m)\n\n            # ----- Low resols\n\n            if not len(self.low_resols):\n                continue\n\n            z = bbox[2] + 1\n            for i in reversed(range(len(lr_all_models))):\n                mdl = lr_all_models[i][i_model]\n\n                if isinstance(mdl, Mesh):\n                    m = Mesh.from_mesh(mdl)\n                else:\n                    m = mdl.to_mesh()\n\n                m.translate((x, 0, z))\n                mesh.join(m)\n                z += 1 + bbox[2]\n\n            x += 1 + bbox[0]\n\n\n        return mesh.to_object(name, shade_smooth=False)\n\n    # ====================================================================================================\n    # Joining instances\n    # ====================================================================================================\n\n    def join(self, *others):\n\n        for other in others:\n\n            if not isinstance(other, Instances):\n                raise AttributeError(f\"Instances can be joined with Instances only, not {type(other).__name__}.\")\n            insts_count = len(self.points)\n            models_count = len(self.models)\n\n            self.models.extend(other.models)\n            self.points.extend(other.points, join_fields=True)\n            self.points[insts_count:] += models_count\n\n        return self\n\n    # ====================================================================================================\n    # Multiply\n    # ====================================================================================================\n\n    def multiply(self, count, in_place=True):\n\n        count = int(count)\n\n        if count == 0:\n            return None\n\n        if count == 1:\n            if in_place:\n                return self\n            else:\n                return type(self)(attr_from=self).join(self)\n\n        if not in_place:\n            return type(self)(attr_from=self).join(self).multiply(count, in_place=True)\n\n        self.points.mmultiply(count)\n\n        return self\n\n    def __mul__(self, count):\n        return self.multiply(count, in_place=False)\n\n    def __imul__(self, count):\n        return self.multiply(count, in_place=True)\n\n    # ====================================================================================================\n    # Operations\n    # ====================================================================================================\n\n    def clear_geometry(self):\n        self.points.clear()\n</code></pre>"},{"location":"api/#npblender.Instances.__init__","title":"<code>__init__(points=None, models=None, model_index=None, attr_from=None, **attributes)</code>","text":"<p>Create new instances.</p>"},{"location":"api/#npblender.Instances.__init__--arguments","title":"Arguments","text":"<pre><code>- points (array of vectors = None) : instances locations\n- models (geometry or list of geometries = None) : the geometries to instantiate\n- model_index (int = 0) : model index of instances\n- **attributes (dict) : other geometry attributes\n</code></pre> Source code in <code>npblender/instances.py</code> <pre><code>def __init__(self, points=None, models=None, model_index=None, attr_from=None, **attributes):\n    \"\"\" Create new instances.\n\n    Arguments\n    ---------\n        - points (array of vectors = None) : instances locations\n        - models (geometry or list of geometries = None) : the geometries to instantiate\n        - model_index (int = 0) : model index of instances\n        - **attributes (dict) : other geometry attributes\n    \"\"\"\n    self.points  = Point()\n    self.join_attributes(attr_from)\n\n    if models is None:\n        self.models = []\n    else:\n        self.models = self.load_models(models)\n    self.low_resols = []\n\n    self.points.append(position=points, model_index=model_index, **attributes)\n</code></pre>"},{"location":"api/#npblender.Mesh","title":"<code>Mesh</code>","text":"<p>               Bases: <code>Geometry</code></p> Source code in <code>npblender/mesh.py</code> <pre><code>class Mesh(Geometry):\n\n    domain_names = ['points', 'corners', 'faces', 'edges']\n\n    def __init__(self, points=None, corners=None, faces=None, edges=None, materials=None, attr_from=None, **attrs):\n        \"\"\" Mesh Geometry.\n\n        Arguments\n        ---------\n            - points (array of vectors = None) : the vertices\n            - corners (array of ints = None) : corners, i.e. indices on the array of points\n            - faces (array of ints = None) : size of the faces, the sum of this array must be equal to the length of the corners array\n            - edges (array of couples of ints = None) : list of edges defined by two vertex indices\n            - materials (str or list of strs = None) : list of materials used in the geometry\n            - attr_from (Geometry) : domain attributes to copy from\n            - **attrs (dict) : other geometry attributes\n        \"\"\"\n\n        # ----- Initialize an empty geometry\n\n        self.points  = Vertex()\n        self.corners = Corner()\n        self.faces   = Face()\n        self.edges   = Edge()\n\n        self.join_attributes(attr_from)\n\n        # ----- The materials\n\n        if materials is None:\n            self.materials = []\n        elif isinstance(materials, str):\n            self.materials = [materials]\n        else:\n            self.materials = [mat for mat in materials]\n\n        # ----- Add geometry\n\n        self.add_geometry(points, corners, faces, edges, **attrs)\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Utilities\n\n    @classmethod\n    def dummy(cls, points_count=0, corners_count=0, faces=None, edges=None, seed=0, **attrs):\n        rng = np.random.default_rng(seed)\n        verts = rng.uniform(-1, 1, (points_count, 3)) if points_count else None\n        corners = rng.uniform(0, points_count, corners_count) if corners_count else None\n        loops = None\n\n        if faces is None:\n            n = corners_count if corners_count else points_count\n            if n &gt; 0:\n                loops = [4] * (n //4)\n                loops[0] = n - np.sum(loops[1:])\n            else:\n                loops = None\n        else:\n            loops = faces\n\n        return cls(points=verts, corners=corners, faces=loops, edges=edges,**attrs)\n\n    def check(self, title=\"Mesh Check\", halt=True):\n        ok = self.corners.check(len(self.points), halt=False) and \\\n               self.faces.check(len(self.corners), halt=False) and \\\n               self.edges.check(len(self.points), halt=False)\n        if ok:\n            return True\n        elif halt:\n            raise Exception(f\"{title} check failed\")\n        else:\n            print(f\"{title} check failed\")\n\n\n    def __str__(self):\n        return f\"&lt;Mesh: points {len(self.points)}, corners {len(self.corners)}, faces {len(self.faces)}, edges {len(self.edges)}&gt;\"\n\n    def __repr__(self):\n        s = \"Mesh:\\n   \" + \"\\n   \".join([str(self.points), str(self.corners), str(self.faces)])\n        return s\n\n    # =============================================================================================================================\n    # Serialization\n    # =============================================================================================================================\n\n    def to_dict(self):\n        return {\n            'geometry':     'Mesh',\n            'materials' :   self.materials,\n            'points':       self.points.to_dict(),\n            'corners':      self.corners.to_dict(),\n            'faces':        self.faces.to_dict(),\n            'edges':        self.edges.to_dict(),\n            }\n\n    @classmethod\n    def from_dict(cls, d):\n        mesh = cls()\n        mesh.materials  = d['materials']\n        mesh.points     = Vertex.from_dict(d['points'])\n        mesh.corners    = Corner.from_dict(d['corners'])\n        mesh.faces      = Face.from_dict(d['faces'])\n        mesh.edges      = Edge.from_dict(d['edges'])\n        return mesh\n\n    # =============================================================================================================================\n    # Clear the geometry\n    # =============================================================================================================================\n\n    def clear_geometry(self):\n        \"\"\" Clear the geometry.\n\n        Delete all the content.\n        \"\"\"\n\n        self.points.clear()\n        self.corners.clear()\n        self.faces.clear()\n        self.edges.clear()\n\n    # =============================================================================================================================\n    # From another Mesh\n    # =============================================================================================================================\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Copy\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def from_mesh(cls, other, points=None, faces=None, edges=None):\n        \"\"\" Create a Mesh from another mesh.\n\n        Arguments\n        ---------\n            - other (Mesh) : the mesh to copy\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n        mesh = cls(materials=other.materials)\n        mesh.points  = Vertex(other.points,  mode='COPY')\n        mesh.corners = Corner(other.corners, mode='COPY')\n        mesh.faces   = Face(other.faces,   mode='COPY')\n        mesh.edges   = Edge(other.edges,    mode='COPY')\n\n        if points is None:\n            points_mask = None\n        else:\n            points_mask = np.ones(len(mesh.points), dtype=bool)\n            points_mask[points] = False\n\n        if faces is None:\n            faces_mask = None\n        else:\n            faces_mask = np.ones(len(mesh.faces), dtype=bool)\n            faces_mask[faces] = False\n\n        if edges is None:\n            edges_mask = None\n        else:\n            edges_mask = np.ones(len(mesh.edges), dtype=bool)\n            edges_mask[edges] = False\n\n        mesh.delete_vertices(points=points_mask, faces=faces_mask, edges=edges_mask)\n\n        return mesh\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Capture another Mesh\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def capture(self, other):\n        \"\"\" Capture the data of another Mesh.\n\n        Arguments\n        ---------\n            - other (Mesh) : the mesh to capture\n\n        Returns\n        -------\n            - self\n        \"\"\"\n\n        self.materials = other.materials\n\n        self.points  = other.points\n        self.corners = other.corners\n        self.faces   = other.faces\n        self.edges   = other.edges\n\n    # =============================================================================================================================\n    # Blender Interface\n    # =============================================================================================================================\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # From Mesh data\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def from_mesh_data(cls, data):\n        \"\"\" Initialize the geometry from a Blender Mesh\n\n        Arguments\n        ---------\n            - mesh (Blender Mesh instance) : the mesh to load\n        \"\"\"\n\n        from . import blender\n\n        bl_mesh = blender.get_mesh(data)\n\n        mesh = cls()\n\n        # ----- Materials\n\n        mesh.materials = [None if mat is None else mat.name for mat in bl_mesh.materials]\n\n        # ----- Vertices\n\n        n = len(bl_mesh.vertices)\n        if n != 0:\n            # Positions will be read as position attribute\n            mesh.points.resize(n)\n\n        # ----- Corners\n\n        n = len(bl_mesh.polygons)\n        if n != 0:\n            a = np.empty(len(bl_mesh.loops), bint)\n            bl_mesh.loops.foreach_get(\"vertex_index\", a)\n            mesh.corners.append(vertex_index=a)\n\n            a = np.empty(len(bl_mesh.polygons), bint)\n            bl_mesh.polygons.foreach_get(\"loop_total\", a)\n            mesh.faces.append_sizes(a)\n\n            del a\n\n        # ----- Edges\n\n        if len(bl_mesh.edges):\n            n = len(bl_mesh.edges)\n            a = np.empty(2*n, bint)\n            bl_mesh.edges.foreach_get(\"vertices\", a)\n            a = np.reshape(a, (n, 2))\n            mesh.edges.append(vertex0=a[:, 0], vertex1=a[:, 1])\n\n            del a\n\n            mesh.edges.remove_face_edges(mesh.faces.get_edges(mesh.corners))\n\n        # ----- Attributes\n\n        mesh.points.from_bl_attributes(bl_mesh.attributes)\n        mesh.corners.from_bl_attributes(bl_mesh.attributes)\n        mesh.faces.from_bl_attributes(bl_mesh.attributes)\n        mesh.edges.from_bl_attributes(bl_mesh.attributes)\n\n        return mesh\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # To Mesh data\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def to_mesh_data(self, data):\n        \"\"\" Write the geometry into a Blender Mesh\n\n        Arguments\n        ---------\n            - mesh (Blender Mesh instance) : the mesh to write\n        \"\"\"\n\n        from npblender import blender\n\n        bl_mesh = blender.get_data(data)\n        bl_mesh.clear_geometry()\n\n        # ----------------------------------------------------------------------------------------------------\n        # Materials\n\n        bl_mesh.materials.clear()\n        for mat_name in self.materials:\n            if mat_name is not None:\n                bl_mesh.materials.append(bpy.data.materials.get(mat_name))\n\n        # ----------------------------------------------------------------------------------------------------\n        # Vertices\n\n        points = self.points.ravel()\n        if len(points):\n            bl_mesh.vertices.add(len(points))\n\n        # ----------------------------------------------------------------------------------------------------\n        # Corners\n\n        corners = self.corners.ravel()\n        if len(corners):\n            bl_mesh.loops.add(len(corners))\n            bl_mesh.loops.foreach_set(\"vertex_index\", blender.int_array(corners.vertex_index))\n\n        # ----------------------------------------------------------------------------------------------------\n        # Faces\n\n        faces = self.faces.ravel()\n        if len(faces):\n            bl_mesh.polygons.add(len(faces))\n            bl_mesh.polygons.foreach_set(\"loop_start\", blender.int_array(faces.loop_start))\n            bl_mesh.polygons.foreach_set(\"loop_total\", blender.int_array(faces.loop_total))\n\n        # ----------------------------------------------------------------------------------------------------\n        # Edges\n\n        edges = self.edges.ravel()\n        if len(self.edges):\n            # edges to add\n            add_edges = self.edges.vertices\n\n            # edges have been created by faces\n            if len(faces):\n                bl_mesh.update()\n\n                cur_n = len(bl_mesh.edges)\n                if cur_n &gt; 0:\n                    a = np.empty((cur_n, 2), dtype=bint)\n                    bl_mesh.edges.foreach_get('vertices', a.ravel())\n\n                add_edges = np.append(a, add_edges, axis=0)\n\n            # add the edges\n            n = len(edges)\n            bl_mesh.edges.add(n)\n\n            bl_mesh.edges.foreach_set('vertices', add_edges.ravel())\n\n        # ----------------------------------------------------------------------------------------------------\n        # Attributes\n\n        attributes = data.attributes\n\n        points.to_bl_attributes(attributes, update=False)\n        corners.to_bl_attributes(attributes, update=False)\n        faces.to_bl_attributes(attributes, update=False)\n        edges.to_bl_attributes(attributes, update=False)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Update\n\n        bl_mesh.update()\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Initialize from an object\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def from_object(cls, obj, evaluated=False):\n        \"\"\" Create a Mesh from an existing object.\n\n        Arguments\n        ---------\n            - obj (str or Blender object) : the object to initialize from\n            - evaluated (bool = False) : object modified by the modifiers if True, raw vertices otherwise\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n\n        from . import blender\n\n        if evaluated:\n            depsgraph = bpy.context.evaluated_depsgraph_get()\n            object_eval = blender.get_object(obj).evaluated_get(depsgraph)\n            return cls.FromMeshData(object_eval.data)\n\n        else:\n            return cls.from_mesh_data(blender.get_object(obj).data)\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # To blender object\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def to_object(self, obj, shade_smooth=None, shapekeys=None, collection=None):\n        \"\"\" Create or update a blender object.\n\n        The method 'to_object' creates the whole geometry. It creates a new object if it doesn't already exist.\n        If the object exists, it must be a mesh, there is no object type conversion.\n\n        Once the object is created, use the method 'update_object' to change the vertices.\n\n        Arguments\n        ---------\n            - obj (str or Blender object) : the object the create\n\n        Returns\n        -------\n            - Blender mesh object\n        \"\"\"\n\n        from npblender import blender\n\n        res = blender.create_mesh_object(obj, collection=collection)\n        self.to_mesh_data(res.data)\n\n        if shade_smooth is not None:\n            res.data.polygons.foreach_set('use_smooth', [shade_smooth]*len(res.data.polygons))\n\n        if shapekeys is not None:\n            if shapekeys is not None:\n                if isinstance(shapekeys, ShapeKeys):\n                    shapekeys.to_mesh_object(obj)\n                else:\n                    for sks in shapekeys:\n                        sks.to_mesh_object(obj)\n\n        return res\n\n    # ====================================================================================================\n    # bmesh edition\n    # ====================================================================================================\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # bmesh utility to pass from internal geometry to bmesh\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def _bm_verts(self, bm):\n        nverts = len(self.points.ravel())\n        verts  = np.zeros(nverts, dtype=object)\n        for vert in bm.verts:\n            verts[vert.index] = vert\n        return verts\n\n    def _bm_edges(self, bm):\n        nedges = len(bm.edges)\n        edges  = np.empty(nedges, dtype=object)\n        verts  = np.empty((nedges, 2), dtype=bint)\n\n        for i_edge, edge in enumerate(bm.edges):\n            edges[i_edge] = edge\n\n            i0, i1 = edge.verts[0].index, edge.verts[1].index\n            verts[i_edge] = (i0, i1) if i0 &lt; i1 else (i1, i0)\n\n        return edges, verts\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # bmesh context\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    @contextmanager\n    def bmesh(self, readonly=False):\n        \"\"\" Acces to bmesh api.\n\n        The example below use bmesh to offset the vertices of +1 in the x axis.\n\n        ``` python\n        mesh = Mesh.Cube()\n\n        # Move the vertices with bmesh\n        with mesh.bmesh() as bm:\n            for v in bm.verts:\n                v.co.x += 1.0\n\n        # Move the vertices directy in numpy array\n        mesh.points.position[:, 1] += 1\n\n        # Cube moved along x and y\n        mesh.to_object(\"Cube\")\n        ```\n\n        Arguments\n        ---------\n            - readonly (bool=False) : avoid to read back the bmesh if not modications were done\n        \"\"\"\n\n        data = bpy.data.meshes.get(DATA_TEMP_NAME)\n        if data is None:\n            data = bpy.data.meshes.new(DATA_TEMP_NAME)\n        self.to_mesh_data(data)\n\n        bm = bmesh.new()   # create an empty BMesh\n        bm.from_mesh(data) # fill it in from a Mesh\n\n        yield bm\n\n        # ----- Back\n\n        if not readonly:\n            bm.to_mesh(data)\n            self.capture(Mesh.from_mesh_data(data))\n\n        bm.free()\n\n    # ====================================================================================================\n    # Mesh data edition\n    # ====================================================================================================\n\n    @contextmanager\n    def blender_data(self, readonly=False):\n        \"\"\" Acces to Blender Mesh API.\n\n        Transfer the geometry to a temporay Blender Mesh.\n        The example below use a blender Mesh to get the normals.\n\n        ``` python\n        mesh = Mesh.Cube()\n\n        with mesh.blender_data() as data:\n            normals = np.array([poly.normal for poly in data.polygons])\n\n        print(normals)\n\n        # &gt; [[-1. -0.  0.]\n        #    [ 0.  1.  0.]\n        #    [ 1. -0.  0.]\n        #    [ 0. -1.  0.]\n        #    [ 0.  0. -1.]\n        #    [ 0. -0.  1.]]\n        ```\n\n        Arguments\n        ---------\n            - readonly (bool=False) : don't read back the geometry if not modified\n\n        Returns\n        -------\n            - Blender Mesh\n        \"\"\"\n\n        data = bpy.data.meshes.get(DATA_TEMP_NAME)\n        if data is None:\n            data = bpy.data.meshes.new(DATA_TEMP_NAME)\n\n        self.to_mesh_data(data)\n\n        yield data\n\n        # ----- Back\n\n        if not readonly:\n            self.capture(Mesh.from_mesh_data(data))\n\n    # ====================================================================================================\n    # From something\n    # ====================================================================================================\n\n    @classmethod\n    def from_model(cls, model, materials=None):\n\n        if isinstance(model, (str, bpy.types.Object)):\n            mesh = cls.from_object(model, evaluated=True)\n\n        elif isinstance(model, dict):\n            mesh = cls.from_dict(model)\n\n        elif isinstance(model, Mesh):\n            mesh = cls.from_mesh(model)\n\n        elif isinstance(model, bpy.types.Mesh):\n            mesh = cls.from_mesh_data(model)\n\n        else:\n            raise Exception(f\"Mesh.from_model: 'model' type is not valid: {type(model)}\")\n\n        return mesh\n\n    # =============================================================================================================================\n    # Utility\n    # =============================================================================================================================\n\n    def get_faces_position(self, selection=None):\n        if selection is None:\n            return self.faces[selection].get_position(self.corners, self.points)\n        else:\n            return self.faces[selection].get_position(self.corners, self.points)\n\n    # =============================================================================================================================\n    # Combining\n    # =============================================================================================================================\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Join other meshes\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def join(self, *others):\n        \"\"\" Join other Meshes.\n\n        Arguments\n        ---------\n            - others (Mesh) : the Mesh to append\n        \"\"\"\n        for other in others:\n\n            # ----------------------------------------------------------------------------------------------------\n            # Vertices\n\n            v_ofs = len(self.points)\n            self.points.extend(other.points)\n\n            # ----------------------------------------------------------------------------------------------------\n            # Corners\n\n            c_ofs = len(self.corners)\n            self.corners.extend(other.corners)\n            if len(self.corners):\n                self.corners.vertex_index[c_ofs:] += v_ofs\n\n            # ----------------------------------------------------------------------------------------------------\n            # Faces\n\n            f_ofs = len(self.faces)\n            self.faces.extend(other.faces)\n            if len(self.faces):\n                self.faces.loop_start[f_ofs:] += c_ofs\n\n            # ----------------------------------------------------------------------------------------------------\n            # Edges\n\n            e_ofs = len(self.edges)\n            self.edges.extend(other.edges)\n            if len(self.edges):\n                self.edges.vertex0[e_ofs:] += v_ofs\n                self.edges.vertex1[e_ofs:] += v_ofs\n\n            # ----- Materials\n\n            remap = np.array([self.get_material_index(mat_name) for mat_name in other.materials])\n            if len(remap)&gt;0:\n                self.faces.material_index[f_ofs:] = remap[other.faces.material_index]\n\n        return self\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Multiply\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def multiply(self, count, in_place=True):\n        \"\"\" Duplicate the geometry.\n\n        Multiplying is a way to efficiently duplicate the geometry a great number of times.\n        Once duplicated, the vertices can be reshapped to address each instance individually.\n\n        ``` python\n        count = 16\n\n        cube = Mesh.Cube() * count\n\n        # Shape the points as 16 blocks of 8 vertices\n        points = np.reshape(cube.points.position, (16, 8, 3))\n\n        # Place the cubes in a circle\n        ags = np.linspace(0, 2*np.pi, count, endpoint=False)\n        points[..., 0] += 6 * np.cos(ags)[:, None]\n        points[..., 1] += 6 * np.sin(ags)[:, None]\n\n        cube.to_object(\"Cubes\")\n        ```\n\n        Arguments\n        ---------\n            - count (int=10) : number of instances\n            - attributes (name=value) : value for named attributes\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n\n        # ----------------------------------------------------------------------------------------------------\n        # Checks and simple cases\n\n        if not isinstance(count, (int, np.int32, np.int64)):\n            raise Exception(f\"A Mesh can be multiplied only by an int, not '{count}'\")\n\n        if count == 0:\n            return None\n\n        if count == 1:\n            if in_place:\n                return self\n            else:\n                return type(self).from_mesh(self)\n\n        if not in_place:\n            return type(self).from_mesh(self).multiply(count, in_place=True)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Vertices\n\n        nverts = len(self.points)\n        self.points.multiply(count)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Corners\n\n        ncorners = len(self.corners)\n        self.corners.multiply(count)\n        self.corners.vertex_index += np.repeat(np.arange(count)*nverts, ncorners)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Faces\n\n        self.faces.multiply(count)\n        self.faces.update_loop_start()\n\n        # ----------------------------------------------------------------------------------------------------\n        # Edges\n\n        nedges = len(self.edges)\n        self.edges.multiply(count)\n        ofs = np.repeat(np.arange(count)*nverts, nedges)\n        self.edges.vertex0 += ofs\n        self.edges.vertex1 += ofs\n\n        return self\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Operators\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def __mul__(self, count):\n        return self.multiply(count, in_place=False)\n\n    def __imul__(self, count):\n        return self.multiply(count, in_place=True)\n\n    # =============================================================================================================================\n    # Editing\n    # =============================================================================================================================\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Extract attributes per domain\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def _attributes_per_domain(self, **attrs):\n\n        dispatched = {\n            'points'  : {},\n            'corners' : {},\n            'faces'   : {},\n            'edges'   : {},\n            }\n\n        for k, v in attrs.items():\n            count = 0\n\n            if k in self.points.all_names:\n                dispatched['points'][k] = v\n                count += 1\n\n            if k in self.corners.all_names:\n                dispatched['corners'][k] = v\n                count += 1\n\n            if k in self.faces.all_names:\n                dispatched['faces'][k] = v\n                count += 1\n\n            if k in self.edges.all_names:\n                dispatched['edges'][k] = v\n                count += 1\n\n            if count == 0:\n                raise AttributeError(f\"Unknown mesh attribute '{k}'.\\n\"\n                                     f\"- points:  {self.points.all_names}\\n\"\n                                     f\"- corners: {self.corners.all_names}\\n\"\n                                     f\"- faces:   {self.faces.all_names}\\n\"\n                                     f\"- edges:   {self.edges.all_names}\\n\"\n                                     )\n\n            if count &gt; 1:\n                raise AttributeError(f\"Mesh add_geometry&gt; attribute '{k}' is ambigous, it belongs to more than one domain (count).\\n\"\n                                     f\"- points:  {self.points.all_names}\\n\"\n                                     f\"- corners: {self.corners.all_names}\\n\"\n                                     f\"- faces:   {self.faces.all_names}\\n\"\n                                     f\"- edges:   {self.edges.all_names}\\n\"\n                                     )\n        return dispatched\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Add geometry\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def add_geometry(self, points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs):\n        \"\"\" Add geometry\n\n        Note that the added geometry can refer to existing vertices. It is appended as is, whithout shifting\n        indices.\n\n        To add independant geometry, use join_geometry.\n\n        ``` python\n        cube = Mesh.cube()\n        # add a triangle on existing vertices\n        # corners argument refers to cube vertices\n        cube.add_geometry(corners=[0, 1, 2], faces=3)\n\n        # add a triangle with additional vertices\n        # corners argument refers to the new vertices\n        cube.join_geometry(points=[[0, 0, 0], [0, 1, 0], [1, 0, 0]], corners=[0, 1, 2], faces=3)\n        ```\n\n        Arguments\n        ---------\n            - points (array of vectors = None) : the vertices\n            - corners (array of ints = None) : corners, i.e. indices on the array of points\n            - sizes (array of ints = None) : size of the faces, the sum of this array must be equal to the length of the corners array\n            - materials (str or list of strs = None) : list of materials used in the geometry\n            - **attrs (dict) : other geometry attributes\n\n        Returns\n        -------\n            - dict : {'points', 'corners', 'faces', 'edges': added geometry indices}\n        \"\"\"\n\n        disp_attrs = self._attributes_per_domain(**attrs)\n        added = {'points': [], 'corners': [], 'faces': [], 'edges': []}\n\n        # ----------------------------------------------------------------------------------------------------\n        # Add vertices\n        # ----------------------------------------------------------------------------------------------------\n\n        if points is not None:\n            added['points'] = self.points.append(position=points, **disp_attrs['points'])\n\n        # ----------------------------------------------------------------------------------------------------\n        # Edges\n        # ----------------------------------------------------------------------------------------------------\n\n        if edges is not None:\n            if np.shape(edges) == (2,):\n                added['edges'] = self.edges.append(vertex0=edges[0], vertex1=edges[1], **disp_attrs['edges'])\n            else:\n                added['edges'] = self.edges.append(vertex0=edges[:, 0], vertex1=edges[:, 1], **disp_attrs['edges'])\n\n        # ----------------------------------------------------------------------------------------------------\n        # Corners and Faces\n        # ----------------------------------------------------------------------------------------------------\n\n        # If corners is provided, faces can be:\n        # - None -&gt; single face made of all corners\n        # - int -&gt; faces are all the same size (len(corners) must be a multiplief of faces)\n        # - array like -&gt; face sizes (len(corners) == np.sum(faces))\n        #\n        # If faces is provided, corners can be:\n        # - None -&gt; faces must be an array of arrays, each array being of list of corners\n        # - not None -&gt; see above\n\n        ok_faces = True\n        if corners is None:\n            if faces is None:\n                ok_faces = False\n            else:\n                corners = []\n                sizes = []\n                ok = hasattr(faces, '__len__')\n                if ok:\n                    for face in faces:\n                        ok = hasattr(faces, '__len__') and len(face) &gt; 2\n                        if not ok:\n                            break\n                        corners.extend(face)\n                        sizes.append(len(face))\n                if not ok:\n                    raise ValueError(f\"Mesh add_geometry&gt; when corners is None, faces must be None or an array of arrays, each array being of list of corners.\")\n                faces = sizes\n\n        else:\n            corners = np.asarray(corners)\n            ncorners = len(corners)\n            if faces is None:\n                faces = [ncorners]\n\n            else:\n                faces = np.asarray(faces)\n                if faces.shape == ():\n                    size = int(faces)\n                    if ncorners % size != 0:\n                        raise ValueError(f\"Mesh add_geometry&gt; when faces is a single number {size}, it must divide the number of corners ({ncorners}).\")\n                    faces = [size]*(ncorners // size)\n                else:\n                    if np.sum(faces) != ncorners:\n                        raise ValueError(f\"Mesh add_geometry&gt; the sum of faces ({np.sum(faces)}) must be equal to the number of corners ({ncorners}).\")\n\n        if ok_faces:\n            added['corners'] = self.corners.append(vertex_index=corners, **disp_attrs['corners'])\n            added['faces'] = self.faces.append_sizes(faces, **disp_attrs['faces'])\n\n        if False: # OLD\n            if np.shape(faces) == ():\n                nfaces = len(corners) // faces\n                if len(corners) % faces != 0:\n                    raise ValueError(f\"Mesh add_geometry&gt; when faces is a single number {faces}, it must divide the number of corners ({len(corners)}).\")\n                faces = np.ones(nfaces, dtype=bint)*faces\n\n            added['corners'] = self.corners.append(vertex_index=corners, **disp_attrs['corners'])\n            added['faces'] = self.faces.append_sizes(faces, **disp_attrs['faces'])\n\n        if safe_mode:\n            self.check()\n\n        return added\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Join geometry\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def join_geometry(self, points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs):\n        \"\"\" Join geometry defined by components.\n\n        The geometry passed in argument is consistent and doesn't refer to existing vertices. It is used\n        to build an independant mesh which is then joined.\n        See 'add_geometry' which, on the contrary, can refer to existing vertices.\n\n        Returns\n        -------\n            - self\n        \"\"\"\n        mesh = Mesh(attr_from=self)\n        mesh.add_geometry(\n            points=points, \n            corners=corners, \n            faces=faces, \n            edges=edges,\n            **attrs)\n        self.join(mesh)\n        return self\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Add Vertices\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def add_points(self, points,  **attributes):\n        \"\"\" Add vertices.\n\n        Arguments\n        ---------\n            - points (array of vectors) : the vertices to add\n            - attributes (name=value) : value for named attributes\n\n        Returns\n        -------\n            - array of ints : indices of the added vertices\n        \"\"\"\n        npoints = len(self.points)\n        return self.points.append(position=points, **attributes)\n\n    # =============================================================================================================================\n    # Split edges\n    # =============================================================================================================================\n\n    def split_edges(self, loop0, loop1, cuts=1):\n\n        n0 = 1 if np.shape(loop0) == () else len(loop0)\n        n1 = 1 if np.shape(loop1) == () else len(loop1)\n        n = max(n0, n1)\n        if n0 == n:\n            loop0 = np.atleast_1d(loop0, dtype=bint)\n        else:\n            loop0 = np.ones(n, dtype=bint)*loop0\n\n        if n1 == n:\n            loop1 = np.atleast_1d(loop1, dtype=bint)\n        else:\n            loop1 = np.ones(n, dtype=bint)*loop1\n\n        to_select = np.stack([np.minimum(loop0, loop1), np.maximum(loop0, loop1)], axis=-1)  # shape (p, 2)\n        with self.bmesh() as bm:\n\n            edges, verts_indices = self._bm_edges(bm)\n\n            # select edges in to_select\n            dtype = np.dtype([('a', bint), ('b', bint)])\n            edges_view = verts_indices.view(dtype)\n            to_select_view = to_select.view(dtype)\n\n            # selection mask\n            mask = np.isin(edges_view.ravel(), to_select_view.ravel())\n\n            edges_to_cut = list(edges[mask])\n\n            if len(edges_to_cut) == 0:\n                return\n\n            # Edges subidivision\n            bmesh.ops.subdivide_edges(\n                bm,\n                edges=edges_to_cut,\n                cuts=cuts,\n                use_grid_fill=False\n            )\n\n    # =============================================================================================================================\n    # Bridge loops\n    # =============================================================================================================================\n\n    def bridge_loops(self, loop0, loop1, close=False, segments=1, **attributes):\n        \"\"\" Create a grid linking two loops of the same size.\n\n        Arguments\n        ---------\n        - loop0 (array of ints) : the first loop\n        - loop1 (array of ints) : the second loop\n        - segments (int = 1) : the number of segments to join the loops\n        - attributes (dict) : attributes to add to the mesh\n        \"\"\"\n        segments = max(1, segments)\n\n        if close:\n            loop0 = np.append(loop0, loop0[0]).astype(bint)\n            loop1 = np.append(loop1, loop1[0]).astype(bint)\n        else:\n            loop0 = np.asarray(loop0, dtype=bint)\n            loop1 = np.asarray(loop1, dtype=bint)\n\n        sel0 = np.stack((loop0[:-1], loop0[1:]), axis=-1)\n        sel1 = np.stack((loop1[:-1], loop1[1:]), axis=-1)\n\n        sel0 = np.sort(sel0, axis=-1)\n        sel1 = np.sort(sel1, axis=-1)\n\n        with self.bmesh() as bm:\n\n            edges, verts_indices = self._bm_edges(bm)\n\n            # Prepare edges view\n            dtype = np.dtype([('a', bint), ('b', bint)])\n            edges_view = verts_indices.view(dtype)\n\n            # First loop\n            sel0_view = sel0.view(dtype)\n            mask = np.isin(edges_view.ravel(), sel0_view.ravel())\n\n            edges_to_bridge = list(edges[mask])\n\n            # Second loop\n            sel1_view = sel1.view(dtype)\n            mask = np.isin(edges_view.ravel(), sel1_view.ravel())\n\n            edges_to_bridge.extend(list(edges[mask]))\n\n            if len(edges_to_bridge) == 0:\n                return\n\n            # Bridge\n            res = bmesh.ops.bridge_loops(\n                bm, \n                edges=edges_to_bridge,\n                #use_cyclic = close,\n                #segments=segments,\n                )\n\n            # Grid\n            if segments &gt; 1:\n                bmesh.ops.subdivide_edges(\n                    bm,\n                    edges=res['edges'],\n                    cuts=segments - 1,\n                    use_grid_fill=False\n                )\n\n    # =============================================================================================================================\n    # Fill cap\n    # =============================================================================================================================\n\n    def fill_cap(self, loop, mode='NGON', center=None, segments=1, clockwise=False, **attributes):\n        \"\"\" Fill a cap between an existing loop\n\n        For NGON mode, center is not required.\n        For FANS mode, a center point is required:\n        - if center is None, it is computed as the center of the loop\n        - if center is an int, it is the index of the point to use\n        - otherwise, the center is considered as the point to use\n\n        Arguments\n        ---------\n        - loop (array of ints) : the circle loop\n        - mode (FillCap = 'NGON') : NGON or FANS\n        - center (point index or point or None) : center of the cap\n        - clockwise (bool = False) : order of the corners in the loop\n        - indexing (str = 'ij') : indexing of the points\n        - attributes (dict) : attributes to add to the mesh (see Geometry.add_geometry(\n        \"\"\"\n        if mode == 'NONE':\n            # To have en empty dict\n            return self.add_geometry()\n\n        elif mode == 'NGON':\n            return self.add_geometry(corners=loop, faces=len(loop), UVMap=self.disk_uv_map(len(loop), mode='NGON', clockwise=clockwise), **attributes)\n\n        elif mode == 'FANS':\n\n            if center is None:\n                verts = self.points.position[loop]\n                center = np.average(verts, axis=0)\n                center_index = len(self.points)\n                cind = self.add_points(center)\n\n            elif isinstance(center, (int, np.int32, np.int64)):\n                center_index = center\n                cind = [center_index]\n\n            else:\n                center_index = len(self.points)\n                cind = self.add_points(center)\n\n            indices = np.append(loop, center_index)\n\n            topo = fans_corners(len(loop), close=True, clockwise=clockwise).ravel()\n\n            corners = indices[topo]\n            uv_map = disk_uv_map(len(loop), mode='FANS', clockwise=clockwise).reshape(-1, 2)\n\n            added = self.add_geometry(corners=corners, faces=3, UVMap=uv_map, **attributes)\n            added['points'] = np.asarray(cind)\n\n            # More than one segments\n\n            if segments &gt; 1:\n                self.split_edges(loop, center_index, cuts=segments - 1)\n\n            return added\n\n        assert(False)\n\n    # ====================================================================================================\n    # Deletion\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Delete faces\n    # ----------------------------------------------------------------------------------------------------\n\n    def delete_faces(self, selection):\n        \"\"\" Delete only faces.\n        \"\"\"\n        self.faces.delete_loops(selection, self.corners)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Delete vertices\n    # ----------------------------------------------------------------------------------------------------\n\n    def delete_vertices(self, points=None, faces=None, edges=None):\n        \"\"\"Delete vertices.\n\n        Arguments\n        ---------\n            points : array selection, optional\n                Vertex indices to delete directly.\n            faces : array selection, optional\n                Faces owning vertices to delete.\n            edges : array selection, optional\n                Edges owning vertices to delete.\n        \"\"\"\n        go = False\n        if points is not None:\n            p_sel = set(np.arange(len(self.points))[points])\n            go = True\n        if faces is not None:\n            f_sel = set(np.arange(len(self.faces))[faces])\n            go = True\n        if edges is not None:\n            e_sel = set(np.arange(len(self.edges))[edges])\n            go = True\n\n        if not go:\n            return \n\n        with self.bmesh() as bm:\n            verts_to_delete = set()\n\n            for vert in bm.verts:\n                if points is not None and vert.index in p_sel:\n                    verts_to_delete.add(vert)\n                    continue\n\n                if faces is not None:\n                    if any(f.index in f_sel for f in vert.link_faces):\n                        verts_to_delete.add(vert)\n                        continue\n\n                if edges is not None:\n                    if any(e.index in e_sel for e in vert.link_edges):\n                        verts_to_delete.add(vert)\n                        continue\n\n            bmesh.ops.delete(bm, geom=list(verts_to_delete), context='VERTS')\n\n    # ====================================================================================================    \n    # Blender primitives\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Grid\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def bl_grid(cls, x_segments=1, y_segments=1, size=2, materials=None):\n        \"\"\" Create a Grid.\n\n        Blender constructor for a Grid.\n\n        Arguments\n        ---------\n            - x_segments (int=1) : number of segments along x axis\n            - y_segments (int=1) : number of segments along y axis\n            - size (float or tuple of floats = 1. : size of the grid\n            - materials (list of strs = None) : materials list\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n\n        mesh = cls(materials=materials)\n        with mesh.bmesh() as bm:\n            bmesh.ops.create_grid(bm, x_segments=x_segments, y_segments=y_segments, size=size, calc_uvs=True)\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Circle\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def bl_circle(cls, radius=1, segments=16, fill_tris=False, materials=None):\n        \"\"\" Create a Circle.\n\n        Blender constructor for a Circle.\n\n        Arguments\n        ---------\n            - radius (float=1.) : circle radius\n            - segments (int=16) : number of segments\n            - fill_tris (bool = False) : fill with triangle fans\n            - materials (list of strs = None) : materials list\n            - transformation (Transformations = None) : the transformation to apply\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n\n        mesh = cls(materials=materials)\n        with mesh.bmesh() as bm:\n            bmesh.ops.create_circle(bm, cap_ends=True, cap_tris=fill_tris, segments=segments, radius=radius, calc_uvs=True)\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Cone\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def bl_cone(cls, radius1=1, radius2=0, depth=2, segments=16, side_segments=1, cap_ends=True, cap_tris=False, materials=None):\n        \"\"\" Create a Cone.\n\n        Blender constructor for a Cone.\n\n        Arguments\n        ---------\n            - radius1 (float=1.) : base radius\n            - radius2 (float=0.) : top radius\n            - depth (float=2.) : cone height\n            - segments (int=16) : number of segments\n            - cap_ends (bool=True) : fill cap faces\n            - cap_tris (bool = False) : fill with triangle fans\n            - materials (list of strs = None) : materials list\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n\n        mesh = cls(materials=materials)\n        with mesh.bmesh() as bm:\n            res = bmesh.ops.create_cone(bm, cap_ends=cap_ends, cap_tris=cap_tris, segments=segments, radius1=radius1, radius2=radius2, depth=depth, calc_uvs=True)\n            if side_segments &gt; 1:\n\n                edges_to_cut = [\n                    e for e in bm.edges\n                    if (e.verts[0].co.z &gt; 0 and e.verts[1].co.z &lt; 0)\n                    or (e.verts[0].co.z &lt; 0 and e.verts[1].co.z &gt; 0)\n                ]\n\n                # Edges subidivision\n                bmesh.ops.subdivide_edges(\n                    bm,\n                    edges         = edges_to_cut,\n                    cuts          = side_segments - 1,\n                    use_grid_fill = False\n                )\n\n        return mesh\n\n    # ====================================================================================================    \n    # Primitives\n    # ====================================================================================================    \n\n\n    # ----------------------------------------------------------------------------------------------------\n    # Points\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def points_cloud(cls, points=None, materials=None):\n        \"\"\" Create a mesh with points at the given positions.\n\n        Arguments\n        ---------\n            - position (shaped array (?, 3)=(0, 0, 0) : position of the points\n\n        Returns\n        -------\n            - mesh (Mesh) : the mesh\n        \"\"\"\n        return cls(points=points, materials=materials)\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Line\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def line(cls, start=(0, 0, 0), end=(0, 0, 1), segments=1, materials=None):\n        \"\"\" Create a mesh with lines between the given positions.\n\n        Arguments\n        ---------\n            - start (vertex =(0, 0, 0) : position of the start of the lines\n            - end (vertex=(0, 0, 1) : position of the end of the lines\n            - count (int=2) : number of points in the line\n\n        Returns\n        -------\n            - mesh (Mesh) : the mesh\n        \"\"\"\n        segments = max(1, segments)\n\n        start = np.asarray(start, dtype=bfloat)\n        end   = np.asarray(end, dtype=bfloat)\n\n        pos = np.linspace(start, end, segments + 1) # shape (segments, n points, 3)\n\n        if len(pos.shape) == 2:\n            edges = border_edges(np.arange(segments))\n        else:\n            shape = pos.shape[:-1]\n            n = int(np.prod(shape))\n            edges = col_edges(np.arange(n).reshape(shape))\n\n        return cls(points=pos.reshape(-1, 3), edges=edges.reshape(-1, 2), materials=materials)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Grid\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def grid(cls, size_x=1, size_y=1, vertices_x=3, vertices_y=3, materials=None):\n        \"\"\" Create a Grid.\n\n        &gt; [!IMPORTANT]\n        &gt; Grid is created with indexing = 'ij': shape = (resolution x, resolution y)\n\n        Arguments\n        ---------\n            - size_x (float=1) : size along x\n            _ size_y (float=1) : size along y\n            - vertices_x (int=3) : number of vertices along x\n            - vertices_y (int=3) : number of vertices along y\n            - materials (list of strs = None) : materials list\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n\n        nx = max(2, vertices_x)\n        ny = max(2, vertices_y)\n\n        topo = grid_corners(nx, ny).ravel()\n\n        # ----------------------------------------------------------------------------------------------------\n        # Base grid for points and uvs\n\n        x, y = np.meshgrid(\n            np.linspace(-size_x/2, size_x/2, nx, dtype=bfloat), \n            np.linspace(-size_y/2, size_y/2, ny, dtype=bfloat), \n            indexing='ij')\n        x, y = x.ravel(), y.ravel()\n\n        # ----------------------------------------------------------------------------------------------------\n        # Let 's build the grid\n\n        points = np.stack((x, y, np.zeros_like(x)), axis=-1)\n        corners = np.arange(len(points))[topo]\n        faces = 4\n        uvmap = grid_uv_map(nx, ny).reshape(-1, 2)\n\n        return cls(points, corners, faces, materials=materials, UVMap=uvmap)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Cube\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def cube(cls, size=2, materials=None):\n        \"\"\" Create a Cube.\n\n        Arguments\n        ---------\n            - size (float=1.) : size of the cube\n            - materials (list of strs = None) : materials list\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n\n        verts = [[-1., -1., -1.], [-1., -1.,  1.], [-1.,  1., -1.], [-1.,  1.,  1.], [ 1., -1., -1.], [ 1., -1.,  1.], [ 1.,  1., -1.], [ 1.,  1.,  1.],]\n        corners = [0, 1, 3, 2,  2, 3, 7, 6,  6, 7, 5, 4,  4, 5, 1, 0,  2, 6, 4, 0,  7, 3, 1, 5]\n        faces = [4]*6\n        uvs   = [[0.375, 0.000], [0.625, 0.000], [0.625, 0.250], [0.375, 0.250], [0.375, 0.250], [0.625, 0.250], [0.625, 0.500], [0.375, 0.500],\n                 [0.375, 0.500], [0.625, 0.500], [0.625, 0.750], [0.375, 0.750], [0.375, 0.750], [0.625, 0.750], [0.625, 1.000], [0.375, 1.000],\n                 [0.125, 0.500], [0.375, 0.500], [0.375, 0.750], [0.125, 0.750], [0.625, 0.500], [0.875, 0.500], [0.875, 0.750], [0.625, 0.750], ]\n\n\n        mesh = cls(points=verts, corners=corners, faces=faces, materials=materials, UVMap=uvs)\n\n        size = np.asarray(size)\n        mesh.points.position *= size/2\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Circle\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def circle(cls, radius=1, segments=16, fill_segments=0, cap='NONE', materials=None):\n        \"\"\" Create a Circle.\n\n        'fill_segments' argument gives the number of internal circles to create.\n        If zero, the circle if filled with a polygon.\n        If positive, the circle is filled with triangle fans.\n\n        Arguments\n        ---------\n            - radius (float=1.) : circle radius\n            - segments (int=16) : number of segments\n            - fill_segments (int = 0) : number of internal segments, polygon is None\n            - materials (list of strs = None) : materials list\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n        ag = np.linspace(0, 2*np.pi, segments, endpoint=False)\n        x = radius*np.cos(ag)\n        y = radius*np.sin(ag)\n        points = np.stack((x, y, np.zeros_like(x)), axis=-1)\n\n        if cap == 'NONE':\n            i = np.arange(segments)\n            edges = np.stack((i, np.roll(i, shift=-1)), axis=-1)\n            return cls(points=points, edges=edges)\n\n        elif cap == 'NGON':\n            return cls(\n                points      = points, \n                corners     = np.arange(segments), \n                faces       = segments,\n                UVMap       = disk_uv_map(segments, mode='NGON').reshape(-1, 2),\n                materials   = materials,\n            )\n\n        elif cap == 'FANS':\n            points = np.append(points, [[0, 0, 0]], axis=0)\n            topo = fans_corners(segments)\n\n            return cls(\n                points      = points, \n                corners     = topo.ravel(), \n                faces       = 3,\n                UVMap       = disk_uv_map(segments, mode='FANS').reshape(-1, 2),\n                materials   = materials,\n            )\n\n        #mesh = cls(points=points)\n        #mesh.fill_cap(np.arange(segments), mode=cap, center=segments, clockwise=True)\n\n        assert(False)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Disk\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def disk(cls, radius=1, segments=16, fill_segments=0, cap='NGON', materials=None):\n        \"\"\" Create a disk.\n\n        Same as circle but default cap is NGON\n        \"\"\"    \n        return cls.circle(radius=radius, segments=segments, fill_segments=fill_segments, cap=cap, materials=materials)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Cone\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def cone(cls, vertices=32, side_segments=1, fill_segments=1, radius_top=0, radius_bottom=1, depth=2, fill_type='NGON', materials=None):\n        \"\"\" Create a Cone.\n\n        Arguments\n        ---------\n            - vertices (int=16) : number of segments\n            - side_segments (int = 1) : number of vertical segments\n            - fill_segments (int = 1) : number of internal circles on the caps\n            - radius_top (float=0) : top radius\n            - radius_bottom (float=1) : bottom radius\n            - depth (float=2.) : cylinder height\n            - fill_type (str or couple of strs ='NGON' in 'NGON', 'FANS', 'NONE') : cap filling\n            - materials (list of strs = None) : materials list\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n        # Empty geometry if fhe two radius are null\n        if radius_top == 0 and radius_bottom == 0:\n            return cls()\n\n        mesh = cls.bl_cone(\n            radius1       = radius_bottom,\n            radius2       = radius_top,\n            segments      = vertices,\n            side_segments = side_segments,\n            depth         = depth,\n            cap_ends      = fill_type in ['NGON', 'FANS'],\n            cap_tris      = fill_type == 'FANS',\n            materials     = materials,\n        )\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Cylinder\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def cylinder(cls, vertices=32, side_segments=1, radius=1, depth=2, fill_type='NGON', materials=None):\n        \"\"\" Create a Cylinder.\n\n        Arguments\n        ---------\n            - vertices (int=16) : number of segments\n            - side_segments (int = 1) : number of vertical segments\n            - radius (float=1.) : radius\n            - depth (float=2.) : cylinder height\n            - fill_type (str or couple of strs ='NGON' in 'NGON', 'TRIANGLE_FAN', 'NONE') : cap filling\n            - materials (list of strs = None) : materials list\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n        mesh = cls.bl_cone(\n            radius1       = radius,\n            radius2       = radius,\n            segments      = vertices,\n            side_segments = side_segments,\n            depth         = depth,\n            cap_ends      = fill_type in ['NGON', 'FANS'],\n            cap_tris      = fill_type == 'FANS',\n            materials     = materials,\n        )\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Pyramid\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def pyramid(cls, size=1, materials=None):\n        \"\"\" Create a Pyramid.\n\n        Arguments\n        ---------\n            - size (float=1.) : size\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n        return cls.cone(vertices=3, radius_bottom=size*0.8660254037844386, depth=size, materials=materials)\n\n    # ----------------------------------------------------------------------------------------------------\n    # UV Sphere\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def uvsphere(cls, segments=32, rings=16, radius=1, materials=None):\n        \"\"\" Create a uv sphere.\n\n        Arguments\n        ---------\n            - segments (int=32) : number of segments\n            - rings (int=16) : number of rings\n            - radius (float=1.) : radius\n            - materials (list of strs = None) : materials list\n            - transformation (Transformations = None) : the transformation to apply\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n        mesh = cls(materials=materials)\n        with mesh.bmesh() as bm:\n            bmesh.ops.create_uvsphere(bm, u_segments=segments, v_segments=rings, radius=radius, calc_uvs=True)\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # IcoSphere\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def icosphere(cls, radius=1, subdivisions=2, materials=None):\n        \"\"\" Create a IcoSphere.\n\n        Blender constructor for a IcoSphere.\n\n        Arguments\n        ---------\n            - radius (float=1.) : radius\n            - subdivisions (int=2) : number subdivisions\n            - materials (list of strs = None) : materials list\n            - transformation (Transformations = None) : the transformation to apply\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n        subdivisions = min(10, subdivisions)\n\n        mesh = cls(materials=materials)\n        with mesh.bmesh() as bm:\n            bmesh.ops.create_icosphere(bm, subdivisions=subdivisions, radius=radius, calc_uvs=True)\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Torus\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def torus(cls, major_segments=48, minor_segments=12, major_radius=1., minor_radius=0.25, materials=None):\n        \"\"\" Create a Torus.\n\n        Arguments\n        ---------\n            - major_segments (int=48) : number of segments for the major radius\n            - minor_segments (int=12) : number of segments for the minor radius\n            - major_radius (float=1.) : major radius\n            - minor_radius (float=.25) : minor radius\n            - materials (list of strs = None) : materials list\n            - transformation (Transformations = None) : the transformation to apply\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n        # Major backbone\n        maj_ag = np.linspace(0, 2*np.pi, major_segments, endpoint=False, dtype=bfloat) + np.pi # + pi to match blender uv\n\n        x = major_radius*np.cos(maj_ag)\n        y = major_radius*np.sin(maj_ag)\n        zeros = np.zeros_like(x)\n\n        transfos = Transformation.from_components(\n            translation=np.stack((x, y, zeros), axis=-1), \n            rotation=Rotation.from_euler(np.stack((zeros, zeros, maj_ag), axis=-1)),\n        )\n\n        # Minor section\n        min_ag = np.linspace(0, 2*np.pi, minor_segments, endpoint=False, dtype=bfloat) + np.pi # + pi to match blender uv\n        x = minor_radius*np.cos(min_ag)\n        z = minor_radius*np.sin(min_ag)\n        y = np.zeros_like(x)\n\n        circle = np.stack((x, y, z), axis=-1)\n\n        # Transform the circle\n        points = transfos[:, None] @ circle\n\n        # Generate the faces\n        corners = grid_corners(major_segments, minor_segments, close_x=True, close_y=True)\n\n        # Get the uv map\n        uvmap = grid_uv_map(major_segments + 1, minor_segments + 1)\n\n        return cls(points=points.reshape(-1, 3), corners=corners.ravel(), faces=4, UVMap=uvmap.reshape(-1, 2), materials=materials)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Monkey\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def monkey(cls, materials=None):\n        \"\"\" Create a Monkey.\n\n        Arguments\n        ---------\n            - materials (list of strs = None) : materials list\n\n        Returns\n        -------\n            - MeshBuilder\n        \"\"\"\n        mesh = cls(materials=materials)\n        with mesh.bmesh() as bm:\n            bmesh.ops.create_monkey(bm)\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Arrow\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def arrow(cls, vector=(0, 0, 1), radius=.05, angle=24., segments=8, adjust_norm=None, materials=None):\n\n        height = np.linalg.norm(vector)\n        if type(adjust_norm).__name__ == 'function':\n            height = adjust_norm(height)\n        elif adjust_norm is not None:\n            height = min(adjust_norm, height)\n\n        head_radius = 3*radius\n        head_height = head_radius/np.tan(np.radians(angle))\n\n        cyl_height = height - head_height*.8\n\n        #cyl  = cls.cylinder(vertices=segments, side_segments=2, radius=radius, depth=cyl_height, transformation=Transformations(position=(0, 0, cyl_height/2)), materials=materials)\n        cyl = cls.cylinder(vertices=segments, side_segments=2, radius=radius, depth=cyl_height, materials=materials)\n        cyl.points.z += cyl_height/2\n        cyl.points[[segments + i for i in range(segments)]].position -= (0, 0, cyl_height/2 - .01)\n\n        cone = cls.cone(vertices=segments, side_segments=2, fill_segments=1, radius_top=0, radius_bottom=head_radius, depth=head_height, fill_type='FANS', materials=materials)\n        cone.points[-1].position += (0, 0, head_height/10)\n        cone.points.position += (0, 0, height - head_height/2)\n\n        arrow = cyl.join(cone)\n        #arrow.points.position = tracker(vector, track_axis='Z') @ arrow.points.position\n        arrow.points.position = Rotation.look_at((0, 0, 1), vector) @ arrow.points.position\n\n        return arrow\n\n    # ----------------------------------------------------------------------------------------------------\n    # Field of vectors\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def vectors_field(cls, locations, vectors, radius=.05, scale_length=1., angle=24., segments=8, head=None, adjust_norm=None, materials=None):\n        \"\"\" Create an arrow at each location corresponding to the vectors.\n\n        The arrow length is equal to the corresponding vector lengths.\n        The arrow radius is constant and equal to the value passe in argument for lengths greater that\n        the argument scale_length. When the length is less than this value, the arrow is scaled down.\n\n        Use the adjust_norm argument to transform the vector lengths to arrows lengths.\n\n        Arguments\n        ---------\n            - locations (array of 3-vectors) : vectors locations\n            - vectors (array of 3 vectors) : vectors to visualize\n            - radius (float = .05) : arrow radius\n            - angle (float = 24) : head radius in degrees\n            - segments (int = 8) : number of segments for the section\n            - head (mesh = None) : mesh model for the head. Create a cone if None\n            - adjust_norm (max length or function = None) : max arrow length or function transforming\n                the vector length into arrow length\n            - scale_length (float = 1.) : arrow length below which the arrow radius is scaled\n\n        Returns\n        -------\n            - Mesh Object\n        \"\"\"\n        locations = np.atleast_2d(locations)\n        vectors = np.atleast_2d(vectors)\n\n        # ---------------------------------------------------------------------------\n        # Vector lengths\n        # ---------------------------------------------------------------------------\n\n        n = len(locations)\n\n        lengths = np.linalg.norm(vectors, axis=-1)\n        is_null = lengths &lt; .00001\n        lengths[is_null] = 1\n        v_dir = vectors / lengths[:, None]\n        if type(adjust_norm).__name__ == 'function':\n            lengths = adjust_norm(lengths)\n        elif adjust_norm is not None:\n            lengths = np.minimum(adjust_norm, lengths)\n        lengths[is_null] = 0\n        vectors = v_dir*lengths[:, None]\n\n        # ---------------------------------------------------------------------------\n        # Arrow head\n        # ---------------------------------------------------------------------------\n\n        head_radius = 3*radius\n        head_height = head_radius/np.tan(np.radians(angle))\n\n        if head is None:\n            cone = cls.cone(\n                vertices = segments, \n                side_segments = 1, \n                fill_segments = 1, \n                radius_top = 0, \n                radius_bottom = head_radius, \n                depth = head_height, \n                fill_type = 'FANS', \n                materials = materials)\n            cone.points[-1].z += head_height/10\n        else:\n            cone = head\n            head_height = cone.bounding_box_dims[2]\n\n        # Head top point is z=0\n        v0, v1 = cone.bounding_box\n        cone.points.z -= v1[2]\n\n        # ---------------------------------------------------------------------------\n        # Small arrows: Vectors whose length &lt; min_length\n        # ---------------------------------------------------------------------------\n\n        # Minimum length\n        # Below this length, the arrow is scaled\n\n        min_length = 2*head_height\n\n        # Small and long arrows if any\n        small_arrows = cls()\n        long_arrows = cls()\n\n        small = lengths &lt; min_length\n        nsmalls = np.sum(small)\n\n        if nsmalls:\n            # shaft height = head height\n            cyl_height = min_length/2 + .01\n            arrow = cls.cylinder(vertices=segments, side_segments=1, radius=radius, depth=cyl_height, materials=materials)\n            arrow.points.z += cyl_height/2\n\n            # Join the head\n            c = cls.from_mesh(cone)\n            c.points.z += min_length\n\n            arrow.join(c)\n\n            # Duplicate the geometry            \n            small_arrows = arrow*nsmalls\n            small_arrows.points.reshape(nsmalls, len(arrow.points))\n\n            # Rotate, scale and translate\n            lg = lengths[small]\n            scale = np.stack((np.ones_like(lg), np.ones_like(lg), lg), axis=-1)\n            small_arrows.transformation(\n                rotation = Rotation.look_at((0, 0, 1), vectors[small])[:, None], \n                scale = scale[:, None], \n                translation = locations[small, None],\n                )\n            small_arrows.points.reshape(-1)\n\n\n        # ---------------------------------------------------------------------------\n        # Long arrows\n        # ---------------------------------------------------------------------------\n\n        long = np.logical_not(small)\n        nlongs = len(locations) - nsmalls\n        if nlongs:\n\n            # Shaft model with a normalized height = 1\n            shaft = cls.cylinder(vertices=segments, side_segments=1, radius=radius, depth=1, materials=materials)\n            shaft.points.z += .5\n\n            # We duplicate and transform the shafts with a scale long z\n            long_arrows = shaft*nlongs\n            long_arrows.points.reshape(nlongs, len(shaft.points))\n\n            lg = lengths[long] - head_height + .01\n            scale = np.stack((np.ones_like(lg), np.ones_like(lg), lg), axis=-1)\n            long_arrows.transformation(\n                rotation = Rotation.look_at((0, 0, 1), vectors[long])[:, None], \n                scale = scale[:, None], \n                translation = locations[long, None],\n                )\n            long_arrows.points.reshape(-1)\n\n            # We duplicate and tranform the heads with no scale\n            heads = cone*nlongs\n            heads.points.reshape(nlongs, len(cone.points))\n            heads.transformation(\n                rotation = Rotation.look_at((0, 0, 1), vectors[long])[:, None], \n                translation = locations[long, None] + vectors[long, None],\n                )\n            heads.points.reshape(-1)\n\n            long_arrows.join(heads)\n\n        # Let's join the result\n        arrows = cls()\n        arrows.join(small_arrows, long_arrows)\n\n        return arrows\n\n    # ----------------------------------------------------------------------------------------------------\n    # Chain Link\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def chain_link(cls, major_segments=48, minor_segments=12, radius=1., section=0.5, length=4., materials=None):\n        \"\"\" Create a chain link.\n\n        ``` python\n        # ----- Some maths\n\n        # Chain follows a catenary curve\n        def catenary(t):\n            return np.stack((t, np.zeros_like(t), np.cosh(t)), axis=-1)\n\n        # Orientation is given by the derivative\n        def derivative(t):\n            dt = 1/10000\n            return (catenary(t + dt) - catenary(t - dt))/(2*dt)\n\n        # Catenary length\n        pts = catenary(np.linspace(-1, 1, 1000))\n        cat_s = np.cumsum(np.linalg.norm(pts[1:] - pts[:-1], axis=-1))\n        cat_len = cat_s[-1]\n\n        # Catenary inverse : t from length\n        def cat_inverse(l):\n            return 2*np.argmin(np.abs(cat_s - l))/1000 - 1\n\n        # ----- Let's build the geometry\n\n        # One chain link\n        section = .02\n        length  = .15\n        link = MeshBuilder.ChainLink(radius=.04, section=section, length=length)\n\n        # Link length taking into account the section\n        l = length - 2*section\n\n        # Number of links\n        count = round(cat_len / l)\n\n        # The chain\n        chain = link*count\n\n        # Rotate pi/2 one on two\n        eulers = Eulers(shape=count)\n        eulers[[i % 2 == 1 for i in range(count)]] = (0, np.pi/2, 0)\n\n        chain.rotate(eulers)\n        chain.rotate_z(np.pi/2)\n\n        # Location of each link\n        t = np.array([cat_inverse(l*i) for i in range(count)])\n\n        chain.toward(derivative(t), track_axis='X', up_axis='Z')\n        chain.translate(catenary(t))\n\n        # To object\n        chain.to_object(\"Catenary\")\n        ```\n\n        Arguments\n        ---------\n            - major_segments (int=48) : number of segments for the link\n            - minor_segments (int=12) : number of segments for the section\n            - radius (float=1.) : radius of the link\n            - section (float=.5) : section (diameter)\n            - length (float=4.) : total length of the link\n            - materials (list of strs = None) : materials list\n\n        Returns\n        -------\n            - MeshBuilder\n        \"\"\"\n\n        delta = length - 2*radius\n\n        # Starting from a torus\n        clink = cls.torus(\n            major_radius    = radius, \n            minor_radius    = section/2, \n            major_segments  = major_segments, \n            minor_segments  = minor_segments, \n            materials       = materials\n        )\n        # Nothing else\n        if delta &lt; radius/10:\n            return clink\n\n        epsilon = radius/major_segments\n\n        # Delete half of the points\n        clink.delete_vertices(points=clink.points.y &lt; -epsilon)\n        npoints = len(clink.points)\n        borders = clink.points.y &lt; epsilon\n        loop0 = np.arange(npoints)[np.logical_and(borders, clink.points.x &lt; 0)]\n        loop1 = np.arange(npoints)[np.logical_and(borders, clink.points.x &gt; 0)]\n        clink.points.y += delta/2\n\n        # Duplicate and inverse\n        half = Mesh.from_mesh(clink)\n        half.points.position[:, :2] *= -1\n\n        # Join\n        clink.join(half)\n\n        # Bridge\n        clink.bridge_loops(loop0, loop1 + npoints, close=True)\n        clink.bridge_loops(loop1, loop0 + npoints, close=True)\n\n        # UVMap\n        nu, nv = major_segments + 3, minor_segments + 1\n        uvmap = grid_uv_map(nu, nv).reshape(nu - 1, nv - 1, 4, 2)\n\n        ratio = (length - radius)/(length - radius + np.pi*radius)\n        dx_side = ratio/2\n\n        uvmap[:-2,..., 0] *= (1 - ratio)/(1 - 2/nu)\n        uvmap[-2,:, [0, 3], 0] = 1 - ratio\n        uvmap[-2,:, [1, 2], 0] = 1 - ratio/2\n        uvmap[-1,:, [0, 3], 0] = 1 - ratio/2\n\n        clink.corners.UVMap = uvmap.reshape(-1, 2)\n\n        return clink\n\n    # ====================================================================================================\n    # Extrusion\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Extrude vertices\n    # ----------------------------------------------------------------------------------------------------\n\n    def extrude_vertices(self, selection, offset, **attributes):\n        \"\"\" Extrude individual vertices\n\n        Arguments\n        ---------\n            - selection (selector) : points selection, all if None\n            - offset (vector or array of vectors) : extrusion vector\n            - attributes (dict) : points attributes\n\n        Returns\n        -------\n            - dictionnary of the created geometry : vertex indices, face indices\n        \"\"\"\n        inds = np.arange(len(self.points))\n        if selection is not None:\n            inds = inds[selection]\n\n        pos = self.points.position[inds] + offset\n        new_inds = np.arange(len(pos)) + len(self.points)\n        edges = edges_between(inds, new_inds)\n\n        return self.add_geometry(points=pos, edges=edges.reshape(-1, 2), **attributes)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Extrude a loop of points\n    # ----------------------------------------------------------------------------------------------------\n\n    def extrude_loop(self, loop, offset, close=False, clockwise=False, **attributes):\n        \"\"\" Extrude a loop of vertices.\n\n        Arguments\n        ---------\n            - loop (array of ints) : vertex indices\n            - offset (float = 1) : multiplicator of the direction vector\n            - direction (vector = None) : extrusion direction, normal if None\n            - clockwise (bool=False) : faces orientation\n            - attributes : attribute for the new geometry\n\n        Returns\n        -------\n            - dictionnary of the created geometry : vertex indices, face indices\n        \"\"\"\n        loop = np.atleast_1d(loop)\n        if len(loop) &lt; 2:\n            return None\n\n        verts = self.points.position[loop]\n        try:\n            new_verts = verts + offset\n        except Exception as e:\n            raise AttributeError(\n                f\"Extrude&gt; Offset argument must be a single vector or an array of {len(verts)} vectors, not {np.shape(offset)}.\"\n                )\n\n        indices = np.append(loop, len(self.points) + np.arange(len(new_verts)))\n        gc = grid_corners(len(verts), 2, row_first=True, close_x=close, clockwise=clockwise)\n        corners = indices[gc.ravel()]\n        uvmap = grid_uv_map(len(verts), 2, close_x=close, clockwise=clockwise).reshape(-1, 2)\n\n        return self.add_geometry(points=new_verts, corners=corners, faces=4, UVMap=uvmap)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Extrude individual faces\n    # ----------------------------------------------------------------------------------------------------\n\n    def extrude_faces(self, selection, offset=None, scale=1.):\n        \"\"\" Extrude individual faces.\n\n        If offset is None, faces are extruder along their normal\n\n        Arguments\n        ---------\n            - selection : indices of the faces to extrude\n            - offset (vector or array of vectors) : the extrusion vector\n            - scale (float = 1) : scale factor for offsets\n            - dissolve (bool = True) : remove starting faces\n\n        Returns\n        -------\n            - dictionnary : 'top' : extruded faces, 'side' : extruded side faces\n        \"\"\"\n\n        # Selected faces indices\n        faces_sel = np.arange(len(self.faces))\n        if selection is not None:\n            faces_sel = faces_sel[selection]\n\n        # bmesh edition\n        with self.bmesh() as bm:\n            #bm.verts.ensure_lookup_table()\n            bm.faces.ensure_lookup_table()\n\n            # select faces\n            start_faces = [bm.faces[i] for i in faces_sel]\n\n            res = {'top': [], 'side': []}\n\n            # bmesh.ops\n            d = bmesh.ops.extrude_discrete_faces(bm, faces=start_faces)\n            new_faces = d[\"faces\"]\n\n\n\n            # One direction per face\n            if offset is not None:\n                shape = np.broadcast_shapes(np.shape(offset), (len(new_faces), 3))\n                offsets = np.broadcast_to(offset, shape)*scale\n\n            # Loop on created faces\n            for i_face, face in enumerate(new_faces):\n                verts = face.verts\n                if offset is None:\n                    ofs = face.normal*scale\n                else:\n                    ofs = offsets[i_face]\n\n                bmesh.ops.translate(bm, verts=list(verts), vec=ofs)\n\n                res['top'].append(face.index)\n                for e in face.edges:\n                    assert(len(e.link_faces) == 2)\n                    if e.link_faces[0].index == face.index:\n                        res['side'].append(e.link_faces[1].index)\n                    else:\n                        res['side'].append(e.link_faces[0].index)\n\n        return res\n\n    # ----------------------------------------------------------------------------------------------------\n    # Extrude region\n    # ----------------------------------------------------------------------------------------------------\n\n    def extrude_region(self, selection, offset=(0, 0, 1), dissolve=False):\n        \"\"\" Extrude individual faces.\n\n        Arguments\n        ---------\n            - selection : indices of the faces to extrude\n            - offset (vector = (0, 0, 1)) : the extrusion vector\n            - dissolve (bool = True) : remove starting faces\n\n        Returns\n        -------\n            - dictionnary : 'top' : extruded faces, 'side' : extruded side faces\n        \"\"\"\n\n        # Selected faces indices\n        faces_sel = np.arange(len(self.faces))\n        if selection is not None:\n            faces_sel = faces_sel[selection]\n\n        # bmesh edition\n        with self.bmesh() as bm:\n            #bm.verts.ensure_lookup_table()\n            bm.faces.ensure_lookup_table()\n\n            # select faces\n            start_faces = [bm.faces[i] for i in faces_sel]\n\n            res = {'top': [], 'side': []}\n\n\n            # Extrusion\n            d = bmesh.ops.extrude_face_region(\n                bm, \n                geom                      = start_faces,\n                #edges_exclude            = set(),\n                #use_keep_orig            = False,\n                #use_normal_flip          = False,\n                #use_normal_from_adjacent = False,\n                #use_dissolve_ortho_edges = False,\n                #use_select_history       = False,\n                )\n\n            # Move new vectors\n            extruded_geom = d[\"geom\"]\n            new_verts = [ele for ele in extruded_geom if isinstance(ele, bmesh.types.BMVert)]\n            new_faces = [ele for ele in extruded_geom if isinstance(ele, bmesh.types.BMFace)]\n\n            bmesh.ops.translate(bm, verts=new_verts, vec=list(offset))\n\n            # ===== Result\n            for face in new_faces:\n                res['top'].append(face.index)\n                for e in face.edges:\n                    assert(len(e.link_faces) == 2)\n                    if e.link_faces[0].index == face.index:\n                        res['side'].append(e.link_faces[1].index)\n                    else:\n                        res['side'].append(e.link_faces[0].index)\n\n            # ===== Dissolve extruded faces\n            if dissolve:\n                bm.faces.ensure_lookup_table()\n                del_faces = [bm.faces[i] for i in faces_sel]\n\n                bmesh.ops.delete(bm, geom=del_faces, context='FACES')                   \n\n        return res\n\n    # ----------------------------------------------------------------------------------------------------\n    # inset faces\n    # ----------------------------------------------------------------------------------------------------\n\n    def inset_faces(self, selection, thickness=0.1, depth=0.0, use_even_offset=True, use_relative_offset=False):\n        \"\"\" Extrude individual faces.\n\n        If offset is None, faces are extruder along their normal\n\n        Arguments\n        ---------\n        selection : selection on faces\n            indices of the faces to inset\n        thickness : float\n            Inset thickness.\n        depth : float\n            Inset depth (extrusion).\n        use_even_offset : bool\n            Keep consistent thickness.\n        use_relative_offset : bool\n            Offset relative to face size.\n\n        Returns\n        -------\n        dict with:\n            'faces' : list of new inset faces\n        \"\"\"\n\n        # Selected faces indices\n        faces_sel = np.arange(len(self.faces))\n        if selection is not None:\n            faces_sel = faces_sel[selection]\n\n        # bmesh edition\n        with self.bmesh() as bm:\n            bm.faces.ensure_lookup_table()\n\n            # select faces\n            start_faces = [bm.faces[i] for i in faces_sel]\n\n            res = {'top': [], 'side': []}\n\n            # bmesh.ops\n            d = bmesh.ops.inset_individual(\n                bm,\n                faces               = start_faces,\n                thickness           = thickness,\n                depth               = depth,\n                use_even_offset     = use_even_offset,\n                use_relative_offset = use_relative_offset,\n            )\n\n            res = {\n                'top': faces_sel,\n                'side': [face.index for face in d[\"faces\"]]\n            }\n\n        return res\n\n    # ----------------------------------------------------------------------------------------------------\n    # Solidify socle\n    # ----------------------------------------------------------------------------------------------------\n\n    def solidify_socle(self, shape, z=0, bottom_material_index=0):\n        \"\"\" The mesh is supposed to be a grid.\n\n        The socle is buit by extruding the external edges to the value z.\n\n        Arguments\n        ---------\n        - shape (tuple of ints) : the grid shade\n        - z (float) : socle base z\n        - bottom_material_index (int = 0) : base face material index\n        - attributes (dict) : attributes to faces\n\n        Returns\n        -------\n        - bottom face index (int) : the index of bottom face\n        \"\"\"\n\n        n = shape[0]*shape[1]\n        inds = np.arange(n).reshape(shape)\n\n        loop1 = np.append(inds[0, :-1], inds[:-1, -1])\n        loop1 = np.append(loop1, np.flip(inds[-1, 1:]))\n        loop1 = np.append(loop1, np.flip(inds[1:, 0]))\n\n        points = np.array(self.points.position[loop1])\n        points[:, 2] = z\n\n        loop0 = self.add_points(points)\n        res = self.add_geometry(corners=loop0) #, faces=len(loop0))\n\n        self.bridge_loops(loop0, loop1, close=True)\n\n        self.faces._ensure_optional_field(\"material_index\")\n        self.faces[res['faces']].material_index = bottom_material_index\n\n    # ----------------------------------------------------------------------------------------------------\n    # Boolean\n    # ----------------------------------------------------------------------------------------------------\n\n    def boolean(self, other, operation='DIFFERENCE'):\n        \"\"\"\n        Apply a boolean operation with another object.\n\n        Parameters\n        ----------\n        other : Mesh\n            The object to use as boolean operand.\n        operation : str\n            Boolean operation: 'INTERSECT', 'UNION', or 'DIFFERENCE'.\n        \"\"\"\n\n        with other.object(0, readonly=True) as other_obj:\n\n            with self.object(1) as obj:\n                mod = obj.modifiers.new(name=\"Boolean\", type='BOOLEAN')\n                mod.object = other_obj\n                mod.operation = operation\n\n                # Apply modifier\n                bpy.ops.object.modifier_apply(modifier=mod.name)\n\n                mesh = Mesh.from_object(obj)\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Solidify\n    # ----------------------------------------------------------------------------------------------------\n\n    def solidify(self, thickness=.01, offset=-1):\n        \"\"\" Boolean difference with another MeshBuilder.\n\n        The methods uses the Solidify Modifier\n\n        ``` python\n        glass = Mesh.Circle(segments=128)\n        glass.extrude_faces(0, -.01)\n        glass.extrude_faces(0, -2)\n        glass.extrude_faces(0, -.01)\n\n        glass.points.translate((0, 0, 2))\n\n        glass = glass.solidify(thickness=.1)\n\n        glass.to_object(\"Solidify\", shade_smooth=True)\n        ```\n\n        Arguments\n        ---------\n            - thickness (float=.01) : thickness\n            - offset (float=-1) : offset\n\n        Returns\n        -------\n            - MeshBuilder : the result of the solidify operation\n        \"\"\"\n\n        with self.object() as obj:\n            mod = obj.modifiers.new(\"Solidify\", 'SOLIDIFY')\n\n            mod.thickness       = thickness\n            mod.use_even_offset = True\n            mod.offset          = offset\n\n            # Apply modifier\n            bpy.ops.object.modifier_apply(modifier=mod.name)\n\n            mesh = Mesh.from_object(obj)\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Remove doubles\n    # ----------------------------------------------------------------------------------------------------\n\n    def remove_doubles(self, dist=.001):\n        \"\"\" Remove doubles.\n\n        Arguments:\n            - dist (float=0.001) : maximum distance between vertices to merge.\n        \"\"\"\n        with self.bmesh() as bm:\n            bmesh.ops.remove_doubles(bm, verts=bm.verts, dist=dist)\n\n        return self\n\n    # ----------------------------------------------------------------------------------------------------\n    # Triangulate\n    # ----------------------------------------------------------------------------------------------------\n\n    def triangulate(self, selection=None):\n\n        faces_sel = np.arange(len(self.faces))\n        if selection is not None:\n            faces_sel = faces_sel[selection]\n\n        if len(faces_sel) == 0:\n            return\n\n        copy = Mesh.from_mesh(self)\n\n        with copy.bmesh(readonly = False) as bm:\n            bm.faces.ensure_lookup_table()\n            faces = [bm.faces[i] for i in faces_sel]\n\n            bmesh.ops.triangulate(bm, faces=faces)\n\n        return copy\n\n    # ----------------------------------------------------------------------------------------------------\n    # Simplify\n    # ----------------------------------------------------------------------------------------------------\n\n    def simplified(self, scale, dist=.001):\n\n        copy = Mesh.from_mesh(self)\n        copy.remove_doubles(dist=dist/scale)\n\n        if len(copy.points) &lt; 8:\n            copy = self.get_cubic_envelop()\n\n        return copy\n\n    # ----------------------------------------------------------------------------------------------------\n    # Faces to islands\n    # ----------------------------------------------------------------------------------------------------\n\n    def separate_faces(self, groups=None):\n        \"\"\" Split faces into isolated islands\n\n        Arguments\n        ---------\n        - groups (list of ints):\n            group ids of faces\n        \"\"\"\n\n        mesh = Mesh(materials=self.materials)\n        attr_names = [name for name in self.faces.actual_names if name not in ['loop_total', 'loop_start']]\n\n        # ---------------------------------------------------------------------------\n        # No group: each face becomes an island\n        # ---------------------------------------------------------------------------\n\n        if groups is None:\n            attrs = {name: self.faces[name] for name in attr_names}\n            return Mesh(attr_from=self).join_geometry(\n                points = self.points.position[self.corners.vertex_index],\n                corners = np.arange(len(self.corners)),\n                faces = self.faces.loop_total,\n                **attrs,\n            )\n\n        # ---------------------------------------------------------------------------\n        # Faces are grouped with groupds IDs\n        # ---------------------------------------------------------------------------\n\n        groups = np.asarray(groups)\n        if groups.shape != (len(self.faces),)   :\n            raise ValueError(f\"The 'groups' argument must be a index per face with a length of {len(self.faces)}.\")\n\n        ugroups, rev_index = np.unique(groups, return_inverse=True)\n        for group in ugroups:\n            faces = self.faces[ugroups[rev_index] == group]\n            attrs = {name: faces[name] for name in attr_names}\n\n            corners = self.corners[faces.get_corner_indices()]\n            uniques, new_corners = np.unique(corners.vertex_index, return_inverse=True)\n            mesh.join(Mesh(attr_from=self).join_geometry(\n                points = self.points.position[uniques],\n                corners = new_corners,\n                faces = faces.loop_total,\n                **attrs,\n            ))\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Dual mesh\n    # ----------------------------------------------------------------------------------------------------\n\n    def dual(self, center=\"median\"):\n\n        verts = np.empty((len(self.faces), 3), np.float32)\n        corners = []\n        faces = []\n\n        with self.bmesh() as bm:\n\n            bm.faces.ensure_lookup_table()\n            bm.verts.ensure_lookup_table()    \n            bm.edges.ensure_lookup_table()    \n\n            # ---------------------------------------------------------------------------\n            # Faces become points\n            # ---------------------------------------------------------------------------\n\n            if center.lower() == 'median':\n                for f in bm.faces:\n                    c = f.calc_center_median()\n                    verts[f.index] = (c.x, c.y, c.z)\n\n            elif center.lower() == 'bounds':\n                for f in bm.faces:\n                    c = f.calc_center_bounds()\n                    verts[f.index] = (c.x, c.y, c.z)\n\n            elif center.lower() == 'weighted':\n                for f in bm.faces:\n                    c = f.calc_center_median_weighted()\n                    verts[f.index] = (c.x, c.y, c.z)\n\n            else:\n                raise ValueError(f\"Center must be in ('median', 'bounds','weighted').\")\n\n            # ---------------------------------------------------------------------------\n            # Vertices becom faces\n            # ---------------------------------------------------------------------------\n\n            for v in bm.verts:\n                # Faces need to be ordered (link_faces is not good)\n                # Get the edges as couples (face.index, face.index)\n                # then chain the edges\n\n                couples = []\n                first = True\n                for edge in v.link_edges:\n\n                    if len(edge.link_faces) != 2:\n                        couples = []\n                        break\n\n                    # First is used for the order between:\n                    # - face0 then face1\n                    # - face1 then face0\n                    if first:\n                        first = False\n\n                        # The edge links two vertices\n                        other_index = edge.verts[0].index if edge.verts[1].index == v.index else edge.verts[1].index\n\n                        # We select as first face the one where loop is v -&gt; other                \n                        face0 = edge.link_faces[0]\n                        for i_loop, lp in enumerate(face0.loops):\n                            if lp.vert.index == other_index:\n                                j = (i_loop + 1)%len(face0.loops)\n                                take0 = face0.loops[j].vert.index == v.index\n                                break\n\n                        if take0:\n                            loop = [edge.link_faces[0].index, edge.link_faces[1].index]\n                        else:\n                            loop = [edge.link_faces[1].index, edge.link_faces[0].index]\n\n                    else:\n                        couples.append((edge.link_faces[0].index, edge.link_faces[1].index))\n\n                if len(couples) &lt; 2:\n                    continue\n\n                # Build the other faces by chaing the edges \n                # First loop to consume the edge couples      \n                for _ in range(len(couples)):\n                    found = False\n                    # Second loop to find the following edge\n                    for i, e in enumerate(couples):\n                        if e[0] == loop[-1]:\n                            loop.append(e[1])\n                            found = True\n                        elif e[1] == loop[-1]:\n                            loop.append(e[0])\n                            found = True\n                        else:\n                            continue\n                        break\n\n                    if found:\n                        del couples[i]\n                    else:\n                        loop = []\n                        break\n\n                if len(loop) &lt; 3:\n                    continue\n\n                faces.append(len(loop))\n                corners.extend(loop)\n\n        # We can build the dual mesh\n        return Mesh(points=verts, corners=corners, faces=faces, materials=self.materials)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Faces neighbors\n    # ----------------------------------------------------------------------------------------------------\n\n    def faces_neighbors(self):\n\n        offset = 0\n        neighbors = []\n\n        with self.bmesh() as bm:           \n            bm.faces.ensure_lookup_table()\n\n            for face in bm.faces:\n                ns = set()\n                for edge in face.edges:\n                    ns = ns.union([edge.link_faces[0].index, edge.link_faces[1].index])\n                ns.remove(face.index)\n                neighbors.append(list(ns))\n\n        return neighbors\n\n    # ----------------------------------------------------------------------------------------------------\n    # Get islands\n    # ----------------------------------------------------------------------------------------------------\n\n    def get_islands(self):\n        \"\"\" Get an island id per face.\n        \"\"\"\n        from collections import deque\n\n        nfaces = len(self.faces)\n        if not nfaces:\n            return []\n\n        islands = np.full(nfaces, -1, dtype=np.int32)\n        cur_island = -1\n\n        passed = np.zeros(nfaces, dtype=bool)\n\n        with self.bmesh() as bm:\n            bm.faces.ensure_lookup_table()\n            bm.edges.ensure_lookup_table()\n\n            for f in bm.faces:\n                # Already visited\n                if islands[f.index] &gt;= 0:\n                    continue\n\n                # New island index\n                cur_island += 1\n\n                q = deque([f])\n                while q:\n                    cur = q.popleft()\n\n                    # Part of the current island\n                    islands[cur.index] = cur_island\n\n                    # No infinite loop\n                    passed[cur.index] = True\n\n                    # Loop on the edges\n                    for e in cur.edges:                                               \n                        # Loop on the edge faces\n                        for nb in e.link_faces:\n                            if passed[nb.index]:\n                                continue\n                            passed[nb.index] = True\n\n                            if islands[nb.index] &lt; 0:\n                                q.append(nb)\n\n\n        return islands\n\n    # ====================================================================================================\n    # BVHTree\n    # ====================================================================================================\n\n    def bvh_tree(self, count=None):\n        if count is None:\n            return BVHTree.FromPolygons(self.points.position, self.faces.sequences(), all_triangles=False, epsilon=0.0)\n\n        else:\n            pos    = self.points.position\n            pos    = pos.reshape(count, -1, 3)\n\n            nfaces = len(self.faces)//count\n            inds   = list(self.corners.vertex_index)\n            faces  = [inds[lstart:lstart+ltotal] for (lstart, ltotal) in zip(self.faces.loop_start[:nfaces], self.faces.loop_total[:nfaces])]\n\n            return [BVHTree.FromPolygons(pos[i], faces, all_triangles=False, epsilon=0.0) for i in range(count)]\n\n\n    # ====================================================================================================\n    # Tests\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Test the primitives\n    # ----------------------------------------------------------------------------------------------------\n\n    @staticmethod\n    def _all_primitives():\n\n        rng = np.random.default_rng(0)\n\n        def toobj(mesh, name, x):\n            mesh.materials = [\"Material\"]   \n            mesh.points.x += x - np.min(mesh.points.x)\n            x = np.max(mesh.points.x) + 1\n\n            mesh.to_object(name, shade_smooth=False)\n\n            return x\n\n        x = 0\n\n        # ----- Points\n        mesh = Mesh.points(rng.uniform(-1, 1, size=(1000, 3)))\n        x = toobj(mesh, \"points\", x)\n\n        # ----- Lines\n        mesh = Mesh.line([0, 0, 0], [[0, -2, 1], [0, -1, 1], [0, 0, 1], [0, 1, 1], [0, 1, 1]])\n        mesh.join(Mesh.line([1, 0, 0], [[1, -2, 1], [1, -1, 1], [1, 0, 1], [1, 1, 1], [1, 1, 1]], segments=3))\n        mesh.join(Mesh.line([-1, 0, 0], [-1, 0, 1], segments=10))\n        x = toobj(mesh, \"line\", x)\n\n        # ----- Grid\n        mesh = Mesh.grid().translate((0, 0, 1)).join(Mesh.grid(5, 3, 50, 30))\n        x = toobj(mesh, \"grid\", x)\n\n        # ----- Cicle\n        mesh = Mesh.circle().join(Mesh.circle(cap='NGON').translate((0, 0, 1)), Mesh.circle(cap='FANS').translate((0, 0, 2)))      \n        x = toobj(mesh, \"circle\", x)\n\n        # ----- Cone\n        mesh = Mesh.cone(fill_type='NONE').join(\n            Mesh.cone(side_segments=10).translate((0, 0, 3)),\n            Mesh.cone(fill_type='NGON').translate((0, 0, 6)),\n            Mesh.cone(fill_type='FANS').translate((0, 0, 9)),\n        )\n        x = toobj(mesh, \"cone\", x)\n\n        # ----- Cylinder\n        mesh = Mesh.cylinder(fill_type='NONE').join(\n            Mesh.cylinder(side_segments=10).translate((0, 0, 3)),\n            Mesh.cylinder(fill_type='NGON').translate((0, 0, 6)),\n            Mesh.cylinder(fill_type='FANS').translate((0, 0, 9)),\n        )\n        x = toobj(mesh, \"cylinder\", x)\n\n        # ----- Arrow\n        mesh = Mesh().join(\n            Mesh.arrow((-1, 0, 0)),\n            Mesh.arrow((+1, 0, 0)),\n            Mesh.arrow((0, -1, 0)),\n            Mesh.arrow((0, +1, 0)),\n            Mesh.arrow((0, 0, -1)),\n            Mesh.arrow((0, 0, +1)),\n        )\n        x = toobj(mesh, \"arrow\", x)\n\n        # ----- Vectors field\n        n = 50\n        pos = rng.uniform(-1, 1, size=(n, 3))\n        ori = rng.uniform(-1, 1, size=(n, 3))\n        mesh = Mesh.vectors_field(\n            pos,\n            ori,\n            radius = .02,\n        )\n        x = toobj(mesh, \"vectors_field\", x)\n\n        # ----- Simple\n        for name in [\"cube\", \"pyramid\", \"uvsphere\", \"icosphere\", \"torus\", \"chain_link\", \"monkey\"]:\n            f = getattr(Mesh, name)\n            mesh = f()\n            x = toobj(mesh, name, x)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Test edition\n    # ----------------------------------------------------------------------------------------------------\n\n    def _test_edition():\n        rng = np.random.default_rng(0)\n\n        # extrude vertices\n        mesh = Mesh.icosphere()\n        sel = rng.uniform(0, 1, len(mesh.points)) &lt; .5\n        mesh.extrude_vertices(sel, mesh.points.position[sel])\n        mesh.to_object(\"extrude_vertices\", shade_smooth=False)\n\n        # extrude loop of vertices\n        mesh = Mesh.circle(materials=\"Material\")\n        mesh.extrude_loop(np.arange(len(mesh.points)), offset=(0, 0, 1), close=True)\n        mesh.points.x += 2\n        mesh.to_object(\"extrude_loop\", shade_smooth=False)\n\n        # extrude individualfaces\n        mesh = Mesh.icosphere()\n        sel = rng.uniform(0, 1, len(mesh.faces)) &lt; .5\n        inds = np.arange(len(mesh.faces))[sel]\n        res = mesh.extrude_faces(sel, scale=.3)\n        res = mesh.inset_faces(res['top'])\n        res = mesh.extrude_faces(res['top'], scale=-.1)\n        mesh.points.x += 4\n        mesh.to_object(\"extrude_faces\", shade_smooth=False)\n\n        # extrude region\n        mesh = Mesh.grid(1, 1, 11, 11)\n        sel = [23, 24, 25, 26, 27, 34, 35, 36, 45]\n        res = mesh.extrude_region(sel, (0, 0, 1), dissolve=False)\n        mesh.extrude_region(res['top'], (0, 0, .5), dissolve=True)\n        mesh.points.x += 7\n        mesh.to_object(\"extrude_region\", shade_smooth=False)\n\n        # solidify socle\n        mesh = Mesh.grid(2, 1.6/3, 80, 30)\n        mesh.points.z = .5 + rng.uniform(-.05, .05, len(mesh.points))\n        mesh.points.x += 10\n        mesh.solidify_socle(shape=(80, 30), z=0)\n        mesh.to_object(\"solidify_socle\", shade_smooth=False)\n\n        # boolean\n        cube = Mesh.cube()\n        cyl = Mesh.cylinder(radius=.5, depth = 3)\n        mesh = cube.boolean(cyl)\n        mesh.points.x += 13\n        mesh.to_object(\"boolean difference\", shade_smooth=False)\n\n        # solidify\n        mesh = Mesh.grid().solidify(thickness=.2)\n        mesh.points.x += 16\n        mesh.to_object(\"solidify\", shade_smooth=False)\n\n        # triangulate\n        mesh = Mesh.cube().triangulate()\n        mesh.points.x += 19\n        mesh.to_object(\"triangulate\", shade_smooth=False)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    # =============================================================================================================================\n    # To curve\n    # =============================================================================================================================\n\n    def to_curve_REVIEW(self):\n        \"\"\" &gt; Convert mesh to curve\n\n        Simple conversion when edges domain is defined\n        \"\"\"\n\n        from npblender import Curve\n\n        if self._edges is None:\n            return None\n\n        splines = []\n        for edge in self.edges:\n            v0, v1 = edge.vertex0, edge.vertex1\n\n            ok = False\n            for spline in splines:\n                if spline[0] == spline[-1]:\n                    continue\n\n                if v0 == spline[0]:\n                    spline.insert(0, v1)\n                    ok = True\n                elif v0 == spline[-1]:\n                    spline.append(v1)\n                    ok = True\n\n                elif v1 == spline[0]:\n                    spline.insert(0, v0)\n                    ok = True\n                elif v1 == spline[-1]:\n                    spline.append(v0)\n                    ok = True\n\n            if not ok:\n                splines.append([v0, v1])\n\n        curve = Curve()\n        for spline in splines:\n            cyclic = spline[0] == spline[-1]\n            if cyclic:\n                spline = spline[:-1]\n\n            curve.add(self.points.position[spline], curve_type='POLY', cyclic=cyclic)\n\n        return curve\n</code></pre>"},{"location":"api/#npblender.Mesh.__init__","title":"<code>__init__(points=None, corners=None, faces=None, edges=None, materials=None, attr_from=None, **attrs)</code>","text":"<p>Mesh Geometry.</p>"},{"location":"api/#npblender.Mesh.__init__--arguments","title":"Arguments","text":"<pre><code>- points (array of vectors = None) : the vertices\n- corners (array of ints = None) : corners, i.e. indices on the array of points\n- faces (array of ints = None) : size of the faces, the sum of this array must be equal to the length of the corners array\n- edges (array of couples of ints = None) : list of edges defined by two vertex indices\n- materials (str or list of strs = None) : list of materials used in the geometry\n- attr_from (Geometry) : domain attributes to copy from\n- **attrs (dict) : other geometry attributes\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def __init__(self, points=None, corners=None, faces=None, edges=None, materials=None, attr_from=None, **attrs):\n    \"\"\" Mesh Geometry.\n\n    Arguments\n    ---------\n        - points (array of vectors = None) : the vertices\n        - corners (array of ints = None) : corners, i.e. indices on the array of points\n        - faces (array of ints = None) : size of the faces, the sum of this array must be equal to the length of the corners array\n        - edges (array of couples of ints = None) : list of edges defined by two vertex indices\n        - materials (str or list of strs = None) : list of materials used in the geometry\n        - attr_from (Geometry) : domain attributes to copy from\n        - **attrs (dict) : other geometry attributes\n    \"\"\"\n\n    # ----- Initialize an empty geometry\n\n    self.points  = Vertex()\n    self.corners = Corner()\n    self.faces   = Face()\n    self.edges   = Edge()\n\n    self.join_attributes(attr_from)\n\n    # ----- The materials\n\n    if materials is None:\n        self.materials = []\n    elif isinstance(materials, str):\n        self.materials = [materials]\n    else:\n        self.materials = [mat for mat in materials]\n\n    # ----- Add geometry\n\n    self.add_geometry(points, corners, faces, edges, **attrs)\n</code></pre>"},{"location":"api/#npblender.Mesh.add_geometry","title":"<code>add_geometry(points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs)</code>","text":"<p>Add geometry</p> <p>Note that the added geometry can refer to existing vertices. It is appended as is, whithout shifting indices.</p> <p>To add independant geometry, use join_geometry.</p> <pre><code>cube = Mesh.cube()\n# add a triangle on existing vertices\n# corners argument refers to cube vertices\ncube.add_geometry(corners=[0, 1, 2], faces=3)\n\n# add a triangle with additional vertices\n# corners argument refers to the new vertices\ncube.join_geometry(points=[[0, 0, 0], [0, 1, 0], [1, 0, 0]], corners=[0, 1, 2], faces=3)\n</code></pre>"},{"location":"api/#npblender.Mesh.add_geometry--arguments","title":"Arguments","text":"<pre><code>- points (array of vectors = None) : the vertices\n- corners (array of ints = None) : corners, i.e. indices on the array of points\n- sizes (array of ints = None) : size of the faces, the sum of this array must be equal to the length of the corners array\n- materials (str or list of strs = None) : list of materials used in the geometry\n- **attrs (dict) : other geometry attributes\n</code></pre>"},{"location":"api/#npblender.Mesh.add_geometry--returns","title":"Returns","text":"<pre><code>- dict : {'points', 'corners', 'faces', 'edges': added geometry indices}\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def add_geometry(self, points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs):\n    \"\"\" Add geometry\n\n    Note that the added geometry can refer to existing vertices. It is appended as is, whithout shifting\n    indices.\n\n    To add independant geometry, use join_geometry.\n\n    ``` python\n    cube = Mesh.cube()\n    # add a triangle on existing vertices\n    # corners argument refers to cube vertices\n    cube.add_geometry(corners=[0, 1, 2], faces=3)\n\n    # add a triangle with additional vertices\n    # corners argument refers to the new vertices\n    cube.join_geometry(points=[[0, 0, 0], [0, 1, 0], [1, 0, 0]], corners=[0, 1, 2], faces=3)\n    ```\n\n    Arguments\n    ---------\n        - points (array of vectors = None) : the vertices\n        - corners (array of ints = None) : corners, i.e. indices on the array of points\n        - sizes (array of ints = None) : size of the faces, the sum of this array must be equal to the length of the corners array\n        - materials (str or list of strs = None) : list of materials used in the geometry\n        - **attrs (dict) : other geometry attributes\n\n    Returns\n    -------\n        - dict : {'points', 'corners', 'faces', 'edges': added geometry indices}\n    \"\"\"\n\n    disp_attrs = self._attributes_per_domain(**attrs)\n    added = {'points': [], 'corners': [], 'faces': [], 'edges': []}\n\n    # ----------------------------------------------------------------------------------------------------\n    # Add vertices\n    # ----------------------------------------------------------------------------------------------------\n\n    if points is not None:\n        added['points'] = self.points.append(position=points, **disp_attrs['points'])\n\n    # ----------------------------------------------------------------------------------------------------\n    # Edges\n    # ----------------------------------------------------------------------------------------------------\n\n    if edges is not None:\n        if np.shape(edges) == (2,):\n            added['edges'] = self.edges.append(vertex0=edges[0], vertex1=edges[1], **disp_attrs['edges'])\n        else:\n            added['edges'] = self.edges.append(vertex0=edges[:, 0], vertex1=edges[:, 1], **disp_attrs['edges'])\n\n    # ----------------------------------------------------------------------------------------------------\n    # Corners and Faces\n    # ----------------------------------------------------------------------------------------------------\n\n    # If corners is provided, faces can be:\n    # - None -&gt; single face made of all corners\n    # - int -&gt; faces are all the same size (len(corners) must be a multiplief of faces)\n    # - array like -&gt; face sizes (len(corners) == np.sum(faces))\n    #\n    # If faces is provided, corners can be:\n    # - None -&gt; faces must be an array of arrays, each array being of list of corners\n    # - not None -&gt; see above\n\n    ok_faces = True\n    if corners is None:\n        if faces is None:\n            ok_faces = False\n        else:\n            corners = []\n            sizes = []\n            ok = hasattr(faces, '__len__')\n            if ok:\n                for face in faces:\n                    ok = hasattr(faces, '__len__') and len(face) &gt; 2\n                    if not ok:\n                        break\n                    corners.extend(face)\n                    sizes.append(len(face))\n            if not ok:\n                raise ValueError(f\"Mesh add_geometry&gt; when corners is None, faces must be None or an array of arrays, each array being of list of corners.\")\n            faces = sizes\n\n    else:\n        corners = np.asarray(corners)\n        ncorners = len(corners)\n        if faces is None:\n            faces = [ncorners]\n\n        else:\n            faces = np.asarray(faces)\n            if faces.shape == ():\n                size = int(faces)\n                if ncorners % size != 0:\n                    raise ValueError(f\"Mesh add_geometry&gt; when faces is a single number {size}, it must divide the number of corners ({ncorners}).\")\n                faces = [size]*(ncorners // size)\n            else:\n                if np.sum(faces) != ncorners:\n                    raise ValueError(f\"Mesh add_geometry&gt; the sum of faces ({np.sum(faces)}) must be equal to the number of corners ({ncorners}).\")\n\n    if ok_faces:\n        added['corners'] = self.corners.append(vertex_index=corners, **disp_attrs['corners'])\n        added['faces'] = self.faces.append_sizes(faces, **disp_attrs['faces'])\n\n    if False: # OLD\n        if np.shape(faces) == ():\n            nfaces = len(corners) // faces\n            if len(corners) % faces != 0:\n                raise ValueError(f\"Mesh add_geometry&gt; when faces is a single number {faces}, it must divide the number of corners ({len(corners)}).\")\n            faces = np.ones(nfaces, dtype=bint)*faces\n\n        added['corners'] = self.corners.append(vertex_index=corners, **disp_attrs['corners'])\n        added['faces'] = self.faces.append_sizes(faces, **disp_attrs['faces'])\n\n    if safe_mode:\n        self.check()\n\n    return added\n</code></pre>"},{"location":"api/#npblender.Mesh.add_points","title":"<code>add_points(points, **attributes)</code>","text":"<p>Add vertices.</p>"},{"location":"api/#npblender.Mesh.add_points--arguments","title":"Arguments","text":"<pre><code>- points (array of vectors) : the vertices to add\n- attributes (name=value) : value for named attributes\n</code></pre>"},{"location":"api/#npblender.Mesh.add_points--returns","title":"Returns","text":"<pre><code>- array of ints : indices of the added vertices\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def add_points(self, points,  **attributes):\n    \"\"\" Add vertices.\n\n    Arguments\n    ---------\n        - points (array of vectors) : the vertices to add\n        - attributes (name=value) : value for named attributes\n\n    Returns\n    -------\n        - array of ints : indices of the added vertices\n    \"\"\"\n    npoints = len(self.points)\n    return self.points.append(position=points, **attributes)\n</code></pre>"},{"location":"api/#npblender.Mesh.bl_circle","title":"<code>bl_circle(radius=1, segments=16, fill_tris=False, materials=None)</code>  <code>classmethod</code>","text":"<p>Create a Circle.</p> <p>Blender constructor for a Circle.</p>"},{"location":"api/#npblender.Mesh.bl_circle--arguments","title":"Arguments","text":"<pre><code>- radius (float=1.) : circle radius\n- segments (int=16) : number of segments\n- fill_tris (bool = False) : fill with triangle fans\n- materials (list of strs = None) : materials list\n- transformation (Transformations = None) : the transformation to apply\n</code></pre>"},{"location":"api/#npblender.Mesh.bl_circle--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef bl_circle(cls, radius=1, segments=16, fill_tris=False, materials=None):\n    \"\"\" Create a Circle.\n\n    Blender constructor for a Circle.\n\n    Arguments\n    ---------\n        - radius (float=1.) : circle radius\n        - segments (int=16) : number of segments\n        - fill_tris (bool = False) : fill with triangle fans\n        - materials (list of strs = None) : materials list\n        - transformation (Transformations = None) : the transformation to apply\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    mesh = cls(materials=materials)\n    with mesh.bmesh() as bm:\n        bmesh.ops.create_circle(bm, cap_ends=True, cap_tris=fill_tris, segments=segments, radius=radius, calc_uvs=True)\n\n    return mesh\n</code></pre>"},{"location":"api/#npblender.Mesh.bl_cone","title":"<code>bl_cone(radius1=1, radius2=0, depth=2, segments=16, side_segments=1, cap_ends=True, cap_tris=False, materials=None)</code>  <code>classmethod</code>","text":"<p>Create a Cone.</p> <p>Blender constructor for a Cone.</p>"},{"location":"api/#npblender.Mesh.bl_cone--arguments","title":"Arguments","text":"<pre><code>- radius1 (float=1.) : base radius\n- radius2 (float=0.) : top radius\n- depth (float=2.) : cone height\n- segments (int=16) : number of segments\n- cap_ends (bool=True) : fill cap faces\n- cap_tris (bool = False) : fill with triangle fans\n- materials (list of strs = None) : materials list\n</code></pre>"},{"location":"api/#npblender.Mesh.bl_cone--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef bl_cone(cls, radius1=1, radius2=0, depth=2, segments=16, side_segments=1, cap_ends=True, cap_tris=False, materials=None):\n    \"\"\" Create a Cone.\n\n    Blender constructor for a Cone.\n\n    Arguments\n    ---------\n        - radius1 (float=1.) : base radius\n        - radius2 (float=0.) : top radius\n        - depth (float=2.) : cone height\n        - segments (int=16) : number of segments\n        - cap_ends (bool=True) : fill cap faces\n        - cap_tris (bool = False) : fill with triangle fans\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    mesh = cls(materials=materials)\n    with mesh.bmesh() as bm:\n        res = bmesh.ops.create_cone(bm, cap_ends=cap_ends, cap_tris=cap_tris, segments=segments, radius1=radius1, radius2=radius2, depth=depth, calc_uvs=True)\n        if side_segments &gt; 1:\n\n            edges_to_cut = [\n                e for e in bm.edges\n                if (e.verts[0].co.z &gt; 0 and e.verts[1].co.z &lt; 0)\n                or (e.verts[0].co.z &lt; 0 and e.verts[1].co.z &gt; 0)\n            ]\n\n            # Edges subidivision\n            bmesh.ops.subdivide_edges(\n                bm,\n                edges         = edges_to_cut,\n                cuts          = side_segments - 1,\n                use_grid_fill = False\n            )\n\n    return mesh\n</code></pre>"},{"location":"api/#npblender.Mesh.bl_grid","title":"<code>bl_grid(x_segments=1, y_segments=1, size=2, materials=None)</code>  <code>classmethod</code>","text":"<p>Create a Grid.</p> <p>Blender constructor for a Grid.</p>"},{"location":"api/#npblender.Mesh.bl_grid--arguments","title":"Arguments","text":"<pre><code>- x_segments (int=1) : number of segments along x axis\n- y_segments (int=1) : number of segments along y axis\n- size (float or tuple of floats = 1. : size of the grid\n- materials (list of strs = None) : materials list\n</code></pre>"},{"location":"api/#npblender.Mesh.bl_grid--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef bl_grid(cls, x_segments=1, y_segments=1, size=2, materials=None):\n    \"\"\" Create a Grid.\n\n    Blender constructor for a Grid.\n\n    Arguments\n    ---------\n        - x_segments (int=1) : number of segments along x axis\n        - y_segments (int=1) : number of segments along y axis\n        - size (float or tuple of floats = 1. : size of the grid\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    mesh = cls(materials=materials)\n    with mesh.bmesh() as bm:\n        bmesh.ops.create_grid(bm, x_segments=x_segments, y_segments=y_segments, size=size, calc_uvs=True)\n\n    return mesh\n</code></pre>"},{"location":"api/#npblender.Mesh.blender_data","title":"<code>blender_data(readonly=False)</code>","text":"<p>Acces to Blender Mesh API.</p> <p>Transfer the geometry to a temporay Blender Mesh. The example below use a blender Mesh to get the normals.</p> <pre><code>mesh = Mesh.Cube()\n\nwith mesh.blender_data() as data:\n    normals = np.array([poly.normal for poly in data.polygons])\n\nprint(normals)\n\n# &gt; [[-1. -0.  0.]\n#    [ 0.  1.  0.]\n#    [ 1. -0.  0.]\n#    [ 0. -1.  0.]\n#    [ 0.  0. -1.]\n#    [ 0. -0.  1.]]\n</code></pre>"},{"location":"api/#npblender.Mesh.blender_data--arguments","title":"Arguments","text":"<pre><code>- readonly (bool=False) : don't read back the geometry if not modified\n</code></pre>"},{"location":"api/#npblender.Mesh.blender_data--returns","title":"Returns","text":"<pre><code>- Blender Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@contextmanager\ndef blender_data(self, readonly=False):\n    \"\"\" Acces to Blender Mesh API.\n\n    Transfer the geometry to a temporay Blender Mesh.\n    The example below use a blender Mesh to get the normals.\n\n    ``` python\n    mesh = Mesh.Cube()\n\n    with mesh.blender_data() as data:\n        normals = np.array([poly.normal for poly in data.polygons])\n\n    print(normals)\n\n    # &gt; [[-1. -0.  0.]\n    #    [ 0.  1.  0.]\n    #    [ 1. -0.  0.]\n    #    [ 0. -1.  0.]\n    #    [ 0.  0. -1.]\n    #    [ 0. -0.  1.]]\n    ```\n\n    Arguments\n    ---------\n        - readonly (bool=False) : don't read back the geometry if not modified\n\n    Returns\n    -------\n        - Blender Mesh\n    \"\"\"\n\n    data = bpy.data.meshes.get(DATA_TEMP_NAME)\n    if data is None:\n        data = bpy.data.meshes.new(DATA_TEMP_NAME)\n\n    self.to_mesh_data(data)\n\n    yield data\n\n    # ----- Back\n\n    if not readonly:\n        self.capture(Mesh.from_mesh_data(data))\n</code></pre>"},{"location":"api/#npblender.Mesh.bmesh","title":"<code>bmesh(readonly=False)</code>","text":"<p>Acces to bmesh api.</p> <p>The example below use bmesh to offset the vertices of +1 in the x axis.</p> <pre><code>mesh = Mesh.Cube()\n\n# Move the vertices with bmesh\nwith mesh.bmesh() as bm:\n    for v in bm.verts:\n        v.co.x += 1.0\n\n# Move the vertices directy in numpy array\nmesh.points.position[:, 1] += 1\n\n# Cube moved along x and y\nmesh.to_object(\"Cube\")\n</code></pre>"},{"location":"api/#npblender.Mesh.bmesh--arguments","title":"Arguments","text":"<pre><code>- readonly (bool=False) : avoid to read back the bmesh if not modications were done\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@contextmanager\ndef bmesh(self, readonly=False):\n    \"\"\" Acces to bmesh api.\n\n    The example below use bmesh to offset the vertices of +1 in the x axis.\n\n    ``` python\n    mesh = Mesh.Cube()\n\n    # Move the vertices with bmesh\n    with mesh.bmesh() as bm:\n        for v in bm.verts:\n            v.co.x += 1.0\n\n    # Move the vertices directy in numpy array\n    mesh.points.position[:, 1] += 1\n\n    # Cube moved along x and y\n    mesh.to_object(\"Cube\")\n    ```\n\n    Arguments\n    ---------\n        - readonly (bool=False) : avoid to read back the bmesh if not modications were done\n    \"\"\"\n\n    data = bpy.data.meshes.get(DATA_TEMP_NAME)\n    if data is None:\n        data = bpy.data.meshes.new(DATA_TEMP_NAME)\n    self.to_mesh_data(data)\n\n    bm = bmesh.new()   # create an empty BMesh\n    bm.from_mesh(data) # fill it in from a Mesh\n\n    yield bm\n\n    # ----- Back\n\n    if not readonly:\n        bm.to_mesh(data)\n        self.capture(Mesh.from_mesh_data(data))\n\n    bm.free()\n</code></pre>"},{"location":"api/#npblender.Mesh.boolean","title":"<code>boolean(other, operation='DIFFERENCE')</code>","text":"<p>Apply a boolean operation with another object.</p>"},{"location":"api/#npblender.Mesh.boolean--parameters","title":"Parameters","text":"<p>other : Mesh     The object to use as boolean operand. operation : str     Boolean operation: 'INTERSECT', 'UNION', or 'DIFFERENCE'.</p> Source code in <code>npblender/mesh.py</code> <pre><code>def boolean(self, other, operation='DIFFERENCE'):\n    \"\"\"\n    Apply a boolean operation with another object.\n\n    Parameters\n    ----------\n    other : Mesh\n        The object to use as boolean operand.\n    operation : str\n        Boolean operation: 'INTERSECT', 'UNION', or 'DIFFERENCE'.\n    \"\"\"\n\n    with other.object(0, readonly=True) as other_obj:\n\n        with self.object(1) as obj:\n            mod = obj.modifiers.new(name=\"Boolean\", type='BOOLEAN')\n            mod.object = other_obj\n            mod.operation = operation\n\n            # Apply modifier\n            bpy.ops.object.modifier_apply(modifier=mod.name)\n\n            mesh = Mesh.from_object(obj)\n\n    return mesh\n</code></pre>"},{"location":"api/#npblender.Mesh.bridge_loops","title":"<code>bridge_loops(loop0, loop1, close=False, segments=1, **attributes)</code>","text":"<p>Create a grid linking two loops of the same size.</p>"},{"location":"api/#npblender.Mesh.bridge_loops--arguments","title":"Arguments","text":"<ul> <li>loop0 (array of ints) : the first loop</li> <li>loop1 (array of ints) : the second loop</li> <li>segments (int = 1) : the number of segments to join the loops</li> <li>attributes (dict) : attributes to add to the mesh</li> </ul> Source code in <code>npblender/mesh.py</code> <pre><code>def bridge_loops(self, loop0, loop1, close=False, segments=1, **attributes):\n    \"\"\" Create a grid linking two loops of the same size.\n\n    Arguments\n    ---------\n    - loop0 (array of ints) : the first loop\n    - loop1 (array of ints) : the second loop\n    - segments (int = 1) : the number of segments to join the loops\n    - attributes (dict) : attributes to add to the mesh\n    \"\"\"\n    segments = max(1, segments)\n\n    if close:\n        loop0 = np.append(loop0, loop0[0]).astype(bint)\n        loop1 = np.append(loop1, loop1[0]).astype(bint)\n    else:\n        loop0 = np.asarray(loop0, dtype=bint)\n        loop1 = np.asarray(loop1, dtype=bint)\n\n    sel0 = np.stack((loop0[:-1], loop0[1:]), axis=-1)\n    sel1 = np.stack((loop1[:-1], loop1[1:]), axis=-1)\n\n    sel0 = np.sort(sel0, axis=-1)\n    sel1 = np.sort(sel1, axis=-1)\n\n    with self.bmesh() as bm:\n\n        edges, verts_indices = self._bm_edges(bm)\n\n        # Prepare edges view\n        dtype = np.dtype([('a', bint), ('b', bint)])\n        edges_view = verts_indices.view(dtype)\n\n        # First loop\n        sel0_view = sel0.view(dtype)\n        mask = np.isin(edges_view.ravel(), sel0_view.ravel())\n\n        edges_to_bridge = list(edges[mask])\n\n        # Second loop\n        sel1_view = sel1.view(dtype)\n        mask = np.isin(edges_view.ravel(), sel1_view.ravel())\n\n        edges_to_bridge.extend(list(edges[mask]))\n\n        if len(edges_to_bridge) == 0:\n            return\n\n        # Bridge\n        res = bmesh.ops.bridge_loops(\n            bm, \n            edges=edges_to_bridge,\n            #use_cyclic = close,\n            #segments=segments,\n            )\n\n        # Grid\n        if segments &gt; 1:\n            bmesh.ops.subdivide_edges(\n                bm,\n                edges=res['edges'],\n                cuts=segments - 1,\n                use_grid_fill=False\n            )\n</code></pre>"},{"location":"api/#npblender.Mesh.capture","title":"<code>capture(other)</code>","text":"<p>Capture the data of another Mesh.</p>"},{"location":"api/#npblender.Mesh.capture--arguments","title":"Arguments","text":"<pre><code>- other (Mesh) : the mesh to capture\n</code></pre>"},{"location":"api/#npblender.Mesh.capture--returns","title":"Returns","text":"<pre><code>- self\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def capture(self, other):\n    \"\"\" Capture the data of another Mesh.\n\n    Arguments\n    ---------\n        - other (Mesh) : the mesh to capture\n\n    Returns\n    -------\n        - self\n    \"\"\"\n\n    self.materials = other.materials\n\n    self.points  = other.points\n    self.corners = other.corners\n    self.faces   = other.faces\n    self.edges   = other.edges\n</code></pre>"},{"location":"api/#npblender.Mesh.chain_link","title":"<code>chain_link(major_segments=48, minor_segments=12, radius=1.0, section=0.5, length=4.0, materials=None)</code>  <code>classmethod</code>","text":"<p>Create a chain link.</p> <pre><code># ----- Some maths\n\n# Chain follows a catenary curve\ndef catenary(t):\n    return np.stack((t, np.zeros_like(t), np.cosh(t)), axis=-1)\n\n# Orientation is given by the derivative\ndef derivative(t):\n    dt = 1/10000\n    return (catenary(t + dt) - catenary(t - dt))/(2*dt)\n\n# Catenary length\npts = catenary(np.linspace(-1, 1, 1000))\ncat_s = np.cumsum(np.linalg.norm(pts[1:] - pts[:-1], axis=-1))\ncat_len = cat_s[-1]\n\n# Catenary inverse : t from length\ndef cat_inverse(l):\n    return 2*np.argmin(np.abs(cat_s - l))/1000 - 1\n\n# ----- Let's build the geometry\n\n# One chain link\nsection = .02\nlength  = .15\nlink = MeshBuilder.ChainLink(radius=.04, section=section, length=length)\n\n# Link length taking into account the section\nl = length - 2*section\n\n# Number of links\ncount = round(cat_len / l)\n\n# The chain\nchain = link*count\n\n# Rotate pi/2 one on two\neulers = Eulers(shape=count)\neulers[[i % 2 == 1 for i in range(count)]] = (0, np.pi/2, 0)\n\nchain.rotate(eulers)\nchain.rotate_z(np.pi/2)\n\n# Location of each link\nt = np.array([cat_inverse(l*i) for i in range(count)])\n\nchain.toward(derivative(t), track_axis='X', up_axis='Z')\nchain.translate(catenary(t))\n\n# To object\nchain.to_object(\"Catenary\")\n</code></pre>"},{"location":"api/#npblender.Mesh.chain_link--arguments","title":"Arguments","text":"<pre><code>- major_segments (int=48) : number of segments for the link\n- minor_segments (int=12) : number of segments for the section\n- radius (float=1.) : radius of the link\n- section (float=.5) : section (diameter)\n- length (float=4.) : total length of the link\n- materials (list of strs = None) : materials list\n</code></pre>"},{"location":"api/#npblender.Mesh.chain_link--returns","title":"Returns","text":"<pre><code>- MeshBuilder\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef chain_link(cls, major_segments=48, minor_segments=12, radius=1., section=0.5, length=4., materials=None):\n    \"\"\" Create a chain link.\n\n    ``` python\n    # ----- Some maths\n\n    # Chain follows a catenary curve\n    def catenary(t):\n        return np.stack((t, np.zeros_like(t), np.cosh(t)), axis=-1)\n\n    # Orientation is given by the derivative\n    def derivative(t):\n        dt = 1/10000\n        return (catenary(t + dt) - catenary(t - dt))/(2*dt)\n\n    # Catenary length\n    pts = catenary(np.linspace(-1, 1, 1000))\n    cat_s = np.cumsum(np.linalg.norm(pts[1:] - pts[:-1], axis=-1))\n    cat_len = cat_s[-1]\n\n    # Catenary inverse : t from length\n    def cat_inverse(l):\n        return 2*np.argmin(np.abs(cat_s - l))/1000 - 1\n\n    # ----- Let's build the geometry\n\n    # One chain link\n    section = .02\n    length  = .15\n    link = MeshBuilder.ChainLink(radius=.04, section=section, length=length)\n\n    # Link length taking into account the section\n    l = length - 2*section\n\n    # Number of links\n    count = round(cat_len / l)\n\n    # The chain\n    chain = link*count\n\n    # Rotate pi/2 one on two\n    eulers = Eulers(shape=count)\n    eulers[[i % 2 == 1 for i in range(count)]] = (0, np.pi/2, 0)\n\n    chain.rotate(eulers)\n    chain.rotate_z(np.pi/2)\n\n    # Location of each link\n    t = np.array([cat_inverse(l*i) for i in range(count)])\n\n    chain.toward(derivative(t), track_axis='X', up_axis='Z')\n    chain.translate(catenary(t))\n\n    # To object\n    chain.to_object(\"Catenary\")\n    ```\n\n    Arguments\n    ---------\n        - major_segments (int=48) : number of segments for the link\n        - minor_segments (int=12) : number of segments for the section\n        - radius (float=1.) : radius of the link\n        - section (float=.5) : section (diameter)\n        - length (float=4.) : total length of the link\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - MeshBuilder\n    \"\"\"\n\n    delta = length - 2*radius\n\n    # Starting from a torus\n    clink = cls.torus(\n        major_radius    = radius, \n        minor_radius    = section/2, \n        major_segments  = major_segments, \n        minor_segments  = minor_segments, \n        materials       = materials\n    )\n    # Nothing else\n    if delta &lt; radius/10:\n        return clink\n\n    epsilon = radius/major_segments\n\n    # Delete half of the points\n    clink.delete_vertices(points=clink.points.y &lt; -epsilon)\n    npoints = len(clink.points)\n    borders = clink.points.y &lt; epsilon\n    loop0 = np.arange(npoints)[np.logical_and(borders, clink.points.x &lt; 0)]\n    loop1 = np.arange(npoints)[np.logical_and(borders, clink.points.x &gt; 0)]\n    clink.points.y += delta/2\n\n    # Duplicate and inverse\n    half = Mesh.from_mesh(clink)\n    half.points.position[:, :2] *= -1\n\n    # Join\n    clink.join(half)\n\n    # Bridge\n    clink.bridge_loops(loop0, loop1 + npoints, close=True)\n    clink.bridge_loops(loop1, loop0 + npoints, close=True)\n\n    # UVMap\n    nu, nv = major_segments + 3, minor_segments + 1\n    uvmap = grid_uv_map(nu, nv).reshape(nu - 1, nv - 1, 4, 2)\n\n    ratio = (length - radius)/(length - radius + np.pi*radius)\n    dx_side = ratio/2\n\n    uvmap[:-2,..., 0] *= (1 - ratio)/(1 - 2/nu)\n    uvmap[-2,:, [0, 3], 0] = 1 - ratio\n    uvmap[-2,:, [1, 2], 0] = 1 - ratio/2\n    uvmap[-1,:, [0, 3], 0] = 1 - ratio/2\n\n    clink.corners.UVMap = uvmap.reshape(-1, 2)\n\n    return clink\n</code></pre>"},{"location":"api/#npblender.Mesh.circle","title":"<code>circle(radius=1, segments=16, fill_segments=0, cap='NONE', materials=None)</code>  <code>classmethod</code>","text":"<p>Create a Circle.</p> <p>'fill_segments' argument gives the number of internal circles to create. If zero, the circle if filled with a polygon. If positive, the circle is filled with triangle fans.</p>"},{"location":"api/#npblender.Mesh.circle--arguments","title":"Arguments","text":"<pre><code>- radius (float=1.) : circle radius\n- segments (int=16) : number of segments\n- fill_segments (int = 0) : number of internal segments, polygon is None\n- materials (list of strs = None) : materials list\n</code></pre>"},{"location":"api/#npblender.Mesh.circle--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef circle(cls, radius=1, segments=16, fill_segments=0, cap='NONE', materials=None):\n    \"\"\" Create a Circle.\n\n    'fill_segments' argument gives the number of internal circles to create.\n    If zero, the circle if filled with a polygon.\n    If positive, the circle is filled with triangle fans.\n\n    Arguments\n    ---------\n        - radius (float=1.) : circle radius\n        - segments (int=16) : number of segments\n        - fill_segments (int = 0) : number of internal segments, polygon is None\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    ag = np.linspace(0, 2*np.pi, segments, endpoint=False)\n    x = radius*np.cos(ag)\n    y = radius*np.sin(ag)\n    points = np.stack((x, y, np.zeros_like(x)), axis=-1)\n\n    if cap == 'NONE':\n        i = np.arange(segments)\n        edges = np.stack((i, np.roll(i, shift=-1)), axis=-1)\n        return cls(points=points, edges=edges)\n\n    elif cap == 'NGON':\n        return cls(\n            points      = points, \n            corners     = np.arange(segments), \n            faces       = segments,\n            UVMap       = disk_uv_map(segments, mode='NGON').reshape(-1, 2),\n            materials   = materials,\n        )\n\n    elif cap == 'FANS':\n        points = np.append(points, [[0, 0, 0]], axis=0)\n        topo = fans_corners(segments)\n\n        return cls(\n            points      = points, \n            corners     = topo.ravel(), \n            faces       = 3,\n            UVMap       = disk_uv_map(segments, mode='FANS').reshape(-1, 2),\n            materials   = materials,\n        )\n\n    #mesh = cls(points=points)\n    #mesh.fill_cap(np.arange(segments), mode=cap, center=segments, clockwise=True)\n\n    assert(False)\n</code></pre>"},{"location":"api/#npblender.Mesh.clear_geometry","title":"<code>clear_geometry()</code>","text":"<p>Clear the geometry.</p> <p>Delete all the content.</p> Source code in <code>npblender/mesh.py</code> <pre><code>def clear_geometry(self):\n    \"\"\" Clear the geometry.\n\n    Delete all the content.\n    \"\"\"\n\n    self.points.clear()\n    self.corners.clear()\n    self.faces.clear()\n    self.edges.clear()\n</code></pre>"},{"location":"api/#npblender.Mesh.cone","title":"<code>cone(vertices=32, side_segments=1, fill_segments=1, radius_top=0, radius_bottom=1, depth=2, fill_type='NGON', materials=None)</code>  <code>classmethod</code>","text":"<p>Create a Cone.</p>"},{"location":"api/#npblender.Mesh.cone--arguments","title":"Arguments","text":"<pre><code>- vertices (int=16) : number of segments\n- side_segments (int = 1) : number of vertical segments\n- fill_segments (int = 1) : number of internal circles on the caps\n- radius_top (float=0) : top radius\n- radius_bottom (float=1) : bottom radius\n- depth (float=2.) : cylinder height\n- fill_type (str or couple of strs ='NGON' in 'NGON', 'FANS', 'NONE') : cap filling\n- materials (list of strs = None) : materials list\n</code></pre>"},{"location":"api/#npblender.Mesh.cone--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef cone(cls, vertices=32, side_segments=1, fill_segments=1, radius_top=0, radius_bottom=1, depth=2, fill_type='NGON', materials=None):\n    \"\"\" Create a Cone.\n\n    Arguments\n    ---------\n        - vertices (int=16) : number of segments\n        - side_segments (int = 1) : number of vertical segments\n        - fill_segments (int = 1) : number of internal circles on the caps\n        - radius_top (float=0) : top radius\n        - radius_bottom (float=1) : bottom radius\n        - depth (float=2.) : cylinder height\n        - fill_type (str or couple of strs ='NGON' in 'NGON', 'FANS', 'NONE') : cap filling\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    # Empty geometry if fhe two radius are null\n    if radius_top == 0 and radius_bottom == 0:\n        return cls()\n\n    mesh = cls.bl_cone(\n        radius1       = radius_bottom,\n        radius2       = radius_top,\n        segments      = vertices,\n        side_segments = side_segments,\n        depth         = depth,\n        cap_ends      = fill_type in ['NGON', 'FANS'],\n        cap_tris      = fill_type == 'FANS',\n        materials     = materials,\n    )\n\n    return mesh\n</code></pre>"},{"location":"api/#npblender.Mesh.cube","title":"<code>cube(size=2, materials=None)</code>  <code>classmethod</code>","text":"<p>Create a Cube.</p>"},{"location":"api/#npblender.Mesh.cube--arguments","title":"Arguments","text":"<pre><code>- size (float=1.) : size of the cube\n- materials (list of strs = None) : materials list\n</code></pre>"},{"location":"api/#npblender.Mesh.cube--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef cube(cls, size=2, materials=None):\n    \"\"\" Create a Cube.\n\n    Arguments\n    ---------\n        - size (float=1.) : size of the cube\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    verts = [[-1., -1., -1.], [-1., -1.,  1.], [-1.,  1., -1.], [-1.,  1.,  1.], [ 1., -1., -1.], [ 1., -1.,  1.], [ 1.,  1., -1.], [ 1.,  1.,  1.],]\n    corners = [0, 1, 3, 2,  2, 3, 7, 6,  6, 7, 5, 4,  4, 5, 1, 0,  2, 6, 4, 0,  7, 3, 1, 5]\n    faces = [4]*6\n    uvs   = [[0.375, 0.000], [0.625, 0.000], [0.625, 0.250], [0.375, 0.250], [0.375, 0.250], [0.625, 0.250], [0.625, 0.500], [0.375, 0.500],\n             [0.375, 0.500], [0.625, 0.500], [0.625, 0.750], [0.375, 0.750], [0.375, 0.750], [0.625, 0.750], [0.625, 1.000], [0.375, 1.000],\n             [0.125, 0.500], [0.375, 0.500], [0.375, 0.750], [0.125, 0.750], [0.625, 0.500], [0.875, 0.500], [0.875, 0.750], [0.625, 0.750], ]\n\n\n    mesh = cls(points=verts, corners=corners, faces=faces, materials=materials, UVMap=uvs)\n\n    size = np.asarray(size)\n    mesh.points.position *= size/2\n\n    return mesh\n</code></pre>"},{"location":"api/#npblender.Mesh.cylinder","title":"<code>cylinder(vertices=32, side_segments=1, radius=1, depth=2, fill_type='NGON', materials=None)</code>  <code>classmethod</code>","text":"<p>Create a Cylinder.</p>"},{"location":"api/#npblender.Mesh.cylinder--arguments","title":"Arguments","text":"<pre><code>- vertices (int=16) : number of segments\n- side_segments (int = 1) : number of vertical segments\n- radius (float=1.) : radius\n- depth (float=2.) : cylinder height\n- fill_type (str or couple of strs ='NGON' in 'NGON', 'TRIANGLE_FAN', 'NONE') : cap filling\n- materials (list of strs = None) : materials list\n</code></pre>"},{"location":"api/#npblender.Mesh.cylinder--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef cylinder(cls, vertices=32, side_segments=1, radius=1, depth=2, fill_type='NGON', materials=None):\n    \"\"\" Create a Cylinder.\n\n    Arguments\n    ---------\n        - vertices (int=16) : number of segments\n        - side_segments (int = 1) : number of vertical segments\n        - radius (float=1.) : radius\n        - depth (float=2.) : cylinder height\n        - fill_type (str or couple of strs ='NGON' in 'NGON', 'TRIANGLE_FAN', 'NONE') : cap filling\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    mesh = cls.bl_cone(\n        radius1       = radius,\n        radius2       = radius,\n        segments      = vertices,\n        side_segments = side_segments,\n        depth         = depth,\n        cap_ends      = fill_type in ['NGON', 'FANS'],\n        cap_tris      = fill_type == 'FANS',\n        materials     = materials,\n    )\n\n    return mesh\n</code></pre>"},{"location":"api/#npblender.Mesh.delete_faces","title":"<code>delete_faces(selection)</code>","text":"<p>Delete only faces.</p> Source code in <code>npblender/mesh.py</code> <pre><code>def delete_faces(self, selection):\n    \"\"\" Delete only faces.\n    \"\"\"\n    self.faces.delete_loops(selection, self.corners)\n</code></pre>"},{"location":"api/#npblender.Mesh.delete_vertices","title":"<code>delete_vertices(points=None, faces=None, edges=None)</code>","text":"<p>Delete vertices.</p>"},{"location":"api/#npblender.Mesh.delete_vertices--arguments","title":"Arguments","text":"<pre><code>points : array selection, optional\n    Vertex indices to delete directly.\nfaces : array selection, optional\n    Faces owning vertices to delete.\nedges : array selection, optional\n    Edges owning vertices to delete.\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def delete_vertices(self, points=None, faces=None, edges=None):\n    \"\"\"Delete vertices.\n\n    Arguments\n    ---------\n        points : array selection, optional\n            Vertex indices to delete directly.\n        faces : array selection, optional\n            Faces owning vertices to delete.\n        edges : array selection, optional\n            Edges owning vertices to delete.\n    \"\"\"\n    go = False\n    if points is not None:\n        p_sel = set(np.arange(len(self.points))[points])\n        go = True\n    if faces is not None:\n        f_sel = set(np.arange(len(self.faces))[faces])\n        go = True\n    if edges is not None:\n        e_sel = set(np.arange(len(self.edges))[edges])\n        go = True\n\n    if not go:\n        return \n\n    with self.bmesh() as bm:\n        verts_to_delete = set()\n\n        for vert in bm.verts:\n            if points is not None and vert.index in p_sel:\n                verts_to_delete.add(vert)\n                continue\n\n            if faces is not None:\n                if any(f.index in f_sel for f in vert.link_faces):\n                    verts_to_delete.add(vert)\n                    continue\n\n            if edges is not None:\n                if any(e.index in e_sel for e in vert.link_edges):\n                    verts_to_delete.add(vert)\n                    continue\n\n        bmesh.ops.delete(bm, geom=list(verts_to_delete), context='VERTS')\n</code></pre>"},{"location":"api/#npblender.Mesh.disk","title":"<code>disk(radius=1, segments=16, fill_segments=0, cap='NGON', materials=None)</code>  <code>classmethod</code>","text":"<p>Create a disk.</p> <p>Same as circle but default cap is NGON</p> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef disk(cls, radius=1, segments=16, fill_segments=0, cap='NGON', materials=None):\n    \"\"\" Create a disk.\n\n    Same as circle but default cap is NGON\n    \"\"\"    \n    return cls.circle(radius=radius, segments=segments, fill_segments=fill_segments, cap=cap, materials=materials)\n</code></pre>"},{"location":"api/#npblender.Mesh.extrude_faces","title":"<code>extrude_faces(selection, offset=None, scale=1.0)</code>","text":"<p>Extrude individual faces.</p> <p>If offset is None, faces are extruder along their normal</p>"},{"location":"api/#npblender.Mesh.extrude_faces--arguments","title":"Arguments","text":"<pre><code>- selection : indices of the faces to extrude\n- offset (vector or array of vectors) : the extrusion vector\n- scale (float = 1) : scale factor for offsets\n- dissolve (bool = True) : remove starting faces\n</code></pre>"},{"location":"api/#npblender.Mesh.extrude_faces--returns","title":"Returns","text":"<pre><code>- dictionnary : 'top' : extruded faces, 'side' : extruded side faces\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def extrude_faces(self, selection, offset=None, scale=1.):\n    \"\"\" Extrude individual faces.\n\n    If offset is None, faces are extruder along their normal\n\n    Arguments\n    ---------\n        - selection : indices of the faces to extrude\n        - offset (vector or array of vectors) : the extrusion vector\n        - scale (float = 1) : scale factor for offsets\n        - dissolve (bool = True) : remove starting faces\n\n    Returns\n    -------\n        - dictionnary : 'top' : extruded faces, 'side' : extruded side faces\n    \"\"\"\n\n    # Selected faces indices\n    faces_sel = np.arange(len(self.faces))\n    if selection is not None:\n        faces_sel = faces_sel[selection]\n\n    # bmesh edition\n    with self.bmesh() as bm:\n        #bm.verts.ensure_lookup_table()\n        bm.faces.ensure_lookup_table()\n\n        # select faces\n        start_faces = [bm.faces[i] for i in faces_sel]\n\n        res = {'top': [], 'side': []}\n\n        # bmesh.ops\n        d = bmesh.ops.extrude_discrete_faces(bm, faces=start_faces)\n        new_faces = d[\"faces\"]\n\n\n\n        # One direction per face\n        if offset is not None:\n            shape = np.broadcast_shapes(np.shape(offset), (len(new_faces), 3))\n            offsets = np.broadcast_to(offset, shape)*scale\n\n        # Loop on created faces\n        for i_face, face in enumerate(new_faces):\n            verts = face.verts\n            if offset is None:\n                ofs = face.normal*scale\n            else:\n                ofs = offsets[i_face]\n\n            bmesh.ops.translate(bm, verts=list(verts), vec=ofs)\n\n            res['top'].append(face.index)\n            for e in face.edges:\n                assert(len(e.link_faces) == 2)\n                if e.link_faces[0].index == face.index:\n                    res['side'].append(e.link_faces[1].index)\n                else:\n                    res['side'].append(e.link_faces[0].index)\n\n    return res\n</code></pre>"},{"location":"api/#npblender.Mesh.extrude_loop","title":"<code>extrude_loop(loop, offset, close=False, clockwise=False, **attributes)</code>","text":"<p>Extrude a loop of vertices.</p>"},{"location":"api/#npblender.Mesh.extrude_loop--arguments","title":"Arguments","text":"<pre><code>- loop (array of ints) : vertex indices\n- offset (float = 1) : multiplicator of the direction vector\n- direction (vector = None) : extrusion direction, normal if None\n- clockwise (bool=False) : faces orientation\n- attributes : attribute for the new geometry\n</code></pre>"},{"location":"api/#npblender.Mesh.extrude_loop--returns","title":"Returns","text":"<pre><code>- dictionnary of the created geometry : vertex indices, face indices\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def extrude_loop(self, loop, offset, close=False, clockwise=False, **attributes):\n    \"\"\" Extrude a loop of vertices.\n\n    Arguments\n    ---------\n        - loop (array of ints) : vertex indices\n        - offset (float = 1) : multiplicator of the direction vector\n        - direction (vector = None) : extrusion direction, normal if None\n        - clockwise (bool=False) : faces orientation\n        - attributes : attribute for the new geometry\n\n    Returns\n    -------\n        - dictionnary of the created geometry : vertex indices, face indices\n    \"\"\"\n    loop = np.atleast_1d(loop)\n    if len(loop) &lt; 2:\n        return None\n\n    verts = self.points.position[loop]\n    try:\n        new_verts = verts + offset\n    except Exception as e:\n        raise AttributeError(\n            f\"Extrude&gt; Offset argument must be a single vector or an array of {len(verts)} vectors, not {np.shape(offset)}.\"\n            )\n\n    indices = np.append(loop, len(self.points) + np.arange(len(new_verts)))\n    gc = grid_corners(len(verts), 2, row_first=True, close_x=close, clockwise=clockwise)\n    corners = indices[gc.ravel()]\n    uvmap = grid_uv_map(len(verts), 2, close_x=close, clockwise=clockwise).reshape(-1, 2)\n\n    return self.add_geometry(points=new_verts, corners=corners, faces=4, UVMap=uvmap)\n</code></pre>"},{"location":"api/#npblender.Mesh.extrude_region","title":"<code>extrude_region(selection, offset=(0, 0, 1), dissolve=False)</code>","text":"<p>Extrude individual faces.</p>"},{"location":"api/#npblender.Mesh.extrude_region--arguments","title":"Arguments","text":"<pre><code>- selection : indices of the faces to extrude\n- offset (vector = (0, 0, 1)) : the extrusion vector\n- dissolve (bool = True) : remove starting faces\n</code></pre>"},{"location":"api/#npblender.Mesh.extrude_region--returns","title":"Returns","text":"<pre><code>- dictionnary : 'top' : extruded faces, 'side' : extruded side faces\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def extrude_region(self, selection, offset=(0, 0, 1), dissolve=False):\n    \"\"\" Extrude individual faces.\n\n    Arguments\n    ---------\n        - selection : indices of the faces to extrude\n        - offset (vector = (0, 0, 1)) : the extrusion vector\n        - dissolve (bool = True) : remove starting faces\n\n    Returns\n    -------\n        - dictionnary : 'top' : extruded faces, 'side' : extruded side faces\n    \"\"\"\n\n    # Selected faces indices\n    faces_sel = np.arange(len(self.faces))\n    if selection is not None:\n        faces_sel = faces_sel[selection]\n\n    # bmesh edition\n    with self.bmesh() as bm:\n        #bm.verts.ensure_lookup_table()\n        bm.faces.ensure_lookup_table()\n\n        # select faces\n        start_faces = [bm.faces[i] for i in faces_sel]\n\n        res = {'top': [], 'side': []}\n\n\n        # Extrusion\n        d = bmesh.ops.extrude_face_region(\n            bm, \n            geom                      = start_faces,\n            #edges_exclude            = set(),\n            #use_keep_orig            = False,\n            #use_normal_flip          = False,\n            #use_normal_from_adjacent = False,\n            #use_dissolve_ortho_edges = False,\n            #use_select_history       = False,\n            )\n\n        # Move new vectors\n        extruded_geom = d[\"geom\"]\n        new_verts = [ele for ele in extruded_geom if isinstance(ele, bmesh.types.BMVert)]\n        new_faces = [ele for ele in extruded_geom if isinstance(ele, bmesh.types.BMFace)]\n\n        bmesh.ops.translate(bm, verts=new_verts, vec=list(offset))\n\n        # ===== Result\n        for face in new_faces:\n            res['top'].append(face.index)\n            for e in face.edges:\n                assert(len(e.link_faces) == 2)\n                if e.link_faces[0].index == face.index:\n                    res['side'].append(e.link_faces[1].index)\n                else:\n                    res['side'].append(e.link_faces[0].index)\n\n        # ===== Dissolve extruded faces\n        if dissolve:\n            bm.faces.ensure_lookup_table()\n            del_faces = [bm.faces[i] for i in faces_sel]\n\n            bmesh.ops.delete(bm, geom=del_faces, context='FACES')                   \n\n    return res\n</code></pre>"},{"location":"api/#npblender.Mesh.extrude_vertices","title":"<code>extrude_vertices(selection, offset, **attributes)</code>","text":"<p>Extrude individual vertices</p>"},{"location":"api/#npblender.Mesh.extrude_vertices--arguments","title":"Arguments","text":"<pre><code>- selection (selector) : points selection, all if None\n- offset (vector or array of vectors) : extrusion vector\n- attributes (dict) : points attributes\n</code></pre>"},{"location":"api/#npblender.Mesh.extrude_vertices--returns","title":"Returns","text":"<pre><code>- dictionnary of the created geometry : vertex indices, face indices\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def extrude_vertices(self, selection, offset, **attributes):\n    \"\"\" Extrude individual vertices\n\n    Arguments\n    ---------\n        - selection (selector) : points selection, all if None\n        - offset (vector or array of vectors) : extrusion vector\n        - attributes (dict) : points attributes\n\n    Returns\n    -------\n        - dictionnary of the created geometry : vertex indices, face indices\n    \"\"\"\n    inds = np.arange(len(self.points))\n    if selection is not None:\n        inds = inds[selection]\n\n    pos = self.points.position[inds] + offset\n    new_inds = np.arange(len(pos)) + len(self.points)\n    edges = edges_between(inds, new_inds)\n\n    return self.add_geometry(points=pos, edges=edges.reshape(-1, 2), **attributes)\n</code></pre>"},{"location":"api/#npblender.Mesh.fill_cap","title":"<code>fill_cap(loop, mode='NGON', center=None, segments=1, clockwise=False, **attributes)</code>","text":"<p>Fill a cap between an existing loop</p> <p>For NGON mode, center is not required. For FANS mode, a center point is required: - if center is None, it is computed as the center of the loop - if center is an int, it is the index of the point to use - otherwise, the center is considered as the point to use</p>"},{"location":"api/#npblender.Mesh.fill_cap--arguments","title":"Arguments","text":"<ul> <li>loop (array of ints) : the circle loop</li> <li>mode (FillCap = 'NGON') : NGON or FANS</li> <li>center (point index or point or None) : center of the cap</li> <li>clockwise (bool = False) : order of the corners in the loop</li> <li>indexing (str = 'ij') : indexing of the points</li> <li>attributes (dict) : attributes to add to the mesh (see Geometry.add_geometry(</li> </ul> Source code in <code>npblender/mesh.py</code> <pre><code>def fill_cap(self, loop, mode='NGON', center=None, segments=1, clockwise=False, **attributes):\n    \"\"\" Fill a cap between an existing loop\n\n    For NGON mode, center is not required.\n    For FANS mode, a center point is required:\n    - if center is None, it is computed as the center of the loop\n    - if center is an int, it is the index of the point to use\n    - otherwise, the center is considered as the point to use\n\n    Arguments\n    ---------\n    - loop (array of ints) : the circle loop\n    - mode (FillCap = 'NGON') : NGON or FANS\n    - center (point index or point or None) : center of the cap\n    - clockwise (bool = False) : order of the corners in the loop\n    - indexing (str = 'ij') : indexing of the points\n    - attributes (dict) : attributes to add to the mesh (see Geometry.add_geometry(\n    \"\"\"\n    if mode == 'NONE':\n        # To have en empty dict\n        return self.add_geometry()\n\n    elif mode == 'NGON':\n        return self.add_geometry(corners=loop, faces=len(loop), UVMap=self.disk_uv_map(len(loop), mode='NGON', clockwise=clockwise), **attributes)\n\n    elif mode == 'FANS':\n\n        if center is None:\n            verts = self.points.position[loop]\n            center = np.average(verts, axis=0)\n            center_index = len(self.points)\n            cind = self.add_points(center)\n\n        elif isinstance(center, (int, np.int32, np.int64)):\n            center_index = center\n            cind = [center_index]\n\n        else:\n            center_index = len(self.points)\n            cind = self.add_points(center)\n\n        indices = np.append(loop, center_index)\n\n        topo = fans_corners(len(loop), close=True, clockwise=clockwise).ravel()\n\n        corners = indices[topo]\n        uv_map = disk_uv_map(len(loop), mode='FANS', clockwise=clockwise).reshape(-1, 2)\n\n        added = self.add_geometry(corners=corners, faces=3, UVMap=uv_map, **attributes)\n        added['points'] = np.asarray(cind)\n\n        # More than one segments\n\n        if segments &gt; 1:\n            self.split_edges(loop, center_index, cuts=segments - 1)\n\n        return added\n\n    assert(False)\n</code></pre>"},{"location":"api/#npblender.Mesh.from_mesh","title":"<code>from_mesh(other, points=None, faces=None, edges=None)</code>  <code>classmethod</code>","text":"<p>Create a Mesh from another mesh.</p>"},{"location":"api/#npblender.Mesh.from_mesh--arguments","title":"Arguments","text":"<pre><code>- other (Mesh) : the mesh to copy\n</code></pre>"},{"location":"api/#npblender.Mesh.from_mesh--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef from_mesh(cls, other, points=None, faces=None, edges=None):\n    \"\"\" Create a Mesh from another mesh.\n\n    Arguments\n    ---------\n        - other (Mesh) : the mesh to copy\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    mesh = cls(materials=other.materials)\n    mesh.points  = Vertex(other.points,  mode='COPY')\n    mesh.corners = Corner(other.corners, mode='COPY')\n    mesh.faces   = Face(other.faces,   mode='COPY')\n    mesh.edges   = Edge(other.edges,    mode='COPY')\n\n    if points is None:\n        points_mask = None\n    else:\n        points_mask = np.ones(len(mesh.points), dtype=bool)\n        points_mask[points] = False\n\n    if faces is None:\n        faces_mask = None\n    else:\n        faces_mask = np.ones(len(mesh.faces), dtype=bool)\n        faces_mask[faces] = False\n\n    if edges is None:\n        edges_mask = None\n    else:\n        edges_mask = np.ones(len(mesh.edges), dtype=bool)\n        edges_mask[edges] = False\n\n    mesh.delete_vertices(points=points_mask, faces=faces_mask, edges=edges_mask)\n\n    return mesh\n</code></pre>"},{"location":"api/#npblender.Mesh.from_mesh_data","title":"<code>from_mesh_data(data)</code>  <code>classmethod</code>","text":"<p>Initialize the geometry from a Blender Mesh</p>"},{"location":"api/#npblender.Mesh.from_mesh_data--arguments","title":"Arguments","text":"<pre><code>- mesh (Blender Mesh instance) : the mesh to load\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef from_mesh_data(cls, data):\n    \"\"\" Initialize the geometry from a Blender Mesh\n\n    Arguments\n    ---------\n        - mesh (Blender Mesh instance) : the mesh to load\n    \"\"\"\n\n    from . import blender\n\n    bl_mesh = blender.get_mesh(data)\n\n    mesh = cls()\n\n    # ----- Materials\n\n    mesh.materials = [None if mat is None else mat.name for mat in bl_mesh.materials]\n\n    # ----- Vertices\n\n    n = len(bl_mesh.vertices)\n    if n != 0:\n        # Positions will be read as position attribute\n        mesh.points.resize(n)\n\n    # ----- Corners\n\n    n = len(bl_mesh.polygons)\n    if n != 0:\n        a = np.empty(len(bl_mesh.loops), bint)\n        bl_mesh.loops.foreach_get(\"vertex_index\", a)\n        mesh.corners.append(vertex_index=a)\n\n        a = np.empty(len(bl_mesh.polygons), bint)\n        bl_mesh.polygons.foreach_get(\"loop_total\", a)\n        mesh.faces.append_sizes(a)\n\n        del a\n\n    # ----- Edges\n\n    if len(bl_mesh.edges):\n        n = len(bl_mesh.edges)\n        a = np.empty(2*n, bint)\n        bl_mesh.edges.foreach_get(\"vertices\", a)\n        a = np.reshape(a, (n, 2))\n        mesh.edges.append(vertex0=a[:, 0], vertex1=a[:, 1])\n\n        del a\n\n        mesh.edges.remove_face_edges(mesh.faces.get_edges(mesh.corners))\n\n    # ----- Attributes\n\n    mesh.points.from_bl_attributes(bl_mesh.attributes)\n    mesh.corners.from_bl_attributes(bl_mesh.attributes)\n    mesh.faces.from_bl_attributes(bl_mesh.attributes)\n    mesh.edges.from_bl_attributes(bl_mesh.attributes)\n\n    return mesh\n</code></pre>"},{"location":"api/#npblender.Mesh.from_object","title":"<code>from_object(obj, evaluated=False)</code>  <code>classmethod</code>","text":"<p>Create a Mesh from an existing object.</p>"},{"location":"api/#npblender.Mesh.from_object--arguments","title":"Arguments","text":"<pre><code>- obj (str or Blender object) : the object to initialize from\n- evaluated (bool = False) : object modified by the modifiers if True, raw vertices otherwise\n</code></pre>"},{"location":"api/#npblender.Mesh.from_object--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef from_object(cls, obj, evaluated=False):\n    \"\"\" Create a Mesh from an existing object.\n\n    Arguments\n    ---------\n        - obj (str or Blender object) : the object to initialize from\n        - evaluated (bool = False) : object modified by the modifiers if True, raw vertices otherwise\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    from . import blender\n\n    if evaluated:\n        depsgraph = bpy.context.evaluated_depsgraph_get()\n        object_eval = blender.get_object(obj).evaluated_get(depsgraph)\n        return cls.FromMeshData(object_eval.data)\n\n    else:\n        return cls.from_mesh_data(blender.get_object(obj).data)\n</code></pre>"},{"location":"api/#npblender.Mesh.get_islands","title":"<code>get_islands()</code>","text":"<p>Get an island id per face.</p> Source code in <code>npblender/mesh.py</code> <pre><code>def get_islands(self):\n    \"\"\" Get an island id per face.\n    \"\"\"\n    from collections import deque\n\n    nfaces = len(self.faces)\n    if not nfaces:\n        return []\n\n    islands = np.full(nfaces, -1, dtype=np.int32)\n    cur_island = -1\n\n    passed = np.zeros(nfaces, dtype=bool)\n\n    with self.bmesh() as bm:\n        bm.faces.ensure_lookup_table()\n        bm.edges.ensure_lookup_table()\n\n        for f in bm.faces:\n            # Already visited\n            if islands[f.index] &gt;= 0:\n                continue\n\n            # New island index\n            cur_island += 1\n\n            q = deque([f])\n            while q:\n                cur = q.popleft()\n\n                # Part of the current island\n                islands[cur.index] = cur_island\n\n                # No infinite loop\n                passed[cur.index] = True\n\n                # Loop on the edges\n                for e in cur.edges:                                               \n                    # Loop on the edge faces\n                    for nb in e.link_faces:\n                        if passed[nb.index]:\n                            continue\n                        passed[nb.index] = True\n\n                        if islands[nb.index] &lt; 0:\n                            q.append(nb)\n\n\n    return islands\n</code></pre>"},{"location":"api/#npblender.Mesh.grid","title":"<code>grid(size_x=1, size_y=1, vertices_x=3, vertices_y=3, materials=None)</code>  <code>classmethod</code>","text":"<p>Create a Grid.</p> <p>[!IMPORTANT] Grid is created with indexing = 'ij': shape = (resolution x, resolution y)</p>"},{"location":"api/#npblender.Mesh.grid--arguments","title":"Arguments","text":"<pre><code>- size_x (float=1) : size along x\n_ size_y (float=1) : size along y\n- vertices_x (int=3) : number of vertices along x\n- vertices_y (int=3) : number of vertices along y\n- materials (list of strs = None) : materials list\n</code></pre>"},{"location":"api/#npblender.Mesh.grid--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef grid(cls, size_x=1, size_y=1, vertices_x=3, vertices_y=3, materials=None):\n    \"\"\" Create a Grid.\n\n    &gt; [!IMPORTANT]\n    &gt; Grid is created with indexing = 'ij': shape = (resolution x, resolution y)\n\n    Arguments\n    ---------\n        - size_x (float=1) : size along x\n        _ size_y (float=1) : size along y\n        - vertices_x (int=3) : number of vertices along x\n        - vertices_y (int=3) : number of vertices along y\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    nx = max(2, vertices_x)\n    ny = max(2, vertices_y)\n\n    topo = grid_corners(nx, ny).ravel()\n\n    # ----------------------------------------------------------------------------------------------------\n    # Base grid for points and uvs\n\n    x, y = np.meshgrid(\n        np.linspace(-size_x/2, size_x/2, nx, dtype=bfloat), \n        np.linspace(-size_y/2, size_y/2, ny, dtype=bfloat), \n        indexing='ij')\n    x, y = x.ravel(), y.ravel()\n\n    # ----------------------------------------------------------------------------------------------------\n    # Let 's build the grid\n\n    points = np.stack((x, y, np.zeros_like(x)), axis=-1)\n    corners = np.arange(len(points))[topo]\n    faces = 4\n    uvmap = grid_uv_map(nx, ny).reshape(-1, 2)\n\n    return cls(points, corners, faces, materials=materials, UVMap=uvmap)\n</code></pre>"},{"location":"api/#npblender.Mesh.icosphere","title":"<code>icosphere(radius=1, subdivisions=2, materials=None)</code>  <code>classmethod</code>","text":"<p>Create a IcoSphere.</p> <p>Blender constructor for a IcoSphere.</p>"},{"location":"api/#npblender.Mesh.icosphere--arguments","title":"Arguments","text":"<pre><code>- radius (float=1.) : radius\n- subdivisions (int=2) : number subdivisions\n- materials (list of strs = None) : materials list\n- transformation (Transformations = None) : the transformation to apply\n</code></pre>"},{"location":"api/#npblender.Mesh.icosphere--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef icosphere(cls, radius=1, subdivisions=2, materials=None):\n    \"\"\" Create a IcoSphere.\n\n    Blender constructor for a IcoSphere.\n\n    Arguments\n    ---------\n        - radius (float=1.) : radius\n        - subdivisions (int=2) : number subdivisions\n        - materials (list of strs = None) : materials list\n        - transformation (Transformations = None) : the transformation to apply\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    subdivisions = min(10, subdivisions)\n\n    mesh = cls(materials=materials)\n    with mesh.bmesh() as bm:\n        bmesh.ops.create_icosphere(bm, subdivisions=subdivisions, radius=radius, calc_uvs=True)\n\n    return mesh\n</code></pre>"},{"location":"api/#npblender.Mesh.inset_faces","title":"<code>inset_faces(selection, thickness=0.1, depth=0.0, use_even_offset=True, use_relative_offset=False)</code>","text":"<p>Extrude individual faces.</p> <p>If offset is None, faces are extruder along their normal</p>"},{"location":"api/#npblender.Mesh.inset_faces--arguments","title":"Arguments","text":"<p>selection : selection on faces     indices of the faces to inset thickness : float     Inset thickness. depth : float     Inset depth (extrusion). use_even_offset : bool     Keep consistent thickness. use_relative_offset : bool     Offset relative to face size.</p>"},{"location":"api/#npblender.Mesh.inset_faces--returns","title":"Returns","text":"<p>dict with:     'faces' : list of new inset faces</p> Source code in <code>npblender/mesh.py</code> <pre><code>def inset_faces(self, selection, thickness=0.1, depth=0.0, use_even_offset=True, use_relative_offset=False):\n    \"\"\" Extrude individual faces.\n\n    If offset is None, faces are extruder along their normal\n\n    Arguments\n    ---------\n    selection : selection on faces\n        indices of the faces to inset\n    thickness : float\n        Inset thickness.\n    depth : float\n        Inset depth (extrusion).\n    use_even_offset : bool\n        Keep consistent thickness.\n    use_relative_offset : bool\n        Offset relative to face size.\n\n    Returns\n    -------\n    dict with:\n        'faces' : list of new inset faces\n    \"\"\"\n\n    # Selected faces indices\n    faces_sel = np.arange(len(self.faces))\n    if selection is not None:\n        faces_sel = faces_sel[selection]\n\n    # bmesh edition\n    with self.bmesh() as bm:\n        bm.faces.ensure_lookup_table()\n\n        # select faces\n        start_faces = [bm.faces[i] for i in faces_sel]\n\n        res = {'top': [], 'side': []}\n\n        # bmesh.ops\n        d = bmesh.ops.inset_individual(\n            bm,\n            faces               = start_faces,\n            thickness           = thickness,\n            depth               = depth,\n            use_even_offset     = use_even_offset,\n            use_relative_offset = use_relative_offset,\n        )\n\n        res = {\n            'top': faces_sel,\n            'side': [face.index for face in d[\"faces\"]]\n        }\n\n    return res\n</code></pre>"},{"location":"api/#npblender.Mesh.join","title":"<code>join(*others)</code>","text":"<p>Join other Meshes.</p>"},{"location":"api/#npblender.Mesh.join--arguments","title":"Arguments","text":"<pre><code>- others (Mesh) : the Mesh to append\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def join(self, *others):\n    \"\"\" Join other Meshes.\n\n    Arguments\n    ---------\n        - others (Mesh) : the Mesh to append\n    \"\"\"\n    for other in others:\n\n        # ----------------------------------------------------------------------------------------------------\n        # Vertices\n\n        v_ofs = len(self.points)\n        self.points.extend(other.points)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Corners\n\n        c_ofs = len(self.corners)\n        self.corners.extend(other.corners)\n        if len(self.corners):\n            self.corners.vertex_index[c_ofs:] += v_ofs\n\n        # ----------------------------------------------------------------------------------------------------\n        # Faces\n\n        f_ofs = len(self.faces)\n        self.faces.extend(other.faces)\n        if len(self.faces):\n            self.faces.loop_start[f_ofs:] += c_ofs\n\n        # ----------------------------------------------------------------------------------------------------\n        # Edges\n\n        e_ofs = len(self.edges)\n        self.edges.extend(other.edges)\n        if len(self.edges):\n            self.edges.vertex0[e_ofs:] += v_ofs\n            self.edges.vertex1[e_ofs:] += v_ofs\n\n        # ----- Materials\n\n        remap = np.array([self.get_material_index(mat_name) for mat_name in other.materials])\n        if len(remap)&gt;0:\n            self.faces.material_index[f_ofs:] = remap[other.faces.material_index]\n\n    return self\n</code></pre>"},{"location":"api/#npblender.Mesh.join_geometry","title":"<code>join_geometry(points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs)</code>","text":"<p>Join geometry defined by components.</p> <p>The geometry passed in argument is consistent and doesn't refer to existing vertices. It is used to build an independant mesh which is then joined. See 'add_geometry' which, on the contrary, can refer to existing vertices.</p>"},{"location":"api/#npblender.Mesh.join_geometry--returns","title":"Returns","text":"<pre><code>- self\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def join_geometry(self, points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs):\n    \"\"\" Join geometry defined by components.\n\n    The geometry passed in argument is consistent and doesn't refer to existing vertices. It is used\n    to build an independant mesh which is then joined.\n    See 'add_geometry' which, on the contrary, can refer to existing vertices.\n\n    Returns\n    -------\n        - self\n    \"\"\"\n    mesh = Mesh(attr_from=self)\n    mesh.add_geometry(\n        points=points, \n        corners=corners, \n        faces=faces, \n        edges=edges,\n        **attrs)\n    self.join(mesh)\n    return self\n</code></pre>"},{"location":"api/#npblender.Mesh.line","title":"<code>line(start=(0, 0, 0), end=(0, 0, 1), segments=1, materials=None)</code>  <code>classmethod</code>","text":"<p>Create a mesh with lines between the given positions.</p>"},{"location":"api/#npblender.Mesh.line--arguments","title":"Arguments","text":"<pre><code>- start (vertex =(0, 0, 0) : position of the start of the lines\n- end (vertex=(0, 0, 1) : position of the end of the lines\n- count (int=2) : number of points in the line\n</code></pre>"},{"location":"api/#npblender.Mesh.line--returns","title":"Returns","text":"<pre><code>- mesh (Mesh) : the mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef line(cls, start=(0, 0, 0), end=(0, 0, 1), segments=1, materials=None):\n    \"\"\" Create a mesh with lines between the given positions.\n\n    Arguments\n    ---------\n        - start (vertex =(0, 0, 0) : position of the start of the lines\n        - end (vertex=(0, 0, 1) : position of the end of the lines\n        - count (int=2) : number of points in the line\n\n    Returns\n    -------\n        - mesh (Mesh) : the mesh\n    \"\"\"\n    segments = max(1, segments)\n\n    start = np.asarray(start, dtype=bfloat)\n    end   = np.asarray(end, dtype=bfloat)\n\n    pos = np.linspace(start, end, segments + 1) # shape (segments, n points, 3)\n\n    if len(pos.shape) == 2:\n        edges = border_edges(np.arange(segments))\n    else:\n        shape = pos.shape[:-1]\n        n = int(np.prod(shape))\n        edges = col_edges(np.arange(n).reshape(shape))\n\n    return cls(points=pos.reshape(-1, 3), edges=edges.reshape(-1, 2), materials=materials)\n</code></pre>"},{"location":"api/#npblender.Mesh.monkey","title":"<code>monkey(materials=None)</code>  <code>classmethod</code>","text":"<p>Create a Monkey.</p>"},{"location":"api/#npblender.Mesh.monkey--arguments","title":"Arguments","text":"<pre><code>- materials (list of strs = None) : materials list\n</code></pre>"},{"location":"api/#npblender.Mesh.monkey--returns","title":"Returns","text":"<pre><code>- MeshBuilder\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef monkey(cls, materials=None):\n    \"\"\" Create a Monkey.\n\n    Arguments\n    ---------\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - MeshBuilder\n    \"\"\"\n    mesh = cls(materials=materials)\n    with mesh.bmesh() as bm:\n        bmesh.ops.create_monkey(bm)\n\n    return mesh\n</code></pre>"},{"location":"api/#npblender.Mesh.multiply","title":"<code>multiply(count, in_place=True)</code>","text":"<p>Duplicate the geometry.</p> <p>Multiplying is a way to efficiently duplicate the geometry a great number of times. Once duplicated, the vertices can be reshapped to address each instance individually.</p> <pre><code>count = 16\n\ncube = Mesh.Cube() * count\n\n# Shape the points as 16 blocks of 8 vertices\npoints = np.reshape(cube.points.position, (16, 8, 3))\n\n# Place the cubes in a circle\nags = np.linspace(0, 2*np.pi, count, endpoint=False)\npoints[..., 0] += 6 * np.cos(ags)[:, None]\npoints[..., 1] += 6 * np.sin(ags)[:, None]\n\ncube.to_object(\"Cubes\")\n</code></pre>"},{"location":"api/#npblender.Mesh.multiply--arguments","title":"Arguments","text":"<pre><code>- count (int=10) : number of instances\n- attributes (name=value) : value for named attributes\n</code></pre>"},{"location":"api/#npblender.Mesh.multiply--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def multiply(self, count, in_place=True):\n    \"\"\" Duplicate the geometry.\n\n    Multiplying is a way to efficiently duplicate the geometry a great number of times.\n    Once duplicated, the vertices can be reshapped to address each instance individually.\n\n    ``` python\n    count = 16\n\n    cube = Mesh.Cube() * count\n\n    # Shape the points as 16 blocks of 8 vertices\n    points = np.reshape(cube.points.position, (16, 8, 3))\n\n    # Place the cubes in a circle\n    ags = np.linspace(0, 2*np.pi, count, endpoint=False)\n    points[..., 0] += 6 * np.cos(ags)[:, None]\n    points[..., 1] += 6 * np.sin(ags)[:, None]\n\n    cube.to_object(\"Cubes\")\n    ```\n\n    Arguments\n    ---------\n        - count (int=10) : number of instances\n        - attributes (name=value) : value for named attributes\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    # ----------------------------------------------------------------------------------------------------\n    # Checks and simple cases\n\n    if not isinstance(count, (int, np.int32, np.int64)):\n        raise Exception(f\"A Mesh can be multiplied only by an int, not '{count}'\")\n\n    if count == 0:\n        return None\n\n    if count == 1:\n        if in_place:\n            return self\n        else:\n            return type(self).from_mesh(self)\n\n    if not in_place:\n        return type(self).from_mesh(self).multiply(count, in_place=True)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Vertices\n\n    nverts = len(self.points)\n    self.points.multiply(count)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Corners\n\n    ncorners = len(self.corners)\n    self.corners.multiply(count)\n    self.corners.vertex_index += np.repeat(np.arange(count)*nverts, ncorners)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Faces\n\n    self.faces.multiply(count)\n    self.faces.update_loop_start()\n\n    # ----------------------------------------------------------------------------------------------------\n    # Edges\n\n    nedges = len(self.edges)\n    self.edges.multiply(count)\n    ofs = np.repeat(np.arange(count)*nverts, nedges)\n    self.edges.vertex0 += ofs\n    self.edges.vertex1 += ofs\n\n    return self\n</code></pre>"},{"location":"api/#npblender.Mesh.points_cloud","title":"<code>points_cloud(points=None, materials=None)</code>  <code>classmethod</code>","text":"<p>Create a mesh with points at the given positions.</p>"},{"location":"api/#npblender.Mesh.points_cloud--arguments","title":"Arguments","text":"<pre><code>- position (shaped array (?, 3)=(0, 0, 0) : position of the points\n</code></pre>"},{"location":"api/#npblender.Mesh.points_cloud--returns","title":"Returns","text":"<pre><code>- mesh (Mesh) : the mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef points_cloud(cls, points=None, materials=None):\n    \"\"\" Create a mesh with points at the given positions.\n\n    Arguments\n    ---------\n        - position (shaped array (?, 3)=(0, 0, 0) : position of the points\n\n    Returns\n    -------\n        - mesh (Mesh) : the mesh\n    \"\"\"\n    return cls(points=points, materials=materials)\n</code></pre>"},{"location":"api/#npblender.Mesh.pyramid","title":"<code>pyramid(size=1, materials=None)</code>  <code>classmethod</code>","text":"<p>Create a Pyramid.</p>"},{"location":"api/#npblender.Mesh.pyramid--arguments","title":"Arguments","text":"<pre><code>- size (float=1.) : size\n</code></pre>"},{"location":"api/#npblender.Mesh.pyramid--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef pyramid(cls, size=1, materials=None):\n    \"\"\" Create a Pyramid.\n\n    Arguments\n    ---------\n        - size (float=1.) : size\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    return cls.cone(vertices=3, radius_bottom=size*0.8660254037844386, depth=size, materials=materials)\n</code></pre>"},{"location":"api/#npblender.Mesh.remove_doubles","title":"<code>remove_doubles(dist=0.001)</code>","text":"<p>Remove doubles.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>dist(float=0.001)</code> <p>maximum distance between vertices to merge.</p> required Source code in <code>npblender/mesh.py</code> <pre><code>def remove_doubles(self, dist=.001):\n    \"\"\" Remove doubles.\n\n    Arguments:\n        - dist (float=0.001) : maximum distance between vertices to merge.\n    \"\"\"\n    with self.bmesh() as bm:\n        bmesh.ops.remove_doubles(bm, verts=bm.verts, dist=dist)\n\n    return self\n</code></pre>"},{"location":"api/#npblender.Mesh.separate_faces","title":"<code>separate_faces(groups=None)</code>","text":"<p>Split faces into isolated islands</p>"},{"location":"api/#npblender.Mesh.separate_faces--arguments","title":"Arguments","text":"<ul> <li>groups (list of ints):     group ids of faces</li> </ul> Source code in <code>npblender/mesh.py</code> <pre><code>def separate_faces(self, groups=None):\n    \"\"\" Split faces into isolated islands\n\n    Arguments\n    ---------\n    - groups (list of ints):\n        group ids of faces\n    \"\"\"\n\n    mesh = Mesh(materials=self.materials)\n    attr_names = [name for name in self.faces.actual_names if name not in ['loop_total', 'loop_start']]\n\n    # ---------------------------------------------------------------------------\n    # No group: each face becomes an island\n    # ---------------------------------------------------------------------------\n\n    if groups is None:\n        attrs = {name: self.faces[name] for name in attr_names}\n        return Mesh(attr_from=self).join_geometry(\n            points = self.points.position[self.corners.vertex_index],\n            corners = np.arange(len(self.corners)),\n            faces = self.faces.loop_total,\n            **attrs,\n        )\n\n    # ---------------------------------------------------------------------------\n    # Faces are grouped with groupds IDs\n    # ---------------------------------------------------------------------------\n\n    groups = np.asarray(groups)\n    if groups.shape != (len(self.faces),)   :\n        raise ValueError(f\"The 'groups' argument must be a index per face with a length of {len(self.faces)}.\")\n\n    ugroups, rev_index = np.unique(groups, return_inverse=True)\n    for group in ugroups:\n        faces = self.faces[ugroups[rev_index] == group]\n        attrs = {name: faces[name] for name in attr_names}\n\n        corners = self.corners[faces.get_corner_indices()]\n        uniques, new_corners = np.unique(corners.vertex_index, return_inverse=True)\n        mesh.join(Mesh(attr_from=self).join_geometry(\n            points = self.points.position[uniques],\n            corners = new_corners,\n            faces = faces.loop_total,\n            **attrs,\n        ))\n\n    return mesh\n</code></pre>"},{"location":"api/#npblender.Mesh.solidify","title":"<code>solidify(thickness=0.01, offset=-1)</code>","text":"<p>Boolean difference with another MeshBuilder.</p> <p>The methods uses the Solidify Modifier</p> <pre><code>glass = Mesh.Circle(segments=128)\nglass.extrude_faces(0, -.01)\nglass.extrude_faces(0, -2)\nglass.extrude_faces(0, -.01)\n\nglass.points.translate((0, 0, 2))\n\nglass = glass.solidify(thickness=.1)\n\nglass.to_object(\"Solidify\", shade_smooth=True)\n</code></pre>"},{"location":"api/#npblender.Mesh.solidify--arguments","title":"Arguments","text":"<pre><code>- thickness (float=.01) : thickness\n- offset (float=-1) : offset\n</code></pre>"},{"location":"api/#npblender.Mesh.solidify--returns","title":"Returns","text":"<pre><code>- MeshBuilder : the result of the solidify operation\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def solidify(self, thickness=.01, offset=-1):\n    \"\"\" Boolean difference with another MeshBuilder.\n\n    The methods uses the Solidify Modifier\n\n    ``` python\n    glass = Mesh.Circle(segments=128)\n    glass.extrude_faces(0, -.01)\n    glass.extrude_faces(0, -2)\n    glass.extrude_faces(0, -.01)\n\n    glass.points.translate((0, 0, 2))\n\n    glass = glass.solidify(thickness=.1)\n\n    glass.to_object(\"Solidify\", shade_smooth=True)\n    ```\n\n    Arguments\n    ---------\n        - thickness (float=.01) : thickness\n        - offset (float=-1) : offset\n\n    Returns\n    -------\n        - MeshBuilder : the result of the solidify operation\n    \"\"\"\n\n    with self.object() as obj:\n        mod = obj.modifiers.new(\"Solidify\", 'SOLIDIFY')\n\n        mod.thickness       = thickness\n        mod.use_even_offset = True\n        mod.offset          = offset\n\n        # Apply modifier\n        bpy.ops.object.modifier_apply(modifier=mod.name)\n\n        mesh = Mesh.from_object(obj)\n\n    return mesh\n</code></pre>"},{"location":"api/#npblender.Mesh.solidify_socle","title":"<code>solidify_socle(shape, z=0, bottom_material_index=0)</code>","text":"<p>The mesh is supposed to be a grid.</p> <p>The socle is buit by extruding the external edges to the value z.</p>"},{"location":"api/#npblender.Mesh.solidify_socle--arguments","title":"Arguments","text":"<ul> <li>shape (tuple of ints) : the grid shade</li> <li>z (float) : socle base z</li> <li>bottom_material_index (int = 0) : base face material index</li> <li>attributes (dict) : attributes to faces</li> </ul>"},{"location":"api/#npblender.Mesh.solidify_socle--returns","title":"Returns","text":"<ul> <li>bottom face index (int) : the index of bottom face</li> </ul> Source code in <code>npblender/mesh.py</code> <pre><code>def solidify_socle(self, shape, z=0, bottom_material_index=0):\n    \"\"\" The mesh is supposed to be a grid.\n\n    The socle is buit by extruding the external edges to the value z.\n\n    Arguments\n    ---------\n    - shape (tuple of ints) : the grid shade\n    - z (float) : socle base z\n    - bottom_material_index (int = 0) : base face material index\n    - attributes (dict) : attributes to faces\n\n    Returns\n    -------\n    - bottom face index (int) : the index of bottom face\n    \"\"\"\n\n    n = shape[0]*shape[1]\n    inds = np.arange(n).reshape(shape)\n\n    loop1 = np.append(inds[0, :-1], inds[:-1, -1])\n    loop1 = np.append(loop1, np.flip(inds[-1, 1:]))\n    loop1 = np.append(loop1, np.flip(inds[1:, 0]))\n\n    points = np.array(self.points.position[loop1])\n    points[:, 2] = z\n\n    loop0 = self.add_points(points)\n    res = self.add_geometry(corners=loop0) #, faces=len(loop0))\n\n    self.bridge_loops(loop0, loop1, close=True)\n\n    self.faces._ensure_optional_field(\"material_index\")\n    self.faces[res['faces']].material_index = bottom_material_index\n</code></pre>"},{"location":"api/#npblender.Mesh.to_curve_REVIEW","title":"<code>to_curve_REVIEW()</code>","text":"<p>Convert mesh to curve</p> <p>Simple conversion when edges domain is defined</p> Source code in <code>npblender/mesh.py</code> <pre><code>def to_curve_REVIEW(self):\n    \"\"\" &gt; Convert mesh to curve\n\n    Simple conversion when edges domain is defined\n    \"\"\"\n\n    from npblender import Curve\n\n    if self._edges is None:\n        return None\n\n    splines = []\n    for edge in self.edges:\n        v0, v1 = edge.vertex0, edge.vertex1\n\n        ok = False\n        for spline in splines:\n            if spline[0] == spline[-1]:\n                continue\n\n            if v0 == spline[0]:\n                spline.insert(0, v1)\n                ok = True\n            elif v0 == spline[-1]:\n                spline.append(v1)\n                ok = True\n\n            elif v1 == spline[0]:\n                spline.insert(0, v0)\n                ok = True\n            elif v1 == spline[-1]:\n                spline.append(v0)\n                ok = True\n\n        if not ok:\n            splines.append([v0, v1])\n\n    curve = Curve()\n    for spline in splines:\n        cyclic = spline[0] == spline[-1]\n        if cyclic:\n            spline = spline[:-1]\n\n        curve.add(self.points.position[spline], curve_type='POLY', cyclic=cyclic)\n\n    return curve\n</code></pre>"},{"location":"api/#npblender.Mesh.to_mesh_data","title":"<code>to_mesh_data(data)</code>","text":"<p>Write the geometry into a Blender Mesh</p>"},{"location":"api/#npblender.Mesh.to_mesh_data--arguments","title":"Arguments","text":"<pre><code>- mesh (Blender Mesh instance) : the mesh to write\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def to_mesh_data(self, data):\n    \"\"\" Write the geometry into a Blender Mesh\n\n    Arguments\n    ---------\n        - mesh (Blender Mesh instance) : the mesh to write\n    \"\"\"\n\n    from npblender import blender\n\n    bl_mesh = blender.get_data(data)\n    bl_mesh.clear_geometry()\n\n    # ----------------------------------------------------------------------------------------------------\n    # Materials\n\n    bl_mesh.materials.clear()\n    for mat_name in self.materials:\n        if mat_name is not None:\n            bl_mesh.materials.append(bpy.data.materials.get(mat_name))\n\n    # ----------------------------------------------------------------------------------------------------\n    # Vertices\n\n    points = self.points.ravel()\n    if len(points):\n        bl_mesh.vertices.add(len(points))\n\n    # ----------------------------------------------------------------------------------------------------\n    # Corners\n\n    corners = self.corners.ravel()\n    if len(corners):\n        bl_mesh.loops.add(len(corners))\n        bl_mesh.loops.foreach_set(\"vertex_index\", blender.int_array(corners.vertex_index))\n\n    # ----------------------------------------------------------------------------------------------------\n    # Faces\n\n    faces = self.faces.ravel()\n    if len(faces):\n        bl_mesh.polygons.add(len(faces))\n        bl_mesh.polygons.foreach_set(\"loop_start\", blender.int_array(faces.loop_start))\n        bl_mesh.polygons.foreach_set(\"loop_total\", blender.int_array(faces.loop_total))\n\n    # ----------------------------------------------------------------------------------------------------\n    # Edges\n\n    edges = self.edges.ravel()\n    if len(self.edges):\n        # edges to add\n        add_edges = self.edges.vertices\n\n        # edges have been created by faces\n        if len(faces):\n            bl_mesh.update()\n\n            cur_n = len(bl_mesh.edges)\n            if cur_n &gt; 0:\n                a = np.empty((cur_n, 2), dtype=bint)\n                bl_mesh.edges.foreach_get('vertices', a.ravel())\n\n            add_edges = np.append(a, add_edges, axis=0)\n\n        # add the edges\n        n = len(edges)\n        bl_mesh.edges.add(n)\n\n        bl_mesh.edges.foreach_set('vertices', add_edges.ravel())\n\n    # ----------------------------------------------------------------------------------------------------\n    # Attributes\n\n    attributes = data.attributes\n\n    points.to_bl_attributes(attributes, update=False)\n    corners.to_bl_attributes(attributes, update=False)\n    faces.to_bl_attributes(attributes, update=False)\n    edges.to_bl_attributes(attributes, update=False)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Update\n\n    bl_mesh.update()\n</code></pre>"},{"location":"api/#npblender.Mesh.to_object","title":"<code>to_object(obj, shade_smooth=None, shapekeys=None, collection=None)</code>","text":"<p>Create or update a blender object.</p> <p>The method 'to_object' creates the whole geometry. It creates a new object if it doesn't already exist. If the object exists, it must be a mesh, there is no object type conversion.</p> <p>Once the object is created, use the method 'update_object' to change the vertices.</p>"},{"location":"api/#npblender.Mesh.to_object--arguments","title":"Arguments","text":"<pre><code>- obj (str or Blender object) : the object the create\n</code></pre>"},{"location":"api/#npblender.Mesh.to_object--returns","title":"Returns","text":"<pre><code>- Blender mesh object\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def to_object(self, obj, shade_smooth=None, shapekeys=None, collection=None):\n    \"\"\" Create or update a blender object.\n\n    The method 'to_object' creates the whole geometry. It creates a new object if it doesn't already exist.\n    If the object exists, it must be a mesh, there is no object type conversion.\n\n    Once the object is created, use the method 'update_object' to change the vertices.\n\n    Arguments\n    ---------\n        - obj (str or Blender object) : the object the create\n\n    Returns\n    -------\n        - Blender mesh object\n    \"\"\"\n\n    from npblender import blender\n\n    res = blender.create_mesh_object(obj, collection=collection)\n    self.to_mesh_data(res.data)\n\n    if shade_smooth is not None:\n        res.data.polygons.foreach_set('use_smooth', [shade_smooth]*len(res.data.polygons))\n\n    if shapekeys is not None:\n        if shapekeys is not None:\n            if isinstance(shapekeys, ShapeKeys):\n                shapekeys.to_mesh_object(obj)\n            else:\n                for sks in shapekeys:\n                    sks.to_mesh_object(obj)\n\n    return res\n</code></pre>"},{"location":"api/#npblender.Mesh.torus","title":"<code>torus(major_segments=48, minor_segments=12, major_radius=1.0, minor_radius=0.25, materials=None)</code>  <code>classmethod</code>","text":"<p>Create a Torus.</p>"},{"location":"api/#npblender.Mesh.torus--arguments","title":"Arguments","text":"<pre><code>- major_segments (int=48) : number of segments for the major radius\n- minor_segments (int=12) : number of segments for the minor radius\n- major_radius (float=1.) : major radius\n- minor_radius (float=.25) : minor radius\n- materials (list of strs = None) : materials list\n- transformation (Transformations = None) : the transformation to apply\n</code></pre>"},{"location":"api/#npblender.Mesh.torus--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef torus(cls, major_segments=48, minor_segments=12, major_radius=1., minor_radius=0.25, materials=None):\n    \"\"\" Create a Torus.\n\n    Arguments\n    ---------\n        - major_segments (int=48) : number of segments for the major radius\n        - minor_segments (int=12) : number of segments for the minor radius\n        - major_radius (float=1.) : major radius\n        - minor_radius (float=.25) : minor radius\n        - materials (list of strs = None) : materials list\n        - transformation (Transformations = None) : the transformation to apply\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    # Major backbone\n    maj_ag = np.linspace(0, 2*np.pi, major_segments, endpoint=False, dtype=bfloat) + np.pi # + pi to match blender uv\n\n    x = major_radius*np.cos(maj_ag)\n    y = major_radius*np.sin(maj_ag)\n    zeros = np.zeros_like(x)\n\n    transfos = Transformation.from_components(\n        translation=np.stack((x, y, zeros), axis=-1), \n        rotation=Rotation.from_euler(np.stack((zeros, zeros, maj_ag), axis=-1)),\n    )\n\n    # Minor section\n    min_ag = np.linspace(0, 2*np.pi, minor_segments, endpoint=False, dtype=bfloat) + np.pi # + pi to match blender uv\n    x = minor_radius*np.cos(min_ag)\n    z = minor_radius*np.sin(min_ag)\n    y = np.zeros_like(x)\n\n    circle = np.stack((x, y, z), axis=-1)\n\n    # Transform the circle\n    points = transfos[:, None] @ circle\n\n    # Generate the faces\n    corners = grid_corners(major_segments, minor_segments, close_x=True, close_y=True)\n\n    # Get the uv map\n    uvmap = grid_uv_map(major_segments + 1, minor_segments + 1)\n\n    return cls(points=points.reshape(-1, 3), corners=corners.ravel(), faces=4, UVMap=uvmap.reshape(-1, 2), materials=materials)\n</code></pre>"},{"location":"api/#npblender.Mesh.uvsphere","title":"<code>uvsphere(segments=32, rings=16, radius=1, materials=None)</code>  <code>classmethod</code>","text":"<p>Create a uv sphere.</p>"},{"location":"api/#npblender.Mesh.uvsphere--arguments","title":"Arguments","text":"<pre><code>- segments (int=32) : number of segments\n- rings (int=16) : number of rings\n- radius (float=1.) : radius\n- materials (list of strs = None) : materials list\n- transformation (Transformations = None) : the transformation to apply\n</code></pre>"},{"location":"api/#npblender.Mesh.uvsphere--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef uvsphere(cls, segments=32, rings=16, radius=1, materials=None):\n    \"\"\" Create a uv sphere.\n\n    Arguments\n    ---------\n        - segments (int=32) : number of segments\n        - rings (int=16) : number of rings\n        - radius (float=1.) : radius\n        - materials (list of strs = None) : materials list\n        - transformation (Transformations = None) : the transformation to apply\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    mesh = cls(materials=materials)\n    with mesh.bmesh() as bm:\n        bmesh.ops.create_uvsphere(bm, u_segments=segments, v_segments=rings, radius=radius, calc_uvs=True)\n\n    return mesh\n</code></pre>"},{"location":"api/#npblender.Mesh.vectors_field","title":"<code>vectors_field(locations, vectors, radius=0.05, scale_length=1.0, angle=24.0, segments=8, head=None, adjust_norm=None, materials=None)</code>  <code>classmethod</code>","text":"<p>Create an arrow at each location corresponding to the vectors.</p> <p>The arrow length is equal to the corresponding vector lengths. The arrow radius is constant and equal to the value passe in argument for lengths greater that the argument scale_length. When the length is less than this value, the arrow is scaled down.</p> <p>Use the adjust_norm argument to transform the vector lengths to arrows lengths.</p>"},{"location":"api/#npblender.Mesh.vectors_field--arguments","title":"Arguments","text":"<pre><code>- locations (array of 3-vectors) : vectors locations\n- vectors (array of 3 vectors) : vectors to visualize\n- radius (float = .05) : arrow radius\n- angle (float = 24) : head radius in degrees\n- segments (int = 8) : number of segments for the section\n- head (mesh = None) : mesh model for the head. Create a cone if None\n- adjust_norm (max length or function = None) : max arrow length or function transforming\n    the vector length into arrow length\n- scale_length (float = 1.) : arrow length below which the arrow radius is scaled\n</code></pre>"},{"location":"api/#npblender.Mesh.vectors_field--returns","title":"Returns","text":"<pre><code>- Mesh Object\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef vectors_field(cls, locations, vectors, radius=.05, scale_length=1., angle=24., segments=8, head=None, adjust_norm=None, materials=None):\n    \"\"\" Create an arrow at each location corresponding to the vectors.\n\n    The arrow length is equal to the corresponding vector lengths.\n    The arrow radius is constant and equal to the value passe in argument for lengths greater that\n    the argument scale_length. When the length is less than this value, the arrow is scaled down.\n\n    Use the adjust_norm argument to transform the vector lengths to arrows lengths.\n\n    Arguments\n    ---------\n        - locations (array of 3-vectors) : vectors locations\n        - vectors (array of 3 vectors) : vectors to visualize\n        - radius (float = .05) : arrow radius\n        - angle (float = 24) : head radius in degrees\n        - segments (int = 8) : number of segments for the section\n        - head (mesh = None) : mesh model for the head. Create a cone if None\n        - adjust_norm (max length or function = None) : max arrow length or function transforming\n            the vector length into arrow length\n        - scale_length (float = 1.) : arrow length below which the arrow radius is scaled\n\n    Returns\n    -------\n        - Mesh Object\n    \"\"\"\n    locations = np.atleast_2d(locations)\n    vectors = np.atleast_2d(vectors)\n\n    # ---------------------------------------------------------------------------\n    # Vector lengths\n    # ---------------------------------------------------------------------------\n\n    n = len(locations)\n\n    lengths = np.linalg.norm(vectors, axis=-1)\n    is_null = lengths &lt; .00001\n    lengths[is_null] = 1\n    v_dir = vectors / lengths[:, None]\n    if type(adjust_norm).__name__ == 'function':\n        lengths = adjust_norm(lengths)\n    elif adjust_norm is not None:\n        lengths = np.minimum(adjust_norm, lengths)\n    lengths[is_null] = 0\n    vectors = v_dir*lengths[:, None]\n\n    # ---------------------------------------------------------------------------\n    # Arrow head\n    # ---------------------------------------------------------------------------\n\n    head_radius = 3*radius\n    head_height = head_radius/np.tan(np.radians(angle))\n\n    if head is None:\n        cone = cls.cone(\n            vertices = segments, \n            side_segments = 1, \n            fill_segments = 1, \n            radius_top = 0, \n            radius_bottom = head_radius, \n            depth = head_height, \n            fill_type = 'FANS', \n            materials = materials)\n        cone.points[-1].z += head_height/10\n    else:\n        cone = head\n        head_height = cone.bounding_box_dims[2]\n\n    # Head top point is z=0\n    v0, v1 = cone.bounding_box\n    cone.points.z -= v1[2]\n\n    # ---------------------------------------------------------------------------\n    # Small arrows: Vectors whose length &lt; min_length\n    # ---------------------------------------------------------------------------\n\n    # Minimum length\n    # Below this length, the arrow is scaled\n\n    min_length = 2*head_height\n\n    # Small and long arrows if any\n    small_arrows = cls()\n    long_arrows = cls()\n\n    small = lengths &lt; min_length\n    nsmalls = np.sum(small)\n\n    if nsmalls:\n        # shaft height = head height\n        cyl_height = min_length/2 + .01\n        arrow = cls.cylinder(vertices=segments, side_segments=1, radius=radius, depth=cyl_height, materials=materials)\n        arrow.points.z += cyl_height/2\n\n        # Join the head\n        c = cls.from_mesh(cone)\n        c.points.z += min_length\n\n        arrow.join(c)\n\n        # Duplicate the geometry            \n        small_arrows = arrow*nsmalls\n        small_arrows.points.reshape(nsmalls, len(arrow.points))\n\n        # Rotate, scale and translate\n        lg = lengths[small]\n        scale = np.stack((np.ones_like(lg), np.ones_like(lg), lg), axis=-1)\n        small_arrows.transformation(\n            rotation = Rotation.look_at((0, 0, 1), vectors[small])[:, None], \n            scale = scale[:, None], \n            translation = locations[small, None],\n            )\n        small_arrows.points.reshape(-1)\n\n\n    # ---------------------------------------------------------------------------\n    # Long arrows\n    # ---------------------------------------------------------------------------\n\n    long = np.logical_not(small)\n    nlongs = len(locations) - nsmalls\n    if nlongs:\n\n        # Shaft model with a normalized height = 1\n        shaft = cls.cylinder(vertices=segments, side_segments=1, radius=radius, depth=1, materials=materials)\n        shaft.points.z += .5\n\n        # We duplicate and transform the shafts with a scale long z\n        long_arrows = shaft*nlongs\n        long_arrows.points.reshape(nlongs, len(shaft.points))\n\n        lg = lengths[long] - head_height + .01\n        scale = np.stack((np.ones_like(lg), np.ones_like(lg), lg), axis=-1)\n        long_arrows.transformation(\n            rotation = Rotation.look_at((0, 0, 1), vectors[long])[:, None], \n            scale = scale[:, None], \n            translation = locations[long, None],\n            )\n        long_arrows.points.reshape(-1)\n\n        # We duplicate and tranform the heads with no scale\n        heads = cone*nlongs\n        heads.points.reshape(nlongs, len(cone.points))\n        heads.transformation(\n            rotation = Rotation.look_at((0, 0, 1), vectors[long])[:, None], \n            translation = locations[long, None] + vectors[long, None],\n            )\n        heads.points.reshape(-1)\n\n        long_arrows.join(heads)\n\n    # Let's join the result\n    arrows = cls()\n    arrows.join(small_arrows, long_arrows)\n\n    return arrows\n</code></pre>"},{"location":"api/#npblender.Meshes","title":"<code>Meshes</code>","text":"<p>               Bases: <code>Geometry</code></p> Source code in <code>npblender/instances.py</code> <pre><code>class Meshes(Geometry):\n\n    def __init__(self, mesh=None, mesh_id=None, attr_from=None, **attributes):\n        \"\"\" Instances based on mesh buckets.\n\n        Instances is best for managing a high number of instances with a low number\n        of models.\n        Meshes manages one mesh per point\n\n        Arguments\n        ---------\n            - mesh (Mesh) : the mesh containing the geometry\n            - mesh_id (int = None) : mesh points attribute defining the instances\n            - attr_from (Geometry) : geometry where to capture attributes from\n            - **attributes (dict) : other geometry attributes\n        \"\"\"\n        self.points  = Point()\n        self.join_attributes(attr_from)\n\n        self._init_buckets(mesh, mesh_id)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Utilities\n    # ----------------------------------------------------------------------------------------------------\n\n    def __str__(self):\n        return f\"&lt;Meshes: {len(self)}, total vertices: {0 if self.mesh is None else len(self.mesh.points)}&gt;\"\n\n    def __len__(self):\n        return len(self.points)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Loop on the buckets\n    # ----------------------------------------------------------------------------------------------------\n\n    def __iter__(self):\n        offset = 0\n        for bucket in self.buckets:\n            yield bucket, offset\n            offset += len(bucket)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Init buckets\n    # ----------------------------------------------------------------------------------------------------\n\n    def _init_buckets(self, mesh, mesh_id):\n\n        from .mesh import Mesh\n\n        self.points.clear()\n\n        if mesh is None:\n            self.mesh = Mesh()\n            self.buckets = []\n\n        else:\n            self.mesh = mesh\n\n            self.buckets = self.mesh.points.make_buckets(mesh_id)\n            npoints = sum([len(b) for b in self.buckets])\n\n            # Position of each mesh\n            position = np.empty((npoints, 3), dtype=bfloat)\n            for bucket, offset in self:\n                pos = np.average(self.mesh.points.position[bucket], axis=1)\n                position[offset:offset + len(bucket)] = pos\n\n                # Put the mesh at center (position is captured by points.position)\n                self.mesh.points.position[bucket] -= pos[:, None]\n\n            self.points.append(position=position)\n\n    # ====================================================================================================\n    # Check\n    # ====================================================================================================\n\n    def check(self, title=\"Meshes Check\", halt=True):\n        npoints = sum([len(b) for b in self.buckets])\n        if npoints != len(self.points):\n            print(title)\n            print(f\"The numbers of points {len(self.mesh.points)} in the mesh is different from the buckets length {npoints}\")\n            if halt:\n                assert(False)\n            return False\n        return True\n\n    # ====================================================================================================\n    # Get the mesh ids\n    # ====================================================================================================\n\n    @property\n    def mesh_id(self):\n        mesh_id = np.empty(len(self.mesh.points), dtype=bint)\n        for index, (bucket, offset) in enumerate(self):\n            mesh_id[offset:offset + len(bucket)] = index\n        return mesh_id\n\n    # ====================================================================================================\n    # From meshes\n    # ====================================================================================================\n\n    @classmethod\n    def from_meshes(cls, meshes):\n\n        from .mesh import Mesh\n\n        if not isinstance(meshes, Meshes):\n            raise AttributeError(f\"meshes argument is not Meshes '{type(meshes).__name__}'.\")\n\n        m = cls(attr_from=meshes)\n        m.mesh = Mesh.from_mesh(meshes.mesh)\n        m.buckets = [np.array(b) for b in meshes.buckets]\n        m.points = Point(meshes.points, mode='COPY')\n\n        return m\n\n    # ====================================================================================================\n    # From islands\n    # ====================================================================================================\n\n    @classmethod\n    def from_mesh_islands(cls, mesh):\n        face_islands = mesh.get_islands()\n        islands = mesh.compute_attribute_on_domain(\"faces\", face_islands, \"points\")\n        return cls(mesh, mesh_id=islands)\n\n    # ====================================================================================================\n    # Serialization\n    # ====================================================================================================\n\n    def to_dict(self):\n        return {\n            'geometry':   'Meshes',\n            'points':     self.points.to_dict(),\n            'mesh':       self.mesh.to_dict(),\n            'buckets':    self.buckets,\n            }\n\n    @classmethod\n    def from_dict(cls, d):\n        from .mesh import Mesh\n\n        meshes = cls()\n        meshes.points     = Point.from_dict(d['points'])\n        meshes.mesh       = Mesh.from_dict(d['mesh'])\n        meshes.buckets    = d['buckets']\n\n        return meshes\n\n    # ====================================================================================================\n    # To mesh\n    # ====================================================================================================\n\n    def realize(self):\n\n        from .mesh import Mesh\n\n        mesh = Mesh.from_mesh(self.mesh)\n        mesh.points.join_fields(self.points)\n\n        attr_names = [name for name in self.points.actual_names if name != 'position']\n        for bucket, offset in self:\n\n            sl = slice(offset, offset + len(bucket))\n            # Transfer the attrbutes\n            for name in attr_names:\n                mesh.points[name][bucket] += self.points[name][offset:offset + len(bucket), None]\n\n            # Transformation\n            if self.points.has_rotation:\n                rot = self.points.rotation[sl]\n            else:\n                rot = None\n\n            scale = self.points.get(\"scale\")\n            if scale is not None:\n                print(\"DEBUG\", self.points.shape, scale.shape, self.points.scale.shape)\n                scale = scale[sl]\n\n            transfo = Transformation.from_components(\n                rotation = rot,\n                scale = scale,\n                translation = self.points.position[sl],\n            )\n            mesh.points.position[bucket] = transfo[:, None] @ mesh.points.position[bucket]\n\n        return mesh\n\n    # ====================================================================================================\n    # Joining meshes\n    # ====================================================================================================\n\n    def join(self, *others):\n\n        from .mesh import Mesh\n\n        for other in others:\n\n            if not isinstance(other, Meshes):\n                raise AttributeError(f\"Meshes can be joined with Meshes only, not {type(other).__name__}.\")\n\n            self.mesh.join(other.mesh)\n            for ob in other.buckets:\n                ok = False\n                for i, sb in enumerate(self.buckets):\n                    if ob.shape[-1] == sb.shape[-1]:\n                        self.buckets[i] = np.append(sb, ob, axis=0)\n                        ok = True\n                if not ok:\n                    self.buckets.append(np.array(ob))\n\n        return self\n\n    # ====================================================================================================\n    # Multiply\n    # ====================================================================================================\n\n    def multiply(self, count, in_place=True):\n\n        count = int(count)\n\n        if count == 0:\n            return None\n\n        if count == 1:\n            if in_place:\n                return self\n            else:\n                return type(self)(attr_from=self).join(self)\n\n        if not in_place:\n            return type(self)(attr_from=self).join(self).multiply(count, in_place=True)\n\n        # Multiply the buckets\n        npoints = len(self.mesh.points)\n        for i in range(len(self.buckets)):\n            bucket = self.buckets[i]\n            n, length = bucket.shape\n            bucket = bucket[None] + (np.arange(count)*npoints)[:, None, None]\n            self.buckets[i] = bucket.reshape(n*count, length)\n\n        # Multiply the points and the mesh        \n        self.points.multiply(count)\n        self.mesh.multiply(count)\n\n        return self\n\n    def __mul__(self, count):\n        return self.multiply(count, in_place=False)\n\n    def __imul__(self, count):\n        return self.multiply(count, in_place=True)\n\n    # ====================================================================================================\n    # Operations\n    # ====================================================================================================\n\n    def clear_geometry(self):\n\n        from .mesh import Mesh\n\n        self.mesh = Mesh()  \n        self.points.clear()  \n        self.buckets = []\n\n    # ----------------------------------------------------------------------------------------------------\n    # Set an attribute on mesh points\n    # ----------------------------------------------------------------------------------------------------\n\n    def set_mesh_points_attribute(self, domain_name, name, value):\n\n        # Will raise en error if attribute doesn' exist\n        attr = self.mesh.points[name]\n\n        # _infos can be accessed securely\n        value = np.broadcast_to(value, (len(self),) + self.mesh.points._infos[name]['shape'])\n\n        # Loop on the buckets\n        offset = 0\n        for bucket in self.buckets:\n            attr[bucket] = value[offset:offset + len(bucket), None]\n            offset += len(bucket)\n\n        return self\n</code></pre>"},{"location":"api/#npblender.Meshes.__init__","title":"<code>__init__(mesh=None, mesh_id=None, attr_from=None, **attributes)</code>","text":"<p>Instances based on mesh buckets.</p> <p>Instances is best for managing a high number of instances with a low number of models. Meshes manages one mesh per point</p>"},{"location":"api/#npblender.Meshes.__init__--arguments","title":"Arguments","text":"<pre><code>- mesh (Mesh) : the mesh containing the geometry\n- mesh_id (int = None) : mesh points attribute defining the instances\n- attr_from (Geometry) : geometry where to capture attributes from\n- **attributes (dict) : other geometry attributes\n</code></pre> Source code in <code>npblender/instances.py</code> <pre><code>def __init__(self, mesh=None, mesh_id=None, attr_from=None, **attributes):\n    \"\"\" Instances based on mesh buckets.\n\n    Instances is best for managing a high number of instances with a low number\n    of models.\n    Meshes manages one mesh per point\n\n    Arguments\n    ---------\n        - mesh (Mesh) : the mesh containing the geometry\n        - mesh_id (int = None) : mesh points attribute defining the instances\n        - attr_from (Geometry) : geometry where to capture attributes from\n        - **attributes (dict) : other geometry attributes\n    \"\"\"\n    self.points  = Point()\n    self.join_attributes(attr_from)\n\n    self._init_buckets(mesh, mesh_id)\n</code></pre>"},{"location":"api/#npblender.MultiResGrid","title":"<code>MultiResGrid</code>","text":"<p>               Bases: <code>Mesh</code></p> <p>Multi resolution grid</p> <p>A surface defined by a function of two parameters u and v. The function can return either a vector or an altitude, u and being interpretated as (x, y).</p> <p>The grid resolution is defined by a depth when calling the method update_grid. The method accepts a camera to adapt its the resolution only to the visible parts.</p>"},{"location":"api/#npblender.MultiResGrid--arguments","title":"Arguments","text":"<ul> <li>shape (2-tuple of ints) : initial division</li> <li>u_space (2-tuple of floats) : u min and max values</li> <li>v_space (2-tuple of floats) : v min and max values</li> <li>is_altitude (bool = False) : the function returns z only vector is built with (u, v) as (x, y)</li> </ul> Source code in <code>npblender/multiresgrid.py</code> <pre><code>class MultiResGrid(Mesh):\n    \"\"\" Multi resolution grid\n\n    A surface defined by a function of two parameters u and v.\n    The function can return either a vector or an altitude, u and being interpretated as (x, y).\n\n    The grid resolution is defined by a depth when calling the method update_grid.\n    The method accepts a camera to adapt its the resolution only to the visible parts.\n\n    Arguments\n    ---------\n    - shape (2-tuple of ints) : initial division\n    - u_space (2-tuple of floats) : u min and max values\n    - v_space (2-tuple of floats) : v min and max values\n    - is_altitude (bool = False) : the function returns z only vector is built with (u, v) as (x, y)\n    \"\"\"\n\n    def __init__(self, func, shape=(3, 3), u_space=(0, 1), v_space=(0, 1), is_altitude=False, normal_func=None):\n        super().__init__()\n\n        if func is None:\n            self.func = lambda U, V: np.stack((U, V, np.zeros_like(U)), axis=-1)\n        else:\n            self.func = func\n        self.is_altitude = is_altitude\n\n        if normal_func is None:\n            self.use_normals = False\n        else:\n            self.use_normals = True\n            self.normal_func = normal_func\n\n        self.uv_shape = shape\n        self.u0, self.ufac = u_space[0], u_space[1] - u_space[0]\n        self.v0, self.vfac = v_space[0], v_space[1] - v_space[0]\n\n        self.update_grid()\n\n    # ====================================================================================================\n    # Call the surface function\n\n    def call_func(self, u, v):\n        \"\"\" Call the surface function\n\n        Arguments\n        ---------\n        - u (array of floats) : u value\n        - v (array of floats) : v value\n\n        Returns\n        -------\n        - array of vectors\n        \"\"\"\n\n        shape = np.shape(u)\n        x = self.u0 + u.flatten()*self.ufac\n        y = self.v0 + v.flatten()*self.vfac\n\n        if self.is_altitude:\n            return np.stack((x, y, self.func(x, y)), axis=1).reshape(shape + (3,))\n        else:\n            return self.func(x, y).reshape(shape + (3,))\n\n    # ====================================================================================================\n    # Get the normals to the surface\n\n    def get_normals(self, u, v):\n        \"\"\" Call the surface function\n\n        Arguments\n        ---------\n        - u (array of floats) : u value\n        - v (array of floats) : v value\n\n        Returns\n        -------\n        - array of vectors\n        \"\"\"\n        if self.use_normals:\n\n            shape = np.shape(u)\n            x = self.u0 + u.flatten()*self.ufac\n            y = self.v0 + v.flatten()*self.vfac\n\n            return self.normal_func(x, y).reshape(shape + (3,))\n        else:\n            return None\n\n    # ====================================================================================================\n    # Compute the normals\n\n    def compute_normals(self, u, v, du, dv):\n        \"\"\" Compute the face normals\n        \"\"\"\n\n        shape = np.shape(u)\n\n        if hasattr(self, 'normal_func'):\n            x = self.u0 + u.flatten()*self.ufac\n            y = self.v0 + v.flatten()*self.vfac\n            return self.normal_func(x, y).reshape(shape + (3,))\n\n        #dx, dy = du*self.ufac, dv*self.vfac\n\n        O = self.call_func(u - du, v - dv)\n        I = self.call_func(u + du, v) - O\n        J = self.call_func(u, v + dv) - O\n\n        vecs = np.cross(I, J)\n        vecs /= np.linalg.norm(vecs, axis=1)[:, None]\n\n        return vecs.reshape(shape + (3,))\n\n    # ====================================================================================================\n    # Update the grid with the given depth\n\n    def update_grid(self, depth=0, camera=None, max_vertices=10_000_000, max_size=.05):\n        \"\"\" Update the grid resolution with the given depth\n\n        Arguments\n        ---------\n        - depth (int) : maximum depth\n        - camera (Camera) : camera to compute visible faces\n        - max_vertices (int = 10_000_000) : maximum number of vertices\n        - max_size (float = .05) : maximum size of faces\n        \"\"\"\n\n        normals_done = False\n\n        # ----------------------------------------------------------------------------------------------------\n        # Prepare\n\n        du = 1 / self.uv_shape[0]\n        u = (np.arange(self.uv_shape[0]) + 0.5)*du\n\n        dv = 1 / self.uv_shape[1]\n        v = (np.arange(self.uv_shape[1]) + 0.5)*dv\n\n        U, V = np.meshgrid(u, v)\n        vecs = self.call_func(U, V)\n\n        verts = FieldArray()\n        verts.new_field(\"position\", bfloat, 3)\n        verts.new_field(\"size\",     bfloat)\n        verts.new_field(\"u\",        bfloat)\n        verts.new_field(\"v\",        bfloat)\n        verts.new_field(\"du\",       bfloat)\n        verts.new_field(\"dv\",       bfloat)\n\n        n = self.uv_shape[0]*self.uv_shape[1]\n        size = np.sqrt((self.ufac/(self.uv_shape[0] - 1))**2 + (self.vfac/(self.uv_shape[1] - 1))**2)\n        du /= 2\n        dv /= 2\n        verts.append(\n            position = vecs.reshape(n, 3),\n            size     = size,\n            u        = U.reshape(n),\n            v        = V.reshape(n),\n            du       = du,\n            dv       = dv)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Loop on depth\n\n        #final = verts.clone(empty=True)\n        final = FieldArray().join_fields(verts)\n        for idepth in range(depth):\n\n            normals = None\n            if len(final) &gt; 1000 and not normals_done:\n                normals = self.compute_normals(verts.u, verts.v, du, dv)\n                normals_done = True\n\n            if camera is not None:\n                p_vis, p_size = camera.visible_points(verts.position, radius=verts.size, normals=normals)\n                vis = p_vis[:, camera.VISIBLE]\n                if normals is not None:\n                    vis &amp;= np.logical_not(p_vis[:, camera.BACK_FACE])\n                vis &amp;= p_size[:, camera.SIZE] &gt;= max_size\n                del p_vis, p_size\n\n                final.extend(verts[np.logical_not(vis)])\n                #verts = verts.extract(vis)\n                verts = FieldArray(verts, selector=vis)\n\n            count = len(verts)\n            if not count:\n                break\n\n            size /= 2\n            du /= 2\n            dv /= 2\n\n            verts.du, verts.dv = du, dv\n\n            #new_verts = verts.clone(empty=True)\n            new_verts = FieldArray().join_fields(verts)\n            new_verts.set_buffer_size(count*4)\n\n            new_verts.append(\n                size = size,\n                u = verts.u - du,\n                v = verts.v - dv,\n                du = du,\n                dv = dv\n            )\n            new_verts.append(\n                size = size,\n                u = verts.u + du,\n                v = verts.v - dv,\n                du = du,\n                dv = dv\n            )\n            new_verts.append(\n                size = size,\n                u = verts.u + du,\n                v = verts.v + dv,\n                du = du,\n                dv = dv\n            )\n            new_verts.append(\n                size = size,\n                u = verts.u - du,\n                v = verts.v + dv,\n                du = du,\n                dv = dv\n            )\n\n            new_verts.position = self.call_func(new_verts.u, new_verts.v)\n\n            del verts\n            verts = new_verts\n\n            if len(final) + len(verts) &gt; max_vertices:\n                break\n\n        # ----------------------------------------------------------------------------------------------------\n        # Compute the vertices in the quads centered on the points\n\n        final.extend(verts)\n        del verts\n        nfinal = len(final)\n\n        Ul = final.u - final.du\n        Ur = final.u + final.du\n        U4 = np.stack((Ul, Ur, Ur, Ul), axis=1)\n        del Ul, Ur\n\n        Vb = final.v - final.dv\n        Vt = final.v + final.dv\n        V4 = np.stack((Vb, Vb, Vt, Vt), axis=1)\n        del Vb, Vt\n\n        corners = np.arange(nfinal*4)\n\n        UV, inv = merge_by_distance_2D(np.stack((U4.flatten(), V4.flatten()), axis=1), precision=(du/2, dv/2))\n        vertices = self.call_func(UV[:, 0], UV[:, 1])\n        corners = inv[corners]\n\n        # ----- To mesh\n\n        self.clear_geometry()\n\n        self.add_geometry(\n            points = vertices,\n            corners = corners,\n            faces = 4,\n            UVMap = np.stack((U4.flatten(), V4.flatten()), axis=1),\n        )\n\n    # ====================================================================================================\n    # Demo function\n\n    @classmethod\n    def sphere_demo(cls):\n\n        def sphere(theta, phi):\n            ct = np.cos(theta)\n            st = np.sin(theta)\n            cp = np.cos(phi)\n            sp = np.sin(phi)\n\n            return np.stack((cp*ct, cp*st, sp), axis=-1)\n\n        return cls(func=sphere, shape=(16, 8), u_space=(-np.pi, np.pi), v_space=(-np.pi/2, np.pi/2))\n\n    @classmethod\n    def demo_sphere(cls, depth=6):\n\n        from .camera import Camera\n        from .engine import engine\n\n        sphere = cls.sphere_demo()\n\n        def update():\n            sphere.update_grid(\n                depth=depth,\n                camera=Camera(), \n                max_vertices=10_000_000, \n                max_size=.05)\n\n            sphere.to_object(\"MR Sphere\", shade_smooth=False)\n\n        engine.go(update)\n\n    @classmethod\n    def demo_terrain(cls, depth=8):\n\n        from .camera import Camera\n        from .engine import engine\n        from .maths.perlin import noise\n\n        def altitude(x, y):\n            coords = np.stack((x, y), axis=-1)\n            return noise(coords, scale=3, octaves=8, lacunarity=4, algo='hetero')\n\n        surface = cls(altitude, shape=(10, 10), u_space=(-10, 10), v_space=(-10, 10), is_altitude=True)\n\n        def update():\n            surface.update_grid(\n                depth=depth,\n                camera=Camera(), \n                max_vertices=10_000_000, \n                max_size=.01)\n\n            surface.to_object(\"Terrain\", shade_smooth=False)\n\n        engine.go(update)\n</code></pre>"},{"location":"api/#npblender.MultiResGrid.call_func","title":"<code>call_func(u, v)</code>","text":"<p>Call the surface function</p>"},{"location":"api/#npblender.MultiResGrid.call_func--arguments","title":"Arguments","text":"<ul> <li>u (array of floats) : u value</li> <li>v (array of floats) : v value</li> </ul>"},{"location":"api/#npblender.MultiResGrid.call_func--returns","title":"Returns","text":"<ul> <li>array of vectors</li> </ul> Source code in <code>npblender/multiresgrid.py</code> <pre><code>def call_func(self, u, v):\n    \"\"\" Call the surface function\n\n    Arguments\n    ---------\n    - u (array of floats) : u value\n    - v (array of floats) : v value\n\n    Returns\n    -------\n    - array of vectors\n    \"\"\"\n\n    shape = np.shape(u)\n    x = self.u0 + u.flatten()*self.ufac\n    y = self.v0 + v.flatten()*self.vfac\n\n    if self.is_altitude:\n        return np.stack((x, y, self.func(x, y)), axis=1).reshape(shape + (3,))\n    else:\n        return self.func(x, y).reshape(shape + (3,))\n</code></pre>"},{"location":"api/#npblender.MultiResGrid.compute_normals","title":"<code>compute_normals(u, v, du, dv)</code>","text":"<p>Compute the face normals</p> Source code in <code>npblender/multiresgrid.py</code> <pre><code>def compute_normals(self, u, v, du, dv):\n    \"\"\" Compute the face normals\n    \"\"\"\n\n    shape = np.shape(u)\n\n    if hasattr(self, 'normal_func'):\n        x = self.u0 + u.flatten()*self.ufac\n        y = self.v0 + v.flatten()*self.vfac\n        return self.normal_func(x, y).reshape(shape + (3,))\n\n    #dx, dy = du*self.ufac, dv*self.vfac\n\n    O = self.call_func(u - du, v - dv)\n    I = self.call_func(u + du, v) - O\n    J = self.call_func(u, v + dv) - O\n\n    vecs = np.cross(I, J)\n    vecs /= np.linalg.norm(vecs, axis=1)[:, None]\n\n    return vecs.reshape(shape + (3,))\n</code></pre>"},{"location":"api/#npblender.MultiResGrid.get_normals","title":"<code>get_normals(u, v)</code>","text":"<p>Call the surface function</p>"},{"location":"api/#npblender.MultiResGrid.get_normals--arguments","title":"Arguments","text":"<ul> <li>u (array of floats) : u value</li> <li>v (array of floats) : v value</li> </ul>"},{"location":"api/#npblender.MultiResGrid.get_normals--returns","title":"Returns","text":"<ul> <li>array of vectors</li> </ul> Source code in <code>npblender/multiresgrid.py</code> <pre><code>def get_normals(self, u, v):\n    \"\"\" Call the surface function\n\n    Arguments\n    ---------\n    - u (array of floats) : u value\n    - v (array of floats) : v value\n\n    Returns\n    -------\n    - array of vectors\n    \"\"\"\n    if self.use_normals:\n\n        shape = np.shape(u)\n        x = self.u0 + u.flatten()*self.ufac\n        y = self.v0 + v.flatten()*self.vfac\n\n        return self.normal_func(x, y).reshape(shape + (3,))\n    else:\n        return None\n</code></pre>"},{"location":"api/#npblender.MultiResGrid.update_grid","title":"<code>update_grid(depth=0, camera=None, max_vertices=10000000, max_size=0.05)</code>","text":"<p>Update the grid resolution with the given depth</p>"},{"location":"api/#npblender.MultiResGrid.update_grid--arguments","title":"Arguments","text":"<ul> <li>depth (int) : maximum depth</li> <li>camera (Camera) : camera to compute visible faces</li> <li>max_vertices (int = 10_000_000) : maximum number of vertices</li> <li>max_size (float = .05) : maximum size of faces</li> </ul> Source code in <code>npblender/multiresgrid.py</code> <pre><code>def update_grid(self, depth=0, camera=None, max_vertices=10_000_000, max_size=.05):\n    \"\"\" Update the grid resolution with the given depth\n\n    Arguments\n    ---------\n    - depth (int) : maximum depth\n    - camera (Camera) : camera to compute visible faces\n    - max_vertices (int = 10_000_000) : maximum number of vertices\n    - max_size (float = .05) : maximum size of faces\n    \"\"\"\n\n    normals_done = False\n\n    # ----------------------------------------------------------------------------------------------------\n    # Prepare\n\n    du = 1 / self.uv_shape[0]\n    u = (np.arange(self.uv_shape[0]) + 0.5)*du\n\n    dv = 1 / self.uv_shape[1]\n    v = (np.arange(self.uv_shape[1]) + 0.5)*dv\n\n    U, V = np.meshgrid(u, v)\n    vecs = self.call_func(U, V)\n\n    verts = FieldArray()\n    verts.new_field(\"position\", bfloat, 3)\n    verts.new_field(\"size\",     bfloat)\n    verts.new_field(\"u\",        bfloat)\n    verts.new_field(\"v\",        bfloat)\n    verts.new_field(\"du\",       bfloat)\n    verts.new_field(\"dv\",       bfloat)\n\n    n = self.uv_shape[0]*self.uv_shape[1]\n    size = np.sqrt((self.ufac/(self.uv_shape[0] - 1))**2 + (self.vfac/(self.uv_shape[1] - 1))**2)\n    du /= 2\n    dv /= 2\n    verts.append(\n        position = vecs.reshape(n, 3),\n        size     = size,\n        u        = U.reshape(n),\n        v        = V.reshape(n),\n        du       = du,\n        dv       = dv)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Loop on depth\n\n    #final = verts.clone(empty=True)\n    final = FieldArray().join_fields(verts)\n    for idepth in range(depth):\n\n        normals = None\n        if len(final) &gt; 1000 and not normals_done:\n            normals = self.compute_normals(verts.u, verts.v, du, dv)\n            normals_done = True\n\n        if camera is not None:\n            p_vis, p_size = camera.visible_points(verts.position, radius=verts.size, normals=normals)\n            vis = p_vis[:, camera.VISIBLE]\n            if normals is not None:\n                vis &amp;= np.logical_not(p_vis[:, camera.BACK_FACE])\n            vis &amp;= p_size[:, camera.SIZE] &gt;= max_size\n            del p_vis, p_size\n\n            final.extend(verts[np.logical_not(vis)])\n            #verts = verts.extract(vis)\n            verts = FieldArray(verts, selector=vis)\n\n        count = len(verts)\n        if not count:\n            break\n\n        size /= 2\n        du /= 2\n        dv /= 2\n\n        verts.du, verts.dv = du, dv\n\n        #new_verts = verts.clone(empty=True)\n        new_verts = FieldArray().join_fields(verts)\n        new_verts.set_buffer_size(count*4)\n\n        new_verts.append(\n            size = size,\n            u = verts.u - du,\n            v = verts.v - dv,\n            du = du,\n            dv = dv\n        )\n        new_verts.append(\n            size = size,\n            u = verts.u + du,\n            v = verts.v - dv,\n            du = du,\n            dv = dv\n        )\n        new_verts.append(\n            size = size,\n            u = verts.u + du,\n            v = verts.v + dv,\n            du = du,\n            dv = dv\n        )\n        new_verts.append(\n            size = size,\n            u = verts.u - du,\n            v = verts.v + dv,\n            du = du,\n            dv = dv\n        )\n\n        new_verts.position = self.call_func(new_verts.u, new_verts.v)\n\n        del verts\n        verts = new_verts\n\n        if len(final) + len(verts) &gt; max_vertices:\n            break\n\n    # ----------------------------------------------------------------------------------------------------\n    # Compute the vertices in the quads centered on the points\n\n    final.extend(verts)\n    del verts\n    nfinal = len(final)\n\n    Ul = final.u - final.du\n    Ur = final.u + final.du\n    U4 = np.stack((Ul, Ur, Ur, Ul), axis=1)\n    del Ul, Ur\n\n    Vb = final.v - final.dv\n    Vt = final.v + final.dv\n    V4 = np.stack((Vb, Vb, Vt, Vt), axis=1)\n    del Vb, Vt\n\n    corners = np.arange(nfinal*4)\n\n    UV, inv = merge_by_distance_2D(np.stack((U4.flatten(), V4.flatten()), axis=1), precision=(du/2, dv/2))\n    vertices = self.call_func(UV[:, 0], UV[:, 1])\n    corners = inv[corners]\n\n    # ----- To mesh\n\n    self.clear_geometry()\n\n    self.add_geometry(\n        points = vertices,\n        corners = corners,\n        faces = 4,\n        UVMap = np.stack((U4.flatten(), V4.flatten()), axis=1),\n    )\n</code></pre>"},{"location":"api/#npblender.ShapeKeys","title":"<code>ShapeKeys</code>","text":"Source code in <code>npblender/shapekeys.py</code> <pre><code>class ShapeKeys:\n    def __init__(self, rec_array, count=1, relative=True, extrapolation='CLIP', ignore_int=True, ignore_bool=True):\n        \"\"\"\n        ShapeKeys manages a stack of structured arrays (like FieldArrays),\n        with the same structure and same number of elements in each array.\n\n        Parameters\n        ----------\n        rec_array : np.ndarray (structured) or FieldArray\n            The reference array to replicate.\n        count : int\n            The number of copies to initialize.\n        relative : bool\n            Optional flag, for later use.\n        \"\"\"\n        rec_array = np.asarray(rec_array)\n        self._ref = rec_array\n        self.relative = relative\n        self.extrapolation = extrapolation\n\n        # Ensure it's a structured 1D array\n        assert rec_array.dtype.names is not None\n        assert rec_array.ndim == 1\n\n        self._build_layout(ignore_int=ignore_int, ignore_bool=ignore_bool)\n\n        count = max(1, count)\n\n        # Initialize by stacking `count` copies\n        a = self._to_flat_array(self._ref)\n        self._mat = np.resize(a, (count, *a.shape))\n        #self._mat = np.stack([a.copy() for _ in range(count)], axis=0)\n\n\n\n    def __str__(self):\n        return f\"&lt;ShapeKeys of shape ({self._mat.shape}) keys with attributes {[name for name, _, _, _ in self._layout]}&gt;\"\n\n    def __len__(self):\n        return self._mat.shape[0]\n\n    def __getitem__(self, idx):\n        return self._from_flat_array(self._mat[idx])\n\n    def __setitem__(self, idx, value):\n        self._mat[idx] = self._to_flat_array(value)\n\n    def as_array(self):\n        return self._mat\n\n    def append(self, array):\n        a = self._to_flat_array(array)\n        self._mat = np.concatenate([self._mat, [a]])\n\n    def insert(self, index, array):\n        a = self._to_flat_array(array)\n        self._mat = np.insert(self._mat, index, a, axis=0)\n\n    def delete(self, index):\n        self._mat = np.delete(self._mat, index, axis=0)\n\n    # ====================================================================================================\n    # Conversion to array of floats\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Build the conversion layout\n    # ----------------------------------------------------------------------------------------------------\n\n    def _build_layout(self, ignore_int=True, ignore_bool=True):\n        \"\"\"Analyze self._ref and store layout for flattening.\"\"\"\n\n        dtype = self._ref.dtype\n        layout = []\n        offset = 0\n\n        for name in dtype.names:\n            dt, _ = dtype.fields[name]\n            base_dtype = dt.base\n            shape = dt.shape or ()\n            kind = np.dtype(base_dtype).kind\n\n            if ignore_bool and kind == 'b':\n                continue\n            if ignore_int and kind in 'iu':\n                continue\n\n            count = int(np.prod(shape or (1,)))\n            sl = slice(offset, offset + count)\n            layout.append((name, base_dtype, shape, sl))\n            offset += count\n\n        self._layout = layout\n        self._total_scalars = offset\n\n    # ----------------------------------------------------------------------------------------------------\n    # Flatten field array\n    # ----------------------------------------------------------------------------------------------------\n\n    def _to_flat_array(self, data):\n        \"\"\"Flatten structured array using precomputed self._layout.\"\"\"\n\n        data = np.asarray(data)\n        flatten = np.empty((len(data), self._total_scalars), dtype=np.float64)\n\n        for name, _, shape, sl in self._layout:\n            values = data[name]\n            if shape == ():\n                flatten[:, sl] = values[:, None]\n            else:\n                flatten[:, sl] = values\n\n        return flatten\n\n    # ----------------------------------------------------------------------------------------------------\n    # From flatten to array with fields\n    # ----------------------------------------------------------------------------------------------------\n\n    def _from_flat_array(self, flat):\n        \"\"\"\n        Convert a flat (N, D) or (M, N, D) float array to a recarray with float fields only,\n        using the layout defined at initialization.\n        \"\"\"\n        flat = np.asarray(flat)\n        single = flat.ndim == 2  # (N, D)\n\n        if single:\n            shape = (flat.shape[0],)  # N\n            flat_2d = flat\n        else:\n            shape = flat.shape[:2]    # (M, N)\n            flat_2d = flat.reshape(-1, flat.shape[-1])  # (M*N, D)\n\n        # Build dtype with only interpolated fields\n        dtype = [(name, dtype, fshape) for name, dtype, fshape, _ in self._layout]\n\n        # Allocate output array\n        out = np.empty(flat_2d.shape[0], dtype=dtype)\n\n        for name, dtype, fshape, sl in self._layout:\n            if fshape == ():  # scalar\n                out[name] = flat_2d[:, sl].reshape(-1)\n            else:\n                out[name] = flat_2d[:, sl].reshape(-1, *fshape)\n\n        out = out.view(np.recarray)\n        return out.reshape(shape)\n\n    # ====================================================================================================\n    # Interpolation\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Absolute interpolation\n    # ----------------------------------------------------------------------------------------------------\n\n    def abs_interpolate(self, t, smooth=1):\n        \"\"\"Absolute interpolation between keyframes.\n\n        Parameters\n        ----------\n        t : float or array_like\n            Interpolation factor(s) in [0, 1].\n        extrapolation : {'CLIP', 'CYCLIC', 'BACK'}, default 'CLIP'\n            How to handle t values outside [0, 1].\n        smooth : int, str or callable, default 1\n            Smoothing method:\n                - int: degree of BSpline\n                - 'CUBIC': cubic spline\n                - callable: function to apply to t\n                - None: linear interpolation\n\n        Returns\n        -------\n        recarray or array of recarrays\n            Interpolated values with only float fields (others ignored).\n        \"\"\"\n        if len(self) &lt;= 1:\n            return self[0].copy()\n\n        t = np.asarray(t)\n        single = (t.ndim == 0)\n        if single:\n            t = t[None]\n\n        # --------------------------\n        # Extrapolation handling\n        # --------------------------\n        if self.extrapolation == 'CLIP':\n            factors = np.clip(t, 0., 1.)\n        elif self.extrapolation == 'CYCLIC':\n            factors = np.mod(t, 1.)\n        elif self.extrapolation == 'BACK':\n            f = np.mod(2 * t, 2.)\n            factors = np.where(f &gt; 1., 2. - f, f)\n        else:\n            raise ValueError(f\"Invalid extrapolation mode: {self.extrapolation}\")\n\n        # --------------------------\n        # Smoothing\n        # --------------------------\n        degree = None\n        use_cubic = False\n\n        if smooth is None:\n            degree = 1\n        elif isinstance(smooth, int):\n            degree = smooth\n        elif hasattr(smooth, '__call__'):\n            factors = smooth(factors)\n        elif isinstance(smooth, str):\n            if smooth.upper() == 'CUBIC':\n                use_cubic = True\n            else:\n                from .utils import maprange\n                factors = maprange(factors, easing=smooth)\n        else:\n            raise TypeError(f\"Invalid smooth type: {type(smooth).__name__}\")\n\n        # --------------------------\n        # Interpolation\n        # --------------------------\n        data = self._mat  # shape (K, N, D)\n        n_keys = len(data)\n\n        if degree is None:\n            fs = factors * (n_keys - 1)\n            inds = np.floor(fs).astype(int)\n            inds = np.clip(inds, 0, n_keys - 2)\n\n            p = (fs - inds)[..., None, None]  # (..., 1, 1) for broadcast\n            a = data[inds]\n            b = data[inds + 1]\n            interp_flat = a * (1 - p) + b * p  # shape (..., N, D)\n\n        elif use_cubic:\n            from scipy.interpolate import CubicSpline\n            x = np.linspace(0, 1, n_keys)\n            interp_flat = CubicSpline(x, data, axis=0, extrapolate=False)(factors)\n\n        else:\n            from scipy.interpolate import BSpline\n            k = degree\n            dx = 1 / (n_keys - 1)\n            x = np.linspace(-k * dx, 1 + k * dx, n_keys + k + 1)\n            interp_flat = BSpline(x, data, k=k, axis=0, extrapolate=False)(factors)\n\n        # --------------------------\n        # Convert back to structured recarray\n        # --------------------------\n        result = self._from_flat_array(interp_flat)\n        return result[0] if single else result\n\n    # ----------------------------------------------------------------------------------------------------\n    # Relative interpolation\n    # ----------------------------------------------------------------------------------------------------\n\n    def rel_interpolate(self, weights, smooth=1):\n        \"\"\"\n        Relative interpolation using deltas from base shape.\n\n        Parameters\n        ----------\n        weights : array_like\n            - shape (K,) for one result\n            - shape (M, K) for multiple results\n            where K = number of shapes - 1\n        smooth : int, str, callable, or None\n            Smoothing method (same as abs_interpolate)\n\n        Returns\n        -------\n        np.recarray or array of recarrays\n            Interpolated result(s) (only float fields)\n        \"\"\"\n        weights = np.asarray(weights)\n        n_shapes = len(self)\n        n_weights = n_shapes - 1\n\n        # --------------------------\n        # Validate shape of weights\n        # --------------------------\n        single = False\n        if weights.ndim == 1:\n            if weights.shape[0] != n_weights:\n                raise ValueError(f\"Expected shape ({n_weights},), got {weights.shape}\")\n            weights = weights[None]  # shape (1, K)\n            single = True\n        elif weights.shape[-1] != n_weights:\n            raise ValueError(f\"Expected shape (..., {n_weights}), got {weights.shape}\")\n\n        # --------------------------\n        # Apply smoothing if needed\n        # --------------------------\n        degree = None\n        use_cubic = False\n\n        if smooth is None:\n            degree = 1\n        elif isinstance(smooth, int):\n            degree = smooth\n        elif hasattr(smooth, '__call__'):\n            weights = smooth(weights)\n        elif isinstance(smooth, str):\n            if smooth.upper() == 'CUBIC':\n                use_cubic = True\n            else:\n                from .utils import maprange\n                weights = maprange(weights, easing=smooth)\n        else:\n            raise TypeError(f\"Invalid smooth type: {type(smooth).__name__}\")\n\n        weights = np.clip(weights, 0, 1)\n\n        # --------------------------\n        # Perform interpolation\n        # --------------------------\n        base = self._mat[0]  # shape (N, D)\n        deltas = self._mat[1:] - base  # shape (K, N, D)\n        w = weights[..., None, None]  # shape (..., 1, 1)\n        weighted = (w * deltas).sum(axis=-3)  # shape (..., N, D)\n        interp_flat = base + weighted\n\n        # --------------------------\n        # Reconstruct structured recarray\n        # --------------------------\n        result = self._from_flat_array(interp_flat)\n        return result[0] if single else result\n\n    # ----------------------------------------------------------------------------------------------------\n    # Interpolation\n    # ----------------------------------------------------------------------------------------------------\n\n    def interpolate(self, param, smooth=1):\n        if self.relative:\n            return self.rel_interpolate(param, smooth=smooth)\n        else:\n            return self.abs_interpolate(param, smooth=smooth)\n\n    # ====================================================================================================\n    # Interface with Blender\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Load mesh shapekeys\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def from_mesh_objet(cls, spec):\n\n        from . import blender\n        from . mesh import Mesh\n\n        obj   = blender.get_object(spec)\n        count = blender.shape_keys_count(obj)\n\n        if count == 0:\n            return None\n\n        mesh = Mesh.from_object(obj)\n        npoints = len(mesh.points)\n\n        sks = cls(mesh.points, count=count)\n\n        a = np.empty((npoints, 3), np.float32)\n        for name, _, _, sl in sks._layout:\n            if name == 'position':\n                pos_slice = sl\n\n        for index in range(count):\n            kb = blender.get_key_block(obj, index)\n            kb.data.foreach_get('co', a.ravel())\n            sks._mat[index, :, pos_slice] = a\n\n        return sks\n\n    # ----------------------------------------------------------------------------------------------------\n    # Store mesh shapekeys\n    # ----------------------------------------------------------------------------------------------------\n\n    def to_mesh_object(self, spec, clear=True):\n\n        from . import blender\n\n        obj = blender.get_object(spec)\n        assert(len(obj.data.vertices) == self._mat.shape[1])\n\n        if clear:\n            blender.shape_keys_clear(obj)\n\n        for name, _, _, sl in self._layout:\n            if name == 'position':\n                pos_slice = sl\n\n        a = np.empty((self._mat.shape[1], 3), np.float32)\n        for index in range(0, len(self)):\n            kb = blender.get_key_block(obj, index, create=True, name=None)\n            a[:] = self._mat[index, :, pos_slice]\n            kb.data.foreach_set('co', a.ravel())\n\n        return obj\n\n    # ----------------------------------------------------------------------------------------------------\n    # Load curve shapekeys\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def from_curve_object(cls, spec):\n\n        from . import blender\n        from curve import Curve\n\n        obj = blender.get_object(spec)\n\n        count = blender.shape_keys_count(obj)\n\n        # ----------------------------------------------------------------------------------------------------\n        # No shape key\n\n        if count == 0:\n            return None\n\n        # ----------------------------------------------------------------------------------------------------\n        # Read the splines\n\n        curve = Curve.FromObject(obj)\n\n        sks = cls.FromGeometry(curve, count=count)\n\n        is_mix     = curve.has_mix_types\n        has_bezier = curve.has_bezier\n        nverts     = sks.points_count\n\n        if not is_mix:\n            v_array = np.empty(nverts*3, float)\n            f_array = np.empty(nverts, float)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Loop on the shape keys\n\n        for index in range(count):\n\n            key_data = blender.get_key_block(obj, index).data\n\n            # ----- Mix types : we must loop on the splines\n\n            if is_mix:\n                for curve_type, loop_start, loop_total in zip(curve.splines.curve_type, curve.splines.loop_start, curve.splines.loop_total):\n\n                    # ----- Bezier\n\n                    if curve_type == blender.BEZIER:\n\n                        for i in range(loop_total):\n                            sks._data[index, loop_start + i, sks._slices['position']] = key_data[loop_start + i].co\n                            sks._data[index, loop_start + i, sks._slices['handle_left']] = key_data[loop_start + i].handle_left\n                            sks._data[index, loop_start + i, sks._slices['handle_right']] = key_data[loop_start + i].handle_right\n\n                            sks._data[index, loop_start + i, sks._slices['radius']] = key_data[loop_start + i].radius\n                            sks._data[index, loop_start + i, sks._slices['tilt']]   = key_data[loop_start + i].tilt\n\n                    # ----- Non Bezier\n\n                    else:\n                        for i in range(loop_total):\n                            sks._data[index, loop_start + i, sks._slices['position']] = key_data[loop_start + i].co\n                            try:\n                                radius, tilt = key_data[loop_start + i].radius, key_data[loop_start + i].tilt\n                            except:\n                                radius, tilt = 1., 0.\n\n                            sks._data[index, loop_start + i, sks._slices['radius']] = radius\n                            sks._data[index, loop_start + i, sks._slices['tilt']]   = tilt\n\n            # ----- Only BEZIER or non Bezier\n\n            else:\n                key_data.foreach_get('co', v_array)\n                sks.position[index] = np.reshape(v_array, (nverts, 3))\n\n                key_data.foreach_get('radius', f_array)\n                sks.radius[index] = f_array\n\n                key_data.foreach_get('tilt', f_array)\n                sks.tilt[index] = f_array\n\n                if has_bezier:\n                    key_data.foreach_get('handle_left', v_array)\n                    sks.handle_left[index] = np.reshape(v_array, (nverts, 3))\n\n                    key_data.foreach_get('handle_right', v_array)\n                    sks.handle_right[index] = np.reshape(v_array, (nverts, 3))\n\n        return sks\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Write the shapes in an existing curve object\n\n    def to_curve_object(self, spec):\n\n        from npblender import Curve\n\n        obj = blender.get_object(spec)\n        curve = Curve.FromObject(obj)\n\n        if self.clear:\n            blender.shape_keys_clear(obj)\n\n        is_mix     = curve.has_mix_types\n        has_bezier = curve.has_bezier\n        nverts     = self.points_count\n\n        if not is_mix:\n            v_array = np.empty(nverts*3, float)\n            f_array = np.empty(nverts, float)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Loop on the shapekeys\n\n        for index in range(len(self)):\n\n            key_data = blender.get_key_block(obj, index, create=True, name=self.key_name).data\n\n            # ----- Mix types : we must loop on the splines\n\n            if is_mix:\n                for curve_type, loop_start, loop_total in zip(curve.splines.curve_type, curve.splines.loop_start, curve.splines.loop_total):\n\n                    # ----- Bezier\n\n                    if curve_type == blender.BEZIER:\n\n                        for i in range(loop_total):\n                            key_data[loop_start + i].co = self._data[index, loop_start + i, self._slices['position']]\n                            key_data[loop_start + i].handle_left = self._data[index, loop_start + i, self._slices['handle_left']]\n                            key_data[loop_start + i].handle_right = self._data[index, loop_start + i, self._slices['handle_right']]\n\n                            key_data[loop_start + i].radius = self._data[index, loop_start + i, self._slices['radius']]\n                            key_data[loop_start + i].tilt   = self._data[index, loop_start + i, self._slices['tilt']]\n\n                    # ----- Non Bezier\n\n                    else:\n\n                        for i in range(loop_total):\n                            key_data[loop_start + i].co = self._data[index, loop_start + i, self._slices['position']]\n                            if hasattr(key_data[loop_start + i], 'radius'):\n                                key_data[loop_start + i].radius = self._data[index, loop_start + i, self._slices['radius']]\n                                key_data[loop_start + i].tilt = self._data[index, loop_start + i, self._slices['tilt']]\n\n            # ----- Only BEZIER or non Bezier\n\n            else:\n                np.reshape(v_array, (nverts, 3))[:] = self.position[index]\n                key_data.foreach_set('co', v_array)\n\n                f_array[:] = self.radius[index]\n                key_data.foreach_set('radius', f_array)\n\n                f_array[:] = self.tilt[index]\n                key_data.foreach_set('tilt', f_array)\n\n                if has_bezier:\n                    np.reshape(v_array, (nverts, 3))[:] = self.handle_left[index]\n                    key_data.foreach_set('handle_left', v_array)\n\n                    np.reshape(v_array, (nverts, 3))[:] = self.handle_right[index]\n                    key_data.foreach_set('handle_right', v_array)\n\n        return obj\n</code></pre>"},{"location":"api/#npblender.ShapeKeys.__init__","title":"<code>__init__(rec_array, count=1, relative=True, extrapolation='CLIP', ignore_int=True, ignore_bool=True)</code>","text":"<p>ShapeKeys manages a stack of structured arrays (like FieldArrays), with the same structure and same number of elements in each array.</p>"},{"location":"api/#npblender.ShapeKeys.__init__--parameters","title":"Parameters","text":"<p>rec_array : np.ndarray (structured) or FieldArray     The reference array to replicate. count : int     The number of copies to initialize. relative : bool     Optional flag, for later use.</p> Source code in <code>npblender/shapekeys.py</code> <pre><code>def __init__(self, rec_array, count=1, relative=True, extrapolation='CLIP', ignore_int=True, ignore_bool=True):\n    \"\"\"\n    ShapeKeys manages a stack of structured arrays (like FieldArrays),\n    with the same structure and same number of elements in each array.\n\n    Parameters\n    ----------\n    rec_array : np.ndarray (structured) or FieldArray\n        The reference array to replicate.\n    count : int\n        The number of copies to initialize.\n    relative : bool\n        Optional flag, for later use.\n    \"\"\"\n    rec_array = np.asarray(rec_array)\n    self._ref = rec_array\n    self.relative = relative\n    self.extrapolation = extrapolation\n\n    # Ensure it's a structured 1D array\n    assert rec_array.dtype.names is not None\n    assert rec_array.ndim == 1\n\n    self._build_layout(ignore_int=ignore_int, ignore_bool=ignore_bool)\n\n    count = max(1, count)\n\n    # Initialize by stacking `count` copies\n    a = self._to_flat_array(self._ref)\n    self._mat = np.resize(a, (count, *a.shape))\n</code></pre>"},{"location":"api/#npblender.ShapeKeys.abs_interpolate","title":"<code>abs_interpolate(t, smooth=1)</code>","text":"<p>Absolute interpolation between keyframes.</p>"},{"location":"api/#npblender.ShapeKeys.abs_interpolate--parameters","title":"Parameters","text":"<p>t : float or array_like     Interpolation factor(s) in [0, 1]. extrapolation : {'CLIP', 'CYCLIC', 'BACK'}, default 'CLIP'     How to handle t values outside [0, 1]. smooth : int, str or callable, default 1     Smoothing method:         - int: degree of BSpline         - 'CUBIC': cubic spline         - callable: function to apply to t         - None: linear interpolation</p>"},{"location":"api/#npblender.ShapeKeys.abs_interpolate--returns","title":"Returns","text":"<p>recarray or array of recarrays     Interpolated values with only float fields (others ignored).</p> Source code in <code>npblender/shapekeys.py</code> <pre><code>def abs_interpolate(self, t, smooth=1):\n    \"\"\"Absolute interpolation between keyframes.\n\n    Parameters\n    ----------\n    t : float or array_like\n        Interpolation factor(s) in [0, 1].\n    extrapolation : {'CLIP', 'CYCLIC', 'BACK'}, default 'CLIP'\n        How to handle t values outside [0, 1].\n    smooth : int, str or callable, default 1\n        Smoothing method:\n            - int: degree of BSpline\n            - 'CUBIC': cubic spline\n            - callable: function to apply to t\n            - None: linear interpolation\n\n    Returns\n    -------\n    recarray or array of recarrays\n        Interpolated values with only float fields (others ignored).\n    \"\"\"\n    if len(self) &lt;= 1:\n        return self[0].copy()\n\n    t = np.asarray(t)\n    single = (t.ndim == 0)\n    if single:\n        t = t[None]\n\n    # --------------------------\n    # Extrapolation handling\n    # --------------------------\n    if self.extrapolation == 'CLIP':\n        factors = np.clip(t, 0., 1.)\n    elif self.extrapolation == 'CYCLIC':\n        factors = np.mod(t, 1.)\n    elif self.extrapolation == 'BACK':\n        f = np.mod(2 * t, 2.)\n        factors = np.where(f &gt; 1., 2. - f, f)\n    else:\n        raise ValueError(f\"Invalid extrapolation mode: {self.extrapolation}\")\n\n    # --------------------------\n    # Smoothing\n    # --------------------------\n    degree = None\n    use_cubic = False\n\n    if smooth is None:\n        degree = 1\n    elif isinstance(smooth, int):\n        degree = smooth\n    elif hasattr(smooth, '__call__'):\n        factors = smooth(factors)\n    elif isinstance(smooth, str):\n        if smooth.upper() == 'CUBIC':\n            use_cubic = True\n        else:\n            from .utils import maprange\n            factors = maprange(factors, easing=smooth)\n    else:\n        raise TypeError(f\"Invalid smooth type: {type(smooth).__name__}\")\n\n    # --------------------------\n    # Interpolation\n    # --------------------------\n    data = self._mat  # shape (K, N, D)\n    n_keys = len(data)\n\n    if degree is None:\n        fs = factors * (n_keys - 1)\n        inds = np.floor(fs).astype(int)\n        inds = np.clip(inds, 0, n_keys - 2)\n\n        p = (fs - inds)[..., None, None]  # (..., 1, 1) for broadcast\n        a = data[inds]\n        b = data[inds + 1]\n        interp_flat = a * (1 - p) + b * p  # shape (..., N, D)\n\n    elif use_cubic:\n        from scipy.interpolate import CubicSpline\n        x = np.linspace(0, 1, n_keys)\n        interp_flat = CubicSpline(x, data, axis=0, extrapolate=False)(factors)\n\n    else:\n        from scipy.interpolate import BSpline\n        k = degree\n        dx = 1 / (n_keys - 1)\n        x = np.linspace(-k * dx, 1 + k * dx, n_keys + k + 1)\n        interp_flat = BSpline(x, data, k=k, axis=0, extrapolate=False)(factors)\n\n    # --------------------------\n    # Convert back to structured recarray\n    # --------------------------\n    result = self._from_flat_array(interp_flat)\n    return result[0] if single else result\n</code></pre>"},{"location":"api/#npblender.ShapeKeys.rel_interpolate","title":"<code>rel_interpolate(weights, smooth=1)</code>","text":"<p>Relative interpolation using deltas from base shape.</p>"},{"location":"api/#npblender.ShapeKeys.rel_interpolate--parameters","title":"Parameters","text":"<p>weights : array_like     - shape (K,) for one result     - shape (M, K) for multiple results     where K = number of shapes - 1 smooth : int, str, callable, or None     Smoothing method (same as abs_interpolate)</p>"},{"location":"api/#npblender.ShapeKeys.rel_interpolate--returns","title":"Returns","text":"<p>np.recarray or array of recarrays     Interpolated result(s) (only float fields)</p> Source code in <code>npblender/shapekeys.py</code> <pre><code>def rel_interpolate(self, weights, smooth=1):\n    \"\"\"\n    Relative interpolation using deltas from base shape.\n\n    Parameters\n    ----------\n    weights : array_like\n        - shape (K,) for one result\n        - shape (M, K) for multiple results\n        where K = number of shapes - 1\n    smooth : int, str, callable, or None\n        Smoothing method (same as abs_interpolate)\n\n    Returns\n    -------\n    np.recarray or array of recarrays\n        Interpolated result(s) (only float fields)\n    \"\"\"\n    weights = np.asarray(weights)\n    n_shapes = len(self)\n    n_weights = n_shapes - 1\n\n    # --------------------------\n    # Validate shape of weights\n    # --------------------------\n    single = False\n    if weights.ndim == 1:\n        if weights.shape[0] != n_weights:\n            raise ValueError(f\"Expected shape ({n_weights},), got {weights.shape}\")\n        weights = weights[None]  # shape (1, K)\n        single = True\n    elif weights.shape[-1] != n_weights:\n        raise ValueError(f\"Expected shape (..., {n_weights}), got {weights.shape}\")\n\n    # --------------------------\n    # Apply smoothing if needed\n    # --------------------------\n    degree = None\n    use_cubic = False\n\n    if smooth is None:\n        degree = 1\n    elif isinstance(smooth, int):\n        degree = smooth\n    elif hasattr(smooth, '__call__'):\n        weights = smooth(weights)\n    elif isinstance(smooth, str):\n        if smooth.upper() == 'CUBIC':\n            use_cubic = True\n        else:\n            from .utils import maprange\n            weights = maprange(weights, easing=smooth)\n    else:\n        raise TypeError(f\"Invalid smooth type: {type(smooth).__name__}\")\n\n    weights = np.clip(weights, 0, 1)\n\n    # --------------------------\n    # Perform interpolation\n    # --------------------------\n    base = self._mat[0]  # shape (N, D)\n    deltas = self._mat[1:] - base  # shape (K, N, D)\n    w = weights[..., None, None]  # shape (..., 1, 1)\n    weighted = (w * deltas).sum(axis=-3)  # shape (..., N, D)\n    interp_flat = base + weighted\n\n    # --------------------------\n    # Reconstruct structured recarray\n    # --------------------------\n    result = self._from_flat_array(interp_flat)\n    return result[0] if single else result\n</code></pre>"},{"location":"api/#npblender.Simulation","title":"<code>Simulation</code>","text":"<p>               Bases: <code>Animation</code></p> Source code in <code>npblender/simulation.py</code> <pre><code>class Simulation(Animation):\n\n    def __init__(self, compute=None, reset=None, view=None):\n\n        super().__init__(compute=compute, reset=reset, view=view)\n\n        self._actions = []\n\n    # ----------------------------------------------------------------------------------------------------\n    # Dump\n    # ----------------------------------------------------------------------------------------------------\n\n    def __str__(self):\n        return f\"Simulation: {len(self.actions)} actions&gt;\"\n\n    # ====================================================================================================\n    # Property\n    # ====================================================================================================\n\n    @property\n    def actions(self):\n        if not hasattr(self, '_actions'):\n            self._actions = []\n        return self._actions\n\n    @property\n    def points(self):\n        if hasattr(self, \"geometry\"):\n            return self.geometry.points\n        raise Exception(f\"'points' property not defined for the class '{type(self).__name__}'\")\n\n    # ====================================================================================================\n    # Actions management\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # An action can be specified by its name\n    # ----------------------------------------------------------------------------------------------------\n\n    def str_to_func(self, func):\n        if isinstance(func, str):\n            return getattr(self, func)\n\n        elif hasattr(func, '__func__'):\n            return func.__func__\n\n        else:\n            return func\n\n    # ----------------------------------------------------------------------------------------------------\n    # Add an action\n    # ----------------------------------------------------------------------------------------------------\n\n    def add_action(self, func, *args, start=0, duration=None, flags=0, **kwargs):\n        \"\"\" Add an action to the simulation\n\n        To add an event, you can use &lt;#add_event&gt;.\n\n        Arguments\n        ---------\n        - func (function) : function of template f(simulation, *args, **kwargs)\n        - top (float = 0) : start time for the actiuon\n        - duration (float = None) : duration of the action (0: call once, None: never stops)\n        - after (bool = False) : exec the action after the exec_loop\n\n        Returns\n        -------\n        - Action : the action added to the simulation\n        \"\"\"\n        action = Action(self.str_to_func(func), *args, start=start, duration=duration, flags=flags, **kwargs)\n        self.actions.append(action)\n\n        return action\n\n    # ----------------------------------------------------------------------------------------------------\n    # Add an event\n    # ----------------------------------------------------------------------------------------------------\n\n    def add_event(self, func, *args, start=0, flags=0, **kwargs):\n        \"\"\" Add an event to the simulation\n\n        The event is executed once. To add an action called at each step, use &lt;#add_action&gt;.\n\n        Arguments\n        ---------\n        - func (function) : function of template f(simulation, *args, **kwargs)\n        - top (float = 0) : start time for the actiuon\n        - after (bool = False) : exec the action after the exec_loop\n\n        Returns\n        -------\n        - Action : the event added to the simulation\n        \"\"\"\n\n        action = Action(self.str_to_func(func), *args, start=start, duration=0., flags=flags, **kwargs)\n        self.actions.append(action)\n        return action\n\n    # ----------------------------------------------------------------------------------------------------\n    # Run the actions\n    # ----------------------------------------------------------------------------------------------------\n\n    def run_actions(self, flags=None):\n        for action in self.actions:\n            if flags is None or (flags &amp; actions.flags):\n                action(self)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Reset\n    # ----------------------------------------------------------------------------------------------------\n\n    def reset(self):\n        \"\"\" Reset the simulation\n        \"\"\"\n        super().reset()\n        for action in self.actions:\n            action.reset()\n\n    # ----------------------------------------------------------------------------------------------------\n    # Compute\n    # ----------------------------------------------------------------------------------------------------\n\n    def compute(self):\n        if hasattr(self, '_compute'):\n            self._compute()\n        else:\n            self.run_actions()\n\n    # ----------------------------------------------------------------------------------------------------\n    # View\n    # ----------------------------------------------------------------------------------------------------\n\n    def view(self):\n        geo = getattr(self, \"geometry\", None)\n        if (not hasattr(self, '_view')) and (geo is not None):\n            geo.to_object(\"Simulation\")\n        else:\n            super().view()\n\n    # ----------------------------------------------------------------------------------------------------\n    # Baking\n    # ----------------------------------------------------------------------------------------------------\n\n    def get_frame_data(self):\n        geo = getattr(self, \"geometry\", None)\n        if geo is not None:\n            return geo.to_dict()\n\n    def set_frame_data(self, data):\n        geo = getattr(self, \"geometry\", None)\n        if geo is not None:\n            self.geometry = geo.from_dict(data)\n            print(\"LOADED\", self.geometry)\n            return True\n        return False\n\n    # ====================================================================================================\n    # Useful actions\n    # ====================================================================================================\n\n    def change_attribute(self, attribute, value, incr=None, factor=None):\n        \"\"\" Modify a points attribute\n\n        ``` python\n        # gravity\n        self.add_action(\"change_attribute\", \"accel\", value=(0, 0, -9.81))\n        ```\n        \"\"\"\n        if value is None:\n            return\n\n        value = np.asarray(value)\n        if factor is not None:\n            shape = self.points[attribute].shape\n\n            factor = np.reshape(factor, (-1,) + (1,)*(len(shape) - 1))\n            value = np.broadcast_to(value, shape)*factor\n\n            print(f\"DEBUG --&gt;: {value.shape=}\")\n            print(value[:5])\n\n        if incr == '+':\n            self.points[attribute] += value\n        elif incr == '-':\n            self.points[attribute] -= value\n        elif incr == '*':\n            self.points[attribute] *= value\n        elif incr == '/':\n            self.points[attribute] /= value\n        else:\n            self.points[attribute] = value\n\n    # ----------------------------------------------------------------------------------------------------\n    # Gravity\n    # ----------------------------------------------------------------------------------------------------\n\n    def gravity(self, g=np.asarray([0, 0, -9.81]), factor=None):\n        self.change_attribute(\"accel\", value=g, factor=factor)\n\n    # ----------------------------------------------------------------------------------------------------\n    # A force\n    # ----------------------------------------------------------------------------------------------------\n\n    def force(self, force, factor=None):\n        self.change_attribute(\"force\", value=force, factor=factor)\n\n    # ----------------------------------------------------------------------------------------------------\n    # A torque\n    # ----------------------------------------------------------------------------------------------------\n\n    def torque(self, torque, factor=None):\n        self.change_attribute(\"torque\", value=force, factor=factor)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Newton's Law\n    # ----------------------------------------------------------------------------------------------------\n\n    def newton_law(self, G=1, power=2, min_distance=.001):\n        \"\"\" Newton's law between points\n\n        The force between two points is given by:\n\n        F = G.m1.m2 / dist**p\n        \"\"\"\n\n        pts = self.points.ravel()\n        if len(pts) &lt; 2:\n            return\n\n        # Vectors between couples of points\n        v = pts.position - pts.position[:, None]\n\n        # Distance\n        d = np.linalg.norm(v, axis=-1)\n        close = d &lt; min_distance\n\n        d[close] = 1\n        F = (G*v)*d[..., None]**(-power - 1)\n        F *= pts.mass[:, None, None]\n        F *= pts.mass[None, :, None]\n        F[close] = 0\n\n        pts.force += np.sum(F, axis=0)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Central force\n    # ----------------------------------------------------------------------------------------------------\n\n    def central_force(self, location=(0, 0, 0), force_factor=1., power=-2, min_distance=.001):\n\n        pts = self.points.ravel()\n\n        v = pts.position - location\n        d = np.linalg.norm(v, axis=-1)\n        close = d &lt; min_distance\n\n        d[close] = 1\n        F = (force_factor*v)*(d[:, None]**(power - 1))\n        F[close] = 0\n\n        pts.force += F\n\n    # ----------------------------------------------------------------------------------------------------\n    # Centrifugal and Coriolis acceleration\n    # ----------------------------------------------------------------------------------------------------\n\n    def centrifugal(self, location=(0, 0, 0), omega=1, axis=(0, 0, 1), coriolis_factor=1.):\n\n        pts = self.points.ravel()\n\n        axis = np.asarray(axis)\n\n        # Position relatively to the axis of rotation\n        v = pts.position - location\n\n        # Decompose height / vector to axis then distance\n        z  = np.einsum('...i, ...i', v, axis)\n        xy = v - axis*z[..., None]\n\n        d = np.linalg.norm(xy, axis=-1)\n\n        # Centrifugal\n        acc = xy*(omega*omega)\n\n        # Coriolis\n        # Factor articially controls the intensity of the Coriolis force\n\n        acc += np.cross((-2*omega)*axis, pts.speed)*coriolis_factor\n\n        pts.accel += acc\n\n    # ----------------------------------------------------------------------------------------------------\n    # Viscosity :  slow down speed according a power law\n    # ----------------------------------------------------------------------------------------------------\n\n    def viscosity(self, viscosity_factor=1., power=2, max_force=None, fluid_speed=None):\n\n        from collections.abc import Callable\n\n        pts = self.points.ravel()\n        speed = pts.speed\n\n        # Speed relative to fluid speed\n        if fluid_speed is None:\n            pass\n\n        elif callable(fluid_speed):\n            spped -= fluid_speed(pts.position)\n\n        else:\n            speed -= fluid_speed\n\n        # Direction and norm\n        nrm = np.linalg.norm(speed, axis=-1)\n        nrm[nrm &lt; .001] = 1\n        u = speed/nrm[:, None]\n\n        # Raw force\n        if 'viscosity' in pts.actual_names:\n            viscosity_factor = viscosity_factor*pts.viscosity\n\n        F = viscosity_factor*(nrm**power)\n\n        # Make sure the force doesn't invese de speed\n        max_F = pts.mass*nrm/self.delta_time\n        F = np.minimum(F, max_F)\n\n        pts.force -= u*F[:, None]\n\n    # ====================================================================================================\n    # Simulation\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Dynamics\n    # ----------------------------------------------------------------------------------------------------\n\n    def compute_motion(self, translation=True, rotation=True, torque=False, flags=None):\n\n        pts = self.points.ravel()\n\n        # ---------------------------------------------------------------------------\n        # Prepare\n        # ---------------------------------------------------------------------------\n\n        # Reset the acceleration and force\n        if translation:\n            pts.accel = 0\n            pts.force = 0\n\n        # Reset angular torque\n        if torque:\n            pts.torque = 0\n\n        # ---------------------------------------------------------------------------\n        # Run the actions\n        # ---------------------------------------------------------------------------\n\n        self.run_actions(flags=flags)\n\n        # ---------------------------------------------------------------------------\n        # Translation\n        # ---------------------------------------------------------------------------\n\n        if translation:\n            F = pts.force\n            mask = pts.mass != 0\n            F[mask] /= pts.mass[mask, None]\n            F[~mask] = 0\n\n            # Full acceleration\n            accel = pts.accel + F\n\n            # Move the particles\n            new_speed = pts.speed + accel*self.delta_time\n            pts.position += (pts.speed + new_speed)*(self.delta_time/2)\n            pts.speed = new_speed\n\n        # ---------------------------------------------------------------------------\n        # Rotation\n        # ---------------------------------------------------------------------------\n\n        if torque:\n            torque = pts.torque\n            mask = pts.moment != 0\n            torque[mask] /= pts.moment[mask, None]\n            torque[~mask] = 0\n\n            omega = pts.omega\n            new_omega = omega + torque*self.delta_time\n            pts.omega = (omega + new_omega)*(self.delta_time/2)\n\n        if rotation:\n            domg = pts.omega*self.delta_time\n            ag = np.linalg.norm(domg, axis=-1)\n            mask = ag != 0\n            domg[mask] = domg[mask]/ag[mask, None]\n            domg[~mask] = (1, 0, 0)\n\n            quat = Quaternion.from_axis_angle(domg, ag)\n            new_rot = quat @ pts.rotation\n            if \"euler\" in pts.euler:\n                pts.euler = new_rot.as_euler()\n            else:\n                pts.quat = new_rot.as_quaternion()\n</code></pre>"},{"location":"api/#npblender.Simulation.add_action","title":"<code>add_action(func, *args, start=0, duration=None, flags=0, **kwargs)</code>","text":"<p>Add an action to the simulation</p> <p>To add an event, you can use &lt;#add_event&gt;.</p>"},{"location":"api/#npblender.Simulation.add_action--arguments","title":"Arguments","text":"<ul> <li>func (function) : function of template f(simulation, args, *kwargs)</li> <li>top (float = 0) : start time for the actiuon</li> <li>duration (float = None) : duration of the action (0: call once, None: never stops)</li> <li>after (bool = False) : exec the action after the exec_loop</li> </ul>"},{"location":"api/#npblender.Simulation.add_action--returns","title":"Returns","text":"<ul> <li>Action : the action added to the simulation</li> </ul> Source code in <code>npblender/simulation.py</code> <pre><code>def add_action(self, func, *args, start=0, duration=None, flags=0, **kwargs):\n    \"\"\" Add an action to the simulation\n\n    To add an event, you can use &lt;#add_event&gt;.\n\n    Arguments\n    ---------\n    - func (function) : function of template f(simulation, *args, **kwargs)\n    - top (float = 0) : start time for the actiuon\n    - duration (float = None) : duration of the action (0: call once, None: never stops)\n    - after (bool = False) : exec the action after the exec_loop\n\n    Returns\n    -------\n    - Action : the action added to the simulation\n    \"\"\"\n    action = Action(self.str_to_func(func), *args, start=start, duration=duration, flags=flags, **kwargs)\n    self.actions.append(action)\n\n    return action\n</code></pre>"},{"location":"api/#npblender.Simulation.add_event","title":"<code>add_event(func, *args, start=0, flags=0, **kwargs)</code>","text":"<p>Add an event to the simulation</p> <p>The event is executed once. To add an action called at each step, use &lt;#add_action&gt;.</p>"},{"location":"api/#npblender.Simulation.add_event--arguments","title":"Arguments","text":"<ul> <li>func (function) : function of template f(simulation, args, *kwargs)</li> <li>top (float = 0) : start time for the actiuon</li> <li>after (bool = False) : exec the action after the exec_loop</li> </ul>"},{"location":"api/#npblender.Simulation.add_event--returns","title":"Returns","text":"<ul> <li>Action : the event added to the simulation</li> </ul> Source code in <code>npblender/simulation.py</code> <pre><code>def add_event(self, func, *args, start=0, flags=0, **kwargs):\n    \"\"\" Add an event to the simulation\n\n    The event is executed once. To add an action called at each step, use &lt;#add_action&gt;.\n\n    Arguments\n    ---------\n    - func (function) : function of template f(simulation, *args, **kwargs)\n    - top (float = 0) : start time for the actiuon\n    - after (bool = False) : exec the action after the exec_loop\n\n    Returns\n    -------\n    - Action : the event added to the simulation\n    \"\"\"\n\n    action = Action(self.str_to_func(func), *args, start=start, duration=0., flags=flags, **kwargs)\n    self.actions.append(action)\n    return action\n</code></pre>"},{"location":"api/#npblender.Simulation.change_attribute","title":"<code>change_attribute(attribute, value, incr=None, factor=None)</code>","text":"<p>Modify a points attribute</p> <pre><code># gravity\nself.add_action(\"change_attribute\", \"accel\", value=(0, 0, -9.81))\n</code></pre> Source code in <code>npblender/simulation.py</code> <pre><code>def change_attribute(self, attribute, value, incr=None, factor=None):\n    \"\"\" Modify a points attribute\n\n    ``` python\n    # gravity\n    self.add_action(\"change_attribute\", \"accel\", value=(0, 0, -9.81))\n    ```\n    \"\"\"\n    if value is None:\n        return\n\n    value = np.asarray(value)\n    if factor is not None:\n        shape = self.points[attribute].shape\n\n        factor = np.reshape(factor, (-1,) + (1,)*(len(shape) - 1))\n        value = np.broadcast_to(value, shape)*factor\n\n        print(f\"DEBUG --&gt;: {value.shape=}\")\n        print(value[:5])\n\n    if incr == '+':\n        self.points[attribute] += value\n    elif incr == '-':\n        self.points[attribute] -= value\n    elif incr == '*':\n        self.points[attribute] *= value\n    elif incr == '/':\n        self.points[attribute] /= value\n    else:\n        self.points[attribute] = value\n</code></pre>"},{"location":"api/#npblender.Simulation.newton_law","title":"<code>newton_law(G=1, power=2, min_distance=0.001)</code>","text":"<p>Newton's law between points</p> <p>The force between two points is given by:</p> <p>F = G.m1.m2 / dist**p</p> Source code in <code>npblender/simulation.py</code> <pre><code>def newton_law(self, G=1, power=2, min_distance=.001):\n    \"\"\" Newton's law between points\n\n    The force between two points is given by:\n\n    F = G.m1.m2 / dist**p\n    \"\"\"\n\n    pts = self.points.ravel()\n    if len(pts) &lt; 2:\n        return\n\n    # Vectors between couples of points\n    v = pts.position - pts.position[:, None]\n\n    # Distance\n    d = np.linalg.norm(v, axis=-1)\n    close = d &lt; min_distance\n\n    d[close] = 1\n    F = (G*v)*d[..., None]**(-power - 1)\n    F *= pts.mass[:, None, None]\n    F *= pts.mass[None, :, None]\n    F[close] = 0\n\n    pts.force += np.sum(F, axis=0)\n</code></pre>"},{"location":"api/#npblender.Simulation.reset","title":"<code>reset()</code>","text":"<p>Reset the simulation</p> Source code in <code>npblender/simulation.py</code> <pre><code>def reset(self):\n    \"\"\" Reset the simulation\n    \"\"\"\n    super().reset()\n    for action in self.actions:\n        action.reset()\n</code></pre>"},{"location":"api/#npblender.Spline","title":"<code>Spline</code>","text":"<p>               Bases: <code>FaceSplineDomain</code></p> <p>Spline domain.</p> <p>Spline domain is specific to Curve geometry. A spline is an array of control points. A Spline is similare to a Face but points directly to the control points and not indirectly as for the faces.</p>"},{"location":"api/#npblender.Spline--attributes","title":"Attributes","text":"<pre><code>- loop_start (int) : first index in control points array\n- loop_total (int) : number of control points\n- material_index (int, optional) : material index\n- resolution (int, optional) : spline resolution\n- cyclic (bool, optional) : spline is cyclic or not\n- order (int, optional) : Nurbs spline order\n- bezierpoint (bool, optional) : Nurbs spline bezierpoint flag\n- endpoint (bool, optional) : Nurbs spline endpoint flag\n</code></pre> Source code in <code>npblender/domain.py</code> <pre><code>class Spline(FaceSplineDomain):\n    \"\"\" Spline domain.\n\n    Spline domain is specific to Curve geometry. A spline is an array of control points.\n    A Spline is similare to a Face but points directly to the control points and not indirectly\n    as for the faces.\n\n    Attributes\n    ----------\n        - loop_start (int) : first index in control points array\n        - loop_total (int) : number of control points\n        - material_index (int, optional) : material index\n        - resolution (int, optional) : spline resolution\n        - cyclic (bool, optional) : spline is cyclic or not\n        - order (int, optional) : Nurbs spline order\n        - bezierpoint (bool, optional) : Nurbs spline bezierpoint flag\n        - endpoint (bool, optional) : Nurbs spline endpoint flag\n    \"\"\"\n\n    domain_name = 'SPLINE'\n\n    def declare_attributes(self):\n        super().declare_attributes()\n\n        self.new_int('curve_type', transdom=False)\n\n        self.new_int('resolution',   optional=True, default=16, transdom=False)\n        self.new_bool('cyclic',      optional=True, default=False, transdom=False)\n\n        # Nurbs\n        self.new_int('order',        optional=True, default=4, transdom=False)\n        self.new_bool('bezierpoint', optional=True, transdom=False)\n        self.new_bool('endpoint',    optional=True, transdom=False)\n\n    # ====================================================================================================\n    # Properties\n    # ====================================================================================================\n\n    @property\n    def has_bezier(self):\n        return np.any(self.curve_type == BEZIER)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Delete splines\n    # ----------------------------------------------------------------------------------------------------\n\n    def delete_splines(self, selection, cpoints):\n        corner_indices = self[selection].get_corner_indices()\n        self.delete(selection)\n        cpoints.delete(corner_indices)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Sample attribute\n    # ----------------------------------------------------------------------------------------------------\n\n    def sample_attribute(self, value):\n        npoints = len(self.bspline.c)\n        count = npoints*self.resolution if self.cyclic else (npoints - 1)*self.resolution + 1\n\n\n    # ====================================================================================================\n    # Adding splines\n    # ====================================================================================================\n\n    def add_splines(self, splines, **attributes):\n        \"\"\" Add splines.\n\n        Arguments\n        ---------\n            - splines (array of ints) : the number of control points per spline\n            - attributes (attribute names, attribute values) : value of the corner attributes\n        \"\"\"\n        return self.add_loops(splines, **attributes)\n\n    # ====================================================================================================\n    # Parameter\n    # ====================================================================================================\n\n    @property\n    def functions(self):\n        \"\"\" Return the functions representing the splines.\n\n        The functions are scipy BSplines initialized with the splines parameters.\n\n        Returns\n        -------\n            - list of BSpline functions\n        \"\"\"\n\n        funcs = BSplines()\n\n        for i, (curve_type, loop_start, loop_total, cyclic, resolution) in enumerate(zip(self.curve_type, self.loop_start, self.loop_total, self.cyclic, self.resolution)):\n\n            if curve_type == BEZIER:\n                funcs.append(Bezier(self.points.position[loop_start:loop_start + loop_total], cyclic=cyclic, resolution=resolution,\n                                lefts  = self.points.handle_left[loop_start:loop_start + loop_total],\n                                rights = self.points.handle_right[loop_start:loop_start + loop_total]\n                                ))\n\n            elif curve_type == POLY:\n                funcs.append(Poly(self.points.position[loop_start:loop_start + loop_total], cyclic=cyclic))\n\n            elif curve_type == NURBS:\n                funcs.append(Nurbs(self.points.position[loop_start:loop_start + loop_total], cyclic=cyclic, resolution=resolution,\n                                    w     = self.w[loop_start:loop_start + loop_total],\n                                    order = self.order[loop_start:loop_start + loop_total],\n                                    ))\n\n            else:\n                assert(False)\n\n        return funcs\n\n    @property\n    def length(self):\n        \"\"\" Length of the splines.\n\n        Returns\n        -------\n            - List of spline lengths\n        \"\"\"\n        return self.functions.length\n\n    def tangent(self, t):\n        \"\"\" Tangents of the splines at a given time.\n\n        Arguments\n        ---------\n            - t (float) : spline parameter between 0 and 1\n\n        Returns\n        -------\n            - list of spline tangents evaluated at time t.\n        \"\"\"\n        return self.functions.tangent(t)\n\n    # ====================================================================================================\n    # Interface with Blender\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Read data attributes\n    # ----------------------------------------------------------------------------------------------------\n\n    def load_bl_attributes(self, data):\n        \"\"\" Read the object attributes.\n\n        Arguments\n        ---------\n            - spec (str or data) : the data to set the attributes to\n        \"\"\"\n\n        from . import blender\n\n        size = None\n        if not hasattr(data, 'attributes'):\n            return\n\n        for name, binfo in data.attributes.items():\n\n            # Must be external and in the domain\n            if binfo.domain != self.domain or binfo.is_internal:\n                continue\n\n            # Create if it doesn't exist\n            if not self.has_field(name):\n                self.new_attribute(name, binfo.data_type, 0, transfer=True)\n\n            # Adjust size\n            if size is None:\n                size = len(binfo.data)\n                self.resize(size)\n            else:\n                # Should never append\n                assert size == len(binfo.data), \"Blender read algorithm is incorrect\"\n\n            try:\n                self[name] = blender.get_attribute(data, name)\n\n            except Exception as e:\n                raise Exception(f\"Failed to read attribute '{name}' from Blender: {e}\")\n\n    # ----------------------------------------------------------------------------------------------------\n    # Write data attributes\n    # ----------------------------------------------------------------------------------------------------\n\n    def to_object(self, data, update=False):\n        \"\"\" Transfer the attributes to a blender mesh object.\n\n        Arguments\n        ---------\n            - spec (str or data) : the mesh to set the attributes to\n            - attributes (array of st = None) : the attributes to transfer (all if None)\n            - update (bool=False) : update the attributes values without trying to create them\n        \"\"\"\n\n        from . import blender\n\n        if not hasattr(data, 'attributes'):\n            return\n\n        for name, info in self._infos.items():\n\n            if not info['transfer']:\n                continue\n\n            if info['data_type'] == 'STRING':\n                pass\n\n            if update:\n                blender.set_attribute(data, name, self[name])\n            else:\n                blender.create_attribute(data, name, info['data_type'], domain=self.domain, value=self[name])    \n\n    # ====================================================================================================\n    # Compute attribute on points\n    # ====================================================================================================\n\n    def compute_attribute_on_points(self, attr, points):\n\n        @njit(cache=True)\n        def _to_points(loop_start, loop_total, source, res): \n            nsplines = loop_start.shape[0]\n            for ispline in range(nsplines):\n                start = loop_start[ispline]\n                total = loop_total[ispline]\n                for ipoint in range(start, start + total):\n                    res[ipoint] += source[ispline]\n\n            return res        \n\n        attr, item_shape = self._check_attribute_to_compute(attr)\n        res = np.zeros((len(points),) + item_shape, dtype=attr.dtype)\n        return _to_points(self.loop_start, self.loop_total, attr, res)                \n</code></pre>"},{"location":"api/#npblender.Spline.functions","title":"<code>functions</code>  <code>property</code>","text":"<p>Return the functions representing the splines.</p> <p>The functions are scipy BSplines initialized with the splines parameters.</p>"},{"location":"api/#npblender.Spline.functions--returns","title":"Returns","text":"<pre><code>- list of BSpline functions\n</code></pre>"},{"location":"api/#npblender.Spline.length","title":"<code>length</code>  <code>property</code>","text":"<p>Length of the splines.</p>"},{"location":"api/#npblender.Spline.length--returns","title":"Returns","text":"<pre><code>- List of spline lengths\n</code></pre>"},{"location":"api/#npblender.Spline.add_splines","title":"<code>add_splines(splines, **attributes)</code>","text":"<p>Add splines.</p>"},{"location":"api/#npblender.Spline.add_splines--arguments","title":"Arguments","text":"<pre><code>- splines (array of ints) : the number of control points per spline\n- attributes (attribute names, attribute values) : value of the corner attributes\n</code></pre> Source code in <code>npblender/domain.py</code> <pre><code>def add_splines(self, splines, **attributes):\n    \"\"\" Add splines.\n\n    Arguments\n    ---------\n        - splines (array of ints) : the number of control points per spline\n        - attributes (attribute names, attribute values) : value of the corner attributes\n    \"\"\"\n    return self.add_loops(splines, **attributes)\n</code></pre>"},{"location":"api/#npblender.Spline.load_bl_attributes","title":"<code>load_bl_attributes(data)</code>","text":"<p>Read the object attributes.</p>"},{"location":"api/#npblender.Spline.load_bl_attributes--arguments","title":"Arguments","text":"<pre><code>- spec (str or data) : the data to set the attributes to\n</code></pre> Source code in <code>npblender/domain.py</code> <pre><code>def load_bl_attributes(self, data):\n    \"\"\" Read the object attributes.\n\n    Arguments\n    ---------\n        - spec (str or data) : the data to set the attributes to\n    \"\"\"\n\n    from . import blender\n\n    size = None\n    if not hasattr(data, 'attributes'):\n        return\n\n    for name, binfo in data.attributes.items():\n\n        # Must be external and in the domain\n        if binfo.domain != self.domain or binfo.is_internal:\n            continue\n\n        # Create if it doesn't exist\n        if not self.has_field(name):\n            self.new_attribute(name, binfo.data_type, 0, transfer=True)\n\n        # Adjust size\n        if size is None:\n            size = len(binfo.data)\n            self.resize(size)\n        else:\n            # Should never append\n            assert size == len(binfo.data), \"Blender read algorithm is incorrect\"\n\n        try:\n            self[name] = blender.get_attribute(data, name)\n\n        except Exception as e:\n            raise Exception(f\"Failed to read attribute '{name}' from Blender: {e}\")\n</code></pre>"},{"location":"api/#npblender.Spline.tangent","title":"<code>tangent(t)</code>","text":"<p>Tangents of the splines at a given time.</p>"},{"location":"api/#npblender.Spline.tangent--arguments","title":"Arguments","text":"<pre><code>- t (float) : spline parameter between 0 and 1\n</code></pre>"},{"location":"api/#npblender.Spline.tangent--returns","title":"Returns","text":"<pre><code>- list of spline tangents evaluated at time t.\n</code></pre> Source code in <code>npblender/domain.py</code> <pre><code>def tangent(self, t):\n    \"\"\" Tangents of the splines at a given time.\n\n    Arguments\n    ---------\n        - t (float) : spline parameter between 0 and 1\n\n    Returns\n    -------\n        - list of spline tangents evaluated at time t.\n    \"\"\"\n    return self.functions.tangent(t)\n</code></pre>"},{"location":"api/#npblender.Spline.to_object","title":"<code>to_object(data, update=False)</code>","text":"<p>Transfer the attributes to a blender mesh object.</p>"},{"location":"api/#npblender.Spline.to_object--arguments","title":"Arguments","text":"<pre><code>- spec (str or data) : the mesh to set the attributes to\n- attributes (array of st = None) : the attributes to transfer (all if None)\n- update (bool=False) : update the attributes values without trying to create them\n</code></pre> Source code in <code>npblender/domain.py</code> <pre><code>def to_object(self, data, update=False):\n    \"\"\" Transfer the attributes to a blender mesh object.\n\n    Arguments\n    ---------\n        - spec (str or data) : the mesh to set the attributes to\n        - attributes (array of st = None) : the attributes to transfer (all if None)\n        - update (bool=False) : update the attributes values without trying to create them\n    \"\"\"\n\n    from . import blender\n\n    if not hasattr(data, 'attributes'):\n        return\n\n    for name, info in self._infos.items():\n\n        if not info['transfer']:\n            continue\n\n        if info['data_type'] == 'STRING':\n            pass\n\n        if update:\n            blender.set_attribute(data, name, self[name])\n        else:\n            blender.create_attribute(data, name, info['data_type'], domain=self.domain, value=self[name])    \n</code></pre>"},{"location":"api/mesh/","title":"Mesh","text":"<p>               Bases: <code>Geometry</code></p> Source code in <code>npblender/mesh.py</code> <pre><code>class Mesh(Geometry):\n\n    domain_names = ['points', 'corners', 'faces', 'edges']\n\n    def __init__(self, points=None, corners=None, faces=None, edges=None, materials=None, attr_from=None, **attrs):\n        \"\"\" Mesh Geometry.\n\n        Arguments\n        ---------\n            - points (array of vectors = None) : the vertices\n            - corners (array of ints = None) : corners, i.e. indices on the array of points\n            - faces (array of ints = None) : size of the faces, the sum of this array must be equal to the length of the corners array\n            - edges (array of couples of ints = None) : list of edges defined by two vertex indices\n            - materials (str or list of strs = None) : list of materials used in the geometry\n            - attr_from (Geometry) : domain attributes to copy from\n            - **attrs (dict) : other geometry attributes\n        \"\"\"\n\n        # ----- Initialize an empty geometry\n\n        self.points  = Vertex()\n        self.corners = Corner()\n        self.faces   = Face()\n        self.edges   = Edge()\n\n        self.join_attributes(attr_from)\n\n        # ----- The materials\n\n        if materials is None:\n            self.materials = []\n        elif isinstance(materials, str):\n            self.materials = [materials]\n        else:\n            self.materials = [mat for mat in materials]\n\n        # ----- Add geometry\n\n        self.add_geometry(points, corners, faces, edges, **attrs)\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Utilities\n\n    @classmethod\n    def dummy(cls, points_count=0, corners_count=0, faces=None, edges=None, seed=0, **attrs):\n        rng = np.random.default_rng(seed)\n        verts = rng.uniform(-1, 1, (points_count, 3)) if points_count else None\n        corners = rng.uniform(0, points_count, corners_count) if corners_count else None\n        loops = None\n\n        if faces is None:\n            n = corners_count if corners_count else points_count\n            if n &gt; 0:\n                loops = [4] * (n //4)\n                loops[0] = n - np.sum(loops[1:])\n            else:\n                loops = None\n        else:\n            loops = faces\n\n        return cls(points=verts, corners=corners, faces=loops, edges=edges,**attrs)\n\n    def check(self, title=\"Mesh Check\", halt=True):\n        ok = self.corners.check(len(self.points), halt=False) and \\\n               self.faces.check(len(self.corners), halt=False) and \\\n               self.edges.check(len(self.points), halt=False)\n        if ok:\n            return True\n        elif halt:\n            raise Exception(f\"{title} check failed\")\n        else:\n            print(f\"{title} check failed\")\n\n\n    def __str__(self):\n        return f\"&lt;Mesh: points {len(self.points)}, corners {len(self.corners)}, faces {len(self.faces)}, edges {len(self.edges)}&gt;\"\n\n    def __repr__(self):\n        s = \"Mesh:\\n   \" + \"\\n   \".join([str(self.points), str(self.corners), str(self.faces)])\n        return s\n\n    # =============================================================================================================================\n    # Serialization\n    # =============================================================================================================================\n\n    def to_dict(self):\n        return {\n            'geometry':     'Mesh',\n            'materials' :   self.materials,\n            'points':       self.points.to_dict(),\n            'corners':      self.corners.to_dict(),\n            'faces':        self.faces.to_dict(),\n            'edges':        self.edges.to_dict(),\n            }\n\n    @classmethod\n    def from_dict(cls, d):\n        mesh = cls()\n        mesh.materials  = d['materials']\n        mesh.points     = Vertex.from_dict(d['points'])\n        mesh.corners    = Corner.from_dict(d['corners'])\n        mesh.faces      = Face.from_dict(d['faces'])\n        mesh.edges      = Edge.from_dict(d['edges'])\n        return mesh\n\n    # =============================================================================================================================\n    # Clear the geometry\n    # =============================================================================================================================\n\n    def clear_geometry(self):\n        \"\"\" Clear the geometry.\n\n        Delete all the content.\n        \"\"\"\n\n        self.points.clear()\n        self.corners.clear()\n        self.faces.clear()\n        self.edges.clear()\n\n    # =============================================================================================================================\n    # From another Mesh\n    # =============================================================================================================================\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Copy\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def from_mesh(cls, other, points=None, faces=None, edges=None):\n        \"\"\" Create a Mesh from another mesh.\n\n        Arguments\n        ---------\n            - other (Mesh) : the mesh to copy\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n        mesh = cls(materials=other.materials)\n        mesh.points  = Vertex(other.points,  mode='COPY')\n        mesh.corners = Corner(other.corners, mode='COPY')\n        mesh.faces   = Face(other.faces,   mode='COPY')\n        mesh.edges   = Edge(other.edges,    mode='COPY')\n\n        if points is None:\n            points_mask = None\n        else:\n            points_mask = np.ones(len(mesh.points), dtype=bool)\n            points_mask[points] = False\n\n        if faces is None:\n            faces_mask = None\n        else:\n            faces_mask = np.ones(len(mesh.faces), dtype=bool)\n            faces_mask[faces] = False\n\n        if edges is None:\n            edges_mask = None\n        else:\n            edges_mask = np.ones(len(mesh.edges), dtype=bool)\n            edges_mask[edges] = False\n\n        mesh.delete_vertices(points=points_mask, faces=faces_mask, edges=edges_mask)\n\n        return mesh\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Capture another Mesh\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def capture(self, other):\n        \"\"\" Capture the data of another Mesh.\n\n        Arguments\n        ---------\n            - other (Mesh) : the mesh to capture\n\n        Returns\n        -------\n            - self\n        \"\"\"\n\n        self.materials = other.materials\n\n        self.points  = other.points\n        self.corners = other.corners\n        self.faces   = other.faces\n        self.edges   = other.edges\n\n    # =============================================================================================================================\n    # Blender Interface\n    # =============================================================================================================================\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # From Mesh data\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def from_mesh_data(cls, data):\n        \"\"\" Initialize the geometry from a Blender Mesh\n\n        Arguments\n        ---------\n            - mesh (Blender Mesh instance) : the mesh to load\n        \"\"\"\n\n        from . import blender\n\n        bl_mesh = blender.get_mesh(data)\n\n        mesh = cls()\n\n        # ----- Materials\n\n        mesh.materials = [None if mat is None else mat.name for mat in bl_mesh.materials]\n\n        # ----- Vertices\n\n        n = len(bl_mesh.vertices)\n        if n != 0:\n            # Positions will be read as position attribute\n            mesh.points.resize(n)\n\n        # ----- Corners\n\n        n = len(bl_mesh.polygons)\n        if n != 0:\n            a = np.empty(len(bl_mesh.loops), bint)\n            bl_mesh.loops.foreach_get(\"vertex_index\", a)\n            mesh.corners.append(vertex_index=a)\n\n            a = np.empty(len(bl_mesh.polygons), bint)\n            bl_mesh.polygons.foreach_get(\"loop_total\", a)\n            mesh.faces.append_sizes(a)\n\n            del a\n\n        # ----- Edges\n\n        if len(bl_mesh.edges):\n            n = len(bl_mesh.edges)\n            a = np.empty(2*n, bint)\n            bl_mesh.edges.foreach_get(\"vertices\", a)\n            a = np.reshape(a, (n, 2))\n            mesh.edges.append(vertex0=a[:, 0], vertex1=a[:, 1])\n\n            del a\n\n            mesh.edges.remove_face_edges(mesh.faces.get_edges(mesh.corners))\n\n        # ----- Attributes\n\n        mesh.points.from_bl_attributes(bl_mesh.attributes)\n        mesh.corners.from_bl_attributes(bl_mesh.attributes)\n        mesh.faces.from_bl_attributes(bl_mesh.attributes)\n        mesh.edges.from_bl_attributes(bl_mesh.attributes)\n\n        return mesh\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # To Mesh data\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def to_mesh_data(self, data):\n        \"\"\" Write the geometry into a Blender Mesh\n\n        Arguments\n        ---------\n            - mesh (Blender Mesh instance) : the mesh to write\n        \"\"\"\n\n        from npblender import blender\n\n        bl_mesh = blender.get_data(data)\n        bl_mesh.clear_geometry()\n\n        # ----------------------------------------------------------------------------------------------------\n        # Materials\n\n        bl_mesh.materials.clear()\n        for mat_name in self.materials:\n            if mat_name is not None:\n                bl_mesh.materials.append(bpy.data.materials.get(mat_name))\n\n        # ----------------------------------------------------------------------------------------------------\n        # Vertices\n\n        points = self.points.ravel()\n        if len(points):\n            bl_mesh.vertices.add(len(points))\n\n        # ----------------------------------------------------------------------------------------------------\n        # Corners\n\n        corners = self.corners.ravel()\n        if len(corners):\n            bl_mesh.loops.add(len(corners))\n            bl_mesh.loops.foreach_set(\"vertex_index\", blender.int_array(corners.vertex_index))\n\n        # ----------------------------------------------------------------------------------------------------\n        # Faces\n\n        faces = self.faces.ravel()\n        if len(faces):\n            bl_mesh.polygons.add(len(faces))\n            bl_mesh.polygons.foreach_set(\"loop_start\", blender.int_array(faces.loop_start))\n            bl_mesh.polygons.foreach_set(\"loop_total\", blender.int_array(faces.loop_total))\n\n        # ----------------------------------------------------------------------------------------------------\n        # Edges\n\n        edges = self.edges.ravel()\n        if len(self.edges):\n            # edges to add\n            add_edges = self.edges.vertices\n\n            # edges have been created by faces\n            if len(faces):\n                bl_mesh.update()\n\n                cur_n = len(bl_mesh.edges)\n                if cur_n &gt; 0:\n                    a = np.empty((cur_n, 2), dtype=bint)\n                    bl_mesh.edges.foreach_get('vertices', a.ravel())\n\n                add_edges = np.append(a, add_edges, axis=0)\n\n            # add the edges\n            n = len(edges)\n            bl_mesh.edges.add(n)\n\n            bl_mesh.edges.foreach_set('vertices', add_edges.ravel())\n\n        # ----------------------------------------------------------------------------------------------------\n        # Attributes\n\n        attributes = data.attributes\n\n        points.to_bl_attributes(attributes, update=False)\n        corners.to_bl_attributes(attributes, update=False)\n        faces.to_bl_attributes(attributes, update=False)\n        edges.to_bl_attributes(attributes, update=False)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Update\n\n        bl_mesh.update()\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Initialize from an object\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def from_object(cls, obj, evaluated=False):\n        \"\"\" Create a Mesh from an existing object.\n\n        Arguments\n        ---------\n            - obj (str or Blender object) : the object to initialize from\n            - evaluated (bool = False) : object modified by the modifiers if True, raw vertices otherwise\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n\n        from . import blender\n\n        if evaluated:\n            depsgraph = bpy.context.evaluated_depsgraph_get()\n            object_eval = blender.get_object(obj).evaluated_get(depsgraph)\n            return cls.FromMeshData(object_eval.data)\n\n        else:\n            return cls.from_mesh_data(blender.get_object(obj).data)\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # To blender object\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def to_object(self, obj, shade_smooth=None, shapekeys=None, collection=None):\n        \"\"\" Create or update a blender object.\n\n        The method 'to_object' creates the whole geometry. It creates a new object if it doesn't already exist.\n        If the object exists, it must be a mesh, there is no object type conversion.\n\n        Once the object is created, use the method 'update_object' to change the vertices.\n\n        Arguments\n        ---------\n            - obj (str or Blender object) : the object the create\n\n        Returns\n        -------\n            - Blender mesh object\n        \"\"\"\n\n        from npblender import blender\n\n        res = blender.create_mesh_object(obj, collection=collection)\n        self.to_mesh_data(res.data)\n\n        if shade_smooth is not None:\n            res.data.polygons.foreach_set('use_smooth', [shade_smooth]*len(res.data.polygons))\n\n        if shapekeys is not None:\n            if shapekeys is not None:\n                if isinstance(shapekeys, ShapeKeys):\n                    shapekeys.to_mesh_object(obj)\n                else:\n                    for sks in shapekeys:\n                        sks.to_mesh_object(obj)\n\n        return res\n\n    # ====================================================================================================\n    # bmesh edition\n    # ====================================================================================================\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # bmesh utility to pass from internal geometry to bmesh\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def _bm_verts(self, bm):\n        nverts = len(self.points.ravel())\n        verts  = np.zeros(nverts, dtype=object)\n        for vert in bm.verts:\n            verts[vert.index] = vert\n        return verts\n\n    def _bm_edges(self, bm):\n        nedges = len(bm.edges)\n        edges  = np.empty(nedges, dtype=object)\n        verts  = np.empty((nedges, 2), dtype=bint)\n\n        for i_edge, edge in enumerate(bm.edges):\n            edges[i_edge] = edge\n\n            i0, i1 = edge.verts[0].index, edge.verts[1].index\n            verts[i_edge] = (i0, i1) if i0 &lt; i1 else (i1, i0)\n\n        return edges, verts\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # bmesh context\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    @contextmanager\n    def bmesh(self, readonly=False):\n        \"\"\" Acces to bmesh api.\n\n        The example below use bmesh to offset the vertices of +1 in the x axis.\n\n        ``` python\n        mesh = Mesh.Cube()\n\n        # Move the vertices with bmesh\n        with mesh.bmesh() as bm:\n            for v in bm.verts:\n                v.co.x += 1.0\n\n        # Move the vertices directy in numpy array\n        mesh.points.position[:, 1] += 1\n\n        # Cube moved along x and y\n        mesh.to_object(\"Cube\")\n        ```\n\n        Arguments\n        ---------\n            - readonly (bool=False) : avoid to read back the bmesh if not modications were done\n        \"\"\"\n\n        data = bpy.data.meshes.get(DATA_TEMP_NAME)\n        if data is None:\n            data = bpy.data.meshes.new(DATA_TEMP_NAME)\n        self.to_mesh_data(data)\n\n        bm = bmesh.new()   # create an empty BMesh\n        bm.from_mesh(data) # fill it in from a Mesh\n\n        yield bm\n\n        # ----- Back\n\n        if not readonly:\n            bm.to_mesh(data)\n            self.capture(Mesh.from_mesh_data(data))\n\n        bm.free()\n\n    # ====================================================================================================\n    # Mesh data edition\n    # ====================================================================================================\n\n    @contextmanager\n    def blender_data(self, readonly=False):\n        \"\"\" Acces to Blender Mesh API.\n\n        Transfer the geometry to a temporay Blender Mesh.\n        The example below use a blender Mesh to get the normals.\n\n        ``` python\n        mesh = Mesh.Cube()\n\n        with mesh.blender_data() as data:\n            normals = np.array([poly.normal for poly in data.polygons])\n\n        print(normals)\n\n        # &gt; [[-1. -0.  0.]\n        #    [ 0.  1.  0.]\n        #    [ 1. -0.  0.]\n        #    [ 0. -1.  0.]\n        #    [ 0.  0. -1.]\n        #    [ 0. -0.  1.]]\n        ```\n\n        Arguments\n        ---------\n            - readonly (bool=False) : don't read back the geometry if not modified\n\n        Returns\n        -------\n            - Blender Mesh\n        \"\"\"\n\n        data = bpy.data.meshes.get(DATA_TEMP_NAME)\n        if data is None:\n            data = bpy.data.meshes.new(DATA_TEMP_NAME)\n\n        self.to_mesh_data(data)\n\n        yield data\n\n        # ----- Back\n\n        if not readonly:\n            self.capture(Mesh.from_mesh_data(data))\n\n    # ====================================================================================================\n    # From something\n    # ====================================================================================================\n\n    @classmethod\n    def from_model(cls, model, materials=None):\n\n        if isinstance(model, (str, bpy.types.Object)):\n            mesh = cls.from_object(model, evaluated=True)\n\n        elif isinstance(model, dict):\n            mesh = cls.from_dict(model)\n\n        elif isinstance(model, Mesh):\n            mesh = cls.from_mesh(model)\n\n        elif isinstance(model, bpy.types.Mesh):\n            mesh = cls.from_mesh_data(model)\n\n        else:\n            raise Exception(f\"Mesh.from_model: 'model' type is not valid: {type(model)}\")\n\n        return mesh\n\n    # =============================================================================================================================\n    # Utility\n    # =============================================================================================================================\n\n    def get_faces_position(self, selection=None):\n        if selection is None:\n            return self.faces[selection].get_position(self.corners, self.points)\n        else:\n            return self.faces[selection].get_position(self.corners, self.points)\n\n    # =============================================================================================================================\n    # Combining\n    # =============================================================================================================================\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Join other meshes\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def join(self, *others):\n        \"\"\" Join other Meshes.\n\n        Arguments\n        ---------\n            - others (Mesh) : the Mesh to append\n        \"\"\"\n        for other in others:\n\n            # ----------------------------------------------------------------------------------------------------\n            # Vertices\n\n            v_ofs = len(self.points)\n            self.points.extend(other.points)\n\n            # ----------------------------------------------------------------------------------------------------\n            # Corners\n\n            c_ofs = len(self.corners)\n            self.corners.extend(other.corners)\n            if len(self.corners):\n                self.corners.vertex_index[c_ofs:] += v_ofs\n\n            # ----------------------------------------------------------------------------------------------------\n            # Faces\n\n            f_ofs = len(self.faces)\n            self.faces.extend(other.faces)\n            if len(self.faces):\n                self.faces.loop_start[f_ofs:] += c_ofs\n\n            # ----------------------------------------------------------------------------------------------------\n            # Edges\n\n            e_ofs = len(self.edges)\n            self.edges.extend(other.edges)\n            if len(self.edges):\n                self.edges.vertex0[e_ofs:] += v_ofs\n                self.edges.vertex1[e_ofs:] += v_ofs\n\n            # ----- Materials\n\n            remap = np.array([self.get_material_index(mat_name) for mat_name in other.materials])\n            if len(remap)&gt;0:\n                self.faces.material_index[f_ofs:] = remap[other.faces.material_index]\n\n        return self\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Multiply\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def multiply(self, count, in_place=True):\n        \"\"\" Duplicate the geometry.\n\n        Multiplying is a way to efficiently duplicate the geometry a great number of times.\n        Once duplicated, the vertices can be reshapped to address each instance individually.\n\n        ``` python\n        count = 16\n\n        cube = Mesh.Cube() * count\n\n        # Shape the points as 16 blocks of 8 vertices\n        points = np.reshape(cube.points.position, (16, 8, 3))\n\n        # Place the cubes in a circle\n        ags = np.linspace(0, 2*np.pi, count, endpoint=False)\n        points[..., 0] += 6 * np.cos(ags)[:, None]\n        points[..., 1] += 6 * np.sin(ags)[:, None]\n\n        cube.to_object(\"Cubes\")\n        ```\n\n        Arguments\n        ---------\n            - count (int=10) : number of instances\n            - attributes (name=value) : value for named attributes\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n\n        # ----------------------------------------------------------------------------------------------------\n        # Checks and simple cases\n\n        if not isinstance(count, (int, np.int32, np.int64)):\n            raise Exception(f\"A Mesh can be multiplied only by an int, not '{count}'\")\n\n        if count == 0:\n            return None\n\n        if count == 1:\n            if in_place:\n                return self\n            else:\n                return type(self).from_mesh(self)\n\n        if not in_place:\n            return type(self).from_mesh(self).multiply(count, in_place=True)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Vertices\n\n        nverts = len(self.points)\n        self.points.multiply(count)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Corners\n\n        ncorners = len(self.corners)\n        self.corners.multiply(count)\n        self.corners.vertex_index += np.repeat(np.arange(count)*nverts, ncorners)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Faces\n\n        self.faces.multiply(count)\n        self.faces.update_loop_start()\n\n        # ----------------------------------------------------------------------------------------------------\n        # Edges\n\n        nedges = len(self.edges)\n        self.edges.multiply(count)\n        ofs = np.repeat(np.arange(count)*nverts, nedges)\n        self.edges.vertex0 += ofs\n        self.edges.vertex1 += ofs\n\n        return self\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Operators\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def __mul__(self, count):\n        return self.multiply(count, in_place=False)\n\n    def __imul__(self, count):\n        return self.multiply(count, in_place=True)\n\n    # =============================================================================================================================\n    # Editing\n    # =============================================================================================================================\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Extract attributes per domain\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def _attributes_per_domain(self, **attrs):\n\n        dispatched = {\n            'points'  : {},\n            'corners' : {},\n            'faces'   : {},\n            'edges'   : {},\n            }\n\n        for k, v in attrs.items():\n            count = 0\n\n            if k in self.points.all_names:\n                dispatched['points'][k] = v\n                count += 1\n\n            if k in self.corners.all_names:\n                dispatched['corners'][k] = v\n                count += 1\n\n            if k in self.faces.all_names:\n                dispatched['faces'][k] = v\n                count += 1\n\n            if k in self.edges.all_names:\n                dispatched['edges'][k] = v\n                count += 1\n\n            if count == 0:\n                raise AttributeError(f\"Unknown mesh attribute '{k}'.\\n\"\n                                     f\"- points:  {self.points.all_names}\\n\"\n                                     f\"- corners: {self.corners.all_names}\\n\"\n                                     f\"- faces:   {self.faces.all_names}\\n\"\n                                     f\"- edges:   {self.edges.all_names}\\n\"\n                                     )\n\n            if count &gt; 1:\n                raise AttributeError(f\"Mesh add_geometry&gt; attribute '{k}' is ambigous, it belongs to more than one domain (count).\\n\"\n                                     f\"- points:  {self.points.all_names}\\n\"\n                                     f\"- corners: {self.corners.all_names}\\n\"\n                                     f\"- faces:   {self.faces.all_names}\\n\"\n                                     f\"- edges:   {self.edges.all_names}\\n\"\n                                     )\n        return dispatched\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Add geometry\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def add_geometry(self, points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs):\n        \"\"\" Add geometry\n\n        Note that the added geometry can refer to existing vertices. It is appended as is, whithout shifting\n        indices.\n\n        To add independant geometry, use join_geometry.\n\n        ``` python\n        cube = Mesh.cube()\n        # add a triangle on existing vertices\n        # corners argument refers to cube vertices\n        cube.add_geometry(corners=[0, 1, 2], faces=3)\n\n        # add a triangle with additional vertices\n        # corners argument refers to the new vertices\n        cube.join_geometry(points=[[0, 0, 0], [0, 1, 0], [1, 0, 0]], corners=[0, 1, 2], faces=3)\n        ```\n\n        Arguments\n        ---------\n            - points (array of vectors = None) : the vertices\n            - corners (array of ints = None) : corners, i.e. indices on the array of points\n            - sizes (array of ints = None) : size of the faces, the sum of this array must be equal to the length of the corners array\n            - materials (str or list of strs = None) : list of materials used in the geometry\n            - **attrs (dict) : other geometry attributes\n\n        Returns\n        -------\n            - dict : {'points', 'corners', 'faces', 'edges': added geometry indices}\n        \"\"\"\n\n        disp_attrs = self._attributes_per_domain(**attrs)\n        added = {'points': [], 'corners': [], 'faces': [], 'edges': []}\n\n        # ----------------------------------------------------------------------------------------------------\n        # Add vertices\n        # ----------------------------------------------------------------------------------------------------\n\n        if points is not None:\n            added['points'] = self.points.append(position=points, **disp_attrs['points'])\n\n        # ----------------------------------------------------------------------------------------------------\n        # Edges\n        # ----------------------------------------------------------------------------------------------------\n\n        if edges is not None:\n            if np.shape(edges) == (2,):\n                added['edges'] = self.edges.append(vertex0=edges[0], vertex1=edges[1], **disp_attrs['edges'])\n            else:\n                added['edges'] = self.edges.append(vertex0=edges[:, 0], vertex1=edges[:, 1], **disp_attrs['edges'])\n\n        # ----------------------------------------------------------------------------------------------------\n        # Corners and Faces\n        # ----------------------------------------------------------------------------------------------------\n\n        # If corners is provided, faces can be:\n        # - None -&gt; single face made of all corners\n        # - int -&gt; faces are all the same size (len(corners) must be a multiplief of faces)\n        # - array like -&gt; face sizes (len(corners) == np.sum(faces))\n        #\n        # If faces is provided, corners can be:\n        # - None -&gt; faces must be an array of arrays, each array being of list of corners\n        # - not None -&gt; see above\n\n        ok_faces = True\n        if corners is None:\n            if faces is None:\n                ok_faces = False\n            else:\n                corners = []\n                sizes = []\n                ok = hasattr(faces, '__len__')\n                if ok:\n                    for face in faces:\n                        ok = hasattr(faces, '__len__') and len(face) &gt; 2\n                        if not ok:\n                            break\n                        corners.extend(face)\n                        sizes.append(len(face))\n                if not ok:\n                    raise ValueError(f\"Mesh add_geometry&gt; when corners is None, faces must be None or an array of arrays, each array being of list of corners.\")\n                faces = sizes\n\n        else:\n            corners = np.asarray(corners)\n            ncorners = len(corners)\n            if faces is None:\n                faces = [ncorners]\n\n            else:\n                faces = np.asarray(faces)\n                if faces.shape == ():\n                    size = int(faces)\n                    if ncorners % size != 0:\n                        raise ValueError(f\"Mesh add_geometry&gt; when faces is a single number {size}, it must divide the number of corners ({ncorners}).\")\n                    faces = [size]*(ncorners // size)\n                else:\n                    if np.sum(faces) != ncorners:\n                        raise ValueError(f\"Mesh add_geometry&gt; the sum of faces ({np.sum(faces)}) must be equal to the number of corners ({ncorners}).\")\n\n        if ok_faces:\n            added['corners'] = self.corners.append(vertex_index=corners, **disp_attrs['corners'])\n            added['faces'] = self.faces.append_sizes(faces, **disp_attrs['faces'])\n\n        if False: # OLD\n            if np.shape(faces) == ():\n                nfaces = len(corners) // faces\n                if len(corners) % faces != 0:\n                    raise ValueError(f\"Mesh add_geometry&gt; when faces is a single number {faces}, it must divide the number of corners ({len(corners)}).\")\n                faces = np.ones(nfaces, dtype=bint)*faces\n\n            added['corners'] = self.corners.append(vertex_index=corners, **disp_attrs['corners'])\n            added['faces'] = self.faces.append_sizes(faces, **disp_attrs['faces'])\n\n        if safe_mode:\n            self.check()\n\n        return added\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Join geometry\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def join_geometry(self, points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs):\n        \"\"\" Join geometry defined by components.\n\n        The geometry passed in argument is consistent and doesn't refer to existing vertices. It is used\n        to build an independant mesh which is then joined.\n        See 'add_geometry' which, on the contrary, can refer to existing vertices.\n\n        Returns\n        -------\n            - self\n        \"\"\"\n        mesh = Mesh(attr_from=self)\n        mesh.add_geometry(\n            points=points, \n            corners=corners, \n            faces=faces, \n            edges=edges,\n            **attrs)\n        self.join(mesh)\n        return self\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Add Vertices\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    def add_points(self, points,  **attributes):\n        \"\"\" Add vertices.\n\n        Arguments\n        ---------\n            - points (array of vectors) : the vertices to add\n            - attributes (name=value) : value for named attributes\n\n        Returns\n        -------\n            - array of ints : indices of the added vertices\n        \"\"\"\n        npoints = len(self.points)\n        return self.points.append(position=points, **attributes)\n\n    # =============================================================================================================================\n    # Split edges\n    # =============================================================================================================================\n\n    def split_edges(self, loop0, loop1, cuts=1):\n\n        n0 = 1 if np.shape(loop0) == () else len(loop0)\n        n1 = 1 if np.shape(loop1) == () else len(loop1)\n        n = max(n0, n1)\n        if n0 == n:\n            loop0 = np.atleast_1d(loop0, dtype=bint)\n        else:\n            loop0 = np.ones(n, dtype=bint)*loop0\n\n        if n1 == n:\n            loop1 = np.atleast_1d(loop1, dtype=bint)\n        else:\n            loop1 = np.ones(n, dtype=bint)*loop1\n\n        to_select = np.stack([np.minimum(loop0, loop1), np.maximum(loop0, loop1)], axis=-1)  # shape (p, 2)\n        with self.bmesh() as bm:\n\n            edges, verts_indices = self._bm_edges(bm)\n\n            # select edges in to_select\n            dtype = np.dtype([('a', bint), ('b', bint)])\n            edges_view = verts_indices.view(dtype)\n            to_select_view = to_select.view(dtype)\n\n            # selection mask\n            mask = np.isin(edges_view.ravel(), to_select_view.ravel())\n\n            edges_to_cut = list(edges[mask])\n\n            if len(edges_to_cut) == 0:\n                return\n\n            # Edges subidivision\n            bmesh.ops.subdivide_edges(\n                bm,\n                edges=edges_to_cut,\n                cuts=cuts,\n                use_grid_fill=False\n            )\n\n    # =============================================================================================================================\n    # Bridge loops\n    # =============================================================================================================================\n\n    def bridge_loops(self, loop0, loop1, close=False, segments=1, **attributes):\n        \"\"\" Create a grid linking two loops of the same size.\n\n        Arguments\n        ---------\n        - loop0 (array of ints) : the first loop\n        - loop1 (array of ints) : the second loop\n        - segments (int = 1) : the number of segments to join the loops\n        - attributes (dict) : attributes to add to the mesh\n        \"\"\"\n        segments = max(1, segments)\n\n        if close:\n            loop0 = np.append(loop0, loop0[0]).astype(bint)\n            loop1 = np.append(loop1, loop1[0]).astype(bint)\n        else:\n            loop0 = np.asarray(loop0, dtype=bint)\n            loop1 = np.asarray(loop1, dtype=bint)\n\n        sel0 = np.stack((loop0[:-1], loop0[1:]), axis=-1)\n        sel1 = np.stack((loop1[:-1], loop1[1:]), axis=-1)\n\n        sel0 = np.sort(sel0, axis=-1)\n        sel1 = np.sort(sel1, axis=-1)\n\n        with self.bmesh() as bm:\n\n            edges, verts_indices = self._bm_edges(bm)\n\n            # Prepare edges view\n            dtype = np.dtype([('a', bint), ('b', bint)])\n            edges_view = verts_indices.view(dtype)\n\n            # First loop\n            sel0_view = sel0.view(dtype)\n            mask = np.isin(edges_view.ravel(), sel0_view.ravel())\n\n            edges_to_bridge = list(edges[mask])\n\n            # Second loop\n            sel1_view = sel1.view(dtype)\n            mask = np.isin(edges_view.ravel(), sel1_view.ravel())\n\n            edges_to_bridge.extend(list(edges[mask]))\n\n            if len(edges_to_bridge) == 0:\n                return\n\n            # Bridge\n            res = bmesh.ops.bridge_loops(\n                bm, \n                edges=edges_to_bridge,\n                #use_cyclic = close,\n                #segments=segments,\n                )\n\n            # Grid\n            if segments &gt; 1:\n                bmesh.ops.subdivide_edges(\n                    bm,\n                    edges=res['edges'],\n                    cuts=segments - 1,\n                    use_grid_fill=False\n                )\n\n    # =============================================================================================================================\n    # Fill cap\n    # =============================================================================================================================\n\n    def fill_cap(self, loop, mode='NGON', center=None, segments=1, clockwise=False, **attributes):\n        \"\"\" Fill a cap between an existing loop\n\n        For NGON mode, center is not required.\n        For FANS mode, a center point is required:\n        - if center is None, it is computed as the center of the loop\n        - if center is an int, it is the index of the point to use\n        - otherwise, the center is considered as the point to use\n\n        Arguments\n        ---------\n        - loop (array of ints) : the circle loop\n        - mode (FillCap = 'NGON') : NGON or FANS\n        - center (point index or point or None) : center of the cap\n        - clockwise (bool = False) : order of the corners in the loop\n        - indexing (str = 'ij') : indexing of the points\n        - attributes (dict) : attributes to add to the mesh (see Geometry.add_geometry(\n        \"\"\"\n        if mode == 'NONE':\n            # To have en empty dict\n            return self.add_geometry()\n\n        elif mode == 'NGON':\n            return self.add_geometry(corners=loop, faces=len(loop), UVMap=self.disk_uv_map(len(loop), mode='NGON', clockwise=clockwise), **attributes)\n\n        elif mode == 'FANS':\n\n            if center is None:\n                verts = self.points.position[loop]\n                center = np.average(verts, axis=0)\n                center_index = len(self.points)\n                cind = self.add_points(center)\n\n            elif isinstance(center, (int, np.int32, np.int64)):\n                center_index = center\n                cind = [center_index]\n\n            else:\n                center_index = len(self.points)\n                cind = self.add_points(center)\n\n            indices = np.append(loop, center_index)\n\n            topo = fans_corners(len(loop), close=True, clockwise=clockwise).ravel()\n\n            corners = indices[topo]\n            uv_map = disk_uv_map(len(loop), mode='FANS', clockwise=clockwise).reshape(-1, 2)\n\n            added = self.add_geometry(corners=corners, faces=3, UVMap=uv_map, **attributes)\n            added['points'] = np.asarray(cind)\n\n            # More than one segments\n\n            if segments &gt; 1:\n                self.split_edges(loop, center_index, cuts=segments - 1)\n\n            return added\n\n        assert(False)\n\n    # ====================================================================================================\n    # Deletion\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Delete faces\n    # ----------------------------------------------------------------------------------------------------\n\n    def delete_faces(self, selection):\n        \"\"\" Delete only faces.\n        \"\"\"\n        self.faces.delete_loops(selection, self.corners)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Delete vertices\n    # ----------------------------------------------------------------------------------------------------\n\n    def delete_vertices(self, points=None, faces=None, edges=None):\n        \"\"\"Delete vertices.\n\n        Arguments\n        ---------\n            points : array selection, optional\n                Vertex indices to delete directly.\n            faces : array selection, optional\n                Faces owning vertices to delete.\n            edges : array selection, optional\n                Edges owning vertices to delete.\n        \"\"\"\n        go = False\n        if points is not None:\n            p_sel = set(np.arange(len(self.points))[points])\n            go = True\n        if faces is not None:\n            f_sel = set(np.arange(len(self.faces))[faces])\n            go = True\n        if edges is not None:\n            e_sel = set(np.arange(len(self.edges))[edges])\n            go = True\n\n        if not go:\n            return \n\n        with self.bmesh() as bm:\n            verts_to_delete = set()\n\n            for vert in bm.verts:\n                if points is not None and vert.index in p_sel:\n                    verts_to_delete.add(vert)\n                    continue\n\n                if faces is not None:\n                    if any(f.index in f_sel for f in vert.link_faces):\n                        verts_to_delete.add(vert)\n                        continue\n\n                if edges is not None:\n                    if any(e.index in e_sel for e in vert.link_edges):\n                        verts_to_delete.add(vert)\n                        continue\n\n            bmesh.ops.delete(bm, geom=list(verts_to_delete), context='VERTS')\n\n    # ====================================================================================================    \n    # Blender primitives\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Grid\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def bl_grid(cls, x_segments=1, y_segments=1, size=2, materials=None):\n        \"\"\" Create a Grid.\n\n        Blender constructor for a Grid.\n\n        Arguments\n        ---------\n            - x_segments (int=1) : number of segments along x axis\n            - y_segments (int=1) : number of segments along y axis\n            - size (float or tuple of floats = 1. : size of the grid\n            - materials (list of strs = None) : materials list\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n\n        mesh = cls(materials=materials)\n        with mesh.bmesh() as bm:\n            bmesh.ops.create_grid(bm, x_segments=x_segments, y_segments=y_segments, size=size, calc_uvs=True)\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Circle\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def bl_circle(cls, radius=1, segments=16, fill_tris=False, materials=None):\n        \"\"\" Create a Circle.\n\n        Blender constructor for a Circle.\n\n        Arguments\n        ---------\n            - radius (float=1.) : circle radius\n            - segments (int=16) : number of segments\n            - fill_tris (bool = False) : fill with triangle fans\n            - materials (list of strs = None) : materials list\n            - transformation (Transformations = None) : the transformation to apply\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n\n        mesh = cls(materials=materials)\n        with mesh.bmesh() as bm:\n            bmesh.ops.create_circle(bm, cap_ends=True, cap_tris=fill_tris, segments=segments, radius=radius, calc_uvs=True)\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Cone\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def bl_cone(cls, radius1=1, radius2=0, depth=2, segments=16, side_segments=1, cap_ends=True, cap_tris=False, materials=None):\n        \"\"\" Create a Cone.\n\n        Blender constructor for a Cone.\n\n        Arguments\n        ---------\n            - radius1 (float=1.) : base radius\n            - radius2 (float=0.) : top radius\n            - depth (float=2.) : cone height\n            - segments (int=16) : number of segments\n            - cap_ends (bool=True) : fill cap faces\n            - cap_tris (bool = False) : fill with triangle fans\n            - materials (list of strs = None) : materials list\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n\n        mesh = cls(materials=materials)\n        with mesh.bmesh() as bm:\n            res = bmesh.ops.create_cone(bm, cap_ends=cap_ends, cap_tris=cap_tris, segments=segments, radius1=radius1, radius2=radius2, depth=depth, calc_uvs=True)\n            if side_segments &gt; 1:\n\n                edges_to_cut = [\n                    e for e in bm.edges\n                    if (e.verts[0].co.z &gt; 0 and e.verts[1].co.z &lt; 0)\n                    or (e.verts[0].co.z &lt; 0 and e.verts[1].co.z &gt; 0)\n                ]\n\n                # Edges subidivision\n                bmesh.ops.subdivide_edges(\n                    bm,\n                    edges         = edges_to_cut,\n                    cuts          = side_segments - 1,\n                    use_grid_fill = False\n                )\n\n        return mesh\n\n    # ====================================================================================================    \n    # Primitives\n    # ====================================================================================================    \n\n\n    # ----------------------------------------------------------------------------------------------------\n    # Points\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def points_cloud(cls, points=None, materials=None):\n        \"\"\" Create a mesh with points at the given positions.\n\n        Arguments\n        ---------\n            - position (shaped array (?, 3)=(0, 0, 0) : position of the points\n\n        Returns\n        -------\n            - mesh (Mesh) : the mesh\n        \"\"\"\n        return cls(points=points, materials=materials)\n\n    # -----------------------------------------------------------------------------------------------------------------------------\n    # Line\n    # -----------------------------------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def line(cls, start=(0, 0, 0), end=(0, 0, 1), segments=1, materials=None):\n        \"\"\" Create a mesh with lines between the given positions.\n\n        Arguments\n        ---------\n            - start (vertex =(0, 0, 0) : position of the start of the lines\n            - end (vertex=(0, 0, 1) : position of the end of the lines\n            - count (int=2) : number of points in the line\n\n        Returns\n        -------\n            - mesh (Mesh) : the mesh\n        \"\"\"\n        segments = max(1, segments)\n\n        start = np.asarray(start, dtype=bfloat)\n        end   = np.asarray(end, dtype=bfloat)\n\n        pos = np.linspace(start, end, segments + 1) # shape (segments, n points, 3)\n\n        if len(pos.shape) == 2:\n            edges = border_edges(np.arange(segments))\n        else:\n            shape = pos.shape[:-1]\n            n = int(np.prod(shape))\n            edges = col_edges(np.arange(n).reshape(shape))\n\n        return cls(points=pos.reshape(-1, 3), edges=edges.reshape(-1, 2), materials=materials)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Grid\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def grid(cls, size_x=1, size_y=1, vertices_x=3, vertices_y=3, materials=None):\n        \"\"\" Create a Grid.\n\n        &gt; [!IMPORTANT]\n        &gt; Grid is created with indexing = 'ij': shape = (resolution x, resolution y)\n\n        Arguments\n        ---------\n            - size_x (float=1) : size along x\n            _ size_y (float=1) : size along y\n            - vertices_x (int=3) : number of vertices along x\n            - vertices_y (int=3) : number of vertices along y\n            - materials (list of strs = None) : materials list\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n\n        nx = max(2, vertices_x)\n        ny = max(2, vertices_y)\n\n        topo = grid_corners(nx, ny).ravel()\n\n        # ----------------------------------------------------------------------------------------------------\n        # Base grid for points and uvs\n\n        x, y = np.meshgrid(\n            np.linspace(-size_x/2, size_x/2, nx, dtype=bfloat), \n            np.linspace(-size_y/2, size_y/2, ny, dtype=bfloat), \n            indexing='ij')\n        x, y = x.ravel(), y.ravel()\n\n        # ----------------------------------------------------------------------------------------------------\n        # Let 's build the grid\n\n        points = np.stack((x, y, np.zeros_like(x)), axis=-1)\n        corners = np.arange(len(points))[topo]\n        faces = 4\n        uvmap = grid_uv_map(nx, ny).reshape(-1, 2)\n\n        return cls(points, corners, faces, materials=materials, UVMap=uvmap)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Cube\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def cube(cls, size=2, materials=None):\n        \"\"\" Create a Cube.\n\n        Arguments\n        ---------\n            - size (float=1.) : size of the cube\n            - materials (list of strs = None) : materials list\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n\n        verts = [[-1., -1., -1.], [-1., -1.,  1.], [-1.,  1., -1.], [-1.,  1.,  1.], [ 1., -1., -1.], [ 1., -1.,  1.], [ 1.,  1., -1.], [ 1.,  1.,  1.],]\n        corners = [0, 1, 3, 2,  2, 3, 7, 6,  6, 7, 5, 4,  4, 5, 1, 0,  2, 6, 4, 0,  7, 3, 1, 5]\n        faces = [4]*6\n        uvs   = [[0.375, 0.000], [0.625, 0.000], [0.625, 0.250], [0.375, 0.250], [0.375, 0.250], [0.625, 0.250], [0.625, 0.500], [0.375, 0.500],\n                 [0.375, 0.500], [0.625, 0.500], [0.625, 0.750], [0.375, 0.750], [0.375, 0.750], [0.625, 0.750], [0.625, 1.000], [0.375, 1.000],\n                 [0.125, 0.500], [0.375, 0.500], [0.375, 0.750], [0.125, 0.750], [0.625, 0.500], [0.875, 0.500], [0.875, 0.750], [0.625, 0.750], ]\n\n\n        mesh = cls(points=verts, corners=corners, faces=faces, materials=materials, UVMap=uvs)\n\n        size = np.asarray(size)\n        mesh.points.position *= size/2\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Circle\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def circle(cls, radius=1, segments=16, fill_segments=0, cap='NONE', materials=None):\n        \"\"\" Create a Circle.\n\n        'fill_segments' argument gives the number of internal circles to create.\n        If zero, the circle if filled with a polygon.\n        If positive, the circle is filled with triangle fans.\n\n        Arguments\n        ---------\n            - radius (float=1.) : circle radius\n            - segments (int=16) : number of segments\n            - fill_segments (int = 0) : number of internal segments, polygon is None\n            - materials (list of strs = None) : materials list\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n        ag = np.linspace(0, 2*np.pi, segments, endpoint=False)\n        x = radius*np.cos(ag)\n        y = radius*np.sin(ag)\n        points = np.stack((x, y, np.zeros_like(x)), axis=-1)\n\n        if cap == 'NONE':\n            i = np.arange(segments)\n            edges = np.stack((i, np.roll(i, shift=-1)), axis=-1)\n            return cls(points=points, edges=edges)\n\n        elif cap == 'NGON':\n            return cls(\n                points      = points, \n                corners     = np.arange(segments), \n                faces       = segments,\n                UVMap       = disk_uv_map(segments, mode='NGON').reshape(-1, 2),\n                materials   = materials,\n            )\n\n        elif cap == 'FANS':\n            points = np.append(points, [[0, 0, 0]], axis=0)\n            topo = fans_corners(segments)\n\n            return cls(\n                points      = points, \n                corners     = topo.ravel(), \n                faces       = 3,\n                UVMap       = disk_uv_map(segments, mode='FANS').reshape(-1, 2),\n                materials   = materials,\n            )\n\n        #mesh = cls(points=points)\n        #mesh.fill_cap(np.arange(segments), mode=cap, center=segments, clockwise=True)\n\n        assert(False)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Disk\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def disk(cls, radius=1, segments=16, fill_segments=0, cap='NGON', materials=None):\n        \"\"\" Create a disk.\n\n        Same as circle but default cap is NGON\n        \"\"\"    \n        return cls.circle(radius=radius, segments=segments, fill_segments=fill_segments, cap=cap, materials=materials)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Cone\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def cone(cls, vertices=32, side_segments=1, fill_segments=1, radius_top=0, radius_bottom=1, depth=2, fill_type='NGON', materials=None):\n        \"\"\" Create a Cone.\n\n        Arguments\n        ---------\n            - vertices (int=16) : number of segments\n            - side_segments (int = 1) : number of vertical segments\n            - fill_segments (int = 1) : number of internal circles on the caps\n            - radius_top (float=0) : top radius\n            - radius_bottom (float=1) : bottom radius\n            - depth (float=2.) : cylinder height\n            - fill_type (str or couple of strs ='NGON' in 'NGON', 'FANS', 'NONE') : cap filling\n            - materials (list of strs = None) : materials list\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n        # Empty geometry if fhe two radius are null\n        if radius_top == 0 and radius_bottom == 0:\n            return cls()\n\n        mesh = cls.bl_cone(\n            radius1       = radius_bottom,\n            radius2       = radius_top,\n            segments      = vertices,\n            side_segments = side_segments,\n            depth         = depth,\n            cap_ends      = fill_type in ['NGON', 'FANS'],\n            cap_tris      = fill_type == 'FANS',\n            materials     = materials,\n        )\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Cylinder\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def cylinder(cls, vertices=32, side_segments=1, radius=1, depth=2, fill_type='NGON', materials=None):\n        \"\"\" Create a Cylinder.\n\n        Arguments\n        ---------\n            - vertices (int=16) : number of segments\n            - side_segments (int = 1) : number of vertical segments\n            - radius (float=1.) : radius\n            - depth (float=2.) : cylinder height\n            - fill_type (str or couple of strs ='NGON' in 'NGON', 'TRIANGLE_FAN', 'NONE') : cap filling\n            - materials (list of strs = None) : materials list\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n        mesh = cls.bl_cone(\n            radius1       = radius,\n            radius2       = radius,\n            segments      = vertices,\n            side_segments = side_segments,\n            depth         = depth,\n            cap_ends      = fill_type in ['NGON', 'FANS'],\n            cap_tris      = fill_type == 'FANS',\n            materials     = materials,\n        )\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Pyramid\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def pyramid(cls, size=1, materials=None):\n        \"\"\" Create a Pyramid.\n\n        Arguments\n        ---------\n            - size (float=1.) : size\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n        return cls.cone(vertices=3, radius_bottom=size*0.8660254037844386, depth=size, materials=materials)\n\n    # ----------------------------------------------------------------------------------------------------\n    # UV Sphere\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def uvsphere(cls, segments=32, rings=16, radius=1, materials=None):\n        \"\"\" Create a uv sphere.\n\n        Arguments\n        ---------\n            - segments (int=32) : number of segments\n            - rings (int=16) : number of rings\n            - radius (float=1.) : radius\n            - materials (list of strs = None) : materials list\n            - transformation (Transformations = None) : the transformation to apply\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n        mesh = cls(materials=materials)\n        with mesh.bmesh() as bm:\n            bmesh.ops.create_uvsphere(bm, u_segments=segments, v_segments=rings, radius=radius, calc_uvs=True)\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # IcoSphere\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def icosphere(cls, radius=1, subdivisions=2, materials=None):\n        \"\"\" Create a IcoSphere.\n\n        Blender constructor for a IcoSphere.\n\n        Arguments\n        ---------\n            - radius (float=1.) : radius\n            - subdivisions (int=2) : number subdivisions\n            - materials (list of strs = None) : materials list\n            - transformation (Transformations = None) : the transformation to apply\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n        subdivisions = min(10, subdivisions)\n\n        mesh = cls(materials=materials)\n        with mesh.bmesh() as bm:\n            bmesh.ops.create_icosphere(bm, subdivisions=subdivisions, radius=radius, calc_uvs=True)\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Torus\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def torus(cls, major_segments=48, minor_segments=12, major_radius=1., minor_radius=0.25, materials=None):\n        \"\"\" Create a Torus.\n\n        Arguments\n        ---------\n            - major_segments (int=48) : number of segments for the major radius\n            - minor_segments (int=12) : number of segments for the minor radius\n            - major_radius (float=1.) : major radius\n            - minor_radius (float=.25) : minor radius\n            - materials (list of strs = None) : materials list\n            - transformation (Transformations = None) : the transformation to apply\n\n        Returns\n        -------\n            - Mesh\n        \"\"\"\n        # Major backbone\n        maj_ag = np.linspace(0, 2*np.pi, major_segments, endpoint=False, dtype=bfloat) + np.pi # + pi to match blender uv\n\n        x = major_radius*np.cos(maj_ag)\n        y = major_radius*np.sin(maj_ag)\n        zeros = np.zeros_like(x)\n\n        transfos = Transformation.from_components(\n            translation=np.stack((x, y, zeros), axis=-1), \n            rotation=Rotation.from_euler(np.stack((zeros, zeros, maj_ag), axis=-1)),\n        )\n\n        # Minor section\n        min_ag = np.linspace(0, 2*np.pi, minor_segments, endpoint=False, dtype=bfloat) + np.pi # + pi to match blender uv\n        x = minor_radius*np.cos(min_ag)\n        z = minor_radius*np.sin(min_ag)\n        y = np.zeros_like(x)\n\n        circle = np.stack((x, y, z), axis=-1)\n\n        # Transform the circle\n        points = transfos[:, None] @ circle\n\n        # Generate the faces\n        corners = grid_corners(major_segments, minor_segments, close_x=True, close_y=True)\n\n        # Get the uv map\n        uvmap = grid_uv_map(major_segments + 1, minor_segments + 1)\n\n        return cls(points=points.reshape(-1, 3), corners=corners.ravel(), faces=4, UVMap=uvmap.reshape(-1, 2), materials=materials)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Monkey\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def monkey(cls, materials=None):\n        \"\"\" Create a Monkey.\n\n        Arguments\n        ---------\n            - materials (list of strs = None) : materials list\n\n        Returns\n        -------\n            - MeshBuilder\n        \"\"\"\n        mesh = cls(materials=materials)\n        with mesh.bmesh() as bm:\n            bmesh.ops.create_monkey(bm)\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Arrow\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def arrow(cls, vector=(0, 0, 1), radius=.05, angle=24., segments=8, adjust_norm=None, materials=None):\n\n        height = np.linalg.norm(vector)\n        if type(adjust_norm).__name__ == 'function':\n            height = adjust_norm(height)\n        elif adjust_norm is not None:\n            height = min(adjust_norm, height)\n\n        head_radius = 3*radius\n        head_height = head_radius/np.tan(np.radians(angle))\n\n        cyl_height = height - head_height*.8\n\n        #cyl  = cls.cylinder(vertices=segments, side_segments=2, radius=radius, depth=cyl_height, transformation=Transformations(position=(0, 0, cyl_height/2)), materials=materials)\n        cyl = cls.cylinder(vertices=segments, side_segments=2, radius=radius, depth=cyl_height, materials=materials)\n        cyl.points.z += cyl_height/2\n        cyl.points[[segments + i for i in range(segments)]].position -= (0, 0, cyl_height/2 - .01)\n\n        cone = cls.cone(vertices=segments, side_segments=2, fill_segments=1, radius_top=0, radius_bottom=head_radius, depth=head_height, fill_type='FANS', materials=materials)\n        cone.points[-1].position += (0, 0, head_height/10)\n        cone.points.position += (0, 0, height - head_height/2)\n\n        arrow = cyl.join(cone)\n        #arrow.points.position = tracker(vector, track_axis='Z') @ arrow.points.position\n        arrow.points.position = Rotation.look_at((0, 0, 1), vector) @ arrow.points.position\n\n        return arrow\n\n    # ----------------------------------------------------------------------------------------------------\n    # Field of vectors\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def vectors_field(cls, locations, vectors, radius=.05, scale_length=1., angle=24., segments=8, head=None, adjust_norm=None, materials=None):\n        \"\"\" Create an arrow at each location corresponding to the vectors.\n\n        The arrow length is equal to the corresponding vector lengths.\n        The arrow radius is constant and equal to the value passe in argument for lengths greater that\n        the argument scale_length. When the length is less than this value, the arrow is scaled down.\n\n        Use the adjust_norm argument to transform the vector lengths to arrows lengths.\n\n        Arguments\n        ---------\n            - locations (array of 3-vectors) : vectors locations\n            - vectors (array of 3 vectors) : vectors to visualize\n            - radius (float = .05) : arrow radius\n            - angle (float = 24) : head radius in degrees\n            - segments (int = 8) : number of segments for the section\n            - head (mesh = None) : mesh model for the head. Create a cone if None\n            - adjust_norm (max length or function = None) : max arrow length or function transforming\n                the vector length into arrow length\n            - scale_length (float = 1.) : arrow length below which the arrow radius is scaled\n\n        Returns\n        -------\n            - Mesh Object\n        \"\"\"\n        locations = np.atleast_2d(locations)\n        vectors = np.atleast_2d(vectors)\n\n        # ---------------------------------------------------------------------------\n        # Vector lengths\n        # ---------------------------------------------------------------------------\n\n        n = len(locations)\n\n        lengths = np.linalg.norm(vectors, axis=-1)\n        is_null = lengths &lt; .00001\n        lengths[is_null] = 1\n        v_dir = vectors / lengths[:, None]\n        if type(adjust_norm).__name__ == 'function':\n            lengths = adjust_norm(lengths)\n        elif adjust_norm is not None:\n            lengths = np.minimum(adjust_norm, lengths)\n        lengths[is_null] = 0\n        vectors = v_dir*lengths[:, None]\n\n        # ---------------------------------------------------------------------------\n        # Arrow head\n        # ---------------------------------------------------------------------------\n\n        head_radius = 3*radius\n        head_height = head_radius/np.tan(np.radians(angle))\n\n        if head is None:\n            cone = cls.cone(\n                vertices = segments, \n                side_segments = 1, \n                fill_segments = 1, \n                radius_top = 0, \n                radius_bottom = head_radius, \n                depth = head_height, \n                fill_type = 'FANS', \n                materials = materials)\n            cone.points[-1].z += head_height/10\n        else:\n            cone = head\n            head_height = cone.bounding_box_dims[2]\n\n        # Head top point is z=0\n        v0, v1 = cone.bounding_box\n        cone.points.z -= v1[2]\n\n        # ---------------------------------------------------------------------------\n        # Small arrows: Vectors whose length &lt; min_length\n        # ---------------------------------------------------------------------------\n\n        # Minimum length\n        # Below this length, the arrow is scaled\n\n        min_length = 2*head_height\n\n        # Small and long arrows if any\n        small_arrows = cls()\n        long_arrows = cls()\n\n        small = lengths &lt; min_length\n        nsmalls = np.sum(small)\n\n        if nsmalls:\n            # shaft height = head height\n            cyl_height = min_length/2 + .01\n            arrow = cls.cylinder(vertices=segments, side_segments=1, radius=radius, depth=cyl_height, materials=materials)\n            arrow.points.z += cyl_height/2\n\n            # Join the head\n            c = cls.from_mesh(cone)\n            c.points.z += min_length\n\n            arrow.join(c)\n\n            # Duplicate the geometry            \n            small_arrows = arrow*nsmalls\n            small_arrows.points.reshape(nsmalls, len(arrow.points))\n\n            # Rotate, scale and translate\n            lg = lengths[small]\n            scale = np.stack((np.ones_like(lg), np.ones_like(lg), lg), axis=-1)\n            small_arrows.transformation(\n                rotation = Rotation.look_at((0, 0, 1), vectors[small])[:, None], \n                scale = scale[:, None], \n                translation = locations[small, None],\n                )\n            small_arrows.points.reshape(-1)\n\n\n        # ---------------------------------------------------------------------------\n        # Long arrows\n        # ---------------------------------------------------------------------------\n\n        long = np.logical_not(small)\n        nlongs = len(locations) - nsmalls\n        if nlongs:\n\n            # Shaft model with a normalized height = 1\n            shaft = cls.cylinder(vertices=segments, side_segments=1, radius=radius, depth=1, materials=materials)\n            shaft.points.z += .5\n\n            # We duplicate and transform the shafts with a scale long z\n            long_arrows = shaft*nlongs\n            long_arrows.points.reshape(nlongs, len(shaft.points))\n\n            lg = lengths[long] - head_height + .01\n            scale = np.stack((np.ones_like(lg), np.ones_like(lg), lg), axis=-1)\n            long_arrows.transformation(\n                rotation = Rotation.look_at((0, 0, 1), vectors[long])[:, None], \n                scale = scale[:, None], \n                translation = locations[long, None],\n                )\n            long_arrows.points.reshape(-1)\n\n            # We duplicate and tranform the heads with no scale\n            heads = cone*nlongs\n            heads.points.reshape(nlongs, len(cone.points))\n            heads.transformation(\n                rotation = Rotation.look_at((0, 0, 1), vectors[long])[:, None], \n                translation = locations[long, None] + vectors[long, None],\n                )\n            heads.points.reshape(-1)\n\n            long_arrows.join(heads)\n\n        # Let's join the result\n        arrows = cls()\n        arrows.join(small_arrows, long_arrows)\n\n        return arrows\n\n    # ----------------------------------------------------------------------------------------------------\n    # Chain Link\n    # ----------------------------------------------------------------------------------------------------\n\n    @classmethod\n    def chain_link(cls, major_segments=48, minor_segments=12, radius=1., section=0.5, length=4., materials=None):\n        \"\"\" Create a chain link.\n\n        ``` python\n        # ----- Some maths\n\n        # Chain follows a catenary curve\n        def catenary(t):\n            return np.stack((t, np.zeros_like(t), np.cosh(t)), axis=-1)\n\n        # Orientation is given by the derivative\n        def derivative(t):\n            dt = 1/10000\n            return (catenary(t + dt) - catenary(t - dt))/(2*dt)\n\n        # Catenary length\n        pts = catenary(np.linspace(-1, 1, 1000))\n        cat_s = np.cumsum(np.linalg.norm(pts[1:] - pts[:-1], axis=-1))\n        cat_len = cat_s[-1]\n\n        # Catenary inverse : t from length\n        def cat_inverse(l):\n            return 2*np.argmin(np.abs(cat_s - l))/1000 - 1\n\n        # ----- Let's build the geometry\n\n        # One chain link\n        section = .02\n        length  = .15\n        link = MeshBuilder.ChainLink(radius=.04, section=section, length=length)\n\n        # Link length taking into account the section\n        l = length - 2*section\n\n        # Number of links\n        count = round(cat_len / l)\n\n        # The chain\n        chain = link*count\n\n        # Rotate pi/2 one on two\n        eulers = Eulers(shape=count)\n        eulers[[i % 2 == 1 for i in range(count)]] = (0, np.pi/2, 0)\n\n        chain.rotate(eulers)\n        chain.rotate_z(np.pi/2)\n\n        # Location of each link\n        t = np.array([cat_inverse(l*i) for i in range(count)])\n\n        chain.toward(derivative(t), track_axis='X', up_axis='Z')\n        chain.translate(catenary(t))\n\n        # To object\n        chain.to_object(\"Catenary\")\n        ```\n\n        Arguments\n        ---------\n            - major_segments (int=48) : number of segments for the link\n            - minor_segments (int=12) : number of segments for the section\n            - radius (float=1.) : radius of the link\n            - section (float=.5) : section (diameter)\n            - length (float=4.) : total length of the link\n            - materials (list of strs = None) : materials list\n\n        Returns\n        -------\n            - MeshBuilder\n        \"\"\"\n\n        delta = length - 2*radius\n\n        # Starting from a torus\n        clink = cls.torus(\n            major_radius    = radius, \n            minor_radius    = section/2, \n            major_segments  = major_segments, \n            minor_segments  = minor_segments, \n            materials       = materials\n        )\n        # Nothing else\n        if delta &lt; radius/10:\n            return clink\n\n        epsilon = radius/major_segments\n\n        # Delete half of the points\n        clink.delete_vertices(points=clink.points.y &lt; -epsilon)\n        npoints = len(clink.points)\n        borders = clink.points.y &lt; epsilon\n        loop0 = np.arange(npoints)[np.logical_and(borders, clink.points.x &lt; 0)]\n        loop1 = np.arange(npoints)[np.logical_and(borders, clink.points.x &gt; 0)]\n        clink.points.y += delta/2\n\n        # Duplicate and inverse\n        half = Mesh.from_mesh(clink)\n        half.points.position[:, :2] *= -1\n\n        # Join\n        clink.join(half)\n\n        # Bridge\n        clink.bridge_loops(loop0, loop1 + npoints, close=True)\n        clink.bridge_loops(loop1, loop0 + npoints, close=True)\n\n        # UVMap\n        nu, nv = major_segments + 3, minor_segments + 1\n        uvmap = grid_uv_map(nu, nv).reshape(nu - 1, nv - 1, 4, 2)\n\n        ratio = (length - radius)/(length - radius + np.pi*radius)\n        dx_side = ratio/2\n\n        uvmap[:-2,..., 0] *= (1 - ratio)/(1 - 2/nu)\n        uvmap[-2,:, [0, 3], 0] = 1 - ratio\n        uvmap[-2,:, [1, 2], 0] = 1 - ratio/2\n        uvmap[-1,:, [0, 3], 0] = 1 - ratio/2\n\n        clink.corners.UVMap = uvmap.reshape(-1, 2)\n\n        return clink\n\n    # ====================================================================================================\n    # Extrusion\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Extrude vertices\n    # ----------------------------------------------------------------------------------------------------\n\n    def extrude_vertices(self, selection, offset, **attributes):\n        \"\"\" Extrude individual vertices\n\n        Arguments\n        ---------\n            - selection (selector) : points selection, all if None\n            - offset (vector or array of vectors) : extrusion vector\n            - attributes (dict) : points attributes\n\n        Returns\n        -------\n            - dictionnary of the created geometry : vertex indices, face indices\n        \"\"\"\n        inds = np.arange(len(self.points))\n        if selection is not None:\n            inds = inds[selection]\n\n        pos = self.points.position[inds] + offset\n        new_inds = np.arange(len(pos)) + len(self.points)\n        edges = edges_between(inds, new_inds)\n\n        return self.add_geometry(points=pos, edges=edges.reshape(-1, 2), **attributes)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Extrude a loop of points\n    # ----------------------------------------------------------------------------------------------------\n\n    def extrude_loop(self, loop, offset, close=False, clockwise=False, **attributes):\n        \"\"\" Extrude a loop of vertices.\n\n        Arguments\n        ---------\n            - loop (array of ints) : vertex indices\n            - offset (float = 1) : multiplicator of the direction vector\n            - direction (vector = None) : extrusion direction, normal if None\n            - clockwise (bool=False) : faces orientation\n            - attributes : attribute for the new geometry\n\n        Returns\n        -------\n            - dictionnary of the created geometry : vertex indices, face indices\n        \"\"\"\n        loop = np.atleast_1d(loop)\n        if len(loop) &lt; 2:\n            return None\n\n        verts = self.points.position[loop]\n        try:\n            new_verts = verts + offset\n        except Exception as e:\n            raise AttributeError(\n                f\"Extrude&gt; Offset argument must be a single vector or an array of {len(verts)} vectors, not {np.shape(offset)}.\"\n                )\n\n        indices = np.append(loop, len(self.points) + np.arange(len(new_verts)))\n        gc = grid_corners(len(verts), 2, row_first=True, close_x=close, clockwise=clockwise)\n        corners = indices[gc.ravel()]\n        uvmap = grid_uv_map(len(verts), 2, close_x=close, clockwise=clockwise).reshape(-1, 2)\n\n        return self.add_geometry(points=new_verts, corners=corners, faces=4, UVMap=uvmap)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Extrude individual faces\n    # ----------------------------------------------------------------------------------------------------\n\n    def extrude_faces(self, selection, offset=None, scale=1.):\n        \"\"\" Extrude individual faces.\n\n        If offset is None, faces are extruder along their normal\n\n        Arguments\n        ---------\n            - selection : indices of the faces to extrude\n            - offset (vector or array of vectors) : the extrusion vector\n            - scale (float = 1) : scale factor for offsets\n            - dissolve (bool = True) : remove starting faces\n\n        Returns\n        -------\n            - dictionnary : 'top' : extruded faces, 'side' : extruded side faces\n        \"\"\"\n\n        # Selected faces indices\n        faces_sel = np.arange(len(self.faces))\n        if selection is not None:\n            faces_sel = faces_sel[selection]\n\n        # bmesh edition\n        with self.bmesh() as bm:\n            #bm.verts.ensure_lookup_table()\n            bm.faces.ensure_lookup_table()\n\n            # select faces\n            start_faces = [bm.faces[i] for i in faces_sel]\n\n            res = {'top': [], 'side': []}\n\n            # bmesh.ops\n            d = bmesh.ops.extrude_discrete_faces(bm, faces=start_faces)\n            new_faces = d[\"faces\"]\n\n\n\n            # One direction per face\n            if offset is not None:\n                shape = np.broadcast_shapes(np.shape(offset), (len(new_faces), 3))\n                offsets = np.broadcast_to(offset, shape)*scale\n\n            # Loop on created faces\n            for i_face, face in enumerate(new_faces):\n                verts = face.verts\n                if offset is None:\n                    ofs = face.normal*scale\n                else:\n                    ofs = offsets[i_face]\n\n                bmesh.ops.translate(bm, verts=list(verts), vec=ofs)\n\n                res['top'].append(face.index)\n                for e in face.edges:\n                    assert(len(e.link_faces) == 2)\n                    if e.link_faces[0].index == face.index:\n                        res['side'].append(e.link_faces[1].index)\n                    else:\n                        res['side'].append(e.link_faces[0].index)\n\n        return res\n\n    # ----------------------------------------------------------------------------------------------------\n    # Extrude region\n    # ----------------------------------------------------------------------------------------------------\n\n    def extrude_region(self, selection, offset=(0, 0, 1), dissolve=False):\n        \"\"\" Extrude individual faces.\n\n        Arguments\n        ---------\n            - selection : indices of the faces to extrude\n            - offset (vector = (0, 0, 1)) : the extrusion vector\n            - dissolve (bool = True) : remove starting faces\n\n        Returns\n        -------\n            - dictionnary : 'top' : extruded faces, 'side' : extruded side faces\n        \"\"\"\n\n        # Selected faces indices\n        faces_sel = np.arange(len(self.faces))\n        if selection is not None:\n            faces_sel = faces_sel[selection]\n\n        # bmesh edition\n        with self.bmesh() as bm:\n            #bm.verts.ensure_lookup_table()\n            bm.faces.ensure_lookup_table()\n\n            # select faces\n            start_faces = [bm.faces[i] for i in faces_sel]\n\n            res = {'top': [], 'side': []}\n\n\n            # Extrusion\n            d = bmesh.ops.extrude_face_region(\n                bm, \n                geom                      = start_faces,\n                #edges_exclude            = set(),\n                #use_keep_orig            = False,\n                #use_normal_flip          = False,\n                #use_normal_from_adjacent = False,\n                #use_dissolve_ortho_edges = False,\n                #use_select_history       = False,\n                )\n\n            # Move new vectors\n            extruded_geom = d[\"geom\"]\n            new_verts = [ele for ele in extruded_geom if isinstance(ele, bmesh.types.BMVert)]\n            new_faces = [ele for ele in extruded_geom if isinstance(ele, bmesh.types.BMFace)]\n\n            bmesh.ops.translate(bm, verts=new_verts, vec=list(offset))\n\n            # ===== Result\n            for face in new_faces:\n                res['top'].append(face.index)\n                for e in face.edges:\n                    assert(len(e.link_faces) == 2)\n                    if e.link_faces[0].index == face.index:\n                        res['side'].append(e.link_faces[1].index)\n                    else:\n                        res['side'].append(e.link_faces[0].index)\n\n            # ===== Dissolve extruded faces\n            if dissolve:\n                bm.faces.ensure_lookup_table()\n                del_faces = [bm.faces[i] for i in faces_sel]\n\n                bmesh.ops.delete(bm, geom=del_faces, context='FACES')                   \n\n        return res\n\n    # ----------------------------------------------------------------------------------------------------\n    # inset faces\n    # ----------------------------------------------------------------------------------------------------\n\n    def inset_faces(self, selection, thickness=0.1, depth=0.0, use_even_offset=True, use_relative_offset=False):\n        \"\"\" Extrude individual faces.\n\n        If offset is None, faces are extruder along their normal\n\n        Arguments\n        ---------\n        selection : selection on faces\n            indices of the faces to inset\n        thickness : float\n            Inset thickness.\n        depth : float\n            Inset depth (extrusion).\n        use_even_offset : bool\n            Keep consistent thickness.\n        use_relative_offset : bool\n            Offset relative to face size.\n\n        Returns\n        -------\n        dict with:\n            'faces' : list of new inset faces\n        \"\"\"\n\n        # Selected faces indices\n        faces_sel = np.arange(len(self.faces))\n        if selection is not None:\n            faces_sel = faces_sel[selection]\n\n        # bmesh edition\n        with self.bmesh() as bm:\n            bm.faces.ensure_lookup_table()\n\n            # select faces\n            start_faces = [bm.faces[i] for i in faces_sel]\n\n            res = {'top': [], 'side': []}\n\n            # bmesh.ops\n            d = bmesh.ops.inset_individual(\n                bm,\n                faces               = start_faces,\n                thickness           = thickness,\n                depth               = depth,\n                use_even_offset     = use_even_offset,\n                use_relative_offset = use_relative_offset,\n            )\n\n            res = {\n                'top': faces_sel,\n                'side': [face.index for face in d[\"faces\"]]\n            }\n\n        return res\n\n    # ----------------------------------------------------------------------------------------------------\n    # Solidify socle\n    # ----------------------------------------------------------------------------------------------------\n\n    def solidify_socle(self, shape, z=0, bottom_material_index=0):\n        \"\"\" The mesh is supposed to be a grid.\n\n        The socle is buit by extruding the external edges to the value z.\n\n        Arguments\n        ---------\n        - shape (tuple of ints) : the grid shade\n        - z (float) : socle base z\n        - bottom_material_index (int = 0) : base face material index\n        - attributes (dict) : attributes to faces\n\n        Returns\n        -------\n        - bottom face index (int) : the index of bottom face\n        \"\"\"\n\n        n = shape[0]*shape[1]\n        inds = np.arange(n).reshape(shape)\n\n        loop1 = np.append(inds[0, :-1], inds[:-1, -1])\n        loop1 = np.append(loop1, np.flip(inds[-1, 1:]))\n        loop1 = np.append(loop1, np.flip(inds[1:, 0]))\n\n        points = np.array(self.points.position[loop1])\n        points[:, 2] = z\n\n        loop0 = self.add_points(points)\n        res = self.add_geometry(corners=loop0) #, faces=len(loop0))\n\n        self.bridge_loops(loop0, loop1, close=True)\n\n        self.faces._ensure_optional_field(\"material_index\")\n        self.faces[res['faces']].material_index = bottom_material_index\n\n    # ----------------------------------------------------------------------------------------------------\n    # Boolean\n    # ----------------------------------------------------------------------------------------------------\n\n    def boolean(self, other, operation='DIFFERENCE'):\n        \"\"\"\n        Apply a boolean operation with another object.\n\n        Parameters\n        ----------\n        other : Mesh\n            The object to use as boolean operand.\n        operation : str\n            Boolean operation: 'INTERSECT', 'UNION', or 'DIFFERENCE'.\n        \"\"\"\n\n        with other.object(0, readonly=True) as other_obj:\n\n            with self.object(1) as obj:\n                mod = obj.modifiers.new(name=\"Boolean\", type='BOOLEAN')\n                mod.object = other_obj\n                mod.operation = operation\n\n                # Apply modifier\n                bpy.ops.object.modifier_apply(modifier=mod.name)\n\n                mesh = Mesh.from_object(obj)\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Solidify\n    # ----------------------------------------------------------------------------------------------------\n\n    def solidify(self, thickness=.01, offset=-1):\n        \"\"\" Boolean difference with another MeshBuilder.\n\n        The methods uses the Solidify Modifier\n\n        ``` python\n        glass = Mesh.Circle(segments=128)\n        glass.extrude_faces(0, -.01)\n        glass.extrude_faces(0, -2)\n        glass.extrude_faces(0, -.01)\n\n        glass.points.translate((0, 0, 2))\n\n        glass = glass.solidify(thickness=.1)\n\n        glass.to_object(\"Solidify\", shade_smooth=True)\n        ```\n\n        Arguments\n        ---------\n            - thickness (float=.01) : thickness\n            - offset (float=-1) : offset\n\n        Returns\n        -------\n            - MeshBuilder : the result of the solidify operation\n        \"\"\"\n\n        with self.object() as obj:\n            mod = obj.modifiers.new(\"Solidify\", 'SOLIDIFY')\n\n            mod.thickness       = thickness\n            mod.use_even_offset = True\n            mod.offset          = offset\n\n            # Apply modifier\n            bpy.ops.object.modifier_apply(modifier=mod.name)\n\n            mesh = Mesh.from_object(obj)\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Remove doubles\n    # ----------------------------------------------------------------------------------------------------\n\n    def remove_doubles(self, dist=.001):\n        \"\"\" Remove doubles.\n\n        Arguments:\n            - dist (float=0.001) : maximum distance between vertices to merge.\n        \"\"\"\n        with self.bmesh() as bm:\n            bmesh.ops.remove_doubles(bm, verts=bm.verts, dist=dist)\n\n        return self\n\n    # ----------------------------------------------------------------------------------------------------\n    # Triangulate\n    # ----------------------------------------------------------------------------------------------------\n\n    def triangulate(self, selection=None):\n\n        faces_sel = np.arange(len(self.faces))\n        if selection is not None:\n            faces_sel = faces_sel[selection]\n\n        if len(faces_sel) == 0:\n            return\n\n        copy = Mesh.from_mesh(self)\n\n        with copy.bmesh(readonly = False) as bm:\n            bm.faces.ensure_lookup_table()\n            faces = [bm.faces[i] for i in faces_sel]\n\n            bmesh.ops.triangulate(bm, faces=faces)\n\n        return copy\n\n    # ----------------------------------------------------------------------------------------------------\n    # Simplify\n    # ----------------------------------------------------------------------------------------------------\n\n    def simplified(self, scale, dist=.001):\n\n        copy = Mesh.from_mesh(self)\n        copy.remove_doubles(dist=dist/scale)\n\n        if len(copy.points) &lt; 8:\n            copy = self.get_cubic_envelop()\n\n        return copy\n\n    # ----------------------------------------------------------------------------------------------------\n    # Faces to islands\n    # ----------------------------------------------------------------------------------------------------\n\n    def separate_faces(self, groups=None):\n        \"\"\" Split faces into isolated islands\n\n        Arguments\n        ---------\n        - groups (list of ints):\n            group ids of faces\n        \"\"\"\n\n        mesh = Mesh(materials=self.materials)\n        attr_names = [name for name in self.faces.actual_names if name not in ['loop_total', 'loop_start']]\n\n        # ---------------------------------------------------------------------------\n        # No group: each face becomes an island\n        # ---------------------------------------------------------------------------\n\n        if groups is None:\n            attrs = {name: self.faces[name] for name in attr_names}\n            return Mesh(attr_from=self).join_geometry(\n                points = self.points.position[self.corners.vertex_index],\n                corners = np.arange(len(self.corners)),\n                faces = self.faces.loop_total,\n                **attrs,\n            )\n\n        # ---------------------------------------------------------------------------\n        # Faces are grouped with groupds IDs\n        # ---------------------------------------------------------------------------\n\n        groups = np.asarray(groups)\n        if groups.shape != (len(self.faces),)   :\n            raise ValueError(f\"The 'groups' argument must be a index per face with a length of {len(self.faces)}.\")\n\n        ugroups, rev_index = np.unique(groups, return_inverse=True)\n        for group in ugroups:\n            faces = self.faces[ugroups[rev_index] == group]\n            attrs = {name: faces[name] for name in attr_names}\n\n            corners = self.corners[faces.get_corner_indices()]\n            uniques, new_corners = np.unique(corners.vertex_index, return_inverse=True)\n            mesh.join(Mesh(attr_from=self).join_geometry(\n                points = self.points.position[uniques],\n                corners = new_corners,\n                faces = faces.loop_total,\n                **attrs,\n            ))\n\n        return mesh\n\n    # ----------------------------------------------------------------------------------------------------\n    # Dual mesh\n    # ----------------------------------------------------------------------------------------------------\n\n    def dual(self, center=\"median\"):\n\n        verts = np.empty((len(self.faces), 3), np.float32)\n        corners = []\n        faces = []\n\n        with self.bmesh() as bm:\n\n            bm.faces.ensure_lookup_table()\n            bm.verts.ensure_lookup_table()    \n            bm.edges.ensure_lookup_table()    \n\n            # ---------------------------------------------------------------------------\n            # Faces become points\n            # ---------------------------------------------------------------------------\n\n            if center.lower() == 'median':\n                for f in bm.faces:\n                    c = f.calc_center_median()\n                    verts[f.index] = (c.x, c.y, c.z)\n\n            elif center.lower() == 'bounds':\n                for f in bm.faces:\n                    c = f.calc_center_bounds()\n                    verts[f.index] = (c.x, c.y, c.z)\n\n            elif center.lower() == 'weighted':\n                for f in bm.faces:\n                    c = f.calc_center_median_weighted()\n                    verts[f.index] = (c.x, c.y, c.z)\n\n            else:\n                raise ValueError(f\"Center must be in ('median', 'bounds','weighted').\")\n\n            # ---------------------------------------------------------------------------\n            # Vertices becom faces\n            # ---------------------------------------------------------------------------\n\n            for v in bm.verts:\n                # Faces need to be ordered (link_faces is not good)\n                # Get the edges as couples (face.index, face.index)\n                # then chain the edges\n\n                couples = []\n                first = True\n                for edge in v.link_edges:\n\n                    if len(edge.link_faces) != 2:\n                        couples = []\n                        break\n\n                    # First is used for the order between:\n                    # - face0 then face1\n                    # - face1 then face0\n                    if first:\n                        first = False\n\n                        # The edge links two vertices\n                        other_index = edge.verts[0].index if edge.verts[1].index == v.index else edge.verts[1].index\n\n                        # We select as first face the one where loop is v -&gt; other                \n                        face0 = edge.link_faces[0]\n                        for i_loop, lp in enumerate(face0.loops):\n                            if lp.vert.index == other_index:\n                                j = (i_loop + 1)%len(face0.loops)\n                                take0 = face0.loops[j].vert.index == v.index\n                                break\n\n                        if take0:\n                            loop = [edge.link_faces[0].index, edge.link_faces[1].index]\n                        else:\n                            loop = [edge.link_faces[1].index, edge.link_faces[0].index]\n\n                    else:\n                        couples.append((edge.link_faces[0].index, edge.link_faces[1].index))\n\n                if len(couples) &lt; 2:\n                    continue\n\n                # Build the other faces by chaing the edges \n                # First loop to consume the edge couples      \n                for _ in range(len(couples)):\n                    found = False\n                    # Second loop to find the following edge\n                    for i, e in enumerate(couples):\n                        if e[0] == loop[-1]:\n                            loop.append(e[1])\n                            found = True\n                        elif e[1] == loop[-1]:\n                            loop.append(e[0])\n                            found = True\n                        else:\n                            continue\n                        break\n\n                    if found:\n                        del couples[i]\n                    else:\n                        loop = []\n                        break\n\n                if len(loop) &lt; 3:\n                    continue\n\n                faces.append(len(loop))\n                corners.extend(loop)\n\n        # We can build the dual mesh\n        return Mesh(points=verts, corners=corners, faces=faces, materials=self.materials)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Faces neighbors\n    # ----------------------------------------------------------------------------------------------------\n\n    def faces_neighbors(self):\n\n        offset = 0\n        neighbors = []\n\n        with self.bmesh() as bm:           \n            bm.faces.ensure_lookup_table()\n\n            for face in bm.faces:\n                ns = set()\n                for edge in face.edges:\n                    ns = ns.union([edge.link_faces[0].index, edge.link_faces[1].index])\n                ns.remove(face.index)\n                neighbors.append(list(ns))\n\n        return neighbors\n\n    # ----------------------------------------------------------------------------------------------------\n    # Get islands\n    # ----------------------------------------------------------------------------------------------------\n\n    def get_islands(self):\n        \"\"\" Get an island id per face.\n        \"\"\"\n        from collections import deque\n\n        nfaces = len(self.faces)\n        if not nfaces:\n            return []\n\n        islands = np.full(nfaces, -1, dtype=np.int32)\n        cur_island = -1\n\n        passed = np.zeros(nfaces, dtype=bool)\n\n        with self.bmesh() as bm:\n            bm.faces.ensure_lookup_table()\n            bm.edges.ensure_lookup_table()\n\n            for f in bm.faces:\n                # Already visited\n                if islands[f.index] &gt;= 0:\n                    continue\n\n                # New island index\n                cur_island += 1\n\n                q = deque([f])\n                while q:\n                    cur = q.popleft()\n\n                    # Part of the current island\n                    islands[cur.index] = cur_island\n\n                    # No infinite loop\n                    passed[cur.index] = True\n\n                    # Loop on the edges\n                    for e in cur.edges:                                               \n                        # Loop on the edge faces\n                        for nb in e.link_faces:\n                            if passed[nb.index]:\n                                continue\n                            passed[nb.index] = True\n\n                            if islands[nb.index] &lt; 0:\n                                q.append(nb)\n\n\n        return islands\n\n    # ====================================================================================================\n    # BVHTree\n    # ====================================================================================================\n\n    def bvh_tree(self, count=None):\n        if count is None:\n            return BVHTree.FromPolygons(self.points.position, self.faces.sequences(), all_triangles=False, epsilon=0.0)\n\n        else:\n            pos    = self.points.position\n            pos    = pos.reshape(count, -1, 3)\n\n            nfaces = len(self.faces)//count\n            inds   = list(self.corners.vertex_index)\n            faces  = [inds[lstart:lstart+ltotal] for (lstart, ltotal) in zip(self.faces.loop_start[:nfaces], self.faces.loop_total[:nfaces])]\n\n            return [BVHTree.FromPolygons(pos[i], faces, all_triangles=False, epsilon=0.0) for i in range(count)]\n\n\n    # ====================================================================================================\n    # Tests\n    # ====================================================================================================\n\n    # ----------------------------------------------------------------------------------------------------\n    # Test the primitives\n    # ----------------------------------------------------------------------------------------------------\n\n    @staticmethod\n    def _all_primitives():\n\n        rng = np.random.default_rng(0)\n\n        def toobj(mesh, name, x):\n            mesh.materials = [\"Material\"]   \n            mesh.points.x += x - np.min(mesh.points.x)\n            x = np.max(mesh.points.x) + 1\n\n            mesh.to_object(name, shade_smooth=False)\n\n            return x\n\n        x = 0\n\n        # ----- Points\n        mesh = Mesh.points(rng.uniform(-1, 1, size=(1000, 3)))\n        x = toobj(mesh, \"points\", x)\n\n        # ----- Lines\n        mesh = Mesh.line([0, 0, 0], [[0, -2, 1], [0, -1, 1], [0, 0, 1], [0, 1, 1], [0, 1, 1]])\n        mesh.join(Mesh.line([1, 0, 0], [[1, -2, 1], [1, -1, 1], [1, 0, 1], [1, 1, 1], [1, 1, 1]], segments=3))\n        mesh.join(Mesh.line([-1, 0, 0], [-1, 0, 1], segments=10))\n        x = toobj(mesh, \"line\", x)\n\n        # ----- Grid\n        mesh = Mesh.grid().translate((0, 0, 1)).join(Mesh.grid(5, 3, 50, 30))\n        x = toobj(mesh, \"grid\", x)\n\n        # ----- Cicle\n        mesh = Mesh.circle().join(Mesh.circle(cap='NGON').translate((0, 0, 1)), Mesh.circle(cap='FANS').translate((0, 0, 2)))      \n        x = toobj(mesh, \"circle\", x)\n\n        # ----- Cone\n        mesh = Mesh.cone(fill_type='NONE').join(\n            Mesh.cone(side_segments=10).translate((0, 0, 3)),\n            Mesh.cone(fill_type='NGON').translate((0, 0, 6)),\n            Mesh.cone(fill_type='FANS').translate((0, 0, 9)),\n        )\n        x = toobj(mesh, \"cone\", x)\n\n        # ----- Cylinder\n        mesh = Mesh.cylinder(fill_type='NONE').join(\n            Mesh.cylinder(side_segments=10).translate((0, 0, 3)),\n            Mesh.cylinder(fill_type='NGON').translate((0, 0, 6)),\n            Mesh.cylinder(fill_type='FANS').translate((0, 0, 9)),\n        )\n        x = toobj(mesh, \"cylinder\", x)\n\n        # ----- Arrow\n        mesh = Mesh().join(\n            Mesh.arrow((-1, 0, 0)),\n            Mesh.arrow((+1, 0, 0)),\n            Mesh.arrow((0, -1, 0)),\n            Mesh.arrow((0, +1, 0)),\n            Mesh.arrow((0, 0, -1)),\n            Mesh.arrow((0, 0, +1)),\n        )\n        x = toobj(mesh, \"arrow\", x)\n\n        # ----- Vectors field\n        n = 50\n        pos = rng.uniform(-1, 1, size=(n, 3))\n        ori = rng.uniform(-1, 1, size=(n, 3))\n        mesh = Mesh.vectors_field(\n            pos,\n            ori,\n            radius = .02,\n        )\n        x = toobj(mesh, \"vectors_field\", x)\n\n        # ----- Simple\n        for name in [\"cube\", \"pyramid\", \"uvsphere\", \"icosphere\", \"torus\", \"chain_link\", \"monkey\"]:\n            f = getattr(Mesh, name)\n            mesh = f()\n            x = toobj(mesh, name, x)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Test edition\n    # ----------------------------------------------------------------------------------------------------\n\n    def _test_edition():\n        rng = np.random.default_rng(0)\n\n        # extrude vertices\n        mesh = Mesh.icosphere()\n        sel = rng.uniform(0, 1, len(mesh.points)) &lt; .5\n        mesh.extrude_vertices(sel, mesh.points.position[sel])\n        mesh.to_object(\"extrude_vertices\", shade_smooth=False)\n\n        # extrude loop of vertices\n        mesh = Mesh.circle(materials=\"Material\")\n        mesh.extrude_loop(np.arange(len(mesh.points)), offset=(0, 0, 1), close=True)\n        mesh.points.x += 2\n        mesh.to_object(\"extrude_loop\", shade_smooth=False)\n\n        # extrude individualfaces\n        mesh = Mesh.icosphere()\n        sel = rng.uniform(0, 1, len(mesh.faces)) &lt; .5\n        inds = np.arange(len(mesh.faces))[sel]\n        res = mesh.extrude_faces(sel, scale=.3)\n        res = mesh.inset_faces(res['top'])\n        res = mesh.extrude_faces(res['top'], scale=-.1)\n        mesh.points.x += 4\n        mesh.to_object(\"extrude_faces\", shade_smooth=False)\n\n        # extrude region\n        mesh = Mesh.grid(1, 1, 11, 11)\n        sel = [23, 24, 25, 26, 27, 34, 35, 36, 45]\n        res = mesh.extrude_region(sel, (0, 0, 1), dissolve=False)\n        mesh.extrude_region(res['top'], (0, 0, .5), dissolve=True)\n        mesh.points.x += 7\n        mesh.to_object(\"extrude_region\", shade_smooth=False)\n\n        # solidify socle\n        mesh = Mesh.grid(2, 1.6/3, 80, 30)\n        mesh.points.z = .5 + rng.uniform(-.05, .05, len(mesh.points))\n        mesh.points.x += 10\n        mesh.solidify_socle(shape=(80, 30), z=0)\n        mesh.to_object(\"solidify_socle\", shade_smooth=False)\n\n        # boolean\n        cube = Mesh.cube()\n        cyl = Mesh.cylinder(radius=.5, depth = 3)\n        mesh = cube.boolean(cyl)\n        mesh.points.x += 13\n        mesh.to_object(\"boolean difference\", shade_smooth=False)\n\n        # solidify\n        mesh = Mesh.grid().solidify(thickness=.2)\n        mesh.points.x += 16\n        mesh.to_object(\"solidify\", shade_smooth=False)\n\n        # triangulate\n        mesh = Mesh.cube().triangulate()\n        mesh.points.x += 19\n        mesh.to_object(\"triangulate\", shade_smooth=False)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    # =============================================================================================================================\n    # To curve\n    # =============================================================================================================================\n\n    def to_curve_REVIEW(self):\n        \"\"\" &gt; Convert mesh to curve\n\n        Simple conversion when edges domain is defined\n        \"\"\"\n\n        from npblender import Curve\n\n        if self._edges is None:\n            return None\n\n        splines = []\n        for edge in self.edges:\n            v0, v1 = edge.vertex0, edge.vertex1\n\n            ok = False\n            for spline in splines:\n                if spline[0] == spline[-1]:\n                    continue\n\n                if v0 == spline[0]:\n                    spline.insert(0, v1)\n                    ok = True\n                elif v0 == spline[-1]:\n                    spline.append(v1)\n                    ok = True\n\n                elif v1 == spline[0]:\n                    spline.insert(0, v0)\n                    ok = True\n                elif v1 == spline[-1]:\n                    spline.append(v0)\n                    ok = True\n\n            if not ok:\n                splines.append([v0, v1])\n\n        curve = Curve()\n        for spline in splines:\n            cyclic = spline[0] == spline[-1]\n            if cyclic:\n                spline = spline[:-1]\n\n            curve.add(self.points.position[spline], curve_type='POLY', cyclic=cyclic)\n\n        return curve\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bounding_box","title":"bounding_box  <code>property</code>","text":"<pre><code>bounding_box\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bounding_box_dims","title":"bounding_box_dims  <code>property</code>","text":"<pre><code>bounding_box_dims\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.corners","title":"corners  <code>instance-attribute</code>","text":"<pre><code>corners = Corner()\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.domain_names","title":"domain_names  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>domain_names = ['points', 'corners', 'faces', 'edges']\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.edges","title":"edges  <code>instance-attribute</code>","text":"<pre><code>edges = Edge()\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.faces","title":"faces  <code>instance-attribute</code>","text":"<pre><code>faces = Face()\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.materials","title":"materials  <code>instance-attribute</code>","text":"<pre><code>materials = []\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.max_size","title":"max_size  <code>property</code>","text":"<pre><code>max_size\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.points","title":"points  <code>instance-attribute</code>","text":"<pre><code>points = Vertex()\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.__imul__","title":"__imul__","text":"<pre><code>__imul__(count)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def __imul__(self, count):\n    return self.multiply(count, in_place=True)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.__init__","title":"__init__","text":"<pre><code>__init__(points=None, corners=None, faces=None, edges=None, materials=None, attr_from=None, **attrs)\n</code></pre> <p>Mesh Geometry.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.__init__--arguments","title":"Arguments","text":"<pre><code>- points (array of vectors = None) : the vertices\n- corners (array of ints = None) : corners, i.e. indices on the array of points\n- faces (array of ints = None) : size of the faces, the sum of this array must be equal to the length of the corners array\n- edges (array of couples of ints = None) : list of edges defined by two vertex indices\n- materials (str or list of strs = None) : list of materials used in the geometry\n- attr_from (Geometry) : domain attributes to copy from\n- **attrs (dict) : other geometry attributes\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def __init__(self, points=None, corners=None, faces=None, edges=None, materials=None, attr_from=None, **attrs):\n    \"\"\" Mesh Geometry.\n\n    Arguments\n    ---------\n        - points (array of vectors = None) : the vertices\n        - corners (array of ints = None) : corners, i.e. indices on the array of points\n        - faces (array of ints = None) : size of the faces, the sum of this array must be equal to the length of the corners array\n        - edges (array of couples of ints = None) : list of edges defined by two vertex indices\n        - materials (str or list of strs = None) : list of materials used in the geometry\n        - attr_from (Geometry) : domain attributes to copy from\n        - **attrs (dict) : other geometry attributes\n    \"\"\"\n\n    # ----- Initialize an empty geometry\n\n    self.points  = Vertex()\n    self.corners = Corner()\n    self.faces   = Face()\n    self.edges   = Edge()\n\n    self.join_attributes(attr_from)\n\n    # ----- The materials\n\n    if materials is None:\n        self.materials = []\n    elif isinstance(materials, str):\n        self.materials = [materials]\n    else:\n        self.materials = [mat for mat in materials]\n\n    # ----- Add geometry\n\n    self.add_geometry(points, corners, faces, edges, **attrs)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.__mul__","title":"__mul__","text":"<pre><code>__mul__(count)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def __mul__(self, count):\n    return self.multiply(count, in_place=False)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def __repr__(self):\n    s = \"Mesh:\\n   \" + \"\\n   \".join([str(self.points), str(self.corners), str(self.faces)])\n    return s\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def __str__(self):\n    return f\"&lt;Mesh: points {len(self.points)}, corners {len(self.corners)}, faces {len(self.faces)}, edges {len(self.edges)}&gt;\"\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh._all_primitives","title":"_all_primitives  <code>staticmethod</code>","text":"<pre><code>_all_primitives()\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@staticmethod\ndef _all_primitives():\n\n    rng = np.random.default_rng(0)\n\n    def toobj(mesh, name, x):\n        mesh.materials = [\"Material\"]   \n        mesh.points.x += x - np.min(mesh.points.x)\n        x = np.max(mesh.points.x) + 1\n\n        mesh.to_object(name, shade_smooth=False)\n\n        return x\n\n    x = 0\n\n    # ----- Points\n    mesh = Mesh.points(rng.uniform(-1, 1, size=(1000, 3)))\n    x = toobj(mesh, \"points\", x)\n\n    # ----- Lines\n    mesh = Mesh.line([0, 0, 0], [[0, -2, 1], [0, -1, 1], [0, 0, 1], [0, 1, 1], [0, 1, 1]])\n    mesh.join(Mesh.line([1, 0, 0], [[1, -2, 1], [1, -1, 1], [1, 0, 1], [1, 1, 1], [1, 1, 1]], segments=3))\n    mesh.join(Mesh.line([-1, 0, 0], [-1, 0, 1], segments=10))\n    x = toobj(mesh, \"line\", x)\n\n    # ----- Grid\n    mesh = Mesh.grid().translate((0, 0, 1)).join(Mesh.grid(5, 3, 50, 30))\n    x = toobj(mesh, \"grid\", x)\n\n    # ----- Cicle\n    mesh = Mesh.circle().join(Mesh.circle(cap='NGON').translate((0, 0, 1)), Mesh.circle(cap='FANS').translate((0, 0, 2)))      \n    x = toobj(mesh, \"circle\", x)\n\n    # ----- Cone\n    mesh = Mesh.cone(fill_type='NONE').join(\n        Mesh.cone(side_segments=10).translate((0, 0, 3)),\n        Mesh.cone(fill_type='NGON').translate((0, 0, 6)),\n        Mesh.cone(fill_type='FANS').translate((0, 0, 9)),\n    )\n    x = toobj(mesh, \"cone\", x)\n\n    # ----- Cylinder\n    mesh = Mesh.cylinder(fill_type='NONE').join(\n        Mesh.cylinder(side_segments=10).translate((0, 0, 3)),\n        Mesh.cylinder(fill_type='NGON').translate((0, 0, 6)),\n        Mesh.cylinder(fill_type='FANS').translate((0, 0, 9)),\n    )\n    x = toobj(mesh, \"cylinder\", x)\n\n    # ----- Arrow\n    mesh = Mesh().join(\n        Mesh.arrow((-1, 0, 0)),\n        Mesh.arrow((+1, 0, 0)),\n        Mesh.arrow((0, -1, 0)),\n        Mesh.arrow((0, +1, 0)),\n        Mesh.arrow((0, 0, -1)),\n        Mesh.arrow((0, 0, +1)),\n    )\n    x = toobj(mesh, \"arrow\", x)\n\n    # ----- Vectors field\n    n = 50\n    pos = rng.uniform(-1, 1, size=(n, 3))\n    ori = rng.uniform(-1, 1, size=(n, 3))\n    mesh = Mesh.vectors_field(\n        pos,\n        ori,\n        radius = .02,\n    )\n    x = toobj(mesh, \"vectors_field\", x)\n\n    # ----- Simple\n    for name in [\"cube\", \"pyramid\", \"uvsphere\", \"icosphere\", \"torus\", \"chain_link\", \"monkey\"]:\n        f = getattr(Mesh, name)\n        mesh = f()\n        x = toobj(mesh, name, x)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh._attributes_per_domain","title":"_attributes_per_domain","text":"<pre><code>_attributes_per_domain(**attrs)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def _attributes_per_domain(self, **attrs):\n\n    dispatched = {\n        'points'  : {},\n        'corners' : {},\n        'faces'   : {},\n        'edges'   : {},\n        }\n\n    for k, v in attrs.items():\n        count = 0\n\n        if k in self.points.all_names:\n            dispatched['points'][k] = v\n            count += 1\n\n        if k in self.corners.all_names:\n            dispatched['corners'][k] = v\n            count += 1\n\n        if k in self.faces.all_names:\n            dispatched['faces'][k] = v\n            count += 1\n\n        if k in self.edges.all_names:\n            dispatched['edges'][k] = v\n            count += 1\n\n        if count == 0:\n            raise AttributeError(f\"Unknown mesh attribute '{k}'.\\n\"\n                                 f\"- points:  {self.points.all_names}\\n\"\n                                 f\"- corners: {self.corners.all_names}\\n\"\n                                 f\"- faces:   {self.faces.all_names}\\n\"\n                                 f\"- edges:   {self.edges.all_names}\\n\"\n                                 )\n\n        if count &gt; 1:\n            raise AttributeError(f\"Mesh add_geometry&gt; attribute '{k}' is ambigous, it belongs to more than one domain (count).\\n\"\n                                 f\"- points:  {self.points.all_names}\\n\"\n                                 f\"- corners: {self.corners.all_names}\\n\"\n                                 f\"- faces:   {self.faces.all_names}\\n\"\n                                 f\"- edges:   {self.edges.all_names}\\n\"\n                                 )\n    return dispatched\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh._bm_edges","title":"_bm_edges","text":"<pre><code>_bm_edges(bm)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def _bm_edges(self, bm):\n    nedges = len(bm.edges)\n    edges  = np.empty(nedges, dtype=object)\n    verts  = np.empty((nedges, 2), dtype=bint)\n\n    for i_edge, edge in enumerate(bm.edges):\n        edges[i_edge] = edge\n\n        i0, i1 = edge.verts[0].index, edge.verts[1].index\n        verts[i_edge] = (i0, i1) if i0 &lt; i1 else (i1, i0)\n\n    return edges, verts\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh._bm_verts","title":"_bm_verts","text":"<pre><code>_bm_verts(bm)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def _bm_verts(self, bm):\n    nverts = len(self.points.ravel())\n    verts  = np.zeros(nverts, dtype=object)\n    for vert in bm.verts:\n        verts[vert.index] = vert\n    return verts\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh._check_transformation_shape","title":"_check_transformation_shape","text":"<pre><code>_check_transformation_shape(t_shape, npoints, label='Transformation')\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def _check_transformation_shape(self, t_shape, npoints, label=\"Transformation\"):\n    if t_shape == ():\n        return (npoints, 3)\n\n    elif len(t_shape) == 1:\n        if t_shape[0] in [1, npoints]:\n            return (npoints, 3)\n\n    else:\n        n = int(np.prod(t_shape))\n        if npoints % n == 0:\n            return t_shape[:-1] + (-1, 3)\n\n    raise AttributeError(f\"{label} shape {t_shape} is not valid to transform {npoints} points.\")\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh._test_edition","title":"_test_edition","text":"<pre><code>_test_edition()\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def _test_edition():\n    rng = np.random.default_rng(0)\n\n    # extrude vertices\n    mesh = Mesh.icosphere()\n    sel = rng.uniform(0, 1, len(mesh.points)) &lt; .5\n    mesh.extrude_vertices(sel, mesh.points.position[sel])\n    mesh.to_object(\"extrude_vertices\", shade_smooth=False)\n\n    # extrude loop of vertices\n    mesh = Mesh.circle(materials=\"Material\")\n    mesh.extrude_loop(np.arange(len(mesh.points)), offset=(0, 0, 1), close=True)\n    mesh.points.x += 2\n    mesh.to_object(\"extrude_loop\", shade_smooth=False)\n\n    # extrude individualfaces\n    mesh = Mesh.icosphere()\n    sel = rng.uniform(0, 1, len(mesh.faces)) &lt; .5\n    inds = np.arange(len(mesh.faces))[sel]\n    res = mesh.extrude_faces(sel, scale=.3)\n    res = mesh.inset_faces(res['top'])\n    res = mesh.extrude_faces(res['top'], scale=-.1)\n    mesh.points.x += 4\n    mesh.to_object(\"extrude_faces\", shade_smooth=False)\n\n    # extrude region\n    mesh = Mesh.grid(1, 1, 11, 11)\n    sel = [23, 24, 25, 26, 27, 34, 35, 36, 45]\n    res = mesh.extrude_region(sel, (0, 0, 1), dissolve=False)\n    mesh.extrude_region(res['top'], (0, 0, .5), dissolve=True)\n    mesh.points.x += 7\n    mesh.to_object(\"extrude_region\", shade_smooth=False)\n\n    # solidify socle\n    mesh = Mesh.grid(2, 1.6/3, 80, 30)\n    mesh.points.z = .5 + rng.uniform(-.05, .05, len(mesh.points))\n    mesh.points.x += 10\n    mesh.solidify_socle(shape=(80, 30), z=0)\n    mesh.to_object(\"solidify_socle\", shade_smooth=False)\n\n    # boolean\n    cube = Mesh.cube()\n    cyl = Mesh.cylinder(radius=.5, depth = 3)\n    mesh = cube.boolean(cyl)\n    mesh.points.x += 13\n    mesh.to_object(\"boolean difference\", shade_smooth=False)\n\n    # solidify\n    mesh = Mesh.grid().solidify(thickness=.2)\n    mesh.points.x += 16\n    mesh.to_object(\"solidify\", shade_smooth=False)\n\n    # triangulate\n    mesh = Mesh.cube().triangulate()\n    mesh.points.x += 19\n    mesh.to_object(\"triangulate\", shade_smooth=False)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_geometry","title":"add_geometry","text":"<pre><code>add_geometry(points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs)\n</code></pre> <p>Add geometry</p> <p>Note that the added geometry can refer to existing vertices. It is appended as is, whithout shifting indices.</p> <p>To add independant geometry, use join_geometry.</p> <pre><code>cube = Mesh.cube()\n# add a triangle on existing vertices\n# corners argument refers to cube vertices\ncube.add_geometry(corners=[0, 1, 2], faces=3)\n\n# add a triangle with additional vertices\n# corners argument refers to the new vertices\ncube.join_geometry(points=[[0, 0, 0], [0, 1, 0], [1, 0, 0]], corners=[0, 1, 2], faces=3)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_geometry--arguments","title":"Arguments","text":"<pre><code>- points (array of vectors = None) : the vertices\n- corners (array of ints = None) : corners, i.e. indices on the array of points\n- sizes (array of ints = None) : size of the faces, the sum of this array must be equal to the length of the corners array\n- materials (str or list of strs = None) : list of materials used in the geometry\n- **attrs (dict) : other geometry attributes\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_geometry--returns","title":"Returns","text":"<pre><code>- dict : {'points', 'corners', 'faces', 'edges': added geometry indices}\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def add_geometry(self, points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs):\n    \"\"\" Add geometry\n\n    Note that the added geometry can refer to existing vertices. It is appended as is, whithout shifting\n    indices.\n\n    To add independant geometry, use join_geometry.\n\n    ``` python\n    cube = Mesh.cube()\n    # add a triangle on existing vertices\n    # corners argument refers to cube vertices\n    cube.add_geometry(corners=[0, 1, 2], faces=3)\n\n    # add a triangle with additional vertices\n    # corners argument refers to the new vertices\n    cube.join_geometry(points=[[0, 0, 0], [0, 1, 0], [1, 0, 0]], corners=[0, 1, 2], faces=3)\n    ```\n\n    Arguments\n    ---------\n        - points (array of vectors = None) : the vertices\n        - corners (array of ints = None) : corners, i.e. indices on the array of points\n        - sizes (array of ints = None) : size of the faces, the sum of this array must be equal to the length of the corners array\n        - materials (str or list of strs = None) : list of materials used in the geometry\n        - **attrs (dict) : other geometry attributes\n\n    Returns\n    -------\n        - dict : {'points', 'corners', 'faces', 'edges': added geometry indices}\n    \"\"\"\n\n    disp_attrs = self._attributes_per_domain(**attrs)\n    added = {'points': [], 'corners': [], 'faces': [], 'edges': []}\n\n    # ----------------------------------------------------------------------------------------------------\n    # Add vertices\n    # ----------------------------------------------------------------------------------------------------\n\n    if points is not None:\n        added['points'] = self.points.append(position=points, **disp_attrs['points'])\n\n    # ----------------------------------------------------------------------------------------------------\n    # Edges\n    # ----------------------------------------------------------------------------------------------------\n\n    if edges is not None:\n        if np.shape(edges) == (2,):\n            added['edges'] = self.edges.append(vertex0=edges[0], vertex1=edges[1], **disp_attrs['edges'])\n        else:\n            added['edges'] = self.edges.append(vertex0=edges[:, 0], vertex1=edges[:, 1], **disp_attrs['edges'])\n\n    # ----------------------------------------------------------------------------------------------------\n    # Corners and Faces\n    # ----------------------------------------------------------------------------------------------------\n\n    # If corners is provided, faces can be:\n    # - None -&gt; single face made of all corners\n    # - int -&gt; faces are all the same size (len(corners) must be a multiplief of faces)\n    # - array like -&gt; face sizes (len(corners) == np.sum(faces))\n    #\n    # If faces is provided, corners can be:\n    # - None -&gt; faces must be an array of arrays, each array being of list of corners\n    # - not None -&gt; see above\n\n    ok_faces = True\n    if corners is None:\n        if faces is None:\n            ok_faces = False\n        else:\n            corners = []\n            sizes = []\n            ok = hasattr(faces, '__len__')\n            if ok:\n                for face in faces:\n                    ok = hasattr(faces, '__len__') and len(face) &gt; 2\n                    if not ok:\n                        break\n                    corners.extend(face)\n                    sizes.append(len(face))\n            if not ok:\n                raise ValueError(f\"Mesh add_geometry&gt; when corners is None, faces must be None or an array of arrays, each array being of list of corners.\")\n            faces = sizes\n\n    else:\n        corners = np.asarray(corners)\n        ncorners = len(corners)\n        if faces is None:\n            faces = [ncorners]\n\n        else:\n            faces = np.asarray(faces)\n            if faces.shape == ():\n                size = int(faces)\n                if ncorners % size != 0:\n                    raise ValueError(f\"Mesh add_geometry&gt; when faces is a single number {size}, it must divide the number of corners ({ncorners}).\")\n                faces = [size]*(ncorners // size)\n            else:\n                if np.sum(faces) != ncorners:\n                    raise ValueError(f\"Mesh add_geometry&gt; the sum of faces ({np.sum(faces)}) must be equal to the number of corners ({ncorners}).\")\n\n    if ok_faces:\n        added['corners'] = self.corners.append(vertex_index=corners, **disp_attrs['corners'])\n        added['faces'] = self.faces.append_sizes(faces, **disp_attrs['faces'])\n\n    if False: # OLD\n        if np.shape(faces) == ():\n            nfaces = len(corners) // faces\n            if len(corners) % faces != 0:\n                raise ValueError(f\"Mesh add_geometry&gt; when faces is a single number {faces}, it must divide the number of corners ({len(corners)}).\")\n            faces = np.ones(nfaces, dtype=bint)*faces\n\n        added['corners'] = self.corners.append(vertex_index=corners, **disp_attrs['corners'])\n        added['faces'] = self.faces.append_sizes(faces, **disp_attrs['faces'])\n\n    if safe_mode:\n        self.check()\n\n    return added\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_materials","title":"add_materials","text":"<pre><code>add_materials(materials)\n</code></pre> <p>Add a materials list to the existing one.</p> <p>If a material already exist, it is not added another time.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_materials--arguments","title":"Arguments","text":"<pre><code>- materials (list of strs) : the list of materials to append.\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def add_materials(self, materials):\n    \"\"\" Add a materials list to the existing one.\n\n    If a material already exist, it is not added another time.\n\n    Arguments\n    ---------\n        - materials (list of strs) : the list of materials to append.\n    \"\"\"\n    if isinstance(materials, str):\n        self.materials.append(materials)\n    else:\n        self.materials.extend(materials)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_points","title":"add_points","text":"<pre><code>add_points(points, **attributes)\n</code></pre> <p>Add vertices.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_points--arguments","title":"Arguments","text":"<pre><code>- points (array of vectors) : the vertices to add\n- attributes (name=value) : value for named attributes\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_points--returns","title":"Returns","text":"<pre><code>- array of ints : indices of the added vertices\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def add_points(self, points,  **attributes):\n    \"\"\" Add vertices.\n\n    Arguments\n    ---------\n        - points (array of vectors) : the vertices to add\n        - attributes (name=value) : value for named attributes\n\n    Returns\n    -------\n        - array of ints : indices of the added vertices\n    \"\"\"\n    npoints = len(self.points)\n    return self.points.append(position=points, **attributes)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.apply_scale","title":"apply_scale","text":"<pre><code>apply_scale(scale, pivot=None)\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def apply_scale(self, scale, pivot=None):\n    return self.transformation(scale=scale, pivot=pivot)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.arrow","title":"arrow  <code>classmethod</code>","text":"<pre><code>arrow(vector=(0, 0, 1), radius=0.05, angle=24.0, segments=8, adjust_norm=None, materials=None)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef arrow(cls, vector=(0, 0, 1), radius=.05, angle=24., segments=8, adjust_norm=None, materials=None):\n\n    height = np.linalg.norm(vector)\n    if type(adjust_norm).__name__ == 'function':\n        height = adjust_norm(height)\n    elif adjust_norm is not None:\n        height = min(adjust_norm, height)\n\n    head_radius = 3*radius\n    head_height = head_radius/np.tan(np.radians(angle))\n\n    cyl_height = height - head_height*.8\n\n    #cyl  = cls.cylinder(vertices=segments, side_segments=2, radius=radius, depth=cyl_height, transformation=Transformations(position=(0, 0, cyl_height/2)), materials=materials)\n    cyl = cls.cylinder(vertices=segments, side_segments=2, radius=radius, depth=cyl_height, materials=materials)\n    cyl.points.z += cyl_height/2\n    cyl.points[[segments + i for i in range(segments)]].position -= (0, 0, cyl_height/2 - .01)\n\n    cone = cls.cone(vertices=segments, side_segments=2, fill_segments=1, radius_top=0, radius_bottom=head_radius, depth=head_height, fill_type='FANS', materials=materials)\n    cone.points[-1].position += (0, 0, head_height/10)\n    cone.points.position += (0, 0, height - head_height/2)\n\n    arrow = cyl.join(cone)\n    #arrow.points.position = tracker(vector, track_axis='Z') @ arrow.points.position\n    arrow.points.position = Rotation.look_at((0, 0, 1), vector) @ arrow.points.position\n\n    return arrow\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_circle","title":"bl_circle  <code>classmethod</code>","text":"<pre><code>bl_circle(radius=1, segments=16, fill_tris=False, materials=None)\n</code></pre> <p>Create a Circle.</p> <p>Blender constructor for a Circle.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_circle--arguments","title":"Arguments","text":"<pre><code>- radius (float=1.) : circle radius\n- segments (int=16) : number of segments\n- fill_tris (bool = False) : fill with triangle fans\n- materials (list of strs = None) : materials list\n- transformation (Transformations = None) : the transformation to apply\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_circle--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef bl_circle(cls, radius=1, segments=16, fill_tris=False, materials=None):\n    \"\"\" Create a Circle.\n\n    Blender constructor for a Circle.\n\n    Arguments\n    ---------\n        - radius (float=1.) : circle radius\n        - segments (int=16) : number of segments\n        - fill_tris (bool = False) : fill with triangle fans\n        - materials (list of strs = None) : materials list\n        - transformation (Transformations = None) : the transformation to apply\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    mesh = cls(materials=materials)\n    with mesh.bmesh() as bm:\n        bmesh.ops.create_circle(bm, cap_ends=True, cap_tris=fill_tris, segments=segments, radius=radius, calc_uvs=True)\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_cone","title":"bl_cone  <code>classmethod</code>","text":"<pre><code>bl_cone(radius1=1, radius2=0, depth=2, segments=16, side_segments=1, cap_ends=True, cap_tris=False, materials=None)\n</code></pre> <p>Create a Cone.</p> <p>Blender constructor for a Cone.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_cone--arguments","title":"Arguments","text":"<pre><code>- radius1 (float=1.) : base radius\n- radius2 (float=0.) : top radius\n- depth (float=2.) : cone height\n- segments (int=16) : number of segments\n- cap_ends (bool=True) : fill cap faces\n- cap_tris (bool = False) : fill with triangle fans\n- materials (list of strs = None) : materials list\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_cone--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef bl_cone(cls, radius1=1, radius2=0, depth=2, segments=16, side_segments=1, cap_ends=True, cap_tris=False, materials=None):\n    \"\"\" Create a Cone.\n\n    Blender constructor for a Cone.\n\n    Arguments\n    ---------\n        - radius1 (float=1.) : base radius\n        - radius2 (float=0.) : top radius\n        - depth (float=2.) : cone height\n        - segments (int=16) : number of segments\n        - cap_ends (bool=True) : fill cap faces\n        - cap_tris (bool = False) : fill with triangle fans\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    mesh = cls(materials=materials)\n    with mesh.bmesh() as bm:\n        res = bmesh.ops.create_cone(bm, cap_ends=cap_ends, cap_tris=cap_tris, segments=segments, radius1=radius1, radius2=radius2, depth=depth, calc_uvs=True)\n        if side_segments &gt; 1:\n\n            edges_to_cut = [\n                e for e in bm.edges\n                if (e.verts[0].co.z &gt; 0 and e.verts[1].co.z &lt; 0)\n                or (e.verts[0].co.z &lt; 0 and e.verts[1].co.z &gt; 0)\n            ]\n\n            # Edges subidivision\n            bmesh.ops.subdivide_edges(\n                bm,\n                edges         = edges_to_cut,\n                cuts          = side_segments - 1,\n                use_grid_fill = False\n            )\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_grid","title":"bl_grid  <code>classmethod</code>","text":"<pre><code>bl_grid(x_segments=1, y_segments=1, size=2, materials=None)\n</code></pre> <p>Create a Grid.</p> <p>Blender constructor for a Grid.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_grid--arguments","title":"Arguments","text":"<pre><code>- x_segments (int=1) : number of segments along x axis\n- y_segments (int=1) : number of segments along y axis\n- size (float or tuple of floats = 1. : size of the grid\n- materials (list of strs = None) : materials list\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_grid--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef bl_grid(cls, x_segments=1, y_segments=1, size=2, materials=None):\n    \"\"\" Create a Grid.\n\n    Blender constructor for a Grid.\n\n    Arguments\n    ---------\n        - x_segments (int=1) : number of segments along x axis\n        - y_segments (int=1) : number of segments along y axis\n        - size (float or tuple of floats = 1. : size of the grid\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    mesh = cls(materials=materials)\n    with mesh.bmesh() as bm:\n        bmesh.ops.create_grid(bm, x_segments=x_segments, y_segments=y_segments, size=size, calc_uvs=True)\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.blender_data","title":"blender_data","text":"<pre><code>blender_data(readonly=False)\n</code></pre> <p>Acces to Blender Mesh API.</p> <p>Transfer the geometry to a temporay Blender Mesh. The example below use a blender Mesh to get the normals.</p> <pre><code>mesh = Mesh.Cube()\n\nwith mesh.blender_data() as data:\n    normals = np.array([poly.normal for poly in data.polygons])\n\nprint(normals)\n\n# &gt; [[-1. -0.  0.]\n#    [ 0.  1.  0.]\n#    [ 1. -0.  0.]\n#    [ 0. -1.  0.]\n#    [ 0.  0. -1.]\n#    [ 0. -0.  1.]]\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.blender_data--arguments","title":"Arguments","text":"<pre><code>- readonly (bool=False) : don't read back the geometry if not modified\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.blender_data--returns","title":"Returns","text":"<pre><code>- Blender Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@contextmanager\ndef blender_data(self, readonly=False):\n    \"\"\" Acces to Blender Mesh API.\n\n    Transfer the geometry to a temporay Blender Mesh.\n    The example below use a blender Mesh to get the normals.\n\n    ``` python\n    mesh = Mesh.Cube()\n\n    with mesh.blender_data() as data:\n        normals = np.array([poly.normal for poly in data.polygons])\n\n    print(normals)\n\n    # &gt; [[-1. -0.  0.]\n    #    [ 0.  1.  0.]\n    #    [ 1. -0.  0.]\n    #    [ 0. -1.  0.]\n    #    [ 0.  0. -1.]\n    #    [ 0. -0.  1.]]\n    ```\n\n    Arguments\n    ---------\n        - readonly (bool=False) : don't read back the geometry if not modified\n\n    Returns\n    -------\n        - Blender Mesh\n    \"\"\"\n\n    data = bpy.data.meshes.get(DATA_TEMP_NAME)\n    if data is None:\n        data = bpy.data.meshes.new(DATA_TEMP_NAME)\n\n    self.to_mesh_data(data)\n\n    yield data\n\n    # ----- Back\n\n    if not readonly:\n        self.capture(Mesh.from_mesh_data(data))\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bmesh","title":"bmesh","text":"<pre><code>bmesh(readonly=False)\n</code></pre> <p>Acces to bmesh api.</p> <p>The example below use bmesh to offset the vertices of +1 in the x axis.</p> <pre><code>mesh = Mesh.Cube()\n\n# Move the vertices with bmesh\nwith mesh.bmesh() as bm:\n    for v in bm.verts:\n        v.co.x += 1.0\n\n# Move the vertices directy in numpy array\nmesh.points.position[:, 1] += 1\n\n# Cube moved along x and y\nmesh.to_object(\"Cube\")\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bmesh--arguments","title":"Arguments","text":"<pre><code>- readonly (bool=False) : avoid to read back the bmesh if not modications were done\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@contextmanager\ndef bmesh(self, readonly=False):\n    \"\"\" Acces to bmesh api.\n\n    The example below use bmesh to offset the vertices of +1 in the x axis.\n\n    ``` python\n    mesh = Mesh.Cube()\n\n    # Move the vertices with bmesh\n    with mesh.bmesh() as bm:\n        for v in bm.verts:\n            v.co.x += 1.0\n\n    # Move the vertices directy in numpy array\n    mesh.points.position[:, 1] += 1\n\n    # Cube moved along x and y\n    mesh.to_object(\"Cube\")\n    ```\n\n    Arguments\n    ---------\n        - readonly (bool=False) : avoid to read back the bmesh if not modications were done\n    \"\"\"\n\n    data = bpy.data.meshes.get(DATA_TEMP_NAME)\n    if data is None:\n        data = bpy.data.meshes.new(DATA_TEMP_NAME)\n    self.to_mesh_data(data)\n\n    bm = bmesh.new()   # create an empty BMesh\n    bm.from_mesh(data) # fill it in from a Mesh\n\n    yield bm\n\n    # ----- Back\n\n    if not readonly:\n        bm.to_mesh(data)\n        self.capture(Mesh.from_mesh_data(data))\n\n    bm.free()\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.boolean","title":"boolean","text":"<pre><code>boolean(other, operation='DIFFERENCE')\n</code></pre> <p>Apply a boolean operation with another object.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.boolean--parameters","title":"Parameters","text":"<p>other : Mesh     The object to use as boolean operand. operation : str     Boolean operation: 'INTERSECT', 'UNION', or 'DIFFERENCE'.</p> Source code in <code>npblender/mesh.py</code> <pre><code>def boolean(self, other, operation='DIFFERENCE'):\n    \"\"\"\n    Apply a boolean operation with another object.\n\n    Parameters\n    ----------\n    other : Mesh\n        The object to use as boolean operand.\n    operation : str\n        Boolean operation: 'INTERSECT', 'UNION', or 'DIFFERENCE'.\n    \"\"\"\n\n    with other.object(0, readonly=True) as other_obj:\n\n        with self.object(1) as obj:\n            mod = obj.modifiers.new(name=\"Boolean\", type='BOOLEAN')\n            mod.object = other_obj\n            mod.operation = operation\n\n            # Apply modifier\n            bpy.ops.object.modifier_apply(modifier=mod.name)\n\n            mesh = Mesh.from_object(obj)\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bridge_loops","title":"bridge_loops","text":"<pre><code>bridge_loops(loop0, loop1, close=False, segments=1, **attributes)\n</code></pre> <p>Create a grid linking two loops of the same size.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bridge_loops--arguments","title":"Arguments","text":"<ul> <li>loop0 (array of ints) : the first loop</li> <li>loop1 (array of ints) : the second loop</li> <li>segments (int = 1) : the number of segments to join the loops</li> <li>attributes (dict) : attributes to add to the mesh</li> </ul> Source code in <code>npblender/mesh.py</code> <pre><code>def bridge_loops(self, loop0, loop1, close=False, segments=1, **attributes):\n    \"\"\" Create a grid linking two loops of the same size.\n\n    Arguments\n    ---------\n    - loop0 (array of ints) : the first loop\n    - loop1 (array of ints) : the second loop\n    - segments (int = 1) : the number of segments to join the loops\n    - attributes (dict) : attributes to add to the mesh\n    \"\"\"\n    segments = max(1, segments)\n\n    if close:\n        loop0 = np.append(loop0, loop0[0]).astype(bint)\n        loop1 = np.append(loop1, loop1[0]).astype(bint)\n    else:\n        loop0 = np.asarray(loop0, dtype=bint)\n        loop1 = np.asarray(loop1, dtype=bint)\n\n    sel0 = np.stack((loop0[:-1], loop0[1:]), axis=-1)\n    sel1 = np.stack((loop1[:-1], loop1[1:]), axis=-1)\n\n    sel0 = np.sort(sel0, axis=-1)\n    sel1 = np.sort(sel1, axis=-1)\n\n    with self.bmesh() as bm:\n\n        edges, verts_indices = self._bm_edges(bm)\n\n        # Prepare edges view\n        dtype = np.dtype([('a', bint), ('b', bint)])\n        edges_view = verts_indices.view(dtype)\n\n        # First loop\n        sel0_view = sel0.view(dtype)\n        mask = np.isin(edges_view.ravel(), sel0_view.ravel())\n\n        edges_to_bridge = list(edges[mask])\n\n        # Second loop\n        sel1_view = sel1.view(dtype)\n        mask = np.isin(edges_view.ravel(), sel1_view.ravel())\n\n        edges_to_bridge.extend(list(edges[mask]))\n\n        if len(edges_to_bridge) == 0:\n            return\n\n        # Bridge\n        res = bmesh.ops.bridge_loops(\n            bm, \n            edges=edges_to_bridge,\n            #use_cyclic = close,\n            #segments=segments,\n            )\n\n        # Grid\n        if segments &gt; 1:\n            bmesh.ops.subdivide_edges(\n                bm,\n                edges=res['edges'],\n                cuts=segments - 1,\n                use_grid_fill=False\n            )\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.bvh_tree","title":"bvh_tree","text":"<pre><code>bvh_tree(count=None)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def bvh_tree(self, count=None):\n    if count is None:\n        return BVHTree.FromPolygons(self.points.position, self.faces.sequences(), all_triangles=False, epsilon=0.0)\n\n    else:\n        pos    = self.points.position\n        pos    = pos.reshape(count, -1, 3)\n\n        nfaces = len(self.faces)//count\n        inds   = list(self.corners.vertex_index)\n        faces  = [inds[lstart:lstart+ltotal] for (lstart, ltotal) in zip(self.faces.loop_start[:nfaces], self.faces.loop_total[:nfaces])]\n\n        return [BVHTree.FromPolygons(pos[i], faces, all_triangles=False, epsilon=0.0) for i in range(count)]\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.capture","title":"capture","text":"<pre><code>capture(other)\n</code></pre> <p>Capture the data of another Mesh.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.capture--arguments","title":"Arguments","text":"<pre><code>- other (Mesh) : the mesh to capture\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.capture--returns","title":"Returns","text":"<pre><code>- self\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def capture(self, other):\n    \"\"\" Capture the data of another Mesh.\n\n    Arguments\n    ---------\n        - other (Mesh) : the mesh to capture\n\n    Returns\n    -------\n        - self\n    \"\"\"\n\n    self.materials = other.materials\n\n    self.points  = other.points\n    self.corners = other.corners\n    self.faces   = other.faces\n    self.edges   = other.edges\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.chain_link","title":"chain_link  <code>classmethod</code>","text":"<pre><code>chain_link(major_segments=48, minor_segments=12, radius=1.0, section=0.5, length=4.0, materials=None)\n</code></pre> <p>Create a chain link.</p> <pre><code># ----- Some maths\n\n# Chain follows a catenary curve\ndef catenary(t):\n    return np.stack((t, np.zeros_like(t), np.cosh(t)), axis=-1)\n\n# Orientation is given by the derivative\ndef derivative(t):\n    dt = 1/10000\n    return (catenary(t + dt) - catenary(t - dt))/(2*dt)\n\n# Catenary length\npts = catenary(np.linspace(-1, 1, 1000))\ncat_s = np.cumsum(np.linalg.norm(pts[1:] - pts[:-1], axis=-1))\ncat_len = cat_s[-1]\n\n# Catenary inverse : t from length\ndef cat_inverse(l):\n    return 2*np.argmin(np.abs(cat_s - l))/1000 - 1\n\n# ----- Let's build the geometry\n\n# One chain link\nsection = .02\nlength  = .15\nlink = MeshBuilder.ChainLink(radius=.04, section=section, length=length)\n\n# Link length taking into account the section\nl = length - 2*section\n\n# Number of links\ncount = round(cat_len / l)\n\n# The chain\nchain = link*count\n\n# Rotate pi/2 one on two\neulers = Eulers(shape=count)\neulers[[i % 2 == 1 for i in range(count)]] = (0, np.pi/2, 0)\n\nchain.rotate(eulers)\nchain.rotate_z(np.pi/2)\n\n# Location of each link\nt = np.array([cat_inverse(l*i) for i in range(count)])\n\nchain.toward(derivative(t), track_axis='X', up_axis='Z')\nchain.translate(catenary(t))\n\n# To object\nchain.to_object(\"Catenary\")\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.chain_link--arguments","title":"Arguments","text":"<pre><code>- major_segments (int=48) : number of segments for the link\n- minor_segments (int=12) : number of segments for the section\n- radius (float=1.) : radius of the link\n- section (float=.5) : section (diameter)\n- length (float=4.) : total length of the link\n- materials (list of strs = None) : materials list\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.chain_link--returns","title":"Returns","text":"<pre><code>- MeshBuilder\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef chain_link(cls, major_segments=48, minor_segments=12, radius=1., section=0.5, length=4., materials=None):\n    \"\"\" Create a chain link.\n\n    ``` python\n    # ----- Some maths\n\n    # Chain follows a catenary curve\n    def catenary(t):\n        return np.stack((t, np.zeros_like(t), np.cosh(t)), axis=-1)\n\n    # Orientation is given by the derivative\n    def derivative(t):\n        dt = 1/10000\n        return (catenary(t + dt) - catenary(t - dt))/(2*dt)\n\n    # Catenary length\n    pts = catenary(np.linspace(-1, 1, 1000))\n    cat_s = np.cumsum(np.linalg.norm(pts[1:] - pts[:-1], axis=-1))\n    cat_len = cat_s[-1]\n\n    # Catenary inverse : t from length\n    def cat_inverse(l):\n        return 2*np.argmin(np.abs(cat_s - l))/1000 - 1\n\n    # ----- Let's build the geometry\n\n    # One chain link\n    section = .02\n    length  = .15\n    link = MeshBuilder.ChainLink(radius=.04, section=section, length=length)\n\n    # Link length taking into account the section\n    l = length - 2*section\n\n    # Number of links\n    count = round(cat_len / l)\n\n    # The chain\n    chain = link*count\n\n    # Rotate pi/2 one on two\n    eulers = Eulers(shape=count)\n    eulers[[i % 2 == 1 for i in range(count)]] = (0, np.pi/2, 0)\n\n    chain.rotate(eulers)\n    chain.rotate_z(np.pi/2)\n\n    # Location of each link\n    t = np.array([cat_inverse(l*i) for i in range(count)])\n\n    chain.toward(derivative(t), track_axis='X', up_axis='Z')\n    chain.translate(catenary(t))\n\n    # To object\n    chain.to_object(\"Catenary\")\n    ```\n\n    Arguments\n    ---------\n        - major_segments (int=48) : number of segments for the link\n        - minor_segments (int=12) : number of segments for the section\n        - radius (float=1.) : radius of the link\n        - section (float=.5) : section (diameter)\n        - length (float=4.) : total length of the link\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - MeshBuilder\n    \"\"\"\n\n    delta = length - 2*radius\n\n    # Starting from a torus\n    clink = cls.torus(\n        major_radius    = radius, \n        minor_radius    = section/2, \n        major_segments  = major_segments, \n        minor_segments  = minor_segments, \n        materials       = materials\n    )\n    # Nothing else\n    if delta &lt; radius/10:\n        return clink\n\n    epsilon = radius/major_segments\n\n    # Delete half of the points\n    clink.delete_vertices(points=clink.points.y &lt; -epsilon)\n    npoints = len(clink.points)\n    borders = clink.points.y &lt; epsilon\n    loop0 = np.arange(npoints)[np.logical_and(borders, clink.points.x &lt; 0)]\n    loop1 = np.arange(npoints)[np.logical_and(borders, clink.points.x &gt; 0)]\n    clink.points.y += delta/2\n\n    # Duplicate and inverse\n    half = Mesh.from_mesh(clink)\n    half.points.position[:, :2] *= -1\n\n    # Join\n    clink.join(half)\n\n    # Bridge\n    clink.bridge_loops(loop0, loop1 + npoints, close=True)\n    clink.bridge_loops(loop1, loop0 + npoints, close=True)\n\n    # UVMap\n    nu, nv = major_segments + 3, minor_segments + 1\n    uvmap = grid_uv_map(nu, nv).reshape(nu - 1, nv - 1, 4, 2)\n\n    ratio = (length - radius)/(length - radius + np.pi*radius)\n    dx_side = ratio/2\n\n    uvmap[:-2,..., 0] *= (1 - ratio)/(1 - 2/nu)\n    uvmap[-2,:, [0, 3], 0] = 1 - ratio\n    uvmap[-2,:, [1, 2], 0] = 1 - ratio/2\n    uvmap[-1,:, [0, 3], 0] = 1 - ratio/2\n\n    clink.corners.UVMap = uvmap.reshape(-1, 2)\n\n    return clink\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.check","title":"check","text":"<pre><code>check(title='Mesh Check', halt=True)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def check(self, title=\"Mesh Check\", halt=True):\n    ok = self.corners.check(len(self.points), halt=False) and \\\n           self.faces.check(len(self.corners), halt=False) and \\\n           self.edges.check(len(self.points), halt=False)\n    if ok:\n        return True\n    elif halt:\n        raise Exception(f\"{title} check failed\")\n    else:\n        print(f\"{title} check failed\")\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.circle","title":"circle  <code>classmethod</code>","text":"<pre><code>circle(radius=1, segments=16, fill_segments=0, cap='NONE', materials=None)\n</code></pre> <p>Create a Circle.</p> <p>'fill_segments' argument gives the number of internal circles to create. If zero, the circle if filled with a polygon. If positive, the circle is filled with triangle fans.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.circle--arguments","title":"Arguments","text":"<pre><code>- radius (float=1.) : circle radius\n- segments (int=16) : number of segments\n- fill_segments (int = 0) : number of internal segments, polygon is None\n- materials (list of strs = None) : materials list\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.circle--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef circle(cls, radius=1, segments=16, fill_segments=0, cap='NONE', materials=None):\n    \"\"\" Create a Circle.\n\n    'fill_segments' argument gives the number of internal circles to create.\n    If zero, the circle if filled with a polygon.\n    If positive, the circle is filled with triangle fans.\n\n    Arguments\n    ---------\n        - radius (float=1.) : circle radius\n        - segments (int=16) : number of segments\n        - fill_segments (int = 0) : number of internal segments, polygon is None\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    ag = np.linspace(0, 2*np.pi, segments, endpoint=False)\n    x = radius*np.cos(ag)\n    y = radius*np.sin(ag)\n    points = np.stack((x, y, np.zeros_like(x)), axis=-1)\n\n    if cap == 'NONE':\n        i = np.arange(segments)\n        edges = np.stack((i, np.roll(i, shift=-1)), axis=-1)\n        return cls(points=points, edges=edges)\n\n    elif cap == 'NGON':\n        return cls(\n            points      = points, \n            corners     = np.arange(segments), \n            faces       = segments,\n            UVMap       = disk_uv_map(segments, mode='NGON').reshape(-1, 2),\n            materials   = materials,\n        )\n\n    elif cap == 'FANS':\n        points = np.append(points, [[0, 0, 0]], axis=0)\n        topo = fans_corners(segments)\n\n        return cls(\n            points      = points, \n            corners     = topo.ravel(), \n            faces       = 3,\n            UVMap       = disk_uv_map(segments, mode='FANS').reshape(-1, 2),\n            materials   = materials,\n        )\n\n    #mesh = cls(points=points)\n    #mesh.fill_cap(np.arange(segments), mode=cap, center=segments, clockwise=True)\n\n    assert(False)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.clear_geometry","title":"clear_geometry","text":"<pre><code>clear_geometry()\n</code></pre> <p>Clear the geometry.</p> <p>Delete all the content.</p> Source code in <code>npblender/mesh.py</code> <pre><code>def clear_geometry(self):\n    \"\"\" Clear the geometry.\n\n    Delete all the content.\n    \"\"\"\n\n    self.points.clear()\n    self.corners.clear()\n    self.faces.clear()\n    self.edges.clear()\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.compute_attribute_on_domain","title":"compute_attribute_on_domain","text":"<pre><code>compute_attribute_on_domain(domain_from, attr, domain_to)\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def compute_attribute_on_domain(self, domain_from, attr, domain_to):\n\n    if domain_from == domain_to:\n        return attr\n\n    if (domain_from not in self.domain_names) or (domain_to not in self.domain_names):\n        raise AttributeError(\n            f\"The geometry '{type(self).__name__}' doesn't have domains '{domain_from}' and '{domain_to}'.\\n\"\n            f\"Valid domains are: {self.domain_names}.\"\n            )\n\n    if domain_from == 'points':\n        if domain_to == 'faces':\n            return self.points.compute_attribute_on_faces(attr, self.corners, self.faces)\n        elif domain_to == 'edges':\n            return self.points.compute_attribute_on_edges(attr, self.edges)\n        elif domain_to == 'corners':\n            return self.points.compute_attribute_on_corners(attr, self.corners)\n        elif domain_to == 'splines':\n            return self.points.compute_attribute_on_splines(attr, self.splines)\n\n    elif domain_from == 'faces':\n        if domain_to == 'points':\n            return self.faces.compute_attribute_on_points(attr, self.corners, self.points)\n        elif domain_to == 'edges':\n            pass\n        elif domain_to == 'corners':\n            pass\n\n    elif domain_from == 'edges':\n        if domain_to == 'points':\n            return self.edges.compute_attribute_on_points(attr, self.points)\n        elif domain_to == 'faces':\n            pass\n        elif domain_to == 'corners':\n            pass\n\n    elif domain_from == 'corners':\n        if domain_to == 'points':\n            return self.corners.compute_attribute_on_points(attr, self.points)\n        elif domain_to == 'faces':\n            pass\n        elif domain_to == 'edges':\n            pass\n\n    elif domain_from == 'splines':\n        if domain_to == 'points':\n            return self.splines.compute_attribute_on_points(attr, self.points)\n\n    raise Exception(\n        f\"Sorry, computing attribue from '{domain_from}' to '{domain_to}' is not implemented yet.\")\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.compute_attribute_on_domain_OLD","title":"compute_attribute_on_domain_OLD","text":"<pre><code>compute_attribute_on_domain_OLD(attr_name, domain_name)\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def compute_attribute_on_domain_OLD(self, attr_name, domain_name):\n\n    from numba import njit, prange\n\n    # ---------------------------------------------------------------------------\n    # Faces to points\n\n    @njit(cache=True)\n    def _faces_to_points(loop_start, loop_total, vertex_index, source, res):\n        V = res.shape[0]\n        F = loop_start.shape[0]\n\n        count = np.zeros(V, dtype=np.int32)\n        for f in range(F):\n            s, t, val = loop_start[f], loop_total[f], source[f]\n            for k in range(t):\n                v = vertex_index[s + k]\n                res[v] += val\n                count[v] += 1\n\n        trailing = 1\n        for d in range(1, res.ndim):\n            trailing *= res.shape[d]\n\n        R2 = res.reshape((V, trailing))\n        for v in range(V):\n            c = count[v]\n            if c &gt; 0:\n                inv = 1.0 / c\n                for j in range(trailing):\n                    R2[v, j] *= inv\n\n        return res\n\n    # ---------------------------------------------------------------------------\n    # Points to faces\n\n    @njit(cache=True)\n    def _points_to_faces(loop_start, loop_total, vertex_index, source, res):\n        F = loop_start.shape[0]\n\n        for f in range(F):\n            s = loop_start[f]\n            t = loop_total[f]\n            for k in range(t):\n                v = vertex_index[s + k]\n                res[f] += source[v]\n            inv = 1.0 / t\n            res[f] *= inv\n\n        return res\n\n    # ---------------------------------------------------------------------------\n    # Get the source domain for attribute\n    # ---------------------------------------------------------------------------\n\n    source_domain_name = None\n    for name in self.domain_names:\n        source_domain = getattr(self, name)\n        if attr_name in source_domain._infos:\n            source_domain_name = name\n            break\n\n    if source_domain_name is None:\n        raise AttributeError(f\"No domain has an attribute named '{attr_name}'\")\n\n    # ---------------------------------------------------------------------------\n    # Prepare\n    # ---------------------------------------------------------------------------\n\n    domain_name = domain_name.lower()\n\n    source = source_domain[attr_name]\n\n    # Source = Target domain\n    if domain_name == source_domain_name:\n        return source\n\n    # Resulting array\n    item_shape = source_domain._infos[attr_name]['shape']\n    target_domain = getattr(self, domain_name)\n    res = np.zeros((len(target_domain),) + item_shape, dtype=source.dtype)\n    count = None\n\n    # ---------------------------------------------------------------------------\n    # Different cases\n    # ---------------------------------------------------------------------------\n\n    # Faces to points\n    if source_domain_name == 'faces' and domain_name == 'points':\n        if True:\n            res = _faces_to_points(\n                np.ascontiguousarray(self.faces.loop_start, dtype=np.int32),\n                np.ascontiguousarray(self.faces.loop_total, dtype=np.int32),\n                np.ascontiguousarray(self.corners.vertex_index, dtype=np.int32),\n                np.ascontiguousarray(source, dtype=source.dtype),\n                np.ascontiguousarray(res, dtype=res.dtype),\n            )\n\n        else:\n            count = np.zeros(len(target_domain), dtype=int)\n            for loop_start, loop_total, val in zip(self.faces.loop_start, self.faces.loop_total, source):\n                corners = self.corners.vertex_index[loop_start:loop_start+loop_total]\n                res[corners] += val\n                count[corners] += 1\n\n    # Points to faces\n    elif source_domain_name == 'points' and domain_name == 'faces':\n        if True:\n            res = _points_to_faces(\n                np.ascontiguousarray(self.faces.loop_start, dtype=np.int32),\n                np.ascontiguousarray(self.faces.loop_total, dtype=np.int32),\n                np.ascontiguousarray(self.corners.vertex_index, dtype=np.int32),\n                np.ascontiguousarray(source, dtype=source.dtype),\n                np.ascontiguousarray(res, dtype=res.dtype),\n            )\n        else:\n            for i_face, (loop_start, loop_total) in enumerate(zip(self.faces.loop_start, self.faces.loop_total)):\n                corners = self.corners[loop_start:loop_start+loop_total]\n                res[i_face] = np.average(source[corners], axis=0)\n\n    # Edges to points\n    elif source_domain_name == 'edges' and domain_name == 'points':\n        count = np.zeros(len(target_domain), dtype=int)\n        for v0, v1, value in zip(self.edges.vertex0, self.edges.vertex1, source):\n            res[v0] += value\n            res[v1] += value\n            count[v0] += 1\n            count[v1] += 1\n\n    # Points to edges\n    elif source_domain_name == 'points' and domain_name == 'edges':\n        for i_edge, (v0, v1) in enumerate(zip(self.edges.vertex0, self.edges.vertex1)):\n            res[i_edge] = (source[v0] + source[v1])/2\n\n    # Splines to points\n    elif source_domain_name == 'splines' and domain_name == 'points':\n        for loop_start, loop_total, val in zip(self.faces.loop_start, self.faces.loop_total, source):\n            res[loop_start:loop_start+loop_total] = val\n\n    # Points to splines\n    elif source_domain_name == 'points' and domain_name == 'splines':\n        for i_spline, (loop_start, loop_total) in enumerate(zip(self.faces.loop_start, self.faces.loop_total)):\n            res[i_spline] = np.average(source[loop_start:loop_start+loop_total], axis=0)\n\n    # Not implemented\n    else:\n        raise Exception(f\"Sorry: compute_attribute from '{source_domain_name}' to '{domain_name}' domains is not implemented yet.\")\n\n    # ---------------------------------------------------------------------------\n    # Finalization\n    # ---------------------------------------------------------------------------\n\n    if count is not None:\n        if len(item_shape) == 1:\n            count = count[:, None]\n        elif len(item_shape) == 2:\n            count = count[:, None, None]\n\n        res = res/count\n\n    return res\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.cone","title":"cone  <code>classmethod</code>","text":"<pre><code>cone(vertices=32, side_segments=1, fill_segments=1, radius_top=0, radius_bottom=1, depth=2, fill_type='NGON', materials=None)\n</code></pre> <p>Create a Cone.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.cone--arguments","title":"Arguments","text":"<pre><code>- vertices (int=16) : number of segments\n- side_segments (int = 1) : number of vertical segments\n- fill_segments (int = 1) : number of internal circles on the caps\n- radius_top (float=0) : top radius\n- radius_bottom (float=1) : bottom radius\n- depth (float=2.) : cylinder height\n- fill_type (str or couple of strs ='NGON' in 'NGON', 'FANS', 'NONE') : cap filling\n- materials (list of strs = None) : materials list\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.cone--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef cone(cls, vertices=32, side_segments=1, fill_segments=1, radius_top=0, radius_bottom=1, depth=2, fill_type='NGON', materials=None):\n    \"\"\" Create a Cone.\n\n    Arguments\n    ---------\n        - vertices (int=16) : number of segments\n        - side_segments (int = 1) : number of vertical segments\n        - fill_segments (int = 1) : number of internal circles on the caps\n        - radius_top (float=0) : top radius\n        - radius_bottom (float=1) : bottom radius\n        - depth (float=2.) : cylinder height\n        - fill_type (str or couple of strs ='NGON' in 'NGON', 'FANS', 'NONE') : cap filling\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    # Empty geometry if fhe two radius are null\n    if radius_top == 0 and radius_bottom == 0:\n        return cls()\n\n    mesh = cls.bl_cone(\n        radius1       = radius_bottom,\n        radius2       = radius_top,\n        segments      = vertices,\n        side_segments = side_segments,\n        depth         = depth,\n        cap_ends      = fill_type in ['NGON', 'FANS'],\n        cap_tris      = fill_type == 'FANS',\n        materials     = materials,\n    )\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.cube","title":"cube  <code>classmethod</code>","text":"<pre><code>cube(size=2, materials=None)\n</code></pre> <p>Create a Cube.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.cube--arguments","title":"Arguments","text":"<pre><code>- size (float=1.) : size of the cube\n- materials (list of strs = None) : materials list\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.cube--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef cube(cls, size=2, materials=None):\n    \"\"\" Create a Cube.\n\n    Arguments\n    ---------\n        - size (float=1.) : size of the cube\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    verts = [[-1., -1., -1.], [-1., -1.,  1.], [-1.,  1., -1.], [-1.,  1.,  1.], [ 1., -1., -1.], [ 1., -1.,  1.], [ 1.,  1., -1.], [ 1.,  1.,  1.],]\n    corners = [0, 1, 3, 2,  2, 3, 7, 6,  6, 7, 5, 4,  4, 5, 1, 0,  2, 6, 4, 0,  7, 3, 1, 5]\n    faces = [4]*6\n    uvs   = [[0.375, 0.000], [0.625, 0.000], [0.625, 0.250], [0.375, 0.250], [0.375, 0.250], [0.625, 0.250], [0.625, 0.500], [0.375, 0.500],\n             [0.375, 0.500], [0.625, 0.500], [0.625, 0.750], [0.375, 0.750], [0.375, 0.750], [0.625, 0.750], [0.625, 1.000], [0.375, 1.000],\n             [0.125, 0.500], [0.375, 0.500], [0.375, 0.750], [0.125, 0.750], [0.625, 0.500], [0.875, 0.500], [0.875, 0.750], [0.625, 0.750], ]\n\n\n    mesh = cls(points=verts, corners=corners, faces=faces, materials=materials, UVMap=uvs)\n\n    size = np.asarray(size)\n    mesh.points.position *= size/2\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.cylinder","title":"cylinder  <code>classmethod</code>","text":"<pre><code>cylinder(vertices=32, side_segments=1, radius=1, depth=2, fill_type='NGON', materials=None)\n</code></pre> <p>Create a Cylinder.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.cylinder--arguments","title":"Arguments","text":"<pre><code>- vertices (int=16) : number of segments\n- side_segments (int = 1) : number of vertical segments\n- radius (float=1.) : radius\n- depth (float=2.) : cylinder height\n- fill_type (str or couple of strs ='NGON' in 'NGON', 'TRIANGLE_FAN', 'NONE') : cap filling\n- materials (list of strs = None) : materials list\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.cylinder--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef cylinder(cls, vertices=32, side_segments=1, radius=1, depth=2, fill_type='NGON', materials=None):\n    \"\"\" Create a Cylinder.\n\n    Arguments\n    ---------\n        - vertices (int=16) : number of segments\n        - side_segments (int = 1) : number of vertical segments\n        - radius (float=1.) : radius\n        - depth (float=2.) : cylinder height\n        - fill_type (str or couple of strs ='NGON' in 'NGON', 'TRIANGLE_FAN', 'NONE') : cap filling\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    mesh = cls.bl_cone(\n        radius1       = radius,\n        radius2       = radius,\n        segments      = vertices,\n        side_segments = side_segments,\n        depth         = depth,\n        cap_ends      = fill_type in ['NGON', 'FANS'],\n        cap_tris      = fill_type == 'FANS',\n        materials     = materials,\n    )\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.delete_faces","title":"delete_faces","text":"<pre><code>delete_faces(selection)\n</code></pre> <p>Delete only faces.</p> Source code in <code>npblender/mesh.py</code> <pre><code>def delete_faces(self, selection):\n    \"\"\" Delete only faces.\n    \"\"\"\n    self.faces.delete_loops(selection, self.corners)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.delete_vertices","title":"delete_vertices","text":"<pre><code>delete_vertices(points=None, faces=None, edges=None)\n</code></pre> <p>Delete vertices.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.delete_vertices--arguments","title":"Arguments","text":"<pre><code>points : array selection, optional\n    Vertex indices to delete directly.\nfaces : array selection, optional\n    Faces owning vertices to delete.\nedges : array selection, optional\n    Edges owning vertices to delete.\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def delete_vertices(self, points=None, faces=None, edges=None):\n    \"\"\"Delete vertices.\n\n    Arguments\n    ---------\n        points : array selection, optional\n            Vertex indices to delete directly.\n        faces : array selection, optional\n            Faces owning vertices to delete.\n        edges : array selection, optional\n            Edges owning vertices to delete.\n    \"\"\"\n    go = False\n    if points is not None:\n        p_sel = set(np.arange(len(self.points))[points])\n        go = True\n    if faces is not None:\n        f_sel = set(np.arange(len(self.faces))[faces])\n        go = True\n    if edges is not None:\n        e_sel = set(np.arange(len(self.edges))[edges])\n        go = True\n\n    if not go:\n        return \n\n    with self.bmesh() as bm:\n        verts_to_delete = set()\n\n        for vert in bm.verts:\n            if points is not None and vert.index in p_sel:\n                verts_to_delete.add(vert)\n                continue\n\n            if faces is not None:\n                if any(f.index in f_sel for f in vert.link_faces):\n                    verts_to_delete.add(vert)\n                    continue\n\n            if edges is not None:\n                if any(e.index in e_sel for e in vert.link_edges):\n                    verts_to_delete.add(vert)\n                    continue\n\n        bmesh.ops.delete(bm, geom=list(verts_to_delete), context='VERTS')\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.disk","title":"disk  <code>classmethod</code>","text":"<pre><code>disk(radius=1, segments=16, fill_segments=0, cap='NGON', materials=None)\n</code></pre> <p>Create a disk.</p> <p>Same as circle but default cap is NGON</p> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef disk(cls, radius=1, segments=16, fill_segments=0, cap='NGON', materials=None):\n    \"\"\" Create a disk.\n\n    Same as circle but default cap is NGON\n    \"\"\"    \n    return cls.circle(radius=radius, segments=segments, fill_segments=fill_segments, cap=cap, materials=materials)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.dual","title":"dual","text":"<pre><code>dual(center='median')\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def dual(self, center=\"median\"):\n\n    verts = np.empty((len(self.faces), 3), np.float32)\n    corners = []\n    faces = []\n\n    with self.bmesh() as bm:\n\n        bm.faces.ensure_lookup_table()\n        bm.verts.ensure_lookup_table()    \n        bm.edges.ensure_lookup_table()    \n\n        # ---------------------------------------------------------------------------\n        # Faces become points\n        # ---------------------------------------------------------------------------\n\n        if center.lower() == 'median':\n            for f in bm.faces:\n                c = f.calc_center_median()\n                verts[f.index] = (c.x, c.y, c.z)\n\n        elif center.lower() == 'bounds':\n            for f in bm.faces:\n                c = f.calc_center_bounds()\n                verts[f.index] = (c.x, c.y, c.z)\n\n        elif center.lower() == 'weighted':\n            for f in bm.faces:\n                c = f.calc_center_median_weighted()\n                verts[f.index] = (c.x, c.y, c.z)\n\n        else:\n            raise ValueError(f\"Center must be in ('median', 'bounds','weighted').\")\n\n        # ---------------------------------------------------------------------------\n        # Vertices becom faces\n        # ---------------------------------------------------------------------------\n\n        for v in bm.verts:\n            # Faces need to be ordered (link_faces is not good)\n            # Get the edges as couples (face.index, face.index)\n            # then chain the edges\n\n            couples = []\n            first = True\n            for edge in v.link_edges:\n\n                if len(edge.link_faces) != 2:\n                    couples = []\n                    break\n\n                # First is used for the order between:\n                # - face0 then face1\n                # - face1 then face0\n                if first:\n                    first = False\n\n                    # The edge links two vertices\n                    other_index = edge.verts[0].index if edge.verts[1].index == v.index else edge.verts[1].index\n\n                    # We select as first face the one where loop is v -&gt; other                \n                    face0 = edge.link_faces[0]\n                    for i_loop, lp in enumerate(face0.loops):\n                        if lp.vert.index == other_index:\n                            j = (i_loop + 1)%len(face0.loops)\n                            take0 = face0.loops[j].vert.index == v.index\n                            break\n\n                    if take0:\n                        loop = [edge.link_faces[0].index, edge.link_faces[1].index]\n                    else:\n                        loop = [edge.link_faces[1].index, edge.link_faces[0].index]\n\n                else:\n                    couples.append((edge.link_faces[0].index, edge.link_faces[1].index))\n\n            if len(couples) &lt; 2:\n                continue\n\n            # Build the other faces by chaing the edges \n            # First loop to consume the edge couples      \n            for _ in range(len(couples)):\n                found = False\n                # Second loop to find the following edge\n                for i, e in enumerate(couples):\n                    if e[0] == loop[-1]:\n                        loop.append(e[1])\n                        found = True\n                    elif e[1] == loop[-1]:\n                        loop.append(e[0])\n                        found = True\n                    else:\n                        continue\n                    break\n\n                if found:\n                    del couples[i]\n                else:\n                    loop = []\n                    break\n\n            if len(loop) &lt; 3:\n                continue\n\n            faces.append(len(loop))\n            corners.extend(loop)\n\n    # We can build the dual mesh\n    return Mesh(points=verts, corners=corners, faces=faces, materials=self.materials)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.dummy","title":"dummy  <code>classmethod</code>","text":"<pre><code>dummy(points_count=0, corners_count=0, faces=None, edges=None, seed=0, **attrs)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef dummy(cls, points_count=0, corners_count=0, faces=None, edges=None, seed=0, **attrs):\n    rng = np.random.default_rng(seed)\n    verts = rng.uniform(-1, 1, (points_count, 3)) if points_count else None\n    corners = rng.uniform(0, points_count, corners_count) if corners_count else None\n    loops = None\n\n    if faces is None:\n        n = corners_count if corners_count else points_count\n        if n &gt; 0:\n            loops = [4] * (n //4)\n            loops[0] = n - np.sum(loops[1:])\n        else:\n            loops = None\n    else:\n        loops = faces\n\n    return cls(points=verts, corners=corners, faces=loops, edges=edges,**attrs)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_faces","title":"extrude_faces","text":"<pre><code>extrude_faces(selection, offset=None, scale=1.0)\n</code></pre> <p>Extrude individual faces.</p> <p>If offset is None, faces are extruder along their normal</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_faces--arguments","title":"Arguments","text":"<pre><code>- selection : indices of the faces to extrude\n- offset (vector or array of vectors) : the extrusion vector\n- scale (float = 1) : scale factor for offsets\n- dissolve (bool = True) : remove starting faces\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_faces--returns","title":"Returns","text":"<pre><code>- dictionnary : 'top' : extruded faces, 'side' : extruded side faces\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def extrude_faces(self, selection, offset=None, scale=1.):\n    \"\"\" Extrude individual faces.\n\n    If offset is None, faces are extruder along their normal\n\n    Arguments\n    ---------\n        - selection : indices of the faces to extrude\n        - offset (vector or array of vectors) : the extrusion vector\n        - scale (float = 1) : scale factor for offsets\n        - dissolve (bool = True) : remove starting faces\n\n    Returns\n    -------\n        - dictionnary : 'top' : extruded faces, 'side' : extruded side faces\n    \"\"\"\n\n    # Selected faces indices\n    faces_sel = np.arange(len(self.faces))\n    if selection is not None:\n        faces_sel = faces_sel[selection]\n\n    # bmesh edition\n    with self.bmesh() as bm:\n        #bm.verts.ensure_lookup_table()\n        bm.faces.ensure_lookup_table()\n\n        # select faces\n        start_faces = [bm.faces[i] for i in faces_sel]\n\n        res = {'top': [], 'side': []}\n\n        # bmesh.ops\n        d = bmesh.ops.extrude_discrete_faces(bm, faces=start_faces)\n        new_faces = d[\"faces\"]\n\n\n\n        # One direction per face\n        if offset is not None:\n            shape = np.broadcast_shapes(np.shape(offset), (len(new_faces), 3))\n            offsets = np.broadcast_to(offset, shape)*scale\n\n        # Loop on created faces\n        for i_face, face in enumerate(new_faces):\n            verts = face.verts\n            if offset is None:\n                ofs = face.normal*scale\n            else:\n                ofs = offsets[i_face]\n\n            bmesh.ops.translate(bm, verts=list(verts), vec=ofs)\n\n            res['top'].append(face.index)\n            for e in face.edges:\n                assert(len(e.link_faces) == 2)\n                if e.link_faces[0].index == face.index:\n                    res['side'].append(e.link_faces[1].index)\n                else:\n                    res['side'].append(e.link_faces[0].index)\n\n    return res\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_loop","title":"extrude_loop","text":"<pre><code>extrude_loop(loop, offset, close=False, clockwise=False, **attributes)\n</code></pre> <p>Extrude a loop of vertices.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_loop--arguments","title":"Arguments","text":"<pre><code>- loop (array of ints) : vertex indices\n- offset (float = 1) : multiplicator of the direction vector\n- direction (vector = None) : extrusion direction, normal if None\n- clockwise (bool=False) : faces orientation\n- attributes : attribute for the new geometry\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_loop--returns","title":"Returns","text":"<pre><code>- dictionnary of the created geometry : vertex indices, face indices\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def extrude_loop(self, loop, offset, close=False, clockwise=False, **attributes):\n    \"\"\" Extrude a loop of vertices.\n\n    Arguments\n    ---------\n        - loop (array of ints) : vertex indices\n        - offset (float = 1) : multiplicator of the direction vector\n        - direction (vector = None) : extrusion direction, normal if None\n        - clockwise (bool=False) : faces orientation\n        - attributes : attribute for the new geometry\n\n    Returns\n    -------\n        - dictionnary of the created geometry : vertex indices, face indices\n    \"\"\"\n    loop = np.atleast_1d(loop)\n    if len(loop) &lt; 2:\n        return None\n\n    verts = self.points.position[loop]\n    try:\n        new_verts = verts + offset\n    except Exception as e:\n        raise AttributeError(\n            f\"Extrude&gt; Offset argument must be a single vector or an array of {len(verts)} vectors, not {np.shape(offset)}.\"\n            )\n\n    indices = np.append(loop, len(self.points) + np.arange(len(new_verts)))\n    gc = grid_corners(len(verts), 2, row_first=True, close_x=close, clockwise=clockwise)\n    corners = indices[gc.ravel()]\n    uvmap = grid_uv_map(len(verts), 2, close_x=close, clockwise=clockwise).reshape(-1, 2)\n\n    return self.add_geometry(points=new_verts, corners=corners, faces=4, UVMap=uvmap)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_region","title":"extrude_region","text":"<pre><code>extrude_region(selection, offset=(0, 0, 1), dissolve=False)\n</code></pre> <p>Extrude individual faces.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_region--arguments","title":"Arguments","text":"<pre><code>- selection : indices of the faces to extrude\n- offset (vector = (0, 0, 1)) : the extrusion vector\n- dissolve (bool = True) : remove starting faces\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_region--returns","title":"Returns","text":"<pre><code>- dictionnary : 'top' : extruded faces, 'side' : extruded side faces\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def extrude_region(self, selection, offset=(0, 0, 1), dissolve=False):\n    \"\"\" Extrude individual faces.\n\n    Arguments\n    ---------\n        - selection : indices of the faces to extrude\n        - offset (vector = (0, 0, 1)) : the extrusion vector\n        - dissolve (bool = True) : remove starting faces\n\n    Returns\n    -------\n        - dictionnary : 'top' : extruded faces, 'side' : extruded side faces\n    \"\"\"\n\n    # Selected faces indices\n    faces_sel = np.arange(len(self.faces))\n    if selection is not None:\n        faces_sel = faces_sel[selection]\n\n    # bmesh edition\n    with self.bmesh() as bm:\n        #bm.verts.ensure_lookup_table()\n        bm.faces.ensure_lookup_table()\n\n        # select faces\n        start_faces = [bm.faces[i] for i in faces_sel]\n\n        res = {'top': [], 'side': []}\n\n\n        # Extrusion\n        d = bmesh.ops.extrude_face_region(\n            bm, \n            geom                      = start_faces,\n            #edges_exclude            = set(),\n            #use_keep_orig            = False,\n            #use_normal_flip          = False,\n            #use_normal_from_adjacent = False,\n            #use_dissolve_ortho_edges = False,\n            #use_select_history       = False,\n            )\n\n        # Move new vectors\n        extruded_geom = d[\"geom\"]\n        new_verts = [ele for ele in extruded_geom if isinstance(ele, bmesh.types.BMVert)]\n        new_faces = [ele for ele in extruded_geom if isinstance(ele, bmesh.types.BMFace)]\n\n        bmesh.ops.translate(bm, verts=new_verts, vec=list(offset))\n\n        # ===== Result\n        for face in new_faces:\n            res['top'].append(face.index)\n            for e in face.edges:\n                assert(len(e.link_faces) == 2)\n                if e.link_faces[0].index == face.index:\n                    res['side'].append(e.link_faces[1].index)\n                else:\n                    res['side'].append(e.link_faces[0].index)\n\n        # ===== Dissolve extruded faces\n        if dissolve:\n            bm.faces.ensure_lookup_table()\n            del_faces = [bm.faces[i] for i in faces_sel]\n\n            bmesh.ops.delete(bm, geom=del_faces, context='FACES')                   \n\n    return res\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_vertices","title":"extrude_vertices","text":"<pre><code>extrude_vertices(selection, offset, **attributes)\n</code></pre> <p>Extrude individual vertices</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_vertices--arguments","title":"Arguments","text":"<pre><code>- selection (selector) : points selection, all if None\n- offset (vector or array of vectors) : extrusion vector\n- attributes (dict) : points attributes\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_vertices--returns","title":"Returns","text":"<pre><code>- dictionnary of the created geometry : vertex indices, face indices\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def extrude_vertices(self, selection, offset, **attributes):\n    \"\"\" Extrude individual vertices\n\n    Arguments\n    ---------\n        - selection (selector) : points selection, all if None\n        - offset (vector or array of vectors) : extrusion vector\n        - attributes (dict) : points attributes\n\n    Returns\n    -------\n        - dictionnary of the created geometry : vertex indices, face indices\n    \"\"\"\n    inds = np.arange(len(self.points))\n    if selection is not None:\n        inds = inds[selection]\n\n    pos = self.points.position[inds] + offset\n    new_inds = np.arange(len(pos)) + len(self.points)\n    edges = edges_between(inds, new_inds)\n\n    return self.add_geometry(points=pos, edges=edges.reshape(-1, 2), **attributes)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.faces_neighbors","title":"faces_neighbors","text":"<pre><code>faces_neighbors()\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def faces_neighbors(self):\n\n    offset = 0\n    neighbors = []\n\n    with self.bmesh() as bm:           \n        bm.faces.ensure_lookup_table()\n\n        for face in bm.faces:\n            ns = set()\n            for edge in face.edges:\n                ns = ns.union([edge.link_faces[0].index, edge.link_faces[1].index])\n            ns.remove(face.index)\n            neighbors.append(list(ns))\n\n    return neighbors\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.fill_cap","title":"fill_cap","text":"<pre><code>fill_cap(loop, mode='NGON', center=None, segments=1, clockwise=False, **attributes)\n</code></pre> <p>Fill a cap between an existing loop</p> <p>For NGON mode, center is not required. For FANS mode, a center point is required: - if center is None, it is computed as the center of the loop - if center is an int, it is the index of the point to use - otherwise, the center is considered as the point to use</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.fill_cap--arguments","title":"Arguments","text":"<ul> <li>loop (array of ints) : the circle loop</li> <li>mode (FillCap = 'NGON') : NGON or FANS</li> <li>center (point index or point or None) : center of the cap</li> <li>clockwise (bool = False) : order of the corners in the loop</li> <li>indexing (str = 'ij') : indexing of the points</li> <li>attributes (dict) : attributes to add to the mesh (see Geometry.add_geometry(</li> </ul> Source code in <code>npblender/mesh.py</code> <pre><code>def fill_cap(self, loop, mode='NGON', center=None, segments=1, clockwise=False, **attributes):\n    \"\"\" Fill a cap between an existing loop\n\n    For NGON mode, center is not required.\n    For FANS mode, a center point is required:\n    - if center is None, it is computed as the center of the loop\n    - if center is an int, it is the index of the point to use\n    - otherwise, the center is considered as the point to use\n\n    Arguments\n    ---------\n    - loop (array of ints) : the circle loop\n    - mode (FillCap = 'NGON') : NGON or FANS\n    - center (point index or point or None) : center of the cap\n    - clockwise (bool = False) : order of the corners in the loop\n    - indexing (str = 'ij') : indexing of the points\n    - attributes (dict) : attributes to add to the mesh (see Geometry.add_geometry(\n    \"\"\"\n    if mode == 'NONE':\n        # To have en empty dict\n        return self.add_geometry()\n\n    elif mode == 'NGON':\n        return self.add_geometry(corners=loop, faces=len(loop), UVMap=self.disk_uv_map(len(loop), mode='NGON', clockwise=clockwise), **attributes)\n\n    elif mode == 'FANS':\n\n        if center is None:\n            verts = self.points.position[loop]\n            center = np.average(verts, axis=0)\n            center_index = len(self.points)\n            cind = self.add_points(center)\n\n        elif isinstance(center, (int, np.int32, np.int64)):\n            center_index = center\n            cind = [center_index]\n\n        else:\n            center_index = len(self.points)\n            cind = self.add_points(center)\n\n        indices = np.append(loop, center_index)\n\n        topo = fans_corners(len(loop), close=True, clockwise=clockwise).ravel()\n\n        corners = indices[topo]\n        uv_map = disk_uv_map(len(loop), mode='FANS', clockwise=clockwise).reshape(-1, 2)\n\n        added = self.add_geometry(corners=corners, faces=3, UVMap=uv_map, **attributes)\n        added['points'] = np.asarray(cind)\n\n        # More than one segments\n\n        if segments &gt; 1:\n            self.split_edges(loop, center_index, cuts=segments - 1)\n\n        return added\n\n    assert(False)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef from_dict(cls, d):\n    mesh = cls()\n    mesh.materials  = d['materials']\n    mesh.points     = Vertex.from_dict(d['points'])\n    mesh.corners    = Corner.from_dict(d['corners'])\n    mesh.faces      = Face.from_dict(d['faces'])\n    mesh.edges      = Edge.from_dict(d['edges'])\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_mesh","title":"from_mesh  <code>classmethod</code>","text":"<pre><code>from_mesh(other, points=None, faces=None, edges=None)\n</code></pre> <p>Create a Mesh from another mesh.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_mesh--arguments","title":"Arguments","text":"<pre><code>- other (Mesh) : the mesh to copy\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_mesh--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef from_mesh(cls, other, points=None, faces=None, edges=None):\n    \"\"\" Create a Mesh from another mesh.\n\n    Arguments\n    ---------\n        - other (Mesh) : the mesh to copy\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    mesh = cls(materials=other.materials)\n    mesh.points  = Vertex(other.points,  mode='COPY')\n    mesh.corners = Corner(other.corners, mode='COPY')\n    mesh.faces   = Face(other.faces,   mode='COPY')\n    mesh.edges   = Edge(other.edges,    mode='COPY')\n\n    if points is None:\n        points_mask = None\n    else:\n        points_mask = np.ones(len(mesh.points), dtype=bool)\n        points_mask[points] = False\n\n    if faces is None:\n        faces_mask = None\n    else:\n        faces_mask = np.ones(len(mesh.faces), dtype=bool)\n        faces_mask[faces] = False\n\n    if edges is None:\n        edges_mask = None\n    else:\n        edges_mask = np.ones(len(mesh.edges), dtype=bool)\n        edges_mask[edges] = False\n\n    mesh.delete_vertices(points=points_mask, faces=faces_mask, edges=edges_mask)\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_mesh_data","title":"from_mesh_data  <code>classmethod</code>","text":"<pre><code>from_mesh_data(data)\n</code></pre> <p>Initialize the geometry from a Blender Mesh</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_mesh_data--arguments","title":"Arguments","text":"<pre><code>- mesh (Blender Mesh instance) : the mesh to load\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef from_mesh_data(cls, data):\n    \"\"\" Initialize the geometry from a Blender Mesh\n\n    Arguments\n    ---------\n        - mesh (Blender Mesh instance) : the mesh to load\n    \"\"\"\n\n    from . import blender\n\n    bl_mesh = blender.get_mesh(data)\n\n    mesh = cls()\n\n    # ----- Materials\n\n    mesh.materials = [None if mat is None else mat.name for mat in bl_mesh.materials]\n\n    # ----- Vertices\n\n    n = len(bl_mesh.vertices)\n    if n != 0:\n        # Positions will be read as position attribute\n        mesh.points.resize(n)\n\n    # ----- Corners\n\n    n = len(bl_mesh.polygons)\n    if n != 0:\n        a = np.empty(len(bl_mesh.loops), bint)\n        bl_mesh.loops.foreach_get(\"vertex_index\", a)\n        mesh.corners.append(vertex_index=a)\n\n        a = np.empty(len(bl_mesh.polygons), bint)\n        bl_mesh.polygons.foreach_get(\"loop_total\", a)\n        mesh.faces.append_sizes(a)\n\n        del a\n\n    # ----- Edges\n\n    if len(bl_mesh.edges):\n        n = len(bl_mesh.edges)\n        a = np.empty(2*n, bint)\n        bl_mesh.edges.foreach_get(\"vertices\", a)\n        a = np.reshape(a, (n, 2))\n        mesh.edges.append(vertex0=a[:, 0], vertex1=a[:, 1])\n\n        del a\n\n        mesh.edges.remove_face_edges(mesh.faces.get_edges(mesh.corners))\n\n    # ----- Attributes\n\n    mesh.points.from_bl_attributes(bl_mesh.attributes)\n    mesh.corners.from_bl_attributes(bl_mesh.attributes)\n    mesh.faces.from_bl_attributes(bl_mesh.attributes)\n    mesh.edges.from_bl_attributes(bl_mesh.attributes)\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_model","title":"from_model  <code>classmethod</code>","text":"<pre><code>from_model(model, materials=None)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef from_model(cls, model, materials=None):\n\n    if isinstance(model, (str, bpy.types.Object)):\n        mesh = cls.from_object(model, evaluated=True)\n\n    elif isinstance(model, dict):\n        mesh = cls.from_dict(model)\n\n    elif isinstance(model, Mesh):\n        mesh = cls.from_mesh(model)\n\n    elif isinstance(model, bpy.types.Mesh):\n        mesh = cls.from_mesh_data(model)\n\n    else:\n        raise Exception(f\"Mesh.from_model: 'model' type is not valid: {type(model)}\")\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_object","title":"from_object  <code>classmethod</code>","text":"<pre><code>from_object(obj, evaluated=False)\n</code></pre> <p>Create a Mesh from an existing object.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_object--arguments","title":"Arguments","text":"<pre><code>- obj (str or Blender object) : the object to initialize from\n- evaluated (bool = False) : object modified by the modifiers if True, raw vertices otherwise\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_object--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef from_object(cls, obj, evaluated=False):\n    \"\"\" Create a Mesh from an existing object.\n\n    Arguments\n    ---------\n        - obj (str or Blender object) : the object to initialize from\n        - evaluated (bool = False) : object modified by the modifiers if True, raw vertices otherwise\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    from . import blender\n\n    if evaluated:\n        depsgraph = bpy.context.evaluated_depsgraph_get()\n        object_eval = blender.get_object(obj).evaluated_get(depsgraph)\n        return cls.FromMeshData(object_eval.data)\n\n    else:\n        return cls.from_mesh_data(blender.get_object(obj).data)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_cubic_envelop","title":"get_cubic_envelop","text":"<pre><code>get_cubic_envelop()\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def get_cubic_envelop(self):\n    from . mesh import Mesh\n\n    size = self.bounding_box_dims\n    return Mesh.cube(size=size, materials=getattr(self, \"materials\", None))\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_faces_position","title":"get_faces_position","text":"<pre><code>get_faces_position(selection=None)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def get_faces_position(self, selection=None):\n    if selection is None:\n        return self.faces[selection].get_position(self.corners, self.points)\n    else:\n        return self.faces[selection].get_position(self.corners, self.points)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_islands","title":"get_islands","text":"<pre><code>get_islands()\n</code></pre> <p>Get an island id per face.</p> Source code in <code>npblender/mesh.py</code> <pre><code>def get_islands(self):\n    \"\"\" Get an island id per face.\n    \"\"\"\n    from collections import deque\n\n    nfaces = len(self.faces)\n    if not nfaces:\n        return []\n\n    islands = np.full(nfaces, -1, dtype=np.int32)\n    cur_island = -1\n\n    passed = np.zeros(nfaces, dtype=bool)\n\n    with self.bmesh() as bm:\n        bm.faces.ensure_lookup_table()\n        bm.edges.ensure_lookup_table()\n\n        for f in bm.faces:\n            # Already visited\n            if islands[f.index] &gt;= 0:\n                continue\n\n            # New island index\n            cur_island += 1\n\n            q = deque([f])\n            while q:\n                cur = q.popleft()\n\n                # Part of the current island\n                islands[cur.index] = cur_island\n\n                # No infinite loop\n                passed[cur.index] = True\n\n                # Loop on the edges\n                for e in cur.edges:                                               \n                    # Loop on the edge faces\n                    for nb in e.link_faces:\n                        if passed[nb.index]:\n                            continue\n                        passed[nb.index] = True\n\n                        if islands[nb.index] &lt; 0:\n                            q.append(nb)\n\n\n    return islands\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_material_index","title":"get_material_index","text":"<pre><code>get_material_index(mat_name)\n</code></pre> <p>Return the index of a material name.</p> <p>If the material doesn't exist, it is created</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_material_index--arguments","title":"Arguments","text":"<pre><code>- mat_name (str) : material name\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_material_index--returns","title":"Returns","text":"<pre><code>- int : index of the material name in the materials list\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def get_material_index(self, mat_name):\n    \"\"\" Return the index of a material name.\n\n    If the material doesn't exist, it is created\n\n    Arguments\n    ---------\n        - mat_name (str) : material name\n\n    Returns\n    -------\n        - int : index of the material name in the materials list\n    \"\"\"\n\n    if mat_name in self.materials:\n        return self.materials.index(mat_name)\n    else:\n        self.materials.append(mat_name)\n        return len(self.materials)-1\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_points_selection","title":"get_points_selection","text":"<pre><code>get_points_selection()\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def get_points_selection(self):\n    return slice(None)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.grid","title":"grid  <code>classmethod</code>","text":"<pre><code>grid(size_x=1, size_y=1, vertices_x=3, vertices_y=3, materials=None)\n</code></pre> <p>Create a Grid.</p> <p>[!IMPORTANT] Grid is created with indexing = 'ij': shape = (resolution x, resolution y)</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.grid--arguments","title":"Arguments","text":"<pre><code>- size_x (float=1) : size along x\n_ size_y (float=1) : size along y\n- vertices_x (int=3) : number of vertices along x\n- vertices_y (int=3) : number of vertices along y\n- materials (list of strs = None) : materials list\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.grid--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef grid(cls, size_x=1, size_y=1, vertices_x=3, vertices_y=3, materials=None):\n    \"\"\" Create a Grid.\n\n    &gt; [!IMPORTANT]\n    &gt; Grid is created with indexing = 'ij': shape = (resolution x, resolution y)\n\n    Arguments\n    ---------\n        - size_x (float=1) : size along x\n        _ size_y (float=1) : size along y\n        - vertices_x (int=3) : number of vertices along x\n        - vertices_y (int=3) : number of vertices along y\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    nx = max(2, vertices_x)\n    ny = max(2, vertices_y)\n\n    topo = grid_corners(nx, ny).ravel()\n\n    # ----------------------------------------------------------------------------------------------------\n    # Base grid for points and uvs\n\n    x, y = np.meshgrid(\n        np.linspace(-size_x/2, size_x/2, nx, dtype=bfloat), \n        np.linspace(-size_y/2, size_y/2, ny, dtype=bfloat), \n        indexing='ij')\n    x, y = x.ravel(), y.ravel()\n\n    # ----------------------------------------------------------------------------------------------------\n    # Let 's build the grid\n\n    points = np.stack((x, y, np.zeros_like(x)), axis=-1)\n    corners = np.arange(len(points))[topo]\n    faces = 4\n    uvmap = grid_uv_map(nx, ny).reshape(-1, 2)\n\n    return cls(points, corners, faces, materials=materials, UVMap=uvmap)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.icosphere","title":"icosphere  <code>classmethod</code>","text":"<pre><code>icosphere(radius=1, subdivisions=2, materials=None)\n</code></pre> <p>Create a IcoSphere.</p> <p>Blender constructor for a IcoSphere.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.icosphere--arguments","title":"Arguments","text":"<pre><code>- radius (float=1.) : radius\n- subdivisions (int=2) : number subdivisions\n- materials (list of strs = None) : materials list\n- transformation (Transformations = None) : the transformation to apply\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.icosphere--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef icosphere(cls, radius=1, subdivisions=2, materials=None):\n    \"\"\" Create a IcoSphere.\n\n    Blender constructor for a IcoSphere.\n\n    Arguments\n    ---------\n        - radius (float=1.) : radius\n        - subdivisions (int=2) : number subdivisions\n        - materials (list of strs = None) : materials list\n        - transformation (Transformations = None) : the transformation to apply\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    subdivisions = min(10, subdivisions)\n\n    mesh = cls(materials=materials)\n    with mesh.bmesh() as bm:\n        bmesh.ops.create_icosphere(bm, subdivisions=subdivisions, radius=radius, calc_uvs=True)\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.inset_faces","title":"inset_faces","text":"<pre><code>inset_faces(selection, thickness=0.1, depth=0.0, use_even_offset=True, use_relative_offset=False)\n</code></pre> <p>Extrude individual faces.</p> <p>If offset is None, faces are extruder along their normal</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.inset_faces--arguments","title":"Arguments","text":"<p>selection : selection on faces     indices of the faces to inset thickness : float     Inset thickness. depth : float     Inset depth (extrusion). use_even_offset : bool     Keep consistent thickness. use_relative_offset : bool     Offset relative to face size.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.inset_faces--returns","title":"Returns","text":"<p>dict with:     'faces' : list of new inset faces</p> Source code in <code>npblender/mesh.py</code> <pre><code>def inset_faces(self, selection, thickness=0.1, depth=0.0, use_even_offset=True, use_relative_offset=False):\n    \"\"\" Extrude individual faces.\n\n    If offset is None, faces are extruder along their normal\n\n    Arguments\n    ---------\n    selection : selection on faces\n        indices of the faces to inset\n    thickness : float\n        Inset thickness.\n    depth : float\n        Inset depth (extrusion).\n    use_even_offset : bool\n        Keep consistent thickness.\n    use_relative_offset : bool\n        Offset relative to face size.\n\n    Returns\n    -------\n    dict with:\n        'faces' : list of new inset faces\n    \"\"\"\n\n    # Selected faces indices\n    faces_sel = np.arange(len(self.faces))\n    if selection is not None:\n        faces_sel = faces_sel[selection]\n\n    # bmesh edition\n    with self.bmesh() as bm:\n        bm.faces.ensure_lookup_table()\n\n        # select faces\n        start_faces = [bm.faces[i] for i in faces_sel]\n\n        res = {'top': [], 'side': []}\n\n        # bmesh.ops\n        d = bmesh.ops.inset_individual(\n            bm,\n            faces               = start_faces,\n            thickness           = thickness,\n            depth               = depth,\n            use_even_offset     = use_even_offset,\n            use_relative_offset = use_relative_offset,\n        )\n\n        res = {\n            'top': faces_sel,\n            'side': [face.index for face in d[\"faces\"]]\n        }\n\n    return res\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.join","title":"join","text":"<pre><code>join(*others)\n</code></pre> <p>Join other Meshes.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.join--arguments","title":"Arguments","text":"<pre><code>- others (Mesh) : the Mesh to append\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def join(self, *others):\n    \"\"\" Join other Meshes.\n\n    Arguments\n    ---------\n        - others (Mesh) : the Mesh to append\n    \"\"\"\n    for other in others:\n\n        # ----------------------------------------------------------------------------------------------------\n        # Vertices\n\n        v_ofs = len(self.points)\n        self.points.extend(other.points)\n\n        # ----------------------------------------------------------------------------------------------------\n        # Corners\n\n        c_ofs = len(self.corners)\n        self.corners.extend(other.corners)\n        if len(self.corners):\n            self.corners.vertex_index[c_ofs:] += v_ofs\n\n        # ----------------------------------------------------------------------------------------------------\n        # Faces\n\n        f_ofs = len(self.faces)\n        self.faces.extend(other.faces)\n        if len(self.faces):\n            self.faces.loop_start[f_ofs:] += c_ofs\n\n        # ----------------------------------------------------------------------------------------------------\n        # Edges\n\n        e_ofs = len(self.edges)\n        self.edges.extend(other.edges)\n        if len(self.edges):\n            self.edges.vertex0[e_ofs:] += v_ofs\n            self.edges.vertex1[e_ofs:] += v_ofs\n\n        # ----- Materials\n\n        remap = np.array([self.get_material_index(mat_name) for mat_name in other.materials])\n        if len(remap)&gt;0:\n            self.faces.material_index[f_ofs:] = remap[other.faces.material_index]\n\n    return self\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other, **kwargs)\n</code></pre> <p>Capture the attributes from another geometry.</p> <p>Other can be a different geometry, in that case, only domains with the same name are captured. kwargs allows to filter the domains to capture:</p> <pre><code>mesh.join_attributes(other_mesh, faces=False)\nmesh.join_attributes(curve)\n</code></pre> <p>Returns:</p> Type Description <ul> <li>self</li> </ul> Source code in <code>npblender/geometry.py</code> <pre><code>def join_attributes(self, other, **kwargs):\n    \"\"\" Capture the attributes from another geometry.\n\n    Other can be a different geometry, in that case, only domains with the same name are captured.\n    kwargs allows to filter the domains to capture:\n\n    ```python\n    mesh.join_attributes(other_mesh, faces=False)\n    mesh.join_attributes(curve)\n    ```\n\n    Returns:\n        - self\n    \"\"\"\n    if other is None:\n        return self\n\n    for name in self.domain_names:\n        if name in other.domain_names and kwargs.get(name, True):\n            getattr(self, name).join_fields(getattr(other, name))\n\n    return self\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.join_geometry","title":"join_geometry","text":"<pre><code>join_geometry(points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs)\n</code></pre> <p>Join geometry defined by components.</p> <p>The geometry passed in argument is consistent and doesn't refer to existing vertices. It is used to build an independant mesh which is then joined. See 'add_geometry' which, on the contrary, can refer to existing vertices.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.join_geometry--returns","title":"Returns","text":"<pre><code>- self\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def join_geometry(self, points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs):\n    \"\"\" Join geometry defined by components.\n\n    The geometry passed in argument is consistent and doesn't refer to existing vertices. It is used\n    to build an independant mesh which is then joined.\n    See 'add_geometry' which, on the contrary, can refer to existing vertices.\n\n    Returns\n    -------\n        - self\n    \"\"\"\n    mesh = Mesh(attr_from=self)\n    mesh.add_geometry(\n        points=points, \n        corners=corners, \n        faces=faces, \n        edges=edges,\n        **attrs)\n    self.join(mesh)\n    return self\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.line","title":"line  <code>classmethod</code>","text":"<pre><code>line(start=(0, 0, 0), end=(0, 0, 1), segments=1, materials=None)\n</code></pre> <p>Create a mesh with lines between the given positions.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.line--arguments","title":"Arguments","text":"<pre><code>- start (vertex =(0, 0, 0) : position of the start of the lines\n- end (vertex=(0, 0, 1) : position of the end of the lines\n- count (int=2) : number of points in the line\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.line--returns","title":"Returns","text":"<pre><code>- mesh (Mesh) : the mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef line(cls, start=(0, 0, 0), end=(0, 0, 1), segments=1, materials=None):\n    \"\"\" Create a mesh with lines between the given positions.\n\n    Arguments\n    ---------\n        - start (vertex =(0, 0, 0) : position of the start of the lines\n        - end (vertex=(0, 0, 1) : position of the end of the lines\n        - count (int=2) : number of points in the line\n\n    Returns\n    -------\n        - mesh (Mesh) : the mesh\n    \"\"\"\n    segments = max(1, segments)\n\n    start = np.asarray(start, dtype=bfloat)\n    end   = np.asarray(end, dtype=bfloat)\n\n    pos = np.linspace(start, end, segments + 1) # shape (segments, n points, 3)\n\n    if len(pos.shape) == 2:\n        edges = border_edges(np.arange(segments))\n    else:\n        shape = pos.shape[:-1]\n        n = int(np.prod(shape))\n        edges = col_edges(np.arange(n).reshape(shape))\n\n    return cls(points=pos.reshape(-1, 3), edges=edges.reshape(-1, 2), materials=materials)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.load_models","title":"load_models  <code>staticmethod</code>","text":"<pre><code>load_models(*specs)\n</code></pre> <p>Load a geometry or geometries from specifications.</p> The specs can be <ul> <li>a Blender collection</li> <li>a Blender object</li> <li>a Geometry</li> </ul>"},{"location":"api/mesh/#npblender.mesh.Mesh.load_models--arguments","title":"Arguments","text":"<pre><code>- specs (list of objects / collections) : the models to load\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.load_models--returns","title":"Returns","text":"<pre><code>- list of geometries\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>@staticmethod\ndef load_models(*specs):\n    \"\"\" Load a geometry or geometries from specifications.\n\n    The specs can be:\n        - a Blender collection\n        - a Blender object\n        - a Geometry\n\n    Arguments\n    ---------\n        - specs (list of objects / collections) : the models to load\n\n    Returns\n    -------\n        - list of geometries\n    \"\"\"\n\n    from .mesh import Mesh\n    from .curve import Curve\n\n    models = []\n\n    for spec in specs:\n        # A list\n        if isinstance(spec, (list, tuple)):\n            models.extend(Geometry.load_models(*spec))\n            continue\n\n        # A collection\n        coll = blender.get_collection(spec, halt=False)\n        if coll is not None:\n            for obj in coll.objects:\n                geo = Geometry.load_object(obj)\n                if isinstance(geo, (Mesh, Curve)):\n                    models.append(geo)\n            continue\n\n        # An object\n        obj = blender.get_object(spec, halt=False)\n        if obj is not None:\n            geo = Geometry.load_object(obj)\n            if isinstance(geo, (Mesh, Curve)):\n                models.append(geo)\n            continue\n\n        # A valid geometry\n        if type(spec).__name__ in ['Mesh', 'Curve']:\n            models.append(spec)\n            continue\n\n        raise ValueError(f\"Unknown model (type '{type(spec)}'): {spec}\")\n\n    return models\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.load_object","title":"load_object  <code>staticmethod</code>","text":"<pre><code>load_object(name)\n</code></pre> <p>Load a Blender object and returns either a Mesh or a Curve.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.load_object--arguments","title":"Arguments","text":"<pre><code>- name (str or bpy.types.Object) : the object to load\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.load_object--returns","title":"Returns","text":"<pre><code>- Mesh or Curve\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>@staticmethod\ndef load_object(name):\n    \"\"\" Load a Blender object and returns either a Mesh or a Curve.\n\n    Arguments\n    ---------\n        - name (str or bpy.types.Object) : the object to load\n\n    Returns\n    -------\n        - Mesh or Curve\n    \"\"\"\n\n    from .mesh import Mesh\n    from .curve import Curve\n\n    obj = blender.getobject(name)\n    if obj is None:\n        return None\n\n    if isinstance(obj.data, bpy.types.Mesh):\n        return Mesh.from_object(obj)\n\n    elif isinstance(obj.data, bpy.types.Curve):\n        return Curve.from_object(obj)\n\n    else:\n        raise Exception(f\"Geometry.load_object error: impossible to load the objet '{obj.name}' of type '{type(obj.data).__name__}'\")\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.monkey","title":"monkey  <code>classmethod</code>","text":"<pre><code>monkey(materials=None)\n</code></pre> <p>Create a Monkey.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.monkey--arguments","title":"Arguments","text":"<pre><code>- materials (list of strs = None) : materials list\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.monkey--returns","title":"Returns","text":"<pre><code>- MeshBuilder\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef monkey(cls, materials=None):\n    \"\"\" Create a Monkey.\n\n    Arguments\n    ---------\n        - materials (list of strs = None) : materials list\n\n    Returns\n    -------\n        - MeshBuilder\n    \"\"\"\n    mesh = cls(materials=materials)\n    with mesh.bmesh() as bm:\n        bmesh.ops.create_monkey(bm)\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.multiply","title":"multiply","text":"<pre><code>multiply(count, in_place=True)\n</code></pre> <p>Duplicate the geometry.</p> <p>Multiplying is a way to efficiently duplicate the geometry a great number of times. Once duplicated, the vertices can be reshapped to address each instance individually.</p> <pre><code>count = 16\n\ncube = Mesh.Cube() * count\n\n# Shape the points as 16 blocks of 8 vertices\npoints = np.reshape(cube.points.position, (16, 8, 3))\n\n# Place the cubes in a circle\nags = np.linspace(0, 2*np.pi, count, endpoint=False)\npoints[..., 0] += 6 * np.cos(ags)[:, None]\npoints[..., 1] += 6 * np.sin(ags)[:, None]\n\ncube.to_object(\"Cubes\")\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.multiply--arguments","title":"Arguments","text":"<pre><code>- count (int=10) : number of instances\n- attributes (name=value) : value for named attributes\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.multiply--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def multiply(self, count, in_place=True):\n    \"\"\" Duplicate the geometry.\n\n    Multiplying is a way to efficiently duplicate the geometry a great number of times.\n    Once duplicated, the vertices can be reshapped to address each instance individually.\n\n    ``` python\n    count = 16\n\n    cube = Mesh.Cube() * count\n\n    # Shape the points as 16 blocks of 8 vertices\n    points = np.reshape(cube.points.position, (16, 8, 3))\n\n    # Place the cubes in a circle\n    ags = np.linspace(0, 2*np.pi, count, endpoint=False)\n    points[..., 0] += 6 * np.cos(ags)[:, None]\n    points[..., 1] += 6 * np.sin(ags)[:, None]\n\n    cube.to_object(\"Cubes\")\n    ```\n\n    Arguments\n    ---------\n        - count (int=10) : number of instances\n        - attributes (name=value) : value for named attributes\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n\n    # ----------------------------------------------------------------------------------------------------\n    # Checks and simple cases\n\n    if not isinstance(count, (int, np.int32, np.int64)):\n        raise Exception(f\"A Mesh can be multiplied only by an int, not '{count}'\")\n\n    if count == 0:\n        return None\n\n    if count == 1:\n        if in_place:\n            return self\n        else:\n            return type(self).from_mesh(self)\n\n    if not in_place:\n        return type(self).from_mesh(self).multiply(count, in_place=True)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Vertices\n\n    nverts = len(self.points)\n    self.points.multiply(count)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Corners\n\n    ncorners = len(self.corners)\n    self.corners.multiply(count)\n    self.corners.vertex_index += np.repeat(np.arange(count)*nverts, ncorners)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Faces\n\n    self.faces.multiply(count)\n    self.faces.update_loop_start()\n\n    # ----------------------------------------------------------------------------------------------------\n    # Edges\n\n    nedges = len(self.edges)\n    self.edges.multiply(count)\n    ofs = np.repeat(np.arange(count)*nverts, nedges)\n    self.edges.vertex0 += ofs\n    self.edges.vertex1 += ofs\n\n    return self\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.object","title":"object","text":"<pre><code>object(index=0, readonly=True)\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>@contextmanager\ndef object(self, index=0, readonly=True):\n\n    import bpy\n    from . import blender\n\n    temp_name = index if isinstance(index, str) else f\"BPBL Temp {index}\"\n\n    ctx = bpy.context\n\n    old_sel = [obj.name for obj in bpy.data.objects if obj.select_get()]\n    old_active = ctx.view_layer.objects.active\n    if old_active is None:\n        old_active_name = None\n    else:\n        old_active_name = old_active.name\n\n    bpy.ops.object.select_all(action='DESELECT')        \n\n    obj = self.to_object(temp_name)\n    obj.select_set(True)\n    bpy.context.view_layer.objects.active = obj        \n\n    yield obj\n\n    # ===== Returns from context\n\n    if not readonly:\n        self.capture(type(self).from_object(obj))\n\n    blender.delete_object(obj)\n\n    bpy.ops.object.select_all(action='DESELECT')        \n    for name in old_sel:\n        obj = bpy.data.objects.get(name)\n        if obj is not None:\n            obj.select_set(True)\n\n    if old_active_name is not None:\n        bpy.context.view_layer.objects.active = bpy.data.objects.get(old_active_name)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.points_cloud","title":"points_cloud  <code>classmethod</code>","text":"<pre><code>points_cloud(points=None, materials=None)\n</code></pre> <p>Create a mesh with points at the given positions.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.points_cloud--arguments","title":"Arguments","text":"<pre><code>- position (shaped array (?, 3)=(0, 0, 0) : position of the points\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.points_cloud--returns","title":"Returns","text":"<pre><code>- mesh (Mesh) : the mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef points_cloud(cls, points=None, materials=None):\n    \"\"\" Create a mesh with points at the given positions.\n\n    Arguments\n    ---------\n        - position (shaped array (?, 3)=(0, 0, 0) : position of the points\n\n    Returns\n    -------\n        - mesh (Mesh) : the mesh\n    \"\"\"\n    return cls(points=points, materials=materials)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.pyramid","title":"pyramid  <code>classmethod</code>","text":"<pre><code>pyramid(size=1, materials=None)\n</code></pre> <p>Create a Pyramid.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.pyramid--arguments","title":"Arguments","text":"<pre><code>- size (float=1.) : size\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.pyramid--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef pyramid(cls, size=1, materials=None):\n    \"\"\" Create a Pyramid.\n\n    Arguments\n    ---------\n        - size (float=1.) : size\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    return cls.cone(vertices=3, radius_bottom=size*0.8660254037844386, depth=size, materials=materials)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.remove_doubles","title":"remove_doubles","text":"<pre><code>remove_doubles(dist=0.001)\n</code></pre> <p>Remove doubles.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>dist(float=0.001)</code> <p>maximum distance between vertices to merge.</p> required Source code in <code>npblender/mesh.py</code> <pre><code>def remove_doubles(self, dist=.001):\n    \"\"\" Remove doubles.\n\n    Arguments:\n        - dist (float=0.001) : maximum distance between vertices to merge.\n    \"\"\"\n    with self.bmesh() as bm:\n        bmesh.ops.remove_doubles(bm, verts=bm.verts, dist=dist)\n\n    return self\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.rotate","title":"rotate","text":"<pre><code>rotate(rotation, pivot=None)\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def rotate(self, rotation, pivot=None):\n    return self.transformation(rotation=rotation, pivot=pivot)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.separate_faces","title":"separate_faces","text":"<pre><code>separate_faces(groups=None)\n</code></pre> <p>Split faces into isolated islands</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.separate_faces--arguments","title":"Arguments","text":"<ul> <li>groups (list of ints):     group ids of faces</li> </ul> Source code in <code>npblender/mesh.py</code> <pre><code>def separate_faces(self, groups=None):\n    \"\"\" Split faces into isolated islands\n\n    Arguments\n    ---------\n    - groups (list of ints):\n        group ids of faces\n    \"\"\"\n\n    mesh = Mesh(materials=self.materials)\n    attr_names = [name for name in self.faces.actual_names if name not in ['loop_total', 'loop_start']]\n\n    # ---------------------------------------------------------------------------\n    # No group: each face becomes an island\n    # ---------------------------------------------------------------------------\n\n    if groups is None:\n        attrs = {name: self.faces[name] for name in attr_names}\n        return Mesh(attr_from=self).join_geometry(\n            points = self.points.position[self.corners.vertex_index],\n            corners = np.arange(len(self.corners)),\n            faces = self.faces.loop_total,\n            **attrs,\n        )\n\n    # ---------------------------------------------------------------------------\n    # Faces are grouped with groupds IDs\n    # ---------------------------------------------------------------------------\n\n    groups = np.asarray(groups)\n    if groups.shape != (len(self.faces),)   :\n        raise ValueError(f\"The 'groups' argument must be a index per face with a length of {len(self.faces)}.\")\n\n    ugroups, rev_index = np.unique(groups, return_inverse=True)\n    for group in ugroups:\n        faces = self.faces[ugroups[rev_index] == group]\n        attrs = {name: faces[name] for name in attr_names}\n\n        corners = self.corners[faces.get_corner_indices()]\n        uniques, new_corners = np.unique(corners.vertex_index, return_inverse=True)\n        mesh.join(Mesh(attr_from=self).join_geometry(\n            points = self.points.position[uniques],\n            corners = new_corners,\n            faces = faces.loop_total,\n            **attrs,\n        ))\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.simplified","title":"simplified","text":"<pre><code>simplified(scale, dist=0.001)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def simplified(self, scale, dist=.001):\n\n    copy = Mesh.from_mesh(self)\n    copy.remove_doubles(dist=dist/scale)\n\n    if len(copy.points) &lt; 8:\n        copy = self.get_cubic_envelop()\n\n    return copy\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.solidify","title":"solidify","text":"<pre><code>solidify(thickness=0.01, offset=-1)\n</code></pre> <p>Boolean difference with another MeshBuilder.</p> <p>The methods uses the Solidify Modifier</p> <pre><code>glass = Mesh.Circle(segments=128)\nglass.extrude_faces(0, -.01)\nglass.extrude_faces(0, -2)\nglass.extrude_faces(0, -.01)\n\nglass.points.translate((0, 0, 2))\n\nglass = glass.solidify(thickness=.1)\n\nglass.to_object(\"Solidify\", shade_smooth=True)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.solidify--arguments","title":"Arguments","text":"<pre><code>- thickness (float=.01) : thickness\n- offset (float=-1) : offset\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.solidify--returns","title":"Returns","text":"<pre><code>- MeshBuilder : the result of the solidify operation\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def solidify(self, thickness=.01, offset=-1):\n    \"\"\" Boolean difference with another MeshBuilder.\n\n    The methods uses the Solidify Modifier\n\n    ``` python\n    glass = Mesh.Circle(segments=128)\n    glass.extrude_faces(0, -.01)\n    glass.extrude_faces(0, -2)\n    glass.extrude_faces(0, -.01)\n\n    glass.points.translate((0, 0, 2))\n\n    glass = glass.solidify(thickness=.1)\n\n    glass.to_object(\"Solidify\", shade_smooth=True)\n    ```\n\n    Arguments\n    ---------\n        - thickness (float=.01) : thickness\n        - offset (float=-1) : offset\n\n    Returns\n    -------\n        - MeshBuilder : the result of the solidify operation\n    \"\"\"\n\n    with self.object() as obj:\n        mod = obj.modifiers.new(\"Solidify\", 'SOLIDIFY')\n\n        mod.thickness       = thickness\n        mod.use_even_offset = True\n        mod.offset          = offset\n\n        # Apply modifier\n        bpy.ops.object.modifier_apply(modifier=mod.name)\n\n        mesh = Mesh.from_object(obj)\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.solidify_socle","title":"solidify_socle","text":"<pre><code>solidify_socle(shape, z=0, bottom_material_index=0)\n</code></pre> <p>The mesh is supposed to be a grid.</p> <p>The socle is buit by extruding the external edges to the value z.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.solidify_socle--arguments","title":"Arguments","text":"<ul> <li>shape (tuple of ints) : the grid shade</li> <li>z (float) : socle base z</li> <li>bottom_material_index (int = 0) : base face material index</li> <li>attributes (dict) : attributes to faces</li> </ul>"},{"location":"api/mesh/#npblender.mesh.Mesh.solidify_socle--returns","title":"Returns","text":"<ul> <li>bottom face index (int) : the index of bottom face</li> </ul> Source code in <code>npblender/mesh.py</code> <pre><code>def solidify_socle(self, shape, z=0, bottom_material_index=0):\n    \"\"\" The mesh is supposed to be a grid.\n\n    The socle is buit by extruding the external edges to the value z.\n\n    Arguments\n    ---------\n    - shape (tuple of ints) : the grid shade\n    - z (float) : socle base z\n    - bottom_material_index (int = 0) : base face material index\n    - attributes (dict) : attributes to faces\n\n    Returns\n    -------\n    - bottom face index (int) : the index of bottom face\n    \"\"\"\n\n    n = shape[0]*shape[1]\n    inds = np.arange(n).reshape(shape)\n\n    loop1 = np.append(inds[0, :-1], inds[:-1, -1])\n    loop1 = np.append(loop1, np.flip(inds[-1, 1:]))\n    loop1 = np.append(loop1, np.flip(inds[1:, 0]))\n\n    points = np.array(self.points.position[loop1])\n    points[:, 2] = z\n\n    loop0 = self.add_points(points)\n    res = self.add_geometry(corners=loop0) #, faces=len(loop0))\n\n    self.bridge_loops(loop0, loop1, close=True)\n\n    self.faces._ensure_optional_field(\"material_index\")\n    self.faces[res['faces']].material_index = bottom_material_index\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.split_edges","title":"split_edges","text":"<pre><code>split_edges(loop0, loop1, cuts=1)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def split_edges(self, loop0, loop1, cuts=1):\n\n    n0 = 1 if np.shape(loop0) == () else len(loop0)\n    n1 = 1 if np.shape(loop1) == () else len(loop1)\n    n = max(n0, n1)\n    if n0 == n:\n        loop0 = np.atleast_1d(loop0, dtype=bint)\n    else:\n        loop0 = np.ones(n, dtype=bint)*loop0\n\n    if n1 == n:\n        loop1 = np.atleast_1d(loop1, dtype=bint)\n    else:\n        loop1 = np.ones(n, dtype=bint)*loop1\n\n    to_select = np.stack([np.minimum(loop0, loop1), np.maximum(loop0, loop1)], axis=-1)  # shape (p, 2)\n    with self.bmesh() as bm:\n\n        edges, verts_indices = self._bm_edges(bm)\n\n        # select edges in to_select\n        dtype = np.dtype([('a', bint), ('b', bint)])\n        edges_view = verts_indices.view(dtype)\n        to_select_view = to_select.view(dtype)\n\n        # selection mask\n        mask = np.isin(edges_view.ravel(), to_select_view.ravel())\n\n        edges_to_cut = list(edges[mask])\n\n        if len(edges_to_cut) == 0:\n            return\n\n        # Edges subidivision\n        bmesh.ops.subdivide_edges(\n            bm,\n            edges=edges_to_cut,\n            cuts=cuts,\n            use_grid_fill=False\n        )\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_curve_REVIEW","title":"to_curve_REVIEW","text":"<pre><code>to_curve_REVIEW()\n</code></pre> <p>Convert mesh to curve</p> <p>Simple conversion when edges domain is defined</p> Source code in <code>npblender/mesh.py</code> <pre><code>def to_curve_REVIEW(self):\n    \"\"\" &gt; Convert mesh to curve\n\n    Simple conversion when edges domain is defined\n    \"\"\"\n\n    from npblender import Curve\n\n    if self._edges is None:\n        return None\n\n    splines = []\n    for edge in self.edges:\n        v0, v1 = edge.vertex0, edge.vertex1\n\n        ok = False\n        for spline in splines:\n            if spline[0] == spline[-1]:\n                continue\n\n            if v0 == spline[0]:\n                spline.insert(0, v1)\n                ok = True\n            elif v0 == spline[-1]:\n                spline.append(v1)\n                ok = True\n\n            elif v1 == spline[0]:\n                spline.insert(0, v0)\n                ok = True\n            elif v1 == spline[-1]:\n                spline.append(v0)\n                ok = True\n\n        if not ok:\n            splines.append([v0, v1])\n\n    curve = Curve()\n    for spline in splines:\n        cyclic = spline[0] == spline[-1]\n        if cyclic:\n            spline = spline[:-1]\n\n        curve.add(self.points.position[spline], curve_type='POLY', cyclic=cyclic)\n\n    return curve\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def to_dict(self):\n    return {\n        'geometry':     'Mesh',\n        'materials' :   self.materials,\n        'points':       self.points.to_dict(),\n        'corners':      self.corners.to_dict(),\n        'faces':        self.faces.to_dict(),\n        'edges':        self.edges.to_dict(),\n        }\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_mesh_data","title":"to_mesh_data","text":"<pre><code>to_mesh_data(data)\n</code></pre> <p>Write the geometry into a Blender Mesh</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_mesh_data--arguments","title":"Arguments","text":"<pre><code>- mesh (Blender Mesh instance) : the mesh to write\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def to_mesh_data(self, data):\n    \"\"\" Write the geometry into a Blender Mesh\n\n    Arguments\n    ---------\n        - mesh (Blender Mesh instance) : the mesh to write\n    \"\"\"\n\n    from npblender import blender\n\n    bl_mesh = blender.get_data(data)\n    bl_mesh.clear_geometry()\n\n    # ----------------------------------------------------------------------------------------------------\n    # Materials\n\n    bl_mesh.materials.clear()\n    for mat_name in self.materials:\n        if mat_name is not None:\n            bl_mesh.materials.append(bpy.data.materials.get(mat_name))\n\n    # ----------------------------------------------------------------------------------------------------\n    # Vertices\n\n    points = self.points.ravel()\n    if len(points):\n        bl_mesh.vertices.add(len(points))\n\n    # ----------------------------------------------------------------------------------------------------\n    # Corners\n\n    corners = self.corners.ravel()\n    if len(corners):\n        bl_mesh.loops.add(len(corners))\n        bl_mesh.loops.foreach_set(\"vertex_index\", blender.int_array(corners.vertex_index))\n\n    # ----------------------------------------------------------------------------------------------------\n    # Faces\n\n    faces = self.faces.ravel()\n    if len(faces):\n        bl_mesh.polygons.add(len(faces))\n        bl_mesh.polygons.foreach_set(\"loop_start\", blender.int_array(faces.loop_start))\n        bl_mesh.polygons.foreach_set(\"loop_total\", blender.int_array(faces.loop_total))\n\n    # ----------------------------------------------------------------------------------------------------\n    # Edges\n\n    edges = self.edges.ravel()\n    if len(self.edges):\n        # edges to add\n        add_edges = self.edges.vertices\n\n        # edges have been created by faces\n        if len(faces):\n            bl_mesh.update()\n\n            cur_n = len(bl_mesh.edges)\n            if cur_n &gt; 0:\n                a = np.empty((cur_n, 2), dtype=bint)\n                bl_mesh.edges.foreach_get('vertices', a.ravel())\n\n            add_edges = np.append(a, add_edges, axis=0)\n\n        # add the edges\n        n = len(edges)\n        bl_mesh.edges.add(n)\n\n        bl_mesh.edges.foreach_set('vertices', add_edges.ravel())\n\n    # ----------------------------------------------------------------------------------------------------\n    # Attributes\n\n    attributes = data.attributes\n\n    points.to_bl_attributes(attributes, update=False)\n    corners.to_bl_attributes(attributes, update=False)\n    faces.to_bl_attributes(attributes, update=False)\n    edges.to_bl_attributes(attributes, update=False)\n\n    # ----------------------------------------------------------------------------------------------------\n    # Update\n\n    bl_mesh.update()\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_object","title":"to_object","text":"<pre><code>to_object(obj, shade_smooth=None, shapekeys=None, collection=None)\n</code></pre> <p>Create or update a blender object.</p> <p>The method 'to_object' creates the whole geometry. It creates a new object if it doesn't already exist. If the object exists, it must be a mesh, there is no object type conversion.</p> <p>Once the object is created, use the method 'update_object' to change the vertices.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_object--arguments","title":"Arguments","text":"<pre><code>- obj (str or Blender object) : the object the create\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_object--returns","title":"Returns","text":"<pre><code>- Blender mesh object\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def to_object(self, obj, shade_smooth=None, shapekeys=None, collection=None):\n    \"\"\" Create or update a blender object.\n\n    The method 'to_object' creates the whole geometry. It creates a new object if it doesn't already exist.\n    If the object exists, it must be a mesh, there is no object type conversion.\n\n    Once the object is created, use the method 'update_object' to change the vertices.\n\n    Arguments\n    ---------\n        - obj (str or Blender object) : the object the create\n\n    Returns\n    -------\n        - Blender mesh object\n    \"\"\"\n\n    from npblender import blender\n\n    res = blender.create_mesh_object(obj, collection=collection)\n    self.to_mesh_data(res.data)\n\n    if shade_smooth is not None:\n        res.data.polygons.foreach_set('use_smooth', [shade_smooth]*len(res.data.polygons))\n\n    if shapekeys is not None:\n        if shapekeys is not None:\n            if isinstance(shapekeys, ShapeKeys):\n                shapekeys.to_mesh_object(obj)\n            else:\n                for sks in shapekeys:\n                    sks.to_mesh_object(obj)\n\n    return res\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.torus","title":"torus  <code>classmethod</code>","text":"<pre><code>torus(major_segments=48, minor_segments=12, major_radius=1.0, minor_radius=0.25, materials=None)\n</code></pre> <p>Create a Torus.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.torus--arguments","title":"Arguments","text":"<pre><code>- major_segments (int=48) : number of segments for the major radius\n- minor_segments (int=12) : number of segments for the minor radius\n- major_radius (float=1.) : major radius\n- minor_radius (float=.25) : minor radius\n- materials (list of strs = None) : materials list\n- transformation (Transformations = None) : the transformation to apply\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.torus--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef torus(cls, major_segments=48, minor_segments=12, major_radius=1., minor_radius=0.25, materials=None):\n    \"\"\" Create a Torus.\n\n    Arguments\n    ---------\n        - major_segments (int=48) : number of segments for the major radius\n        - minor_segments (int=12) : number of segments for the minor radius\n        - major_radius (float=1.) : major radius\n        - minor_radius (float=.25) : minor radius\n        - materials (list of strs = None) : materials list\n        - transformation (Transformations = None) : the transformation to apply\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    # Major backbone\n    maj_ag = np.linspace(0, 2*np.pi, major_segments, endpoint=False, dtype=bfloat) + np.pi # + pi to match blender uv\n\n    x = major_radius*np.cos(maj_ag)\n    y = major_radius*np.sin(maj_ag)\n    zeros = np.zeros_like(x)\n\n    transfos = Transformation.from_components(\n        translation=np.stack((x, y, zeros), axis=-1), \n        rotation=Rotation.from_euler(np.stack((zeros, zeros, maj_ag), axis=-1)),\n    )\n\n    # Minor section\n    min_ag = np.linspace(0, 2*np.pi, minor_segments, endpoint=False, dtype=bfloat) + np.pi # + pi to match blender uv\n    x = minor_radius*np.cos(min_ag)\n    z = minor_radius*np.sin(min_ag)\n    y = np.zeros_like(x)\n\n    circle = np.stack((x, y, z), axis=-1)\n\n    # Transform the circle\n    points = transfos[:, None] @ circle\n\n    # Generate the faces\n    corners = grid_corners(major_segments, minor_segments, close_x=True, close_y=True)\n\n    # Get the uv map\n    uvmap = grid_uv_map(major_segments + 1, minor_segments + 1)\n\n    return cls(points=points.reshape(-1, 3), corners=corners.ravel(), faces=4, UVMap=uvmap.reshape(-1, 2), materials=materials)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.transform","title":"transform","text":"<pre><code>transform(transformation)\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def transform(self, transformation):\n    return self.transformation(rotation=transformation)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.transformation","title":"transformation","text":"<pre><code>transformation(rotation=None, scale=None, translation=None, pivot=None)\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def transformation(self, rotation=None, scale=None, translation=None, pivot=None):\n\n    # Curve splines can be a subset of the points \n    pts_sel = self.get_points_selection()\n    pos = self.points.position[pts_sel]\n    npoints = len(pos)\n    all_vecs = [pos]\n\n    has_handles = \"handle_left\" in self.points.actual_names\n    if has_handles:\n        left = self.points.handle_left[pts_sel]\n        right = self.points.handle_right[pts_sel]\n        all_vecs.extend([left, right])\n\n    # First pivot\n    if pivot is not None:\n        pivot = np.asarray(pivot)\n        pivot_shape = self._check_transformation_shape(pivot.shape[:-1], npoints, label=\"Pivot\")\n        for v in all_vecs:\n            v.reshape(pivot_shape)[:] -= pivot\n\n    # Scale\n    if scale is not None:\n        scale = np.asarray(scale)\n        scale_shape = self._check_transformation_shape(scale.shape[:-1], npoints, label=\"Scale\")\n        for v in all_vecs:\n            v.reshape(scale_shape)[:] *= scale\n\n    # Rotation\n    if rotation is not None:\n        rot_shape = self._check_transformation_shape(rotation.shape, npoints, label=\"Rotation\")\n        for v in all_vecs:\n            v.reshape(rot_shape)[:] = rotation @ v.reshape(rot_shape)\n\n    # Pivot back\n    if pivot is not None:\n        for v in all_vecs:\n            v.reshape(pivot_shape)[:] += pivot\n\n    # Translation\n    if translation is not None:\n        translation = np.asarray(translation)\n        tr_shape = self._check_transformation_shape(translation.shape[:-1], npoints, label=\"Pivot\")\n        for v in all_vecs:\n            v.reshape(tr_shape)[:] += translation\n\n    # Back\n    self.points[pts_sel].position = pos\n    if has_handles:\n        self.points[pts_sel].handle_left = all_vecs[1]\n        self.points[pts_sel].handle_right = all_vecs[2]\n\n    return self\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.translate","title":"translate","text":"<pre><code>translate(translation)\n</code></pre> Source code in <code>npblender/geometry.py</code> <pre><code>def translate(self, translation):\n    return self.transformation(translation=translation)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.triangulate","title":"triangulate","text":"<pre><code>triangulate(selection=None)\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>def triangulate(self, selection=None):\n\n    faces_sel = np.arange(len(self.faces))\n    if selection is not None:\n        faces_sel = faces_sel[selection]\n\n    if len(faces_sel) == 0:\n        return\n\n    copy = Mesh.from_mesh(self)\n\n    with copy.bmesh(readonly = False) as bm:\n        bm.faces.ensure_lookup_table()\n        faces = [bm.faces[i] for i in faces_sel]\n\n        bmesh.ops.triangulate(bm, faces=faces)\n\n    return copy\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.uvsphere","title":"uvsphere  <code>classmethod</code>","text":"<pre><code>uvsphere(segments=32, rings=16, radius=1, materials=None)\n</code></pre> <p>Create a uv sphere.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.uvsphere--arguments","title":"Arguments","text":"<pre><code>- segments (int=32) : number of segments\n- rings (int=16) : number of rings\n- radius (float=1.) : radius\n- materials (list of strs = None) : materials list\n- transformation (Transformations = None) : the transformation to apply\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.uvsphere--returns","title":"Returns","text":"<pre><code>- Mesh\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef uvsphere(cls, segments=32, rings=16, radius=1, materials=None):\n    \"\"\" Create a uv sphere.\n\n    Arguments\n    ---------\n        - segments (int=32) : number of segments\n        - rings (int=16) : number of rings\n        - radius (float=1.) : radius\n        - materials (list of strs = None) : materials list\n        - transformation (Transformations = None) : the transformation to apply\n\n    Returns\n    -------\n        - Mesh\n    \"\"\"\n    mesh = cls(materials=materials)\n    with mesh.bmesh() as bm:\n        bmesh.ops.create_uvsphere(bm, u_segments=segments, v_segments=rings, radius=radius, calc_uvs=True)\n\n    return mesh\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.vectors_field","title":"vectors_field  <code>classmethod</code>","text":"<pre><code>vectors_field(locations, vectors, radius=0.05, scale_length=1.0, angle=24.0, segments=8, head=None, adjust_norm=None, materials=None)\n</code></pre> <p>Create an arrow at each location corresponding to the vectors.</p> <p>The arrow length is equal to the corresponding vector lengths. The arrow radius is constant and equal to the value passe in argument for lengths greater that the argument scale_length. When the length is less than this value, the arrow is scaled down.</p> <p>Use the adjust_norm argument to transform the vector lengths to arrows lengths.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.vectors_field--arguments","title":"Arguments","text":"<pre><code>- locations (array of 3-vectors) : vectors locations\n- vectors (array of 3 vectors) : vectors to visualize\n- radius (float = .05) : arrow radius\n- angle (float = 24) : head radius in degrees\n- segments (int = 8) : number of segments for the section\n- head (mesh = None) : mesh model for the head. Create a cone if None\n- adjust_norm (max length or function = None) : max arrow length or function transforming\n    the vector length into arrow length\n- scale_length (float = 1.) : arrow length below which the arrow radius is scaled\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.vectors_field--returns","title":"Returns","text":"<pre><code>- Mesh Object\n</code></pre> Source code in <code>npblender/mesh.py</code> <pre><code>@classmethod\ndef vectors_field(cls, locations, vectors, radius=.05, scale_length=1., angle=24., segments=8, head=None, adjust_norm=None, materials=None):\n    \"\"\" Create an arrow at each location corresponding to the vectors.\n\n    The arrow length is equal to the corresponding vector lengths.\n    The arrow radius is constant and equal to the value passe in argument for lengths greater that\n    the argument scale_length. When the length is less than this value, the arrow is scaled down.\n\n    Use the adjust_norm argument to transform the vector lengths to arrows lengths.\n\n    Arguments\n    ---------\n        - locations (array of 3-vectors) : vectors locations\n        - vectors (array of 3 vectors) : vectors to visualize\n        - radius (float = .05) : arrow radius\n        - angle (float = 24) : head radius in degrees\n        - segments (int = 8) : number of segments for the section\n        - head (mesh = None) : mesh model for the head. Create a cone if None\n        - adjust_norm (max length or function = None) : max arrow length or function transforming\n            the vector length into arrow length\n        - scale_length (float = 1.) : arrow length below which the arrow radius is scaled\n\n    Returns\n    -------\n        - Mesh Object\n    \"\"\"\n    locations = np.atleast_2d(locations)\n    vectors = np.atleast_2d(vectors)\n\n    # ---------------------------------------------------------------------------\n    # Vector lengths\n    # ---------------------------------------------------------------------------\n\n    n = len(locations)\n\n    lengths = np.linalg.norm(vectors, axis=-1)\n    is_null = lengths &lt; .00001\n    lengths[is_null] = 1\n    v_dir = vectors / lengths[:, None]\n    if type(adjust_norm).__name__ == 'function':\n        lengths = adjust_norm(lengths)\n    elif adjust_norm is not None:\n        lengths = np.minimum(adjust_norm, lengths)\n    lengths[is_null] = 0\n    vectors = v_dir*lengths[:, None]\n\n    # ---------------------------------------------------------------------------\n    # Arrow head\n    # ---------------------------------------------------------------------------\n\n    head_radius = 3*radius\n    head_height = head_radius/np.tan(np.radians(angle))\n\n    if head is None:\n        cone = cls.cone(\n            vertices = segments, \n            side_segments = 1, \n            fill_segments = 1, \n            radius_top = 0, \n            radius_bottom = head_radius, \n            depth = head_height, \n            fill_type = 'FANS', \n            materials = materials)\n        cone.points[-1].z += head_height/10\n    else:\n        cone = head\n        head_height = cone.bounding_box_dims[2]\n\n    # Head top point is z=0\n    v0, v1 = cone.bounding_box\n    cone.points.z -= v1[2]\n\n    # ---------------------------------------------------------------------------\n    # Small arrows: Vectors whose length &lt; min_length\n    # ---------------------------------------------------------------------------\n\n    # Minimum length\n    # Below this length, the arrow is scaled\n\n    min_length = 2*head_height\n\n    # Small and long arrows if any\n    small_arrows = cls()\n    long_arrows = cls()\n\n    small = lengths &lt; min_length\n    nsmalls = np.sum(small)\n\n    if nsmalls:\n        # shaft height = head height\n        cyl_height = min_length/2 + .01\n        arrow = cls.cylinder(vertices=segments, side_segments=1, radius=radius, depth=cyl_height, materials=materials)\n        arrow.points.z += cyl_height/2\n\n        # Join the head\n        c = cls.from_mesh(cone)\n        c.points.z += min_length\n\n        arrow.join(c)\n\n        # Duplicate the geometry            \n        small_arrows = arrow*nsmalls\n        small_arrows.points.reshape(nsmalls, len(arrow.points))\n\n        # Rotate, scale and translate\n        lg = lengths[small]\n        scale = np.stack((np.ones_like(lg), np.ones_like(lg), lg), axis=-1)\n        small_arrows.transformation(\n            rotation = Rotation.look_at((0, 0, 1), vectors[small])[:, None], \n            scale = scale[:, None], \n            translation = locations[small, None],\n            )\n        small_arrows.points.reshape(-1)\n\n\n    # ---------------------------------------------------------------------------\n    # Long arrows\n    # ---------------------------------------------------------------------------\n\n    long = np.logical_not(small)\n    nlongs = len(locations) - nsmalls\n    if nlongs:\n\n        # Shaft model with a normalized height = 1\n        shaft = cls.cylinder(vertices=segments, side_segments=1, radius=radius, depth=1, materials=materials)\n        shaft.points.z += .5\n\n        # We duplicate and transform the shafts with a scale long z\n        long_arrows = shaft*nlongs\n        long_arrows.points.reshape(nlongs, len(shaft.points))\n\n        lg = lengths[long] - head_height + .01\n        scale = np.stack((np.ones_like(lg), np.ones_like(lg), lg), axis=-1)\n        long_arrows.transformation(\n            rotation = Rotation.look_at((0, 0, 1), vectors[long])[:, None], \n            scale = scale[:, None], \n            translation = locations[long, None],\n            )\n        long_arrows.points.reshape(-1)\n\n        # We duplicate and tranform the heads with no scale\n        heads = cone*nlongs\n        heads.points.reshape(nlongs, len(cone.points))\n        heads.transformation(\n            rotation = Rotation.look_at((0, 0, 1), vectors[long])[:, None], \n            translation = locations[long, None] + vectors[long, None],\n            )\n        heads.points.reshape(-1)\n\n        long_arrows.join(heads)\n\n    # Let's join the result\n    arrows = cls()\n    arrows.join(small_arrows, long_arrows)\n\n    return arrows\n</code></pre>"}]}