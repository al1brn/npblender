{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"npblender","text":"<p>Numpy for Blender</p> <p>Doc in progress....</p> <p>Update soon :) (this is a test for the workflow)</p>"},{"location":"api/","title":"R\u00e9f\u00e9rence API","text":""},{"location":"api/#npblender.Camera","title":"Camera","text":"<pre><code>Camera(camera=None)\n</code></pre>"},{"location":"api/#npblender.Camera.distance_for_scale","title":"distance_for_scale","text":"<pre><code>distance_for_scale(size_max, scale=1.0, margin=0.0, fit_axis='auto')\n</code></pre> <p>Compute: - d0: distance at which an unscaled object of real size <code>size_max</code> exactly fits         the camera frame along <code>fit_axis</code> (largest dimension touches the borders). - d : distance such that the UNscaled object at distance d has the same apparent size         as the SCALED object (size_max * scale) at distance d0. (i.e. d = d0 / scale) - meters_per_pixel: world-space length at distance d that projects to exactly 1 pixel         (so two vertices closer than this fall onto the same pixel).</p> <p>Parameters:</p> Name Type Description Default <code>size_max</code> <code>float</code> <p>Largest real dimension of the mesh (Blender units).</p> required <code>scale</code> <code>float</code> <p>Geometry scale (&gt; 0) applied at distance d0.</p> <code>1.0</code> <code>margin</code> <code>float</code> <p>Extra margin around the frame (same convention as elsewhere).</p> <code>0.0</code> <code>fit_axis</code> <code>(auto, width, height)</code> <p>Which frame span to use to define \"exactly fits\". - \"auto\": min(width, height) - \"width\": frame width - \"height\": frame height</p> <code>\"auto\"</code> <p>Returns:</p> Name Type Description <code>d</code> <code>float</code> <p>Distance where the UNscaled object matches the apparent size of the SCALED one at d0 (d = d0 / scale).</p> <code>meters_per_pixel</code> <code>float</code> <p>World-space size corresponding to 1 pixel at distance d.</p> Notes <ul> <li>Uses Blender's view_frame on plane z = cam_z. width  = cam_x1 - cam_x0 height = cam_y1 - cam_y0</li> <li>Perspective: apparent_size \u221d size / distance equality \u21d2 size_max / d = (size_max * scale) / d0 \u21d2 d = d0 / scale.</li> </ul>"},{"location":"api/#npblender.Camera.pixels_per_meter","title":"pixels_per_meter","text":"<pre><code>pixels_per_meter(distances)\n</code></pre> <p>Returns the number of pixels per meter given the distances</p> Arguments <ul> <li>distances (array of floats) : the distances</li> </ul> <p>Returns:</p> Type Description <code>- array of floats : the size of a meter in pixels</code>"},{"location":"api/#npblender.Camera.visible_edges","title":"visible_edges","text":"<pre><code>visible_edges(mesh, radius=0.0, margin=0.0)\n</code></pre> <p>Mesh edges visibility</p> <p>The visibility of each point is computed with the given radius. An edge is considered invisible if both points are hidden for the same reason: both are left to the camera, or right, or behind...</p> <p>In the other case, the edge is considered as visible.</p> Arguments <p>mesh : Mesh     The mesh with points and edges radius : float     The radius of the camera margin : float     The margin of the camera</p> <p>Returns:</p> Name Type Description <code>vis</code> <code>array (n) of bools</code> <p>The visibility of each edge</p> <code>size</code> <code>array (n) of floats</code> <p>The size of the projected edges</p>"},{"location":"api/#npblender.Camera.visible_faces","title":"visible_faces","text":"<pre><code>visible_faces(mesh, margin=0.0, back_face_culling=False)\n</code></pre> <p>Mesh faces visibility</p> <p>A face is considered invisible if all its points are hidden for the same reason: all are left to the camera, or right, or behind...</p> Arguments <p>mesh : Mesh     The mesh with points and faces margin : float     The margin of the camera back_face_culling : bool     If True, the back face is not considered as visible</p> <p>Returns:</p> Name Type Description <code>vis</code> <code>array (n) of bools</code> <p>The visibility of each face</p> <code>size</code> <code>array (n) of floats</code> <p>The size of the projected faces</p> <code>proj</code> <code>array (n, 3) of floats</code> <p>The projected position of each face</p>"},{"location":"api/#npblender.Camera.visible_islands","title":"visible_islands","text":"<pre><code>visible_islands(mesh, islands, attribute='Island', margin=0.0)\n</code></pre> <p>Mesh islands visibility</p> <p>Islands are defined by an integer.</p> <p>Visibility is computed with the position and size of the islands</p> Arguments <p>mesh : Mesh     The mesh with points and faces islands: array of ints     One identifier per island attribute: attribute name     The attribute name to use for the islands margin : float     The margin of the camera</p> <p>Returns:</p> Type Description <code>    - couple of arrays : array[n, 7] of bools, array[n, 2] of floats</code>"},{"location":"api/#npblender.Camera.visible_points","title":"visible_points","text":"<pre><code>visible_points(verts, radius=0.0, margin=0.0, normals=None, return_proj=False)\n</code></pre> <p>Compute the visibility of vertices.</p> <p>For each vertex, the following values are computed: - visible : vertex is visible (all bools below are False) - behind : vertex is behind the visible rectangle - left : vertex is left to the visible rectangle - right : vertex if right to the visible rectangle - above : vertex is above the visible rectangle - below : vertex is below the visible rectangle - back : normal points outards - distance : distance to the camera - size : apparent size (based on radius)</p> Arguments <pre><code>- verts (array of vectors) : vertex locations\n- radius (array of floats or float = 0.) : size at the locations\n- margin (float, default=0.) : margin factor around the camera\n- normals (array of vectors = None) : normal pointing outwards are not visible\n</code></pre> <p>Returns:</p> Type Description <code>    - couple of arrays : array[n, 7] of bools, array[n, 2] of floats</code>"},{"location":"api/#npblender.Cloud","title":"Cloud","text":"<pre><code>Cloud(points=None, attr_from=None, **attrs)\n</code></pre> <p>               Bases: <code>Geometry</code></p> <p>Cloud Geometry class representing a collection of points with various attributes.</p> <p>This class provides methods to create, manipulate, and transform point clouds, including loading from and saving to Blender data structures, combining multiple clouds, and generating point distributions in various shapes (line, arc, circle, rectangle, pie, disk, cylinder, sphere, dome, cube, ball).</p> <p>Attributes:     points (Point): The vertices of the cloud with associated attributes.</p> <p>Methods:     from_geometry: Create a Cloud from another geometry with points.     from_cloud: Synonym for from_geometry.     capture: Capture data from another Cloud instance.     from_data: Initialize from Blender Mesh or PointCloud data.     to_data: Write the cloud geometry into a Blender Mesh.     from_object: Create a Cloud from a Blender object.     to_object: Create or update a Blender object with the cloud data.     object: Context manager for temporary Blender object editing.     join: Join other Clouds into this one.     transform, translate, scale: Geometric transformations.     Various distribution methods: line_dist, arc_dist, circle_dist, rect_dist, pie_dist, disk_dist,         cylinder_dist, sphere_dist, dome_dist, cube_dist, ball_dist for generating points in shapes.</p> <p>Cloud Geometry.</p> <p>Initialize a Cloud geometry object.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like of vectors</code> <p>The vertices of the cloud geometry. Default is None.</p> <code>None</code> <code>attr_from</code> <code>optional</code> <p>An optional source from which to join attributes.</p> <code>None</code> <code>**attrs</code> <code>dict</code> <p>Additional geometry attributes to be added.</p> <code>{}</code> Notes <ul> <li>Initializes an empty geometry with a Point container.</li> <li>Joins attributes from <code>attr_from</code> if provided.</li> <li>Appends given points and attributes to the geometry.</li> </ul>"},{"location":"api/#npblender.Cloud.capture","title":"capture","text":"<pre><code>capture(other)\n</code></pre> <p>Capture the data of another Mesh.</p> Arguments <pre><code>- other (Cloud) : the mesh to capture\n</code></pre> <p>Returns:</p> Type Description <code>    - self</code>"},{"location":"api/#npblender.Cloud.clear_geometry","title":"clear_geometry","text":"<pre><code>clear_geometry()\n</code></pre> <p>Clear the geometry.</p> <p>Delete all the content.</p>"},{"location":"api/#npblender.Cloud.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(data)\n</code></pre> <p>Initialize the geometry from a Blender data (Mesh or PointCloud)</p> Arguments <pre><code>- data (Blender Mesh or PointCloud) : the data to load\n</code></pre>"},{"location":"api/#npblender.Cloud.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(other, selection=None)\n</code></pre> <p>Create a Cloud from another gemetry with points domain.</p> Arguments <pre><code>- other (Geometry) : the geometry to copy\n- selection (selection) : a valid selection on points\n</code></pre> <p>Returns:</p> Type Description <code>    - Cloud</code>"},{"location":"api/#npblender.Cloud.from_object","title":"from_object  <code>classmethod</code>","text":"<pre><code>from_object(obj, evaluated=False)\n</code></pre> <p>Create a Mesh from an existing object.</p> Arguments <pre><code>- obj (str or Blender object) : the object to initialize from\n- evaluated (bool = False) : object modified by the modifiers if True, raw vertices otherwise\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Cloud.join","title":"join","text":"<pre><code>join(*others)\n</code></pre> <p>Join other clouds.</p> Arguments <pre><code>- other (Mesh) : the Meshes to append\n</code></pre>"},{"location":"api/#npblender.Cloud.to_data","title":"to_data","text":"<pre><code>to_data(data)\n</code></pre> <p>Write the geometry into a Blender Mesh</p> <p>[!CAUTION]: to_data creates a blender Mesh, not PointCloud since the pyton API doesn't allow to dynamically change the number of points</p> Arguments <pre><code>- mesh (Blender Mesh instance) : the mesh to write\n</code></pre>"},{"location":"api/#npblender.Cloud.to_object","title":"to_object","text":"<pre><code>to_object(obj, point_cloud=False, collection=None)\n</code></pre> <p>Create or update a blender object.</p> <p>By default, a mesh object is created. If as_point_cloud is True, the object is the converted to a PointCloud object.</p> Arguments <pre><code>- obj (str or Blender object) : the object the create\n- point_cloud (bool = False) : the object is a PointCloud object if True\n- collection (str or Blender collection) : the collection to add the object to\n</code></pre> <p>Returns:</p> Type Description <code>    - Blender Mesh or PointCloud object</code>"},{"location":"api/#npblender.Corner","title":"Corner","text":"<pre><code>Corner(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>               Bases: <code>Domain</code></p> <p>Corner domain stores a vertex index for face descriptions.</p> <p>This domain is specific to Mesh geometry. It keeps a pointer to the Mesh POINT domain.</p> <p>Attributes:</p> Name Type Description <code>- vertex_index (int)</code> <code>vertex index in the points array</code> <ul> <li>UVMap (float2, optional) : UV Map coordinates</li> </ul>"},{"location":"api/#npblender.Curve","title":"Curve","text":"<pre><code>Curve(points=None, splines=None, curve_type=POLY, materials=None, attr_from=None, **attrs)\n</code></pre> <p>               Bases: <code>Geometry</code></p> <p>Curve Geometry.</p> Arguments <pre><code>- points (array of vectors = None) : the vertices\n- splines (array of ints = None) : sizes\n- curve_type (array onf ints) : curve types\n- materials (str or list of strs = None) : list of materials used in the geometry\n- **attrs (dict) : other geometry attributes\n</code></pre>"},{"location":"api/#npblender.Curve.add_bezier","title":"add_bezier","text":"<pre><code>add_bezier(points, splines=None, handle_left=None, handle_right=None, cyclic=False, **attrs)\n</code></pre> <p>Add Bezier splines</p> <p>The arguments 'splines' gives the length(s) of the bezier spline(s). If None: - the number of points is taken (one spline is added) - points.shape[1] is taken if the shape of points is (m, , 3)</p> <p>handle_left and handle_right must have the same shape as points if provided. If they aren't provided, they are computed.</p> Arguments <ul> <li>points (array (n, 3) or (m, n, 3) of vectors) : the points of the curves</li> <li>splines (int or array of ints = None) : spline or splines length</li> <li>handle_left (same shape as points = None) : left handles</li> <li>handle_right (same shape as points = None) : right handles</li> <li>cyclic (bool = False) : whether the curve is cyclic or not</li> <li>attrs (dict) : spline and/or points attributes</li> </ul> <p>Returns:</p> Type Description <code>- dict ('points': added points indices, 'splines': added splines indices)</code>"},{"location":"api/#npblender.Curve.add_poly","title":"add_poly","text":"<pre><code>add_poly(points, splines=None, curve_type=POLY, cyclic=False, w=1.0, **attrs)\n</code></pre> <p>Add Poly or Nurbs splines</p> <p>The arguments 'splines' gives the length(s) of the spline(s). If None: - the number of points is taken (one spline is added) - points.shape[1] is taken if the shape of points is (m, , 3)</p> <p>Non bezeier splines use 4D points. If the provided vectors are 4D, the argument w is ignored.</p> Arguments <ul> <li>points (array (n, 3 or 4) or (m, n, 3 or 4) of vectors) : the points of the curves</li> <li>splines (int or array of ints = None) : spline or splines length</li> <li>cyclic (bool = False) : whether the curve is cyclic or not</li> <li>w (float) : w value, ignored if points are 4D</li> <li>attrs (dict) : spline and/or points attributes</li> </ul> <p>Returns:</p> Type Description <code>- dict ('points': added points indices, 'splines': added splines indices)</code>"},{"location":"api/#npblender.Curve.add_splines","title":"add_splines","text":"<pre><code>add_splines(points=None, splines=None, curve_type=POLY, **attrs)\n</code></pre> <p>Add splines</p>"},{"location":"api/#npblender.Curve.blender_data","title":"blender_data","text":"<pre><code>blender_data(readonly=False)\n</code></pre> <p>Acces to Blender Curve API.</p> <p>Transfer the geometry to a temporay Blender Curve. The example below use a blender Mesh to get the normals.</p> <pre><code>curve = Curve.Spiral()\n\nwith curve.blender_data() as bcurve:\n    print(\"Number of points\", len(bcurve.splines[0].points))\n\n# &gt; Number of points 65\n</code></pre> Arguments <pre><code>- readonly (bool=False) : don't read back the geometry if not modified\n</code></pre> <p>Returns:</p> Type Description <code>    - Blender Mesh</code>"},{"location":"api/#npblender.Curve.capture","title":"capture","text":"<pre><code>capture(other)\n</code></pre> <p>Capture the data of another Curve.</p> Arguments <pre><code>- other (Curve) : the mesh to capture\n</code></pre> <p>Returns:</p> Type Description <code>    - self</code>"},{"location":"api/#npblender.Curve.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Clear the geometry</p>"},{"location":"api/#npblender.Curve.compute_bezier_handles","title":"compute_bezier_handles  <code>staticmethod</code>","text":"<pre><code>compute_bezier_handles(points, cyclic=False, eps=1e-06)\n</code></pre> <p>Compute cubic Bezier handles (left/right) from anchors using Catmull-Rom style tangents.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>(N,3) or (B,N,3) float32/float64</code> <p>OPEN storage (no duplicated first point).</p> required <code>cyclic</code> <code>bool</code> <p>If True, wrap neighbors; else use one-sided differences at ends.</p> <code>False</code> <code>eps</code> <code>float</code> <p>Small epsilon to guard against zero-length tangents.</p> <code>1e-06</code> <p>Returns:</p> Type Description <code>left, right : same shape as `points`</code> <p>left[i]  = P[i] - T[i] * (len_in[i]  / 3) right[i] = P[i] + T[i] * (len_out[i] / 3) with len_in = ||P[i] - P[i-1]|| and len_out = ||P[i+1] - P[i]|| (wrapped if cyclic).</p>"},{"location":"api/#npblender.Curve.delete_points","title":"delete_points","text":"<pre><code>delete_points(points=None, splines=None)\n</code></pre> <p>Delete points.</p> Arguments <pre><code>points : points selection, optional\n    Points indices to delete directly.\nsplines : splines selection, optional\n    Splines owning vertices to delete.\n</code></pre>"},{"location":"api/#npblender.Curve.delete_splines","title":"delete_splines","text":"<pre><code>delete_splines(splines=None)\n</code></pre> <p>Delete splines.</p> Arguments <pre><code>splines : splines selection, optional\n    Splines owning vertices to delete.\n</code></pre>"},{"location":"api/#npblender.Curve.for_each_bucket","title":"for_each_bucket","text":"<pre><code>for_each_bucket(func)\n</code></pre> <p>Iterate over homogeneous spline buckets and call <code>func</code> once per bucket.</p> <p>Bucketing key: (curve_type, N, cyclic, resolution)    # resolution only relevant for BEZIER</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>Signature:     func(curve, curve_type, loop_total, is_cyclic, resolution=None) -&gt; any - <code>curve</code> is a Curve view on self . - <code>curve_type</code> is the spline type. - <code>loop_total</code> is the number of points in the spline. - <code>is_cyclic</code> is True if the spline is cyclic. - <code>resolution</code> is the resolution of the loop, or None if the spline is not Bezier.</p> required <p>Yields:</p> Type Description <code>(indices, result)</code> <p>indices : list[int]     Spline indices for this bucket, in stacking order. result : any     Whatever <code>func</code> returned for this bucket.</p>"},{"location":"api/#npblender.Curve.from_curve","title":"from_curve  <code>classmethod</code>","text":"<pre><code>from_curve(other, points=None, splines=None)\n</code></pre> <p>Create a Curve from another curve.</p> Arguments <pre><code>- other (Mesh) : the mesh to copy\n- points (selector = None) : points selection\n- splines (selector = None) : splines selection\n</code></pre> <p>Returns:</p> Type Description <code>    - Curve</code>"},{"location":"api/#npblender.Curve.from_curve_data","title":"from_curve_data  <code>classmethod</code>","text":"<pre><code>from_curve_data(data)\n</code></pre> <p>Initialize the geometry from a Blender Curve</p> Arguments <pre><code>- data (Blender Curve instance) : the curve to load\n</code></pre>"},{"location":"api/#npblender.Curve.from_object","title":"from_object  <code>classmethod</code>","text":"<pre><code>from_object(obj, evaluated=False)\n</code></pre> <p>Create a Curve from an existing curve.</p> Arguments <pre><code>- obj (str or Blender object) : the object to initialize from\n- evaluated (bool = False) : object modified by the modifiers if True, raw vertices otherwise\n</code></pre> <p>Returns:</p> Type Description <code>    - Curve</code>"},{"location":"api/#npblender.Curve.get_points_selection","title":"get_points_selection","text":"<pre><code>get_points_selection()\n</code></pre> <p>Get selection on points associated to the splines.</p> <p>If the Curve is not a view on splines, if return [:], otherwise it returns a selection on the points.</p> <p>Returns:</p> Type Description <code>    - sel (slice) : indices of splines points</code>"},{"location":"api/#npblender.Curve.join","title":"join","text":"<pre><code>join(*others)\n</code></pre> <p>Join other Curves.</p> Arguments <pre><code>- others (Curve) : the curves to append\n</code></pre>"},{"location":"api/#npblender.Curve.multiply","title":"multiply","text":"<pre><code>multiply(count, in_place=True)\n</code></pre> <p>Duplicate the geometry.</p> <p>Multiplying is a way to efficiently duplicate the geometry a great number of times. Once duplicated, the points can be reshapped to address each instance individually.</p> <pre><code>count = 16\n\ncube = Mesh.Cube() * count\n\n# Shape the points as 16 blocks of 8 vertices\npoints = np.reshape(cube.points.position, (16, 8, 3))\n\n# Place the cubes in a circle\nags = np.linspace(0, 2*np.pi, count, endpoint=False)\npoints[..., 0] += 6 * np.cos(ags)[:, None]\npoints[..., 1] += 6 * np.sin(ags)[:, None]\n\ncube.to_object(\"Cubes\")\n</code></pre> Arguments <pre><code>- count (int=10) : number of instances\n- attributes (name=value) : value for named attributes\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Curve.no_view","title":"no_view","text":"<pre><code>no_view()\n</code></pre> <p>Materialize a view-curve into a standalone curve (deep copy of splines and points), preserving all point-domain fields (handles, custom attrs, ...).</p>"},{"location":"api/#npblender.Curve.select","title":"select","text":"<pre><code>select(indices)\n</code></pre> <p>Explicit alias for subsetting splines; same semantics as curve[indices].</p>"},{"location":"api/#npblender.Curve.to_bezier","title":"to_bezier","text":"<pre><code>to_bezier(control_count=None, resolution=16)\n</code></pre> <p>Convert splines to Bezier splines (OPEN storage).</p> <p>Parameters:</p> Name Type Description Default <code>control_count</code> <code>int or None</code> <p>Number of anchor points to generate per spline. If None, keep current loop_total. For cyclic splines, anchors are sampled on [0,1) (no duplicate). For non-cyclic, on [0,1].</p> <code>None</code> <code>resolution</code> <code>int</code> <p>Per-segment resolution to write into <code>splines.resolution</code> (&gt;=1).</p> <code>16</code>"},{"location":"api/#npblender.Curve.to_curve_data","title":"to_curve_data","text":"<pre><code>to_curve_data(data)\n</code></pre> <p>Initialize the geometry from a Blender Curve</p> Arguments <pre><code>- data (Blender Curve instance) : the curve to load\n</code></pre>"},{"location":"api/#npblender.Curve.to_mesh","title":"to_mesh","text":"<pre><code>to_mesh(profile=None, caps=True, use_radius=True, camera_culling=False)\n</code></pre> <p>Transform curve to mesh</p> <p>If profile is None, the mesh contains only edges otherwise they are ignored</p> Arguments <ul> <li>profile (Curve = None) : profile curve</li> <li>caps (bool = True) : use caps</li> <li>use_radius (bool = True) : use the radius as a scale for profile</li> </ul> <p>Returns:</p> Type Description <code>-Mesh</code>"},{"location":"api/#npblender.Curve.to_object","title":"to_object","text":"<pre><code>to_object(obj, collection=None)\n</code></pre> <p>Create or update a blender object.</p> <p>The method 'to_object' creates the whole geometry. It creates a new object if it doesn't already exist. If the object exists, it must be a curve, there is no object type conversion.</p> <p>Once the object is created, use the method 'update_object' to change the vertices.</p> Arguments <pre><code>- obj (str or Blender object) : the object the create\n</code></pre> <p>Returns:</p> Type Description <code>    - Blender curve object</code>"},{"location":"api/#npblender.Curve.to_poly","title":"to_poly","text":"<pre><code>to_poly(resolution=None)\n</code></pre> <p>Convert the splines to Poly splines.</p> <p>If resolution is None: - <code>splines.resolution</code> is used to split Bezier segments - poly lines are left unchanged</p> <p>If resolution is not None, all splines are resampled using this value</p> Arguments: <pre><code>resolution (int):          Poly resolution, use spline resolution for Bezier if None.\n</code></pre>"},{"location":"api/#npblender.Edge","title":"Edge","text":"<pre><code>Edge(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>               Bases: <code>Domain</code></p> <p>Edge domain.</p> <p>Attributes:</p> Name Type Description <code>- vertex0 (int)</code> <code>index of the first vertex</code> <ul> <li>vertex1 (int) : index of the second vertex</li> </ul>"},{"location":"api/#npblender.Face","title":"Face","text":"<pre><code>Face(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>               Bases: <code>FaceSplineDomain</code></p>"},{"location":"api/#npblender.Face.area","title":"area","text":"<pre><code>area(corners, points)\n</code></pre> <p>Faces areas</p> <p>Args:     verts (array (:, 3) of floats): The vertices</p> <p>Returns:     array (len(self)) of floats: The surfaces</p>"},{"location":"api/#npblender.Face.area_vectors","title":"area_vectors","text":"<pre><code>area_vectors(corners, points)\n</code></pre> <p>Compute the surfaces vectors</p> <p>The surfaces are computed by cross products of triangles. This also gives the normal to the face. The normal vector normal the length of which is the surface is called the surface vector.</p> Arguments <pre><code>- faces (int or array of ints = None) : the faces\n</code></pre> <p>Returns:</p> Type Description <code>    - array of vectors of floats: The surfaces normals</code>"},{"location":"api/#npblender.Face.get_edges","title":"get_edges","text":"<pre><code>get_edges(corners)\n</code></pre> <p>Get all the edge couples of the faces.</p>"},{"location":"api/#npblender.Face.get_face_edges","title":"get_face_edges","text":"<pre><code>get_face_edges(corners)\n</code></pre> <p>Return edge couples with ordered vertex indices par face.</p> <p>The face edge couples can be accessed via loop_start and loop_total</p>"},{"location":"api/#npblender.Face.normal","title":"normal","text":"<pre><code>normal(corners, points)\n</code></pre> <p>Compute the normals</p> <p>Args:     verts (array (:, 3) of floats): The vertices</p> <p>Returns:     array (len(self), 3) of floats: The normals</p>"},{"location":"api/#npblender.Face.position","title":"position","text":"<pre><code>position(corners, points)\n</code></pre> <p>Centers of the faces</p> <p>Args:     verts (array (:, 3) of floats): The vertices</p> <p>Returns:     array (len(self), 3) of floats: The centers</p>"},{"location":"api/#npblender.FieldArray","title":"FieldArray","text":"<pre><code>FieldArray(a=None, mode='COPY', selector=None)\n</code></pre> <p>               Bases: <code>object</code></p> <p>Dynamic structured array</p> <p>A structured array with cache management to optimize record appending.</p> <p>Initialize the array with another array</p> Arguments <ul> <li>a (array or FieldArray) : the array to initialize from</li> <li>mode (str in 'COPY', 'CAPTURE', 'EMPTY') : copy the content</li> <li>selector (Any = None) : a selector on data</li> </ul>"},{"location":"api/#npblender.FieldArray.actual_names","title":"actual_names  <code>property</code>","text":"<pre><code>actual_names\n</code></pre> <p>Column names.</p> <p>Returns the actual field names, excluding optional fields.</p>"},{"location":"api/#npblender.FieldArray.all_names","title":"all_names  <code>property</code>","text":"<pre><code>all_names\n</code></pre> <p>Column names.</p> <p>Returns all the field names, including optional ones.</p>"},{"location":"api/#npblender.FieldArray.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Array structured dtype</p> <p>Returns the dtype property of the structured array.</p>"},{"location":"api/#npblender.FieldArray.add","title":"add","text":"<pre><code>add(count, **fields)\n</code></pre> <p>Add count records</p> <p>New records are set with default values or values provided by the user in fields dict.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of records to add.</p> required <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/#npblender.FieldArray.append","title":"append","text":"<pre><code>append(**fields)\n</code></pre> <p>Append values to the structured array.</p> <p>The number of records to append is determined by the number of fields provided in the fields dictionary. The values of the fields are copied to the new records.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/#npblender.FieldArray.as_kwargs","title":"as_kwargs","text":"<pre><code>as_kwargs(selector=None, include=None, exclude=None)\n</code></pre> <p>Return a dictionary of field values formatted as kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>slice, int, list, or mask</code> <p>Optional selection of elements to extract.</p> <code>None</code> <code>include</code> <code>list[str]</code> <p>List of field names (original or python names) to include.</p> <code>None</code> <code>exclude</code> <code>list[str]</code> <p>List of field names (original or python names) to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Mapping from python-safe field names to array values.</p>"},{"location":"api/#npblender.FieldArray.copy_field","title":"copy_field","text":"<pre><code>copy_field(field_name, new_name, **infos)\n</code></pre> <p>Duplicate an existing field under a new name, with optional metadata overrides.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the existing field to copy.</p> required <code>new_name</code> <code>str</code> <p>The name of the new field to create.</p> required <code>infos</code> <code>keyword arguments</code> <p>Optional metadata (e.g. default, unit, description...) to override or supplement the original field's metadata.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the source field does not exist.</p> <code>ValueError</code> <p>If the target name already exists or is reserved.</p>"},{"location":"api/#npblender.FieldArray.delete","title":"delete","text":"<pre><code>delete(index)\n</code></pre> <p>Delete a selection of items from the array.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int, slice, or array-like</code> <p>The indices of the elements to delete from the current data.</p> required Notes <p>This operates only on the valid range <code>[0:self._length]</code>. The internal buffer is preserved (no reallocation).</p>"},{"location":"api/#npblender.FieldArray.extend","title":"extend","text":"<pre><code>extend(other, join_fields=True)\n</code></pre> <p>Append multiple records from another array or FieldArray.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray or structured np.ndarray</code> <p>The array of records to append. Must have named fields matching a subset of the current array's fields.</p> required"},{"location":"api/#npblender.FieldArray.filtered","title":"filtered","text":"<pre><code>filtered(selector, *, copy=False)\n</code></pre> <p>Return a FieldArray containing only the selected records.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>array\u2011like, slice or int</code> <p>Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice. It is applied to the current valid part of the buffer (<code>self._data[:self._length]</code>).</p> required <code>copy</code> <code>bool</code> <ul> <li>False    (default) =&gt; the new array shares the same memory                          (changes propagate both ways).</li> <li>True           =&gt; the data are physically copied.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>FieldArray</code> <p>A new instance holding exactly <code>len(selector)</code> records and inheriting the current field\u2011infos.</p>"},{"location":"api/#npblender.FieldArray.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Build a FieldArray from a dictionary with field data and optional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, array - like or (array, dict)]</code> <p>Mapping field names to arrays or (array, infos). Infos must include NAME.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the data. Default: True.</p> required <p>Returns:</p> Type Description <code>FieldArray</code>"},{"location":"api/#npblender.FieldArray.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> <p>Get attribute by name.</p> <p>If name is not an actual field, return default value. Name can be an array.</p> <pre><code>pos = field_array.get(\"position\", (0, 0, 1))\npos = field_array.get([[0, 0, 1], [0, 0, 0]])\n</code></pre>"},{"location":"api/#npblender.FieldArray.join_fields","title":"join_fields","text":"<pre><code>join_fields(other, exclude=[])\n</code></pre> <p>Add all missing fields from another FieldArray.</p> <p>For every field in <code>other</code> that is not present in <code>self</code>, a new field is created with the same dtype and shape, and initialized with its default value across all existing records.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray</code> <p>Another FieldArray instance whose fields will be checked for missing fields.</p> required <p>Returns:</p> Type Description <code>self</code>"},{"location":"api/#npblender.FieldArray.multiply","title":"multiply","text":"<pre><code>multiply(count)\n</code></pre> <p>Duplicate the current records <code>count</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of times to repeat the current records.</p> required Notes <p>This duplicates the current valid records (up to self._length). If the array is empty or count &lt;= 1, nothing happens.</p> Example: <p>If the array has 3 records and count == 4, the result will be:</p> <p>[rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]</p>"},{"location":"api/#npblender.FieldArray.new_field","title":"new_field","text":"<pre><code>new_field(name, dtype, shape=None, default=0, optional=False, **infos)\n</code></pre> <p>Add a field to the structured array.</p> Arguments <pre><code>- name (str) : field name\n- dtype (type) : a valid numpy dtype\n- shape (tuple = None) : the shape of the field\n- default (any = 0) : default value\n- optional (bool = False) : the field is created only when accessed\n- infos (dict) : field infos\n</code></pre>"},{"location":"api/#npblender.FieldArray.to_dict","title":"to_dict","text":"<pre><code>to_dict(*, copy=True, with_infos=True)\n</code></pre> <p>Convert the array to a dictionary of fields or (field, infos) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Whether to copy the arrays.</p> <code>True</code> <code>with_infos</code> <code>bool</code> <p>If True, return (array, infos) for each field.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, array or (array, dict)]</code>"},{"location":"api/#npblender.Geometry","title":"Geometry","text":""},{"location":"api/#npblender.Geometry.add_materials","title":"add_materials","text":"<pre><code>add_materials(materials)\n</code></pre> <p>Add a materials list to the existing one.</p> <p>If a material already exist, it is not added another time.</p> Arguments <pre><code>- materials (list of strs) : the list of materials to append.\n</code></pre>"},{"location":"api/#npblender.Geometry.get_material_index","title":"get_material_index","text":"<pre><code>get_material_index(mat_name)\n</code></pre> <p>Return the index of a material name.</p> <p>If the material doesn't exist, it is created</p> Arguments <pre><code>- mat_name (str) : material name\n</code></pre> <p>Returns:</p> Type Description <code>    - int : index of the material name in the materials list</code>"},{"location":"api/#npblender.Geometry.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other, **kwargs)\n</code></pre> <p>Capture the attributes from another geometry.</p> <p>Other can be a different geometry, in that case, only domains with the same name are captured. kwargs allows to filter the domains to capture:</p> <pre><code>mesh.join_attributes(other_mesh, faces=False)\nmesh.join_attributes(curve)\n</code></pre> <p>Returns:     - self</p>"},{"location":"api/#npblender.Geometry.load_models","title":"load_models  <code>staticmethod</code>","text":"<pre><code>load_models(*specs)\n</code></pre> <p>Load a geometry or geometries from specifications.</p> <p>The specs can be:     - a Blender collection     - a Blender object     - a Geometry</p> Arguments <pre><code>- specs (list of objects / collections) : the models to load\n</code></pre> <p>Returns:</p> Type Description <code>    - list of geometries</code>"},{"location":"api/#npblender.Geometry.load_object","title":"load_object  <code>staticmethod</code>","text":"<pre><code>load_object(name)\n</code></pre> <p>Load a Blender object and returns either a Mesh or a Curve.</p> Arguments <pre><code>- name (str or bpy.types.Object) : the object to load\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh or Curve</code>"},{"location":"api/#npblender.Instances","title":"Instances","text":"<pre><code>Instances(points=None, models=None, model_index=None, attr_from=None, **attributes)\n</code></pre> <p>               Bases: <code>Geometry</code></p> <p>Create new instances.</p> Arguments <pre><code>- points (array of vectors = None) : instances locations\n- models (geometry or list of geometries = None) : the geometries to instantiate\n- model_index (int = 0) : model index of instances\n- **attributes (dict) : other geometry attributes\n</code></pre>"},{"location":"api/#npblender.Mesh","title":"Mesh","text":"<pre><code>Mesh(points=None, corners=None, faces=None, edges=None, materials=None, attr_from=None, **attrs)\n</code></pre> <p>               Bases: <code>Geometry</code></p> <p>Initialize a Mesh Geometry object.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array_like</code> <p>The vertices of the mesh (default is None).</p> <code>None</code> <code>corners</code> <code>array_like of int</code> <p>Corners, i.e., indices on the array of points (default is None).</p> <code>None</code> <code>faces</code> <code>array_like of int</code> <p>Sizes of the faces; the sum of this array must be equal to the length of the corners array (default is None).</p> <code>None</code> <code>edges</code> <code>array_like of tuple of int</code> <p>List of edges defined by pairs of vertex indices (default is None).</p> <code>None</code> <code>materials</code> <code>str or list of str</code> <p>List of materials used in the geometry. If a single string is provided, it is converted to a list containing that string (default is None).</p> <code>None</code> <code>attr_from</code> <code>Geometry</code> <p>Domain attributes to copy from another Geometry object (default is None).</p> <code>None</code> <code>**attrs</code> <code>dict</code> <p>Additional geometry attributes.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>points</code> <code>Vertex</code> <p>The vertices of the mesh.</p> <code>corners</code> <code>Corner</code> <p>The corners of the mesh.</p> <code>faces</code> <code>Face</code> <p>The faces of the mesh.</p> <code>edges</code> <code>Edge</code> <p>The edges of the mesh.</p> <code>materials</code> <code>list of str</code> <p>The list of materials used in the geometry.</p>"},{"location":"api/#npblender.Mesh.add_geometry","title":"add_geometry","text":"<pre><code>add_geometry(points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs)\n</code></pre> <p>Add geometry components (vertices, corners, faces, edges) to the mesh.</p> <p>This method appends the specified geometry to the mesh without altering existing indices. It supports referencing existing vertices through corners or adding new vertices.</p> <p>Note: To add independent geometry with new vertices, use <code>Mesh.join_geometry</code> instead.</p> <p>Examples:</p> <pre><code>``` python\ncube = Mesh.cube()\n# Add a triangle on existing vertices\n# corners argument refers to cube vertices\ncube.add_geometry(corners=[0, 1, 2], faces=3)\n\n# Add a triangle with additional vertices\n# corners argument refers to the new vertices, passed values [0, 1, 2]\n# will be shifted to actual values [8, 9, 10]\ncube.join_geometry(points=[[0, 0, 0], [0, 1, 0], [1, 0, 0]], corners=[0, 1, 2], faces=3)\n```\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like of vectors</code> <p>Vertices to add to the mesh.</p> <code>None</code> <code>corners</code> <code>array-like of int</code> <p>Indices referring to vertices in the points array.</p> <code>None</code> <code>faces</code> <code>int, array-like of int, or list of lists</code> <p>Defines the faces topology: - If <code>corners</code> is provided:     - None: Single face made of all corners.     - int: All faces have the same size (must divide the number of corners).     - array-like: Face sizes; sum must equal the number of corners. - If <code>corners</code> is None:     - Must be a list of lists, each sublist is a list of corners.</p> <code>None</code> <code>edges</code> <code>array-like of pairs of int</code> <p>Edges defined by pairs of vertex indices.</p> <code>None</code> <code>safe_mode</code> <code>bool</code> <p>If True, perform a mesh integrity check after adding geometry.</p> <code>False</code> <code>**attrs</code> <code>dict</code> <p>Additional geometry attributes to apply.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys {'points', 'corners', 'faces', 'edges'} mapping to lists of added geometry indices.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If faces and corners lengths are inconsistent or invalid.</p>"},{"location":"api/#npblender.Mesh.add_points","title":"add_points","text":"<pre><code>add_points(points, **attributes)\n</code></pre> <p>Add vertices.</p> Arguments <pre><code>- points (array of vectors) : the vertices to add\n- attributes (name=value) : value for named attributes\n</code></pre> <p>Returns:</p> Type Description <code>    - array of ints : indices of the added vertices</code>"},{"location":"api/#npblender.Mesh.arrow","title":"arrow  <code>classmethod</code>","text":"<pre><code>arrow(vector=(0, 0, 1), radius=0.05, angle=24.0, segments=8, adjust_norm=None, materials=None)\n</code></pre> <p>Create an arrow mesh oriented along a given vector.</p> <p>The arrow is composed of a cylindrical shaft and a conical head, proportionally scaled to the length of the input vector.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>array-like of float, shape (3,)</code> <p>Direction and length of the arrow. The norm of the vector defines the arrow length. Default is (0, 0, 1).</p> <code>(0, 0, 1)</code> <code>radius</code> <code>float</code> <p>Radius of the cylindrical shaft. Default is 0.05.</p> <code>0.05</code> <code>angle</code> <code>float</code> <p>Opening angle of the conical head in degrees. Default is 24.</p> <code>24.0</code> <code>segments</code> <code>int</code> <p>Number of segments around the circumference. Default is 8.</p> <code>8</code> <code>adjust_norm</code> <code>(callable, float, None)</code> <ul> <li>If callable: a function applied to the vector norm to adjust the arrow length.</li> <li>If float: the arrow length is clamped to this maximum.</li> <li>If None: use the norm of <code>vector</code> directly. Default is None.</li> </ul> <code>callable</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the arrow. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the arrow.</p> Notes <ul> <li>The shaft is created with <code>cylinder</code>.</li> <li>The head is created with <code>cone</code> using <code>fill_type='FANS'</code> for proper triangulation.</li> <li>The arrow is aligned to <code>vector</code> using <code>Rotation.look_at</code>.</li> <li>A small correction is applied to avoid overlap between shaft and head.</li> </ul> <p>Examples:</p> <p>Create a default arrow of length 1 along Z:</p> <pre><code>arrow = Mesh.arrow()\n</code></pre> <p>Create an arrow along vector (1, 2, 0.5) with custom shaft radius:</p> <pre><code>arrow = Mesh.arrow(vector=(1, 2, 0.5), radius=0.1)\n</code></pre> <p>Create an arrow clamped to maximum length 2:</p> <pre><code>arrow = Mesh.arrow(vector=(0, 0, 5), adjust_norm=2)\n</code></pre> See Also <p><code>cylinder</code> :     Used to create the arrow shaft. <code>cone</code> :     Used to create the arrow head. <code>Rotation.look_at</code> :     Utility to orient the arrow along a target vector.</p> <p>Caution: If <code>vector</code> has zero length, the arrow cannot be constructed properly.</p> <p>Note: The conical head radius is set to <code>3 * radius</code> by default, and its height is determined by the opening <code>angle</code>.</p>"},{"location":"api/#npblender.Mesh.bl_circle","title":"bl_circle  <code>classmethod</code>","text":"<pre><code>bl_circle(radius=1, segments=16, fill_tris=False, materials=None)\n</code></pre> <p>Create a circle mesh.</p> <p>Blender constructor for generating a circle primitive using <code>bmesh.ops.create_circle</code>.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the circle. Default is 1.</p> <code>1</code> <code>segments</code> <code>int</code> <p>Number of segments (vertices) forming the circle. Default is 16.</p> <code>16</code> <code>fill_tris</code> <code>bool</code> <p>If True, fills the circle with a triangle fan. Default is False.</p> <code>False</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the circle. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the circle.</p> Notes <ul> <li>The circle is created using <code>bmesh.ops.create_circle</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> <li>By default (<code>fill_tris=False</code>), the circle is an open ring. With <code>fill_tris=True</code>, the circle is filled with triangles (fan topology).</li> </ul> <p>Examples:</p> <p>Create an empty circle of radius 2 with 32 segments:</p> <pre><code>circle = Mesh.bl_circle(radius=2, segments=32)\n</code></pre> <p>Create a filled circle (disk) of radius 1 with 24 segments:</p> <pre><code>circle = Mesh.bl_circle(radius=1, segments=24, fill_tris=True)\n</code></pre> See Also <p><code>bmesh.ops.create_circle</code> :     BMesh operator used for creating a circle primitive.</p> <p>Note: UVs are automatically calculated when the circle is created.</p>"},{"location":"api/#npblender.Mesh.bl_cone","title":"bl_cone  <code>classmethod</code>","text":"<pre><code>bl_cone(radius1=1, radius2=0, depth=2, segments=16, side_segments=1, cap_ends=True, cap_tris=False, materials=None)\n</code></pre> <p>Create a cone mesh.</p> <p>Blender constructor for generating a cone (or cylinder) primitive using <code>bmesh.ops.create_cone</code>.</p> <p>Parameters:</p> Name Type Description Default <code>radius1</code> <code>float</code> <p>Base radius of the cone. Default is 1.</p> <code>1</code> <code>radius2</code> <code>float</code> <p>Top radius of the cone. If set to 0, produces a true cone; if equal to <code>radius1</code>, produces a cylinder. Default is 0.</p> <code>0</code> <code>depth</code> <code>float</code> <p>Height of the cone along the Z axis. Default is 2.</p> <code>2</code> <code>segments</code> <code>int</code> <p>Number of segments around the circumference. Default is 16.</p> <code>16</code> <code>side_segments</code> <code>int</code> <p>Number of subdivisions along the vertical side edges. Default is 1 (no subdivision).</p> <code>1</code> <code>cap_ends</code> <code>bool</code> <p>If True, fill the top and bottom caps. Default is True.</p> <code>True</code> <code>cap_tris</code> <code>bool</code> <p>If True, fill the caps using triangle fans instead of n-gons. Default is False.</p> <code>False</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the cone. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the cone.</p> Notes <ul> <li>The cone is created using <code>bmesh.ops.create_cone</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> <li>When <code>side_segments &gt; 1</code>, vertical edges crossing the top and bottom are subdivided using <code>bmesh.ops.subdivide_edges</code>.</li> </ul> <p>Examples:</p> <p>Create a simple cone with radius 1 and height 2:</p> <pre><code>cone = Mesh.bl_cone(radius1=1, radius2=0, depth=2, segments=16)\n</code></pre> <p>Create a cylinder with 32 segments and subdivided sides:</p> <pre><code>cylinder = Mesh.bl_cone(radius1=1, radius2=1, depth=3,\n                        segments=32, side_segments=4)\n</code></pre> <p>Create a cone with filled caps using triangle fans:</p> <pre><code>cone = Mesh.bl_cone(radius1=1, radius2=0, depth=2,\n                    cap_ends=True, cap_tris=True)\n</code></pre> See Also <p><code>bmesh.ops.create_cone</code> :     BMesh operator used for creating cone and cylinder primitives. <code>bmesh.ops.subdivide_edges</code> :     BMesh operator used for subdividing vertical edges when <code>side_segments &gt; 1</code>.</p> <p>Note: UVs are automatically calculated when the cone is created.</p>"},{"location":"api/#npblender.Mesh.bl_grid","title":"bl_grid  <code>classmethod</code>","text":"<pre><code>bl_grid(x_segments=1, y_segments=1, size=2, materials=None)\n</code></pre> <p>Create a grid mesh.</p> <p>Blender constructor for generating a grid primitive using <code>bmesh.ops.create_grid</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x_segments</code> <code>int</code> <p>Number of segments along the X axis. Default is 1.</p> <code>1</code> <code>y_segments</code> <code>int</code> <p>Number of segments along the Y axis. Default is 1.</p> <code>1</code> <code>size</code> <code>float or tuple of float</code> <p>Size of the grid. If a single float is given, the grid is square. If a tuple is given, defines the grid dimensions along X and Y. Default is 2.</p> <code>2</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the grid. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the grid.</p> Notes <ul> <li>The grid is created using <code>bmesh.ops.create_grid</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> </ul> <p>Examples:</p> <p>Create a 10x10 grid of size 5:</p> <pre><code>grid = Mesh.bl_grid(x_segments=10, y_segments=10, size=5)\n</code></pre> <p>Create a rectangular grid 4x8 of size (2, 5):</p> <pre><code>grid = Mesh.bl_grid(x_segments=4, y_segments=8, size=(2, 5))\n</code></pre> See Also <p><code>bmesh.ops.create_grid</code> :     BMesh operator used for creating a grid primitive.</p> <p>Note: UVs are automatically calculated when the grid is created.</p>"},{"location":"api/#npblender.Mesh.blender_data","title":"blender_data","text":"<pre><code>blender_data(readonly=False)\n</code></pre> <p>Context manager to access the Blender Mesh API with a temporary mesh.</p> <p>This method transfers the current mesh geometry to a temporary Blender Mesh data block, yields it for reading or modification, and optionally captures the changes back into the mesh.</p> <p>Example usage:     ```python     mesh = Mesh.Cube()</p> <pre><code>with mesh.blender_data() as data:\n    normals = np.array([poly.normal for poly in data.polygons])\n\nprint(normals)\n# Output:\n# [[-1. -0.  0.]\n#  [ 0.  1.  0.]\n#  [ 1. -0.  0.]\n#  [ 0. -1.  0.]\n#  [ 0.  0. -1.]\n#  [ 0. -0.  1.]]\n```\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>readonly</code> <code>bool</code> <p>If True, the geometry is not read back from the Blender Mesh after modification. Default is False.</p> <code>False</code> <p>Yields:</p> Type Description <code>Mesh</code> <p>A temporary Blender Mesh data block representing the mesh geometry.</p>"},{"location":"api/#npblender.Mesh.bmesh","title":"bmesh","text":"<pre><code>bmesh(readonly=False)\n</code></pre> <p>Context manager to access and manipulate the mesh using Blender's BMesh API.</p> <p>This method creates a temporary BMesh from the mesh data, yields it for modification, and then writes back the changes to the mesh data unless in readonly mode.</p> <p>Example usage:     ```python     mesh = Mesh.Cube()</p> <pre><code># Move the vertices with bmesh\nwith mesh.bmesh() as bm:\n    for v in bm.verts:\n        v.co.x += 1.0\n\n# Move the vertices directly in numpy array\nmesh.points.position[:, 1] += 1\n\n# Cube moved along x and y\nmesh.to_object(\"Cube\")\n```\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>readonly</code> <code>bool</code> <p>If True, changes made to the BMesh are not written back to the mesh data (default is False).</p> <code>False</code> <p>Yields:</p> Type Description <code>BMesh</code> <p>A BMesh object representing the mesh data, which can be modified within the context.</p>"},{"location":"api/#npblender.Mesh.boolean","title":"boolean","text":"<pre><code>boolean(other, operation='DIFFERENCE')\n</code></pre> <p>Apply a boolean CSG operation with another mesh object and return the result.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Mesh</code> <p>The mesh used as the boolean operand.</p> required <code>operation</code> <code>(INTERSECT, UNION, DIFFERENCE)</code> <p>Type of boolean operation to perform. Default is 'DIFFERENCE'.</p> <code>'INTERSECT'</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance created from the object after applying the Boolean modifier.</p> Notes <ul> <li>Internally, a Blender Boolean modifier is added to <code>self</code>, pointing to <code>other</code>, and then applied via <code>bpy.ops.object.modifier_apply</code>.</li> <li>The result is read back as a new mesh using <code>Mesh.from_object</code>.</li> <li>Context managers <code>object</code> are used to obtain temporary Blender objects for both meshes.</li> </ul> <p>Examples:</p> <p>Subtract <code>B</code> from <code>A</code>:</p> <pre><code>result = A.boolean(B, operation='DIFFERENCE')\n</code></pre> <p>Compute the union:</p> <pre><code>result = A.boolean(B, operation='UNION')\n</code></pre> <p>Keep only the intersection:</p> <pre><code>result = A.boolean(B, operation='INTERSECT')\n</code></pre> See Also <p><code>Mesh.from_object</code> :     Converts a Blender object back into a mesh wrapper. <code>object</code> :     Context manager yielding a temporary Blender object.</p> <p>Warning: Applying the modifier is destructive to the underlying Blender object for <code>self</code> (its mesh data is changed). The method returns a new mesh instance representing the modified result.</p> <p>Caution: Ensure <code>operation</code> is one of {'INTERSECT', 'UNION', 'DIFFERENCE'}; other values are invalid for Blender's Boolean modifier.</p>"},{"location":"api/#npblender.Mesh.bridge_loops","title":"bridge_loops","text":"<pre><code>bridge_loops(loop0, loop1, close=False, segments=1, **attributes)\n</code></pre> <p>Create a grid connecting two vertex loops of equal size.</p> <p>The operation selects the edges forming each loop and bridges them using <code>bmesh.ops.bridge_loops</code>. If <code>segments &gt; 1</code>, the newly created edges are subdivided to form a denser grid between the loops.</p> <p>Parameters:</p> Name Type Description Default <code>loop0</code> <code>array-like of int</code> <p>The first loop of vertex indices.</p> required <code>loop1</code> <code>array-like of int</code> <p>The second loop of vertex indices. Must have the same length as <code>loop0</code>.</p> required <code>close</code> <code>bool</code> <p>If True, the loops are treated as closed and the first vertex is appended at the end to close the cycle. Default is False.</p> <code>False</code> <code>segments</code> <code>int</code> <p>Number of segments to subdivide between the loops. Must be &gt;= 1. Default is 1 (no subdivision).</p> <code>1</code> <code>**attributes</code> <code>dict</code> <p>Additional attributes to set on the mesh after bridging (passed as keyword arguments).</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>Modifies the mesh in place. Returns <code>None</code>.</p> Notes <ul> <li>Edges belonging to each loop are identified by sorting endpoint pairs and matching them against the current BMesh edge list via a structured dtype view and <code>np.isin</code>.</li> <li>Bridging is performed with <code>bmesh.ops.bridge_loops</code>.</li> <li>When <code>segments &gt; 1</code>, subdivision of the bridge edges is performed with <code>bmesh.ops.subdivide_edges</code> using <code>cuts=segments - 1</code> and <code>use_grid_fill=False</code>.</li> </ul> <p>Examples:</p> <p>Bridge two loops with no subdivision:</p> <pre><code>obj.bridge_loops(loop0, loop1, segments=1)\n</code></pre> <p>Bridge two closed loops with 3 subdivisions:</p> <pre><code>obj.bridge_loops(loop0, loop1, close=True, segments=3)\n</code></pre> See Also <p>bmesh.ops.bridge_loops : BMesh operator for bridging edge loops. bmesh.ops.subdivide_edges : BMesh operator for subdividing edges.</p> <p>Warning: This function modifies the mesh in place and may create new vertices/edges/faces. Handle undo/history in Blender if needed.</p> <p>Caution: Both loops must have the same number of vertices for correct bridging.</p> <p>Note: When <code>close=True</code>, the first vertex of each loop is duplicated at the end to ensure cyclic connectivity.</p>"},{"location":"api/#npblender.Mesh.bvh_tree","title":"bvh_tree","text":"<pre><code>bvh_tree(count=None)\n</code></pre> <p>Build a Blender BVH tree for fast spatial queries (ray casting, overlap, nearest point, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>If <code>None</code>, build a single BVH tree for the whole mesh. If an integer <code>count</code> is provided, the mesh is assumed to represent a batch of <code>count</code> sub-meshes laid out in a structured array, and a list of BVH trees (one per sub-mesh) is returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>BVHTree or list of BVHTree</code> <ul> <li>If <code>count</code> is <code>None</code>, a single <code>BVHTree</code> instance built from the current mesh.</li> <li>If <code>count</code> is an integer, a list of <code>BVHTree</code> objects, one for each sub-mesh.</li> </ul> Notes <ul> <li>Internally uses <code>mathutils.bvhtree.BVHTree.FromPolygons</code>.</li> <li>When <code>count</code> is given, vertices are reshaped to <code>(count, n, 3)</code> and faces are assumed to be identical across all sub-meshes.</li> <li><code>epsilon=0.0</code> is used for exact geometry.</li> </ul> <p>Examples:</p> <p>Build a single BVH tree:</p> <pre><code>tree = mesh.bvh_tree()\nloc, normal, index, dist = tree.ray_cast((0, 0, 10), (0, 0, -1))\n</code></pre> <p>Build multiple BVH trees for a batch of 5 sub-meshes:</p> <pre><code>trees = mesh.bvh_tree(count=5)\nfor t in trees:\n    print(t.find_nearest((0, 0, 0)))\n</code></pre> <p>Caution: When <code>count</code> is provided, the mesh must be structured consistently: faces are taken from the first sub-mesh and reused for all.</p>"},{"location":"api/#npblender.Mesh.capture","title":"capture","text":"<pre><code>capture(other)\n</code></pre> <p>Capture the data of another Mesh.</p> Arguments <pre><code>- other (Mesh) : the mesh to capture\n</code></pre> <p>Returns:</p> Type Description <code>    - self</code>"},{"location":"api/#npblender.Mesh.chain_link","title":"chain_link  <code>classmethod</code>","text":"<pre><code>chain_link(major_segments=48, minor_segments=12, radius=1.0, section=0.5, length=4.0, materials=None)\n</code></pre> <p>Create a single chain link (oval torus with straightened sides).</p> <p>The link is built from a torus of major radius <code>radius</code> and tube radius <code>section / 2</code>. If <code>length &gt; 2 * radius</code>, the torus is split in half, translated to open a gap of size <code>delta = length - 2 * radius</code>, mirrored, then the opposite borders are bridged to form the elongated link. UVs are adjusted to keep a clean seam layout.</p> <p>Parameters:</p> Name Type Description Default <code>major_segments</code> <code>int</code> <p>Number of segments around the major loop. Default is 48.</p> <code>48</code> <code>minor_segments</code> <code>int</code> <p>Number of segments around the tube section. Default is 12.</p> <code>12</code> <code>radius</code> <code>float</code> <p>Major radius of the link (half the distance between opposite sides on the long axis before elongation). Default is 1.0.</p> <code>1.0</code> <code>section</code> <code>float</code> <p>Diameter of the link cross-section (tube thickness). Default is 0.5.</p> <code>0.5</code> <code>length</code> <code>float</code> <p>Target overall length of the link along its long axis. If close to <code>2 * radius</code>, the result is essentially a pure torus. Default is 4.0.</p> <code>4.0</code> <code>materials</code> <code>list of str</code> <p>Material names to assign to the link. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the chain link.</p> Notes <ul> <li>Construction steps: 1) Create a torus with <code>torus</code>. 2) Delete approximately half the vertices on the negative Y side with     <code>delete_vertices</code>. 3) Duplicate and mirror the remaining half to the other side. 4) Bridge the facing border loops with     <code>bridge_loops</code> (twice, crossing). 5) Recompute and assign UVs using <code>grid_uv_map</code>     to distribute the texture coordinates and minimize stretching.</li> <li>When <code>length - 2 * radius</code> is smaller than ~<code>radius / 10</code>, the method returns the original torus since elongation would be negligible.</li> </ul> <p>Examples:</p> <p>Create a standard chain link:</p> <pre><code>link = Mesh.chain_link(major_segments=64, minor_segments=16,\n                    radius=0.5, section=0.12, length=1.6)\n</code></pre> <p>Create a thicker, longer link:</p> <pre><code>link = Mesh.chain_link(radius=1.0, section=0.25, length=3.0)\n</code></pre> See Also <p><code>torus</code> :     Base primitive used to start the link. <code>delete_vertices</code> :     Used to remove half of the torus before mirroring. <code>bridge_loops</code> :     Used to reconnect mirrored borders. <code>grid_uv_map</code> :     Generates UVs for the final link surface. <code>from_mesh</code> :     Utility for duplicating mesh halves before joining.</p> <p>Caution: Very small <code>section</code> relative to <code>major_segments</code> can create skinny triangles near the bridged areas. Increase segment counts or <code>section</code> for cleaner topology.</p> <p>Note: If <code>length &lt;= 2 * radius</code>, no elongation is performed and the result is (nearly) identical to a torus of the given parameters.</p>"},{"location":"api/#npblender.Mesh.check","title":"check","text":"<pre><code>check(title='Mesh Check', halt=True)\n</code></pre> <p>Check if mesh domains (corners, faces, edges) are consistent.</p> <p>This method verifies the consistency of the mesh domains by checking the validity of corners, faces, and edges relative to the number of points. In development mode, it raises an exception to prevent Blender from crashing if inconsistencies are found.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title prefix for error messages (default is \"Mesh Check\").</p> <code>'Mesh Check'</code> <code>halt</code> <code>bool</code> <p>If True, raise an exception on failure; otherwise, print a warning (default is True).</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if all checks pass; otherwise, raises an exception or prints an error.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the check fails and halt is True.</p>"},{"location":"api/#npblender.Mesh.circle","title":"circle  <code>classmethod</code>","text":"<pre><code>circle(radius=1, segments=16, fill_segments=0, cap='NONE', materials=None)\n</code></pre> <p>Create a circle mesh.</p> <p>The circle can be created as: - An open ring (<code>cap='NONE'</code>). - A filled n-gon (<code>cap='NGON'</code>). - A triangle fan (<code>cap='FANS'</code>).</p> <p>The argument <code>fill_segments</code> controls how the interior of the circle is filled: - If <code>fill_segments == 0</code> and <code>cap='NGON'</code>, the circle is filled with a single polygon. - If <code>fill_segments &gt; 0</code>, the circle is filled with concentric rings and triangle fans (not yet implemented in this method, but the behavior corresponds to <code>cap='FANS'</code>).</p> <p>Note: The <code>disk</code> method provides the same functionality with <code>cap='NGON'</code> as its default mode.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the circle. Default is 1.</p> <code>1</code> <code>segments</code> <code>int</code> <p>Number of segments (vertices) around the circle. Default is 16.</p> <code>16</code> <code>fill_segments</code> <code>int</code> <p>Number of internal subdivisions (concentric circles). If 0, the circle is filled with a single polygon when <code>cap='NGON'</code>. Default is 0.</p> <code>0</code> <code>cap</code> <code>(NONE, NGON, FANS)</code> <p>How to fill the interior of the circle. Default is 'NONE'.</p> <code>'NONE'</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the circle. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the circle.</p> Notes <ul> <li><code>cap='NONE'</code>: returns only the ring of edges.</li> <li><code>cap='NGON'</code>: fills the circle with a polygon face.</li> <li><code>cap='FANS'</code>: fills the circle with a fan of triangles around a central point.</li> <li>UV coordinates are generated with <code>disk_uv_map</code>.</li> <li>Fan topology is generated with <code>fans_corners</code>.</li> </ul> <p>Examples:</p> <p>Create an open circle with 32 segments:</p> <pre><code>circle = Mesh.circle(radius=1, segments=32, cap='NONE')\n</code></pre> <p>Create a filled disk using an n-gon:</p> <pre><code>circle = Mesh.circle(radius=2, segments=24, cap='NGON')\n</code></pre> <p>Create a filled disk with triangle fans:</p> <pre><code>circle = Mesh.circle(radius=1, segments=16, cap='FANS')\n</code></pre> See Also <p><code>disk</code> :     Equivalent method for creating disks (default <code>cap='NGON'</code>). <code>disk_uv_map</code> :     Generates UV coordinates for circular caps. <code>fans_corners</code> :     Generates corner topology for triangle fans.</p> <p>Caution: When using <code>cap='FANS'</code>, a new center vertex is added.</p>"},{"location":"api/#npblender.Mesh.clear_geometry","title":"clear_geometry","text":"<pre><code>clear_geometry()\n</code></pre> <p>Clear the geometry by deleting all geometric content.</p> <p>This method clears the points, corners, faces, and edges collections, effectively removing all geometric data from the mesh.</p> <p>Note:     The materials list associated with the mesh remains unchanged.</p>"},{"location":"api/#npblender.Mesh.cone","title":"cone  <code>classmethod</code>","text":"<pre><code>cone(vertices=32, side_segments=1, fill_segments=1, radius_top=0, radius_bottom=1, depth=2, fill_type='NGON', materials=None)\n</code></pre> <p>Create a cone (or cylinder) mesh.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>int</code> <p>Number of vertices around the circumference. Default is 32.</p> <code>32</code> <code>side_segments</code> <code>int</code> <p>Number of subdivisions along the vertical side edges. Default is 1 (no subdivision).</p> <code>1</code> <code>fill_segments</code> <code>int</code> <p>Number of concentric circles added to the caps. Currently unused. Default is 1.</p> <code>1</code> <code>radius_top</code> <code>float</code> <p>Radius of the top face. Default is 0 (cone).</p> <code>0</code> <code>radius_bottom</code> <code>float</code> <p>Radius of the bottom face. Default is 1.</p> <code>1</code> <code>depth</code> <code>float</code> <p>Height of the cone along the Z axis. Default is 2.</p> <code>2</code> <code>fill_type</code> <code>(NGON, FANS, NONE)</code> <p>Type of filling for the top and bottom caps: - <code>'NGON'</code>: fill with n-gons. - <code>'FANS'</code>: fill with triangle fans. - <code>'NONE'</code>: no cap filling. Default is <code>'NGON'</code>.</p> <code>'NGON'</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the cone.</p> Notes <ul> <li>If both <code>radius_top</code> and <code>radius_bottom</code> are zero, the result is an empty mesh.</li> <li>Internally calls <code>bl_cone</code> with <code>cap_ends</code> and <code>cap_tris</code> derived from <code>fill_type</code>.</li> <li>UVs are generated automatically by Blender's cone operator.</li> </ul> <p>Examples:</p> <p>Create a simple cone of height 2 and base radius 1:</p> <pre><code>cone = Mesh.cone(vertices=32, radius_top=0, radius_bottom=1, depth=2)\n</code></pre> <p>Create a cylinder with 16 vertices and subdivided sides:</p> <pre><code>cylinder = Mesh.cone(vertices=16, radius_top=1, radius_bottom=1,\n                    depth=3, side_segments=3)\n</code></pre> <p>Create a cone with triangle fan caps:</p> <pre><code>cone = Mesh.cone(vertices=24, radius_top=0, radius_bottom=2,\n                depth=4, fill_type='FANS')\n</code></pre> See Also <p><code>bl_cone</code> :     Low-level constructor for cones and cylinders. <code>bl_circle</code> :     For creating circle primitives with optional triangle fan filling.</p> <p>Note: Use <code>fill_type='NONE'</code> to create an open-ended cone or cylinder.</p>"},{"location":"api/#npblender.Mesh.cube","title":"cube  <code>classmethod</code>","text":"<pre><code>cube(size=2, materials=None)\n</code></pre> <p>Create a cube mesh.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>float or array-like of shape (3,)</code> <p>Size of the cube. If a single float is given, the cube is uniform in all dimensions. If an array of three floats is given, it specifies the size along the X, Y, and Z axes. Default is 2.</p> <code>2</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the cube. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the cube.</p> Notes <ul> <li>The cube is created centered at the origin with side length <code>size</code>.</li> <li>UV coordinates are assigned so that all six faces are unwrapped into a cross-like layout.</li> </ul> <p>Examples:</p> <p>Create a default cube of size 2:</p> <pre><code>cube = Mesh.cube()\n</code></pre> <p>Create a cube of size 5:</p> <pre><code>cube = Mesh.cube(size=5)\n</code></pre> <p>Create a rectangular box of dimensions (2, 3, 4):</p> <pre><code>box = Mesh.cube(size=(2, 3, 4))\n</code></pre> See Also <p><code>Mesh</code> :     The mesh class used to construct and manage geometry.</p> <p>Note: The cube is centered at the origin and scaled by <code>size/2</code> after construction.</p>"},{"location":"api/#npblender.Mesh.cylinder","title":"cylinder  <code>classmethod</code>","text":"<pre><code>cylinder(vertices=32, side_segments=1, radius=1, depth=2, fill_type='NGON', materials=None)\n</code></pre> <p>Create a cylinder mesh.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>int</code> <p>Number of vertices around the circumference. Default is 32.</p> <code>32</code> <code>side_segments</code> <code>int</code> <p>Number of subdivisions along the vertical side edges. Default is 1 (no subdivision).</p> <code>1</code> <code>radius</code> <code>float</code> <p>Radius of both the top and bottom faces. Default is 1.</p> <code>1</code> <code>depth</code> <code>float</code> <p>Height of the cylinder along the Z axis. Default is 2.</p> <code>2</code> <code>fill_type</code> <code>(NGON, FANS, NONE)</code> <p>Type of filling for the top and bottom caps: - <code>'NGON'</code>: fill with n-gons. - <code>'FANS'</code>: fill with triangle fans. - <code>'NONE'</code>: no cap filling. Default is <code>'NGON'</code>.</p> <code>'NGON'</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the cylinder.</p> Notes <ul> <li>Internally calls <code>bl_cone</code> with <code>radius1 = radius2 = radius</code>.</li> <li>UVs are generated automatically by Blender's cone operator.</li> </ul> <p>Examples:</p> <p>Create a default cylinder of radius 1 and height 2:</p> <pre><code>cyl = Mesh.cylinder()\n</code></pre> <p>Create a cylinder with 64 vertices and 4 vertical subdivisions:</p> <pre><code>cyl = Mesh.cylinder(vertices=64, side_segments=4, radius=2, depth=5)\n</code></pre> <p>Create an open cylinder without caps:</p> <pre><code>cyl = Mesh.cylinder(radius=1, depth=3, fill_type='NONE')\n</code></pre> See Also <p><code>bl_cone</code> :     Low-level constructor for cones and cylinders. <code>cone</code> :     Generalized method for cones and cylinders.</p> <p>Note: This method is a convenience wrapper for <code>bl_cone</code> with equal top and bottom radii.</p>"},{"location":"api/#npblender.Mesh.delete_faces","title":"delete_faces","text":"<pre><code>delete_faces(selection)\n</code></pre> <p>Delete only the selected faces from the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool</code> <p>Indices or boolean mask specifying which faces to delete.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Modifies the mesh in place. Returns <code>None</code>.</p> See Also <p><code>delete_loops</code> :     Method used internally to remove the corners and faces. <code>corners</code> :     Corner array of the mesh, used to identify face connectivity.</p> <p>Warning: This function permanently deletes faces and their associated corners. Handle undo/history in Blender if needed.</p> <p>Note: Only faces are removed. Edges and vertices remain in the mesh unless explicitly deleted by other operations.</p>"},{"location":"api/#npblender.Mesh.delete_vertices","title":"delete_vertices","text":"<pre><code>delete_vertices(points=None, faces=None, edges=None)\n</code></pre> <p>Delete vertices from the mesh, with optional selection by points, faces, or edges.</p> <p>A vertex is deleted if it is explicitly listed in <code>points</code>, or if it belongs to any of the given <code>faces</code> or <code>edges</code>.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like of int or bool</code> <p>Vertex indices (or boolean mask) specifying which vertices to delete directly.</p> <code>None</code> <code>faces</code> <code>array-like of int or bool</code> <p>Face indices (or boolean mask). Any vertex belonging to these faces will be deleted.</p> <code>None</code> <code>edges</code> <code>array-like of int or bool</code> <p>Edge indices (or boolean mask). Any vertex belonging to these edges will be deleted.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>Modifies the mesh in place. Returns <code>None</code>.</p> Notes <ul> <li>At least one of <code>points</code>, <code>faces</code>, or <code>edges</code> must be provided, otherwise the function does nothing.</li> <li>The deletion is executed using <code>bmesh.ops.delete</code> with <code>context='VERTS'</code>.</li> </ul> <p>Examples:</p> <p>Delete specific vertices:</p> <pre><code>obj.delete_vertices(points=[0, 1, 2])\n</code></pre> <p>Delete all vertices belonging to certain faces:</p> <pre><code>obj.delete_vertices(faces=[10, 11])\n</code></pre> <p>Delete all vertices belonging to certain edges:</p> <pre><code>obj.delete_vertices(edges=[5, 6, 7])\n</code></pre> See Also <p><code>bmesh.ops.delete</code> :     Blender BMesh operator used for deleting geometry.</p> <p>Warning: This function permanently removes vertices and any connected geometry (edges, faces). Handle undo/history in Blender if needed.</p> <p>Note: If multiple selectors (<code>points</code>, <code>faces</code>, <code>edges</code>) are provided, the union of all matched vertices will be deleted.</p>"},{"location":"api/#npblender.Mesh.disk","title":"disk  <code>classmethod</code>","text":"<pre><code>disk(radius=1, segments=16, fill_segments=0, cap='NGON', materials=None)\n</code></pre> <p>Create a disk mesh.</p> <p>This is equivalent to <code>circle</code>, but with <code>cap='NGON'</code> as the default filling mode.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the disk. Default is 1.</p> <code>1</code> <code>segments</code> <code>int</code> <p>Number of segments (vertices) around the disk. Default is 16.</p> <code>16</code> <code>fill_segments</code> <code>int</code> <p>Number of internal subdivisions (concentric circles). Default is 0 (single n-gon when <code>cap='NGON'</code>).</p> <code>0</code> <code>cap</code> <code>(NONE, NGON, FANS)</code> <p>How to fill the interior of the disk. Default is 'NGON'.</p> <code>'NONE'</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the disk. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the disk.</p> <p>Examples:</p> <p>Create a default disk of radius 2 with 32 segments:</p> <pre><code>disk = Mesh.disk(radius=2, segments=32)\n</code></pre> <p>Create a disk filled with triangle fans:</p> <pre><code>disk = Mesh.disk(radius=1, segments=16, cap='FANS')\n</code></pre> See Also <p><code>circle</code> :     General method for circle/disk creation with customizable cap. <code>disk_uv_map</code> :     Generates UV coordinates for circular caps. <code>fans_corners</code> :     Generates corner topology for triangle fans.</p> <p>Note: This method is a shorthand for <code>circle(..., cap='NGON')</code>.</p>"},{"location":"api/#npblender.Mesh.dual","title":"dual","text":"<pre><code>dual(center='median')\n</code></pre> <p>Construct the dual mesh: one vertex per original face, and one face per original vertex (linking adjacent face-centers around that vertex).</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>(median, bounds, weighted)</code> <p>Method to compute the position of each dual vertex (i.e., the center of the corresponding original face): - <code>'median'</code>: face median center (<code>BMFace.calc_center_median</code>). - <code>'bounds'</code>: face bounds center (<code>BMFace.calc_center_bounds</code>). - <code>'weighted'</code>: area-weighted center (<code>BMFace.calc_center_median_weighted</code>). Default is <code>'median'</code>.</p> <code>'median'</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>The dual mesh, where: - points = centers of original faces, - faces  = polygons formed by chaining the adjacent original faces around each original vertex.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>center</code> is not one of <code>{'median', 'bounds', 'weighted'}</code>.</p> Notes <ul> <li>For each original face <code>f</code>, a dual vertex is computed using the chosen center method and stored at index <code>f.index</code>.</li> <li>For each original vertex <code>v</code>, its incident faces are ordered by walking across <code>v</code>\u2019s incident edges (each with exactly two linked faces) to form a cyclic sequence of face indices; this ordered loop becomes a polygon in the dual.</li> <li>Non-manifold or boundary configurations (edges with a number of linked faces different from 2) are skipped for that vertex; no dual face is created in such cases.</li> </ul> <p>Examples:</p> <p>Build the dual using area-weighted face centers:</p> <pre><code>d = mesh.dual(center='weighted')\n</code></pre> <p>Build the dual with bounds centers:</p> <pre><code>d = mesh.dual(center='bounds')\n</code></pre> See Also <p><code>triangulate</code> :     Triangulation can improve robustness before dualization. <code>remove_doubles</code> :     Helpful for cleaning geometry prior to constructing the dual.</p> <p>Caution: On meshes with boundaries or non-manifold edges, some vertices may not yield a valid cyclic ordering of adjacent faces; those dual faces are omitted.</p> <p>Note: Dualization does not, in general, invert perfectly (i.e., the dual of the dual is not guaranteed to reproduce the original mesh), especially in the presence of boundaries or irregular valences.</p>"},{"location":"api/#npblender.Mesh.extrude_faces","title":"extrude_faces","text":"<pre><code>extrude_faces(selection, offset=None, scale=1.0)\n</code></pre> <p>Extrude individual faces by duplicating them, optionally displacing them by <code>offset</code>, and connecting side faces.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Indices (or mask) of faces to extrude. If <code>None</code>, all faces are extruded.</p> required <code>offset</code> <code>(array - like, shape(3) or (N, 3))</code> <p>Extrusion vector(s). A single vector is broadcast to all faces. If <code>None</code>, each face is extruded along its own normal.</p> <code>None</code> <code>scale</code> <code>float</code> <p>Scale factor applied to <code>offset</code> (or to the face normal if <code>offset=None</code>). Default is 1.0.</p> <code>1.0</code> <code>dissolve</code> <code>bool</code> <p>Not implemented in this version. Placeholder for removing the starting faces after extrusion.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with two keys: - <code>'top'</code>: indices of the extruded (displaced) faces. - <code>'side'</code>: indices of the side faces connecting the original and new faces.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>offset</code> cannot be broadcast to shape <code>(len(faces), 3)</code>.</p> <code>AssertionError</code> <p>If a side edge of an extruded face does not have exactly two linked faces.</p> Notes <ul> <li>Uses <code>bmesh.ops.extrude_discrete_faces</code> to duplicate each selected face independently.</li> <li>If <code>offset</code> is <code>None</code>, displacement is along each face's local normal.</li> <li>Side faces are identified by checking edges linked to the extruded faces.</li> </ul> <p>Examples:</p> <p>Extrude all faces along their normals:</p> <pre><code>res = Mesh.extrude_faces(selection=None, scale=0.2)\n</code></pre> <p>Extrude a subset of faces by a fixed offset:</p> <pre><code>res = Mesh.extrude_faces(selection=[0, 2, 5], offset=(0, 0, 1))\n</code></pre> <p>Extrude faces with per-face offsets:</p> <pre><code>offs = np.random.randn(len(sel), 3) * 0.1\nres = Mesh.extrude_faces(selection=sel, offset=offs)\n</code></pre> See Also <p><code>extrude_vertices</code> :     Extrude isolated vertices. <code>extrude_loop</code> :     Extrude a vertex loop into a quad strip.</p> <p>Caution: If <code>offset</code> is given per-face, its length must match the number of extruded faces or broadcasting will fail.</p> <p>Note: Side face indices may be repeated if multiple extrusions share edges.</p>"},{"location":"api/#npblender.Mesh.extrude_loop","title":"extrude_loop","text":"<pre><code>extrude_loop(loop, offset, close=False, clockwise=False, **attributes)\n</code></pre> <p>Extrude a loop of vertices by duplicating the loop, offsetting it, and creating a quad strip between the original and the offset loop.</p> <p>Parameters:</p> Name Type Description Default <code>loop</code> <code>array-like of int</code> <p>Vertex indices defining the loop to extrude. Must contain at least 2 vertices.</p> required <code>offset</code> <code>(array - like, shape(3) or (N, 3))</code> <p>Extrusion vector(s). A single 3D vector is broadcast to all vertices in <code>loop</code>, or provide one vector per vertex (N == len(loop)).</p> required <code>close</code> <code>bool</code> <p>If True, treats the input as a closed loop and connects the last vertex back to the first when building side quads. Default is False.</p> <code>False</code> <code>clockwise</code> <code>bool</code> <p>Controls the orientation (winding) of the generated faces and the UV layout. Default is False.</p> <code>False</code> <code>**attributes</code> <code>dict</code> <p>Extra attributes intended for the new geometry (see Caution).</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary describing the created geometry as returned by <code>add_geometry</code>. Contains at least: - <code>'points'</code>: indices of the duplicated (offset) vertices. - <code>'corners'</code>: indices of the generated quad strip corners. - <code>'faces'</code>: face arity (4 for quads).</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>offset</code> is neither a single <code>(3,)</code> vector nor an array of shape <code>(len(loop), 3)</code>.</p> Notes <ul> <li>New vertices are computed as <code>points[loop] + offset</code> (with broadcasting if <code>offset</code> is a single vector).</li> <li>Side faces are constructed using the topology from <code>grid_corners</code> with two rows (original and offset loop).</li> <li>UVs for the side strip are generated by <code>grid_uv_map</code> with matching parameters.</li> </ul> <p>Examples:</p> <p>Extrude an open loop along a single vector:</p> <pre><code>new = Mesh.extrude_loop(loop, offset=(0, 0, 1), close=False)\n</code></pre> <p>Extrude a closed loop with per-vertex offsets and flipped winding:</p> <pre><code>offs = np.random.randn(len(loop), 3) * 0.02\nnew = Mesh.extrude_loop(loop, offset=offs, close=True, clockwise=True)\n</code></pre> See Also <p><code>extrude_vertices</code> :     Extrude isolated vertices with edges to their duplicates. <code>add_geometry</code> :     Adds the new points/corners/faces and returns their indices. <code>grid_corners</code> :     Builds the quad topology of the side strip. <code>grid_uv_map</code> :     Generates UVs for the side strip.</p> <p>Caution: <code>offset</code> must be either a single <code>(3,)</code> vector or an array of shape <code>(len(loop), 3)</code>. Any other shape will raise an error.</p> <p>Caution: The <code>attributes</code> kwargs are currently not forwarded to <code>add_geometry</code> in this implementation. If you need them applied, pass them through explicitly in the call to <code>add_geometry</code>.</p>"},{"location":"api/#npblender.Mesh.extrude_region","title":"extrude_region","text":"<pre><code>extrude_region(selection, offset=(0, 0, 1), dissolve=False)\n</code></pre> <p>Extrude a connected face region, translate the new geometry by <code>offset</code>, and optionally dissolve the original faces.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Indices (or mask) of faces to extrude. If <code>None</code>, all faces are used.</p> required <code>offset</code> <code>array-like of float, shape (3,)</code> <p>Translation vector applied to the newly created vertices of the region. Default is (0, 0, 1).</p> <code>(0, 0, 1)</code> <code>dissolve</code> <code>bool</code> <p>If True, delete the original (pre-extrusion) faces after the region has been extruded. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with two keys: - <code>'top'</code>: indices of the newly extruded faces (translated region). - <code>'side'</code>: indices of the side faces that connect original and new faces.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If a side edge of an extruded face does not have exactly two linked faces (non-manifold condition).</p> Notes <ul> <li>Region extrusion is performed via <code>bmesh.ops.extrude_face_region</code>, then the new vertices are moved using <code>bmesh.ops.translate</code>.</li> <li>Side faces are discovered by scanning the edges of the extruded faces and collecting the adjacent face opposite to each extruded face.</li> </ul> <p>Examples:</p> <p>Extrude a region upward and keep the original faces:</p> <pre><code>res = Mesh.extrude_region(selection=[0, 1, 2], offset=(0, 0, 0.2), dissolve=False)\n</code></pre> <p>Extrude a region and dissolve the starting faces:</p> <pre><code>res = Mesh.extrude_region(selection=mask, offset=(0.1, 0, 0), dissolve=True)\n</code></pre> See Also <p><code>extrude_faces</code> :     Extrude faces individually (discrete), not as a connected region. <code>extrude_loop</code> :     Create a quad strip by offsetting a vertex loop. <code>extrude_vertices</code> :     Duplicate and connect selected vertices.</p> <p>Caution: <code>offset</code> must be a 3D vector. Non-3D inputs may cause the translation operator to fail.</p> <p>Note: With <code>dissolve=True</code>, the original faces are removed, leaving only the extruded shell.</p>"},{"location":"api/#npblender.Mesh.extrude_vertices","title":"extrude_vertices","text":"<pre><code>extrude_vertices(selection, offset, **attributes)\n</code></pre> <p>Extrude individual vertices by creating new points displaced by <code>offset</code> and connecting each original vertex to its duplicate with an edge.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Vertex indices or boolean mask selecting the vertices to extrude. If <code>None</code>, all vertices are extruded.</p> required <code>offset</code> <code>(array - like, shape(3) or (N, 3))</code> <p>Extrusion vector(s). Can be a single 3D vector applied to every selected vertex, or an array of vectors with one per selected vertex.</p> required <code>**attributes</code> <code>dict</code> <p>Optional attributes to attach to the created geometry (forwarded to <code>add_geometry</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary describing the created geometry as returned by <code>add_geometry</code>. Contains at least: - <code>'points'</code>: indices of newly added vertices. - <code>'edges'</code>: indices of newly added edges.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>offset</code> is neither a single <code>(3,)</code> vector nor an array of shape <code>(len(loop), 3)</code>.</p> Notes <ul> <li>New vertices are positioned at <code>points[selection] + offset</code>.</li> <li>One edge is created between each original vertex and its newly created counterpart using <code>edges_between</code>.</li> </ul> <p>Examples:</p> <p>Extrude all vertices by (0, 0, 1):</p> <pre><code>added = Mesh.extrude_vertices(selection=None, offset=(0, 0, 1))\n</code></pre> <p>Extrude a subset with per-vertex offsets:</p> <pre><code>sel = np.array([0, 2, 5, 7])\noffs = np.random.randn(len(sel), 3) * 0.1\nadded = Mesh.extrude_vertices(selection=sel, offset=offs)\n</code></pre> See Also <p><code>add_geometry</code> :     Adds new points/edges/faces and returns their indices. <code>edges_between</code> :     Builds edge pairs between two index arrays of equal length.</p> <p>Caution: When <code>offset</code> is an array, its length must match the number of selected vertices.</p> <p>Note: This operation creates only points and edges. Faces are not generated automatically.</p>"},{"location":"api/#npblender.Mesh.faces_neighbors","title":"faces_neighbors","text":"<pre><code>faces_neighbors()\n</code></pre> <p>Compute the neighboring faces for each face, defined as faces sharing at least one edge.</p> <p>Returns:</p> Type Description <code>list of list of int</code> <p>For each face (by index), a list of indices of adjacent faces.</p> Notes <ul> <li>Each face\u2019s neighbors are determined by scanning its incident edges and collecting the two faces linked to each edge.</li> <li>The current face index is excluded from its own neighbor list.</li> <li>Non-manifold edges (with more or fewer than two linked faces) are not expected; if present, results may be incomplete or inconsistent.</li> </ul> <p>Examples:</p> <p>Get adjacency information for all faces:</p> <pre><code>neighbors = mesh.faces_neighbors()\nfor i, ns in enumerate(neighbors):\n    print(f\"Face {i} neighbors: {ns}\")\n</code></pre> <p>Note: The output is a Python list of lists (not a NumPy array).</p>"},{"location":"api/#npblender.Mesh.fill_cap","title":"fill_cap","text":"<pre><code>fill_cap(loop, mode='NGON', center=None, segments=1, clockwise=False, **attributes)\n</code></pre> <p>Fill a cap between vertices forming a loop.</p> <p>Supports two modes: - NGON: creates a single n-gon face from the loop. No center point is required. - FANS: creates a fan of triangles around a center point. The center can be: * <code>None</code>: automatically computed as the centroid of the loop. * <code>int</code>: the index of an existing vertex to use as center. * <code>array-like</code>: explicit coordinates of the center, which will be added as a new vertex.</p> <p>Parameters:</p> Name Type Description Default <code>loop</code> <code>array-like of int</code> <p>The vertex indices defining the loop.</p> required <code>mode</code> <code>(NGON, FANS)</code> <p>Fill mode to use. Default is 'NGON'.</p> <code>'NGON'</code> <code>center</code> <code>int or array - like or None</code> <p>Center of the cap (used only in 'FANS' mode). - <code>None</code>: computed centroid. - <code>int</code>: index of an existing vertex. - array-like: coordinates of a new vertex.</p> <code>None</code> <code>segments</code> <code>int</code> <p>Number of radial subdivisions for FANS mode. Must be &gt;= 1. Default is 1 (no subdivision).</p> <code>1</code> <code>clockwise</code> <code>bool</code> <p>Whether the loop is ordered clockwise. Default is False.</p> <code>False</code> <code>**attributes</code> <code>dict</code> <p>Additional attributes to add to the mesh (passed to <code>add_geometry</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the newly added geometry, as returned by <code>add_geometry</code>. Includes at least keys for 'faces' and 'corners'. In FANS mode, also includes the added 'points' if a new center is created.</p> Notes <ul> <li>In 'NGON' mode, a UV map is generated using <code>disk_uv_map</code>.</li> <li>In 'FANS' mode, the fan topology is created with <code>fans_corners</code> and UVs are generated with <code>disk_uv_map</code>.</li> <li>If <code>segments &gt; 1</code> in FANS mode, radial edges are subdivided using <code>split_edges</code>.</li> </ul> <p>Examples:</p> <p>Fill a loop with an n-gon:</p> <pre><code>obj.fill_cap(loop, mode='NGON')\n</code></pre> <p>Fill a loop with a triangle fan around an automatically computed center:</p> <pre><code>obj.fill_cap(loop, mode='FANS')\n</code></pre> <p>Fill a loop with a fan using an existing vertex as the center and add 3 subdivisions:</p> <pre><code>obj.fill_cap(loop, mode='FANS', center=42, segments=3)\n</code></pre> See Also <p><code>add_geometry</code> :     Method used to add the created geometry to the mesh. <code>split_edges</code> :     Used to subdivide radial edges in FANS mode. <code>disk_uv_map</code> :     Generates UV coordinates for circular caps. <code>fans_corners</code> :     Generates corner topology for FANS mode.</p> <p>Warning: This function modifies the mesh in place and may create new vertices, faces, and edges.</p> <p>Caution: In FANS mode, if <code>center=None</code>, a new vertex is added at the centroid of the loop.</p> <p>Note: The <code>segments</code> parameter only applies to FANS mode; NGON mode always produces a single polygon face.</p>"},{"location":"api/#npblender.Mesh.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d)\n</code></pre> <p>Create a Mesh instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Dictionary containing mesh data with keys 'materials', 'points', 'corners', 'faces', and 'edges'.</p> required <p>Returns:</p> Type Description <code>Mesh</code> <p>A new Mesh instance initialized with the data from the dictionary.</p>"},{"location":"api/#npblender.Mesh.from_mesh","title":"from_mesh  <code>classmethod</code>","text":"<pre><code>from_mesh(other, points=None, faces=None, edges=None)\n</code></pre> <p>Create a copy of a Mesh object, optionally excluding specified points, faces, or edges.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Mesh</code> <p>The source Mesh object to copy.</p> required <code>points</code> <code>array-like of int</code> <p>Indices of points to exclude from the copy.</p> <code>None</code> <code>faces</code> <code>array-like of int</code> <p>Indices of faces to exclude from the copy.</p> <code>None</code> <code>edges</code> <code>array-like of int</code> <p>Indices of edges to exclude from the copy.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new Mesh instance copied from the source, with specified elements excluded.</p>"},{"location":"api/#npblender.Mesh.from_mesh_data","title":"from_mesh_data  <code>classmethod</code>","text":"<pre><code>from_mesh_data(data)\n</code></pre> <p>Initialize the geometry from a Blender Mesh data.</p> <p>This method creates and returns an instance of the mesh class initialized with vertices, edges, faces, corners, materials, and attributes extracted from the provided Blender mesh data.</p> <p>Args:     data: Blender mesh data or object that can be processed           by the blender.get_mesh function to obtain a Blender Mesh instance.</p> <p>Returns:     An instance of the mesh class initialized with the geometry     and attributes from the Blender Mesh.</p> <p>Raises:     ImportError: If the local blender module cannot be imported.     Any exceptions raised by blender.get_mesh if the data is invalid.</p>"},{"location":"api/#npblender.Mesh.from_model","title":"from_model  <code>classmethod</code>","text":"<pre><code>from_model(model, materials=None)\n</code></pre> <p>Create a Mesh instance from various types of input models.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str, bpy.types.Object, dict, Mesh, or bpy.types.Mesh</code> <p>The input model to create the Mesh from. It can be: - A string or Blender object to be evaluated and converted. - A dictionary representing the mesh data. - An existing Mesh instance. - A Blender Mesh data block.</p> required <code>materials</code> <code>list or None</code> <p>Materials to associate with the mesh (currently unused in this method).</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>The created Mesh instance based on the input model.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the type of the model is not supported.</p>"},{"location":"api/#npblender.Mesh.from_object","title":"from_object  <code>classmethod</code>","text":"<pre><code>from_object(obj, evaluated=False)\n</code></pre> <p>Create a Mesh instance from an existing Blender object.</p> <p>This method initializes a mesh from a Blender object, optionally using the evaluated version of the object (i.e., after applying modifiers).</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str or Object</code> <p>The Blender object or its name from which to create the mesh.</p> required <code>evaluated</code> <code>bool</code> <p>If True, use the evaluated object with modifiers applied. If False, use the raw mesh data. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new Mesh instance created from the specified Blender object.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the local blender module cannot be imported.</p>"},{"location":"api/#npblender.Mesh.get_islands","title":"get_islands","text":"<pre><code>get_islands()\n</code></pre> <p>Compute connected components of faces (islands) and assign an island ID to each face.</p> <p>Returns:</p> Type Description <code>ndarray of int, shape (n_faces,)</code> <p>Array of island IDs, one per face. Faces in the same connected component share the same integer ID. Empty mesh returns an empty list.</p> Notes <ul> <li>Islands are defined as groups of faces connected through shared edges.</li> <li>A breadth-first search (BFS) is used to traverse each connected component.</li> <li>IDs are assigned sequentially starting from 0.</li> </ul> <p>Examples:</p> <p>Get island IDs for all faces:</p> <pre><code>ids = mesh.get_islands()\nprint(\"Unique islands:\", np.unique(ids))\n</code></pre> <p>Map faces by island:</p> <pre><code>ids = mesh.get_islands()\nfor island_id in np.unique(ids):\n    faces = np.where(ids == island_id)[0]\n    print(f\"Island {island_id}: faces {faces}\")\n</code></pre> <p>Note: Non-manifold meshes are still handled, but faces that share only a vertex (not an edge) are considered separate islands.</p>"},{"location":"api/#npblender.Mesh.grid","title":"grid  <code>classmethod</code>","text":"<pre><code>grid(size_x=1, size_y=1, vertices_x=3, vertices_y=3, materials=None)\n</code></pre> <p>Create a rectangular grid mesh.</p> <p>The grid is constructed in the XY plane with indexing set to <code>'ij'</code>, meaning the generated arrays have shape <code>(vertices_x, vertices_y)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>size_x</code> <code>float</code> <p>Size of the grid along the X axis. Default is 1.</p> <code>1</code> <code>size_y</code> <code>float</code> <p>Size of the grid along the Y axis. Default is 1.</p> <code>1</code> <code>vertices_x</code> <code>int</code> <p>Number of vertices along the X axis. Must be &gt;= 2. Default is 3.</p> <code>3</code> <code>vertices_y</code> <code>int</code> <p>Number of vertices along the Y axis. Must be &gt;= 2. Default is 3.</p> <code>3</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the grid. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the rectangular grid.</p> Notes <ul> <li>The grid is created with <code>'ij'</code> indexing, so coordinates follow NumPy's <code>meshgrid(..., indexing='ij')</code> convention.</li> <li>UV coordinates are generated using <code>grid_uv_map</code>.</li> <li>The grid topology is built using <code>grid_corners</code>.</li> </ul> <p>Examples:</p> <p>Create a 2x2 grid with 10 vertices along X and 5 along Y:</p> <pre><code>grid = Mesh.grid(size_x=2, size_y=2, vertices_x=10, vertices_y=5)\n</code></pre> <p>Create a square grid of size 5 with default vertex count:</p> <pre><code>grid = Mesh.grid(size_x=5, size_y=5)\n</code></pre> See Also <p><code>grid_corners</code> :     Helper for constructing the corner topology of the grid. <code>grid_uv_map</code> :     Generates UV coordinates for a regular grid.</p> <p>Important: The grid is always created with <code>'ij'</code> indexing (shape = <code>(vertices_x, vertices_y)</code>).</p>"},{"location":"api/#npblender.Mesh.icosphere","title":"icosphere  <code>classmethod</code>","text":"<pre><code>icosphere(radius=1, subdivisions=2, materials=None)\n</code></pre> <p>Create an icosphere mesh.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the icosphere. Default is 1.</p> <code>1</code> <code>subdivisions</code> <code>int</code> <p>Number of recursive subdivisions applied to the base icosahedron. Higher values yield smoother spheres. Clamped to a maximum of 10. Default is 2.</p> <code>2</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the icosphere. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the icosphere.</p> Notes <ul> <li>The icosphere is created using <code>bmesh.ops.create_icosphere</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> <li>Unlike a UV sphere, an icosphere has more uniform vertex distribution, making it suitable for certain simulation and subdivision tasks.</li> <li>Subdivisions are internally capped at 10 for performance reasons.</li> </ul> <p>Examples:</p> <p>Create a default icosphere of radius 1 with 2 subdivisions:</p> <pre><code>ico = Mesh.icosphere()\n</code></pre> <p>Create a larger icosphere with 4 subdivisions:</p> <pre><code>ico = Mesh.icosphere(radius=3, subdivisions=4)\n</code></pre> See Also <p><code>uvsphere</code> :     Sphere primitive based on UV parameterization. <code>bmesh.ops.create_icosphere</code> :     BMesh operator used for creating icospheres.</p> <p>Note: Use <code>uvsphere</code> when you require consistent UV mapping, and <code>icosphere</code> for uniform tessellation.</p>"},{"location":"api/#npblender.Mesh.inset_faces","title":"inset_faces","text":"<pre><code>inset_faces(selection, thickness=0.1, depth=0.0, use_even_offset=True, use_relative_offset=False)\n</code></pre> <p>Inset selected faces individually, optionally adding depth (local extrusion).</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Indices (or mask) of faces to inset. If <code>None</code>, all faces are used.</p> required <code>thickness</code> <code>float</code> <p>Inset thickness applied per face. Default is 0.1.</p> <code>0.1</code> <code>depth</code> <code>float</code> <p>Local extrusion depth along each face normal. Default is 0.0.</p> <code>0.0</code> <code>use_even_offset</code> <code>bool</code> <p>Keep thickness consistent across faces (even offset). Default is True.</p> <code>True</code> <code>use_relative_offset</code> <code>bool</code> <p>Scale thickness relative to face size. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with: - <code>'top'</code>: indices of the original (selected) faces. - <code>'side'</code>: indices of the new faces created by the inset operation (typically the rim/side faces around each inset).</p> Notes <ul> <li>Implementation uses <code>bmesh.ops.inset_individual</code>.</li> <li>The <code>'top'</code> entry mirrors the input selection; <code>'side'</code> comes from <code>d[\"faces\"]</code> returned by the BMesh operator.</li> </ul> <p>Examples:</p> <p>Inset a set of faces with even offset:</p> <pre><code>res = Mesh.inset_faces(selection=[0, 2, 5], thickness=0.05, depth=0.0)\n</code></pre> <p>Inset all faces with relative offset and a small depth:</p> <pre><code>res = Mesh.inset_faces(selection=None, thickness=0.02,\n                    depth=0.01, use_relative_offset=True)\n</code></pre> See Also <p><code>extrude_faces</code> :     Extrude faces discretely instead of insetting. <code>extrude_region</code> :     Extrude connected face regions.</p>"},{"location":"api/#npblender.Mesh.join","title":"join","text":"<pre><code>join(*others)\n</code></pre> <p>Join other Mesh instances into this mesh.</p> <p>This method appends the geometry and materials of the given meshes to the current mesh, updating indices to maintain consistency.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Mesh</code> <p>One or more Mesh instances to be joined with the current mesh.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>self</code> <code>Mesh</code> <p>The updated mesh instance with joined geometry.</p>"},{"location":"api/#npblender.Mesh.join_geometry","title":"join_geometry","text":"<pre><code>join_geometry(points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs)\n</code></pre> <p>Join geometry defined by components into the current mesh.</p> <p>This method creates a new independent mesh from the provided geometry components (points, corners, faces, edges) which do not refer to existing vertices. The new mesh is then joined to the current mesh instance.</p> <p>To add geometry using existing vertices, see <code>Mesh.add_geometry</code>.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>iterable</code> <p>Iterable of points (vertices) to add to the mesh.</p> <code>None</code> <code>corners</code> <code>iterable</code> <p>Iterable of corner indices defining the mesh topology.</p> <code>None</code> <code>faces</code> <code>iterable</code> <p>Iterable of faces defined by indices of corners.</p> <code>None</code> <code>edges</code> <code>iterable</code> <p>Iterable of edges defined by indices of vertices.</p> <code>None</code> <code>safe_mode</code> <code>bool</code> <p>Flag to enable safe mode operations (currently unused).</p> <code>False</code> <code>**attrs</code> <code>dict</code> <p>Additional attributes to be passed to the geometry addition.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>self</code> <code>Mesh</code> <p>The current mesh instance with the new geometry joined.</p>"},{"location":"api/#npblender.Mesh.line","title":"line  <code>classmethod</code>","text":"<pre><code>line(start=(0, 0, 0), end=(0, 0, 1), segments=1, materials=None)\n</code></pre> <p>Create a mesh representing a straight line (or multiple lines) subdivided into segments.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>array-like of float, shape (..., 3)</code> <p>Coordinates of the start point(s). Can be a single 3D vector or an array of multiple vectors. Default is (0, 0, 0).</p> <code>(0, 0, 0)</code> <code>end</code> <code>array-like of float, shape (..., 3)</code> <p>Coordinates of the end point(s). Can be a single 3D vector or an array of multiple vectors with the same shape as <code>start</code>. Default is (0, 0, 1).</p> <code>(0, 0, 1)</code> <code>segments</code> <code>int</code> <p>Number of line segments (subdivisions) between each pair of start and end points. Must be &gt;= 1. Default is 1.</p> <code>1</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the line mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the subdivided line(s).</p> Notes <ul> <li>The function interpolates <code>segments + 1</code> points between <code>start</code> and <code>end</code> using <code>np.linspace</code>.</li> <li>If <code>start</code> and <code>end</code> are arrays of shape <code>(N, 3)</code>, the method generates <code>N</code> independent polylines, each subdivided into <code>segments</code>.</li> <li>For higher-dimensional batched input, the function reshapes the grid and constructs edges using <code>col_edges</code>.</li> </ul> <p>Examples:</p> <p>Create a simple line with 5 segments between (0, 0, 0) and (0, 0, 1):</p> <pre><code>line = Mesh.line(start=(0, 0, 0), end=(0, 0, 1), segments=5)\n</code></pre> <p>Create three parallel lines defined by arrays of start and end points:</p> <pre><code>starts = np.array([[0, 0, 0],\n                [1, 0, 0],\n                [2, 0, 0]])\nends = np.array([[0, 0, 1],\n                [1, 0, 1],\n                [2, 0, 1]])\nlines = Mesh.line(start=starts, end=ends, segments=4)\n</code></pre> See Also <p><code>border_edges</code> :     Helper for constructing consecutive edges in a single polyline. <code>col_edges</code> :     Helper for constructing edges in multi-dimensional point grids.</p> <p>Note: The line mesh consists only of vertices and edges, no faces are created.</p>"},{"location":"api/#npblender.Mesh.monkey","title":"monkey  <code>classmethod</code>","text":"<pre><code>monkey(materials=None)\n</code></pre> <p>Create the famous Blender \"Suzanne\" monkey mesh.</p> <p>Parameters:</p> Name Type Description Default <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the Suzanne primitive.</p> Notes <ul> <li>The monkey head is created using <code>bmesh.ops.create_monkey</code>.</li> <li>Suzanne is often used as a test model and is considered Blender\u2019s mascot.</li> </ul> <p>Examples:</p> <p>Create a Suzanne mesh:</p> <pre><code>monkey = Mesh.monkey()\n</code></pre> See Also <p><code>bmesh.ops.create_monkey</code> :     BMesh operator used to generate the Suzanne primitive.</p> <p>Note: Suzanne is widely used as a benchmark and test object in Blender.</p>"},{"location":"api/#npblender.Mesh.multiply","title":"multiply","text":"<pre><code>multiply(count, in_place=True)\n</code></pre> <p>Duplicate the geometry.</p> <p>Multiplying is a way to efficiently duplicate the geometry a great number of times. Once duplicated, the vertices can be reshapped to address each instance individually.</p> <pre><code>count = 16\n\ncube = Mesh.Cube() * count\n\n# Shape the points as 16 blocks of 8 vertices\npoints = np.reshape(cube.points.position, (16, 8, 3))\n\n# Place the cubes in a circle\nags = np.linspace(0, 2*np.pi, count, endpoint=False)\npoints[..., 0] += 6 * np.cos(ags)[:, None]\npoints[..., 1] += 6 * np.sin(ags)[:, None]\n\ncube.to_object(\"Cubes\")\n</code></pre> Arguments <pre><code>- count (int=10) : number of instances\n- attributes (name=value) : value for named attributes\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/#npblender.Mesh.points_cloud","title":"points_cloud  <code>classmethod</code>","text":"<pre><code>points_cloud(points=None, materials=None)\n</code></pre> <p>Create a mesh containing only points at the given positions.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like of shape (N, 3)</code> <p>Coordinates of the points. If None, an empty mesh is created.</p> <code>None</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the given points.</p> Notes <ul> <li>This method does not create any edges or faces, only isolated points.</li> </ul> <p>Examples:</p> <p>Create a point cloud with three points:</p> <pre><code>pts = np.array([[0, 0, 0],\n                [1, 0, 0],\n                [0, 1, 0]])\ncloud = Mesh.points_cloud(points=pts)\n</code></pre> See Also <p><code>Mesh</code> :     The mesh class used to construct and manage geometry.</p> <p>Note: This constructor is useful for importing raw point data or initializing a mesh before adding edges and faces.</p>"},{"location":"api/#npblender.Mesh.pyramid","title":"pyramid  <code>classmethod</code>","text":"<pre><code>pyramid(size=1, materials=None)\n</code></pre> <p>Create a pyramid mesh.</p> <p>The pyramid is generated as a cone with 3 vertices at the base (a triangle) and an apex at the top.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>float</code> <p>Size of the pyramid. Determines both the base dimensions and the height. Default is 1.</p> <code>1</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the pyramid.</p> Notes <ul> <li>The base radius is scaled by <code>size * sqrt(3)/2</code> so that the pyramid has approximately unit proportions when <code>size=1</code>.</li> <li>Internally calls <code>cone</code> with <code>vertices=3</code>.</li> </ul> <p>Examples:</p> <p>Create a default pyramid of size 1:</p> <pre><code>pyramid = Mesh.pyramid()\n</code></pre> <p>Create a larger pyramid of size 5:</p> <pre><code>pyramid = Mesh.pyramid(size=5)\n</code></pre> See Also <p><code>cone</code> :     Generalized method for cones and pyramids. <code>bl_cone</code> :     Low-level constructor for cone-based primitives.</p> <p>Note: This method is equivalent to creating a triangular-based cone.</p>"},{"location":"api/#npblender.Mesh.remove_doubles","title":"remove_doubles","text":"<pre><code>remove_doubles(dist=0.001)\n</code></pre> <p>Merge duplicate vertices within a distance threshold.</p> <p>Parameters:</p> Name Type Description Default <code>dist</code> <code>float</code> <p>Maximum distance between vertices to be merged. Default is 0.001.</p> <code>0.001</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>The current mesh instance (<code>self</code>) with duplicate vertices removed.</p> Notes <ul> <li>Internally uses <code>bmesh.ops.remove_doubles</code>.</li> <li>All vertices in the mesh are considered for merging.</li> <li>Useful for cleaning geometry after operations that may generate coincident vertices (e.g., mirroring, joining, or extrusion).</li> </ul> <p>Examples:</p> <p>Remove doubles with default threshold:</p> <pre><code>mesh.remove_doubles()\n</code></pre> <p>Remove doubles with a larger threshold:</p> <pre><code>mesh.remove_doubles(dist=0.01)\n</code></pre> <p>Note: This method modifies the mesh in place and returns <code>self</code> for chaining.</p>"},{"location":"api/#npblender.Mesh.separate_faces","title":"separate_faces","text":"<pre><code>separate_faces(groups=None)\n</code></pre> <p>Split faces into isolated islands, either one per face or grouped by provided IDs.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>array-like of int, shape (n_faces,)</code> <p>Group IDs for each face. If <code>None</code>, each face is isolated as its own island. If provided, must be the same length as the number of faces.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh where faces are separated into independent islands with duplicated vertices.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>groups</code> is provided but its shape does not match <code>(n_faces,)</code>.</p> Notes <ul> <li>When <code>groups</code> is <code>None</code>, the output mesh has one disconnected island per face.</li> <li>When grouping, faces sharing the same group ID are kept together in the same island, with vertices duplicated so that each group is independent.</li> <li>Face attributes are preserved except for <code>'loop_total'</code> and <code>'loop_start'</code>.</li> </ul> <p>Examples:</p> <p>Separate every face:</p> <pre><code>islands = mesh.separate_faces()\n</code></pre> <p>Separate faces into two groups:</p> <pre><code>groups = np.array([0, 0, 1, 1, 1, 0])  # one group ID per face\nsplit = mesh.separate_faces(groups=groups)\n</code></pre> See Also <p><code>join_geometry</code> :     Utility to assemble new meshes from points, corners, faces, and attributes. <code>join</code> :     Used internally to accumulate separated islands.</p> <p>Caution: The number of groups must equal the number of faces in the mesh, otherwise a <code>ValueError</code> is raised.</p>"},{"location":"api/#npblender.Mesh.simplified","title":"simplified","text":"<pre><code>simplified(scale, dist=0.001)\n</code></pre> <p>Return a simplified copy of the mesh by merging close vertices, with a fallback to a cubic envelope if the result is too small.</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>float</code> <p>Scale factor applied to the distance threshold.</p> required <code>dist</code> <code>float</code> <p>Base merge distance for vertices. The effective threshold is <code>dist / scale</code>. Default is 0.001.</p> <code>0.001</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A simplified copy of the mesh. If the simplification produces fewer than 8 vertices, returns a cubic envelope instead.</p> Notes <ul> <li>The copy is created with <code>Mesh.from_mesh</code>.</li> <li>Duplicate vertices are merged with <code>remove_doubles</code>.</li> <li>If too few vertices remain, a fallback is generated using <code>get_cubic_envelop</code>.</li> </ul> <p>Examples:</p> <p>Simplify a mesh with scale factor 10:</p> <pre><code>simp = mesh.simplified(scale=10, dist=0.002)\n</code></pre> See Also <p><code>remove_doubles</code> :     Merges vertices within a distance threshold. <code>get_cubic_envelop</code> :     Provides a fallback cubic mesh when simplification collapses geometry.</p>"},{"location":"api/#npblender.Mesh.solidify","title":"solidify","text":"<pre><code>solidify(thickness=0.01, offset=-1)\n</code></pre> <p>Apply a Solidify modifier to give thickness to a surface mesh.</p> <p>Parameters:</p> Name Type Description Default <code>thickness</code> <code>float</code> <p>Thickness of the shell to generate. Positive values expand outward, negative values inward. Default is 0.01.</p> <code>0.01</code> <code>offset</code> <code>float</code> <p>Offset factor determining the solidification direction relative to the original surface: -1 \u2192 inward, 0 \u2192 centered, +1 \u2192 outward. Default is -1.</p> <code>-1</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance resulting from the solidify operation.</p> Notes <ul> <li>Internally creates a Blender Solidify modifier with <code>use_even_offset=True</code> for consistent thickness.</li> <li>The modifier is applied destructively via <code>bpy.ops.object.modifier_apply</code>, and the resulting mesh is retrieved with <code>Mesh.from_object</code>.</li> <li>Works best on manifold surfaces (open meshes may produce artifacts).</li> </ul> <p>Examples:</p> <p>Solidify a circular glass mesh:</p> <pre><code>glass = Mesh.circle(segments=128)\nglass.extrude_faces(0, -0.01)\nglass.extrude_faces(0, -2)\nglass.extrude_faces(0, -0.01)\nglass.points.translate((0, 0, 2))\n\nglass = glass.solidify(thickness=0.1)\nglass.to_object(\"Solidify\", shade_smooth=True)\n</code></pre> See Also <p><code>Mesh.from_object</code> :     Converts a Blender object back into a mesh wrapper. <code>object</code> :     Context manager yielding a temporary Blender object.</p> <p>Caution: Applying the modifier is destructive to the underlying Blender object; the method returns a new mesh instance of the result.</p>"},{"location":"api/#npblender.Mesh.solidify_socle","title":"solidify_socle","text":"<pre><code>solidify_socle(shape, z=0, bottom_material_index=0)\n</code></pre> <p>Build a solid base (\u201csocle\u201d) by extruding the outer boundary of a grid mesh down (or up) to a given Z level, then bridging the side wall.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple of int</code> <p>Grid shape <code>(nx, ny)</code> of the mesh topology (using <code>'ij'</code> indexing).</p> required <code>z</code> <code>float</code> <p>Target Z coordinate for the base ring (the new bottom boundary). Default is 0.</p> <code>0</code> <code>bottom_material_index</code> <code>int</code> <p>Material index assigned to the bottom face created by the operation. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>Modifies the mesh in place. Returns <code>None</code>. The bottom face indices produced by <code>add_geometry</code> are stored internally and their <code>material_index</code> is set to <code>bottom_material_index</code>.</p> Notes <ul> <li>The outer boundary loop is derived from the provided grid <code>shape</code> assuming a regular lattice of <code>nx * ny</code> points laid out with NumPy\u2019s <code>'ij'</code> indexing.</li> <li>A new ring of points is created at Z = <code>z</code> via <code>add_points</code>.</li> <li>The vertical side wall is created by bridging loops with <code>bridge_loops</code> using <code>close=True</code>.</li> <li>The bottom face material is assigned by ensuring and editing the optional <code>material_index</code> field on <code>self.faces</code>.</li> </ul> <p>Examples:</p> <p>Solidify a 20\u00d730 grid down to Z = -0.1 with material index 2:</p> <pre><code>Mesh.solidify_socle(shape=(20, 30), z=-0.1, bottom_material_index=2)\n</code></pre> See Also <p><code>add_points</code> :     Adds the new base ring vertices at Z = <code>z</code>. <code>add_geometry</code> :     Creates the bottom polygon from the added ring. <code>bridge_loops</code> :     Connects the side wall between original and new boundary loops.</p> <p>Caution: This method assumes the mesh vertices correspond to a regular <code>(nx, ny)</code> grid ordered consistently with <code>'ij'</code> indexing; inconsistent layouts will produce incorrect boundaries.</p> <p>Note: The function does not return the created face indices; it sets their <code>material_index</code> internally based on <code>bottom_material_index</code>.</p>"},{"location":"api/#npblender.Mesh.split_edges","title":"split_edges","text":"<pre><code>split_edges(loop0, loop1, cuts=1)\n</code></pre> <p>Subdivide in place the edges whose endpoints match the pairs (loop0[i], loop1[i]) regardless of order (edges are treated as undirected).</p> <p>The inputs <code>loop0</code> and <code>loop1</code> can be: - scalars (a single vertex index), - sequences of the same length, - or a mix of both (a scalar is broadcast to match the length of the other).</p> <p>The vertex pairs are normalized by sorting (min, max) so that order does not matter, and then compared against the BMesh edge list to determine which edges should be subdivided.</p> <p>Parameters:</p> Name Type Description Default <code>loop0</code> <code>int or array-like of int</code> <p>First vertex (or list of vertices) of the edges to be selected. If scalar, it will be broadcast to the length of <code>loop1</code> if needed.</p> required <code>loop1</code> <code>int or array-like of int</code> <p>Second vertex (or list of vertices) of the edges to be selected. If scalar, it will be broadcast to the length of <code>loop0</code> if needed.</p> required <code>cuts</code> <code>int</code> <p>Number of cuts per selected edge, as defined by <code>bmesh.ops.subdivide_edges</code>. Default is <code>1</code>. Must be &gt;= 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>None</code> <p>Modifies the geometry in place. Returns <code>None</code>. If no edge matches the given pairs, the function returns immediately without modifying the mesh.</p> Notes <ul> <li>Edge selection is performed by constructing an array of sorted vertex pairs <code>(min(v0, v1), max(v0, v1))</code> and checking membership (via <code>np.isin</code> on a structured dtype view) against the BMesh edge list.</li> <li>Subdivision is executed with <code>bmesh.ops.subdivide_edges</code> and <code>use_grid_fill=False</code>.</li> </ul> <p>Examples:</p> <p>Subdivide a single edge (vertices 12 and 34) with 2 cuts:</p> <pre><code>obj = ...  # wrapper object providing .bmesh() and ._bm_edges(...)\nobj.split_edges(12, 34, cuts=2)\n</code></pre> <p>Subdivide multiple edges defined by pairs of vertices:</p> <pre><code>v0 = [1, 5, 9]\nv1 = [2, 6, 10]\nobj.split_edges(v0, v1, cuts=1)\n</code></pre> <p>Use a scalar broadcast against a vector:</p> <pre><code># All edges (7, x) for x in [8, 9, 10]\nobj.split_edges(7, [8, 9, 10], cuts=1)\n</code></pre> See Also <p>bmesh.ops.subdivide_edges : The underlying BMesh operator used for subdivision.</p> <p>Warning: This operation modifies the mesh in place and may create new vertices/edges/faces. Handle undo/history in Blender if needed.</p> <p>Caution: <code>use_grid_fill=False</code> prevents automatic grid filling. Depending on topology, additional n-gons or triangles may be introduced.</p> <p>Note: Edges are considered undirected: (a, b) and (b, a) are equivalent when matching edges.</p>"},{"location":"api/#npblender.Mesh.to_curve_REVIEW","title":"to_curve_REVIEW","text":"<pre><code>to_curve_REVIEW()\n</code></pre> <p>Convert mesh to curve</p> <p>Simple conversion when edges domain is defined</p>"},{"location":"api/#npblender.Mesh.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize the Mesh object to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the serialized data of the mesh, including: - 'geometry': The type of geometry (always 'Mesh'). - 'materials': List of material names. - 'points': Serialized points data. - 'corners': Serialized corners data. - 'faces': Serialized faces data. - 'edges': Serialized edges data.</p>"},{"location":"api/#npblender.Mesh.to_mesh_data","title":"to_mesh_data","text":"<pre><code>to_mesh_data(data)\n</code></pre> <p>Write the geometry data from this mesh into a Blender Mesh instance.</p> <p>This method transfers the mesh's vertices, edges, faces, corners, materials, and custom attributes into the provided Blender Mesh data structure.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Blender Mesh instance</code> <p>The Blender Mesh object to which the geometry will be written.</p> required <p>Returns:</p> Type Description <code>None</code> Side Effects <p>Modifies the provided Blender Mesh instance by clearing its current geometry and populating it with the data from this mesh. Updates the mesh to reflect the changes.</p>"},{"location":"api/#npblender.Mesh.to_object","title":"to_object","text":"<pre><code>to_object(obj, shade_smooth=None, shapekeys=None, collection=None)\n</code></pre> <p>Create or update a Blender mesh object from this mesh data.</p> <p>This method creates a new Blender mesh object if it does not already exist, or updates the existing object's mesh data. It does not perform object type conversion; the existing object must be a mesh.</p> <p>After the object is created or updated, use 'update_object' to modify vertices.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str or Object</code> <p>The Blender object or its name to create or update.</p> required <code>shade_smooth</code> <code>bool or None</code> <p>If specified, sets the shading mode of the mesh polygons to smooth or flat.</p> <code>None</code> <code>shapekeys</code> <code>ShapeKeys or iterable of ShapeKeys</code> <p>Shape keys to apply to the mesh object.</p> <code>None</code> <code>collection</code> <code>Collection or None</code> <p>The collection to which the object should be linked.</p> <code>None</code> <p>Returns:</p> Type Description <code>Object</code> <p>The created or updated Blender mesh object.</p>"},{"location":"api/#npblender.Mesh.torus","title":"torus  <code>classmethod</code>","text":"<pre><code>torus(major_segments=48, minor_segments=12, major_radius=1.0, minor_radius=0.25, materials=None)\n</code></pre> <p>Create a torus mesh.</p> <p>Parameters:</p> Name Type Description Default <code>major_segments</code> <code>int</code> <p>Number of segments around the major (outer) radius. Default is 48.</p> <code>48</code> <code>minor_segments</code> <code>int</code> <p>Number of segments around the minor (inner) radius (the cross-section). Default is 12.</p> <code>12</code> <code>major_radius</code> <code>float</code> <p>The distance from the center of the torus to the center of the tube. Default is 1.</p> <code>1.0</code> <code>minor_radius</code> <code>float</code> <p>The radius of the tube itself. Default is 0.25.</p> <code>0.25</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the torus. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the torus.</p> Notes <ul> <li>The torus is constructed by sweeping a circle of radius <code>minor_radius</code> around a larger circle of radius <code>major_radius</code>.</li> <li>The transformation of the cross-section is handled by <code>Transformation</code> and <code>Rotation</code>.</li> <li>UV coordinates are generated using <code>grid_uv_map</code>, resulting in a square parameterization.</li> <li>Topology is constructed with <code>grid_corners</code> with both axes closed.</li> </ul> <p>Examples:</p> <p>Create a standard torus:</p> <pre><code>torus = Mesh.torus()\n</code></pre> <p>Create a torus with a larger tube and finer resolution:</p> <pre><code>torus = Mesh.torus(major_segments=64, minor_segments=32,\n                major_radius=2, minor_radius=0.5)\n</code></pre> See Also <p><code>grid_corners</code> :     Helper for constructing the corner topology of the torus grid. <code>grid_uv_map</code> :     Generates UV coordinates for grid-like surfaces. <code>Transformation</code> :     Used to position and orient the swept circle. <code>Rotation</code> :     Used to orient the minor circle along the sweep path.</p> <p>Note: UV coordinates are generated with an offset of \u03c0 to match Blender's default torus orientation.</p>"},{"location":"api/#npblender.Mesh.triangulate","title":"triangulate","text":"<pre><code>triangulate(selection=None)\n</code></pre> <p>Triangulate selected faces (or all faces) and return a new mesh.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Indices (or mask) of faces to triangulate. If <code>None</code>, all faces are triangulated. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh or None</code> <p>A new mesh instance with the selected faces triangulated. Returns <code>None</code> if no faces were selected.</p> Notes <ul> <li>Creates a copy of the current mesh with <code>Mesh.from_mesh</code>.</li> <li>Triangulation is applied in-place on the copy via <code>bmesh.ops.triangulate</code>.</li> <li>The original mesh is left unchanged.</li> </ul> <p>Examples:</p> <p>Triangulate all faces:</p> <pre><code>tri_mesh = mesh.triangulate()\n</code></pre> <p>Triangulate only a subset:</p> <pre><code>tri_mesh = mesh.triangulate(selection=[0, 5, 7])\n</code></pre> See Also <p><code>Mesh.from_mesh</code> :     Utility to duplicate the mesh before applying triangulation.</p> <p>Note: If <code>selection</code> is empty, the method returns <code>None</code>.</p>"},{"location":"api/#npblender.Mesh.uvsphere","title":"uvsphere  <code>classmethod</code>","text":"<pre><code>uvsphere(segments=32, rings=16, radius=1, materials=None)\n</code></pre> <p>Create a UV sphere mesh.</p> <p>Parameters:</p> Name Type Description Default <code>segments</code> <code>int</code> <p>Number of longitudinal segments (meridians). Default is 32.</p> <code>32</code> <code>rings</code> <code>int</code> <p>Number of latitudinal rings (parallels). Default is 16.</p> <code>16</code> <code>radius</code> <code>float</code> <p>Radius of the sphere. Default is 1.</p> <code>1</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the sphere. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the UV sphere.</p> Notes <ul> <li>The sphere is created using <code>bmesh.ops.create_uvsphere</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> <li>The geometry is distributed evenly in the UV parameterization, which means denser vertices near the poles.</li> </ul> <p>Examples:</p> <p>Create a default UV sphere of radius 1:</p> <pre><code>sphere = Mesh.uvsphere()\n</code></pre> <p>Create a high-resolution sphere:</p> <pre><code>sphere = Mesh.uvsphere(segments=64, rings=32, radius=2)\n</code></pre> See Also <p><code>icosphere</code> :     Alternative sphere primitive with more uniform vertex distribution. <code>bmesh.ops.create_uvsphere</code> :     BMesh operator used for creating UV spheres.</p> <p>Note: Use <code>icosphere</code> if you need a more uniform tessellation without poles.</p>"},{"location":"api/#npblender.Mesh.vectors_field","title":"vectors_field  <code>classmethod</code>","text":"<pre><code>vectors_field(locations, vectors, radius=0.05, scale_length=1.0, angle=24.0, segments=8, head=None, adjust_norm=None, materials=None)\n</code></pre> <p>Create an arrow at each <code>location</code> oriented and scaled by the corresponding <code>vector</code>.</p> <p>Each arrow consists of a cylindrical shaft and a conical head aligned with the vector direction. Arrow length is derived from the vector norm, optionally transformed by <code>adjust_norm</code>. For very short vectors, the arrow is scaled down to preserve proportions.</p> <p>Parameters:</p> Name Type Description Default <code>locations</code> <code>array-like of shape (N, 3)</code> <p>Positions where arrows are placed.</p> required <code>vectors</code> <code>array-like of shape (N, 3)</code> <p>Direction (and base length) of each arrow. Must match the length of <code>locations</code>.</p> required <code>radius</code> <code>float</code> <p>Shaft radius for the arrows. Default is 0.05.</p> <code>0.05</code> <code>scale_length</code> <code>float</code> <p>Length threshold below which arrows are uniformly scaled down (radius and shaft) while keeping proportions. Default is 1.0.</p> <code>1.0</code> <code>angle</code> <code>float</code> <p>Opening angle (in degrees) of the conical head. Default is 24.</p> <code>24.0</code> <code>segments</code> <code>int</code> <p>Number of radial segments for both shaft and head. Default is 8.</p> <code>8</code> <code>head</code> <code>Mesh or None</code> <p>Optional mesh to use as the arrow head. If <code>None</code>, a cone is created. When provided, its Z size defines the head height.</p> <code>None</code> <code>adjust_norm</code> <code>(callable, float, None)</code> <p>Controls how vector norms are mapped to arrow lengths: - callable: applied to the array of norms. - float: acts as a maximum length (clamp). - None: use the raw norms. Default is None.</p> <code>callable</code> <code>materials</code> <code>list of str</code> <p>Material names to assign to created geometry. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A mesh containing all arrows.</p> Notes <ul> <li>The head radius is <code>3 * radius</code>; its height is derived from <code>angle</code> via <code>head_height = head_radius / tan(angle)</code>.</li> <li>Arrows with very small vectors are handled specially to avoid degenerate geometry (a minimum total length of approximately <code>2 * head_height</code> is enforced).</li> <li>Alignment is achieved with <code>Rotation.look_at</code>.</li> <li>The shaft is built from <code>cylinder</code>, and the head from <code>cone</code> (when <code>head is None</code>).</li> </ul> <p>Examples:</p> <p>Create a field of unit arrows from a grid:</p> <pre><code>P = np.stack(np.meshgrid(np.linspace(-1, 1, 5),\n                        np.linspace(-1, 1, 5),\n                        [0.0], indexing='ij'), axis=-1).reshape(-1, 3)\nV = np.tile(np.array([0, 0, 1.0]), (len(P), 1))\nfield = Mesh.vectors_field(P, V, radius=0.03, segments=12)\n</code></pre> <p>Clamp arrow lengths to 2 units:</p> <pre><code>field = Mesh.vectors_field(P, V * 5.0, adjust_norm=2.0)\n</code></pre> <p>Map norms nonlinearly (e.g., sqrt):</p> <pre><code>field = Mesh.vectors_field(P, V, adjust_norm=np.sqrt)\n</code></pre> See Also <p><code>arrow</code> :     Convenience method to create a single arrow. <code>cylinder</code> :     Used to create the arrow shafts. <code>cone</code> :     Used to create the arrow heads (when <code>head is None</code>). <code>Rotation.look_at</code> :     Used to orient arrows along their vectors.</p> <p>Caution: <code>locations</code> and <code>vectors</code> must have the same length (N). Mismatched inputs will lead to incorrect alignment or runtime errors.</p> <p>Note: Zero-length vectors are handled safely; corresponding arrows collapse to length 0 and are effectively omitted.</p>"},{"location":"api/#npblender.Meshes","title":"Meshes","text":"<pre><code>Meshes(mesh=None, mesh_id=None, attr_from=None, **attributes)\n</code></pre> <p>               Bases: <code>Geometry</code></p> <p>Instances based on mesh buckets.</p> <p>Instances is best for managing a high number of instances with a low number of models. Meshes manages one mesh per point</p> Arguments <pre><code>- mesh (Mesh) : the mesh containing the geometry\n- mesh_id (int = None) : mesh points attribute defining the instances\n- attr_from (Geometry) : geometry where to capture attributes from\n- **attributes (dict) : other geometry attributes\n</code></pre>"},{"location":"api/#npblender.MultiResGrid","title":"MultiResGrid","text":"<pre><code>MultiResGrid(func, shape=(3, 3), u_space=(0, 1), v_space=(0, 1), is_altitude=False, normal_func=None)\n</code></pre> <p>               Bases: <code>Mesh</code></p> <p>Multi resolution grid</p> <p>A surface defined by a function of two parameters u and v. The function can return either a vector or an altitude, u and being interpretated as (x, y).</p> <p>The grid resolution is defined by a depth when calling the method update_grid. The method accepts a camera to adapt its the resolution only to the visible parts.</p> Arguments <ul> <li>shape (2-tuple of ints) : initial division</li> <li>u_space (2-tuple of floats) : u min and max values</li> <li>v_space (2-tuple of floats) : v min and max values</li> <li>is_altitude (bool = False) : the function returns z only vector is built with (u, v) as (x, y)</li> </ul>"},{"location":"api/#npblender.MultiResGrid.call_func","title":"call_func","text":"<pre><code>call_func(u, v)\n</code></pre> <p>Call the surface function</p> Arguments <ul> <li>u (array of floats) : u value</li> <li>v (array of floats) : v value</li> </ul> <p>Returns:</p> Type Description <code>- array of vectors</code>"},{"location":"api/#npblender.MultiResGrid.compute_normals","title":"compute_normals","text":"<pre><code>compute_normals(u, v, du, dv)\n</code></pre> <p>Compute the face normals</p>"},{"location":"api/#npblender.MultiResGrid.get_normals","title":"get_normals","text":"<pre><code>get_normals(u, v)\n</code></pre> <p>Call the surface function</p> Arguments <ul> <li>u (array of floats) : u value</li> <li>v (array of floats) : v value</li> </ul> <p>Returns:</p> Type Description <code>- array of vectors</code>"},{"location":"api/#npblender.MultiResGrid.update_grid","title":"update_grid","text":"<pre><code>update_grid(depth=0, camera=None, max_vertices=10000000, max_size=0.05)\n</code></pre> <p>Update the grid resolution with the given depth</p> Arguments <ul> <li>depth (int) : maximum depth</li> <li>camera (Camera) : camera to compute visible faces</li> <li>max_vertices (int = 10_000_000) : maximum number of vertices</li> <li>max_size (float = .05) : maximum size of faces</li> </ul>"},{"location":"api/#npblender.ShapeKeys","title":"ShapeKeys","text":"<pre><code>ShapeKeys(rec_array, count=1, relative=True, extrapolation='CLIP', ignore_int=True, ignore_bool=True)\n</code></pre> <p>ShapeKeys manages a stack of structured arrays (like FieldArrays), with the same structure and same number of elements in each array.</p> <p>Parameters:</p> Name Type Description Default <code>rec_array</code> <code>ndarray(structured) or FieldArray</code> <p>The reference array to replicate.</p> required <code>count</code> <code>int</code> <p>The number of copies to initialize.</p> <code>1</code> <code>relative</code> <code>bool</code> <p>Optional flag, for later use.</p> <code>True</code>"},{"location":"api/#npblender.ShapeKeys.abs_interpolate","title":"abs_interpolate","text":"<pre><code>abs_interpolate(t, smooth=1)\n</code></pre> <p>Absolute interpolation between keyframes.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float or array_like</code> <p>Interpolation factor(s) in [0, 1].</p> required <code>extrapolation</code> <code>(CLIP, CYCLIC, BACK)</code> <p>How to handle t values outside [0, 1].</p> <code>'CLIP'</code> <code>smooth</code> <code>(int, str or callable)</code> <p>Smoothing method:     - int: degree of BSpline     - 'CUBIC': cubic spline     - callable: function to apply to t     - None: linear interpolation</p> <code>1</code> <p>Returns:</p> Type Description <code>recarray or array of recarrays</code> <p>Interpolated values with only float fields (others ignored).</p>"},{"location":"api/#npblender.ShapeKeys.rel_interpolate","title":"rel_interpolate","text":"<pre><code>rel_interpolate(weights, smooth=1)\n</code></pre> <p>Relative interpolation using deltas from base shape.</p> <p>Parameters:</p> Name Type Description Default <code>weights</code> <code>array_like</code> <ul> <li>shape (K,) for one result</li> <li>shape (M, K) for multiple results where K = number of shapes - 1</li> </ul> required <code>smooth</code> <code>int, str, callable, or None</code> <p>Smoothing method (same as abs_interpolate)</p> <code>1</code> <p>Returns:</p> Type Description <code>np.recarray or array of recarrays</code> <p>Interpolated result(s) (only float fields)</p>"},{"location":"api/#npblender.Simulation","title":"Simulation","text":"<pre><code>Simulation(compute=None, reset=None, view=None)\n</code></pre> <p>               Bases: <code>Animation</code></p>"},{"location":"api/#npblender.Simulation.add_action","title":"add_action","text":"<pre><code>add_action(func, *args, start=0, duration=None, flags=0, **kwargs)\n</code></pre> <p>Add an action to the simulation</p> <p>To add an event, you can use &lt;#add_event&gt;.</p> Arguments <ul> <li>func (function) : function of template f(simulation, args, *kwargs)</li> <li>top (float = 0) : start time for the actiuon</li> <li>duration (float = None) : duration of the action (0: call once, None: never stops)</li> <li>after (bool = False) : exec the action after the exec_loop</li> </ul> <p>Returns:</p> Type Description <code>- Action : the action added to the simulation</code>"},{"location":"api/#npblender.Simulation.add_event","title":"add_event","text":"<pre><code>add_event(func, *args, start=0, flags=0, **kwargs)\n</code></pre> <p>Add an event to the simulation</p> <p>The event is executed once. To add an action called at each step, use &lt;#add_action&gt;.</p> Arguments <ul> <li>func (function) : function of template f(simulation, args, *kwargs)</li> <li>top (float = 0) : start time for the actiuon</li> <li>after (bool = False) : exec the action after the exec_loop</li> </ul> <p>Returns:</p> Type Description <code>- Action : the event added to the simulation</code>"},{"location":"api/#npblender.Simulation.change_attribute","title":"change_attribute","text":"<pre><code>change_attribute(attribute, value, incr=None, factor=None)\n</code></pre> <p>Modify a points attribute</p> <pre><code># gravity\nself.add_action(\"change_attribute\", \"accel\", value=(0, 0, -9.81))\n</code></pre>"},{"location":"api/#npblender.Simulation.newton_law","title":"newton_law","text":"<pre><code>newton_law(G=1, power=2, min_distance=0.001)\n</code></pre> <p>Newton's law between points</p> <p>The force between two points is given by:</p> <p>F = G.m1.m2 / dist**p</p>"},{"location":"api/#npblender.Simulation.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the simulation</p>"},{"location":"api/#npblender.Spline","title":"Spline","text":"<pre><code>Spline(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>               Bases: <code>FaceSplineDomain</code></p> <p>Spline domain.</p> <p>Spline domain is specific to Curve geometry. A spline is an array of control points. A Spline is similare to a Face but points directly to the control points and not indirectly as for the faces.</p> <p>Attributes:</p> Name Type Description <code>- loop_start (int)</code> <code>first index in control points array</code> <ul> <li>loop_total (int) : number of control points</li> <li>material_index (int, optional) : material index</li> <li>resolution (int, optional) : spline resolution</li> <li>cyclic (bool, optional) : spline is cyclic or not</li> <li>order (int, optional) : Nurbs spline order</li> <li>bezierpoint (bool, optional) : Nurbs spline bezierpoint flag</li> <li>endpoint (bool, optional) : Nurbs spline endpoint flag</li> </ul>"},{"location":"api/#npblender.Spline.functions","title":"functions  <code>property</code>","text":"<pre><code>functions\n</code></pre> <p>Return the functions representing the splines.</p> <p>The functions are scipy BSplines initialized with the splines parameters.</p> <p>Returns:</p> Type Description <code>    - list of BSpline functions</code>"},{"location":"api/#npblender.Spline.length","title":"length  <code>property</code>","text":"<pre><code>length\n</code></pre> <p>Length of the splines.</p> <p>Returns:</p> Type Description <code>    - List of spline lengths</code>"},{"location":"api/#npblender.Spline.add_splines","title":"add_splines","text":"<pre><code>add_splines(splines, **attributes)\n</code></pre> <p>Add splines.</p> Arguments <pre><code>- splines (array of ints) : the number of control points per spline\n- attributes (attribute names, attribute values) : value of the corner attributes\n</code></pre>"},{"location":"api/#npblender.Spline.load_bl_attributes","title":"load_bl_attributes","text":"<pre><code>load_bl_attributes(data)\n</code></pre> <p>Read the object attributes.</p> Arguments <pre><code>- spec (str or data) : the data to set the attributes to\n</code></pre>"},{"location":"api/#npblender.Spline.tangent","title":"tangent","text":"<pre><code>tangent(t)\n</code></pre> <p>Tangents of the splines at a given time.</p> Arguments <pre><code>- t (float) : spline parameter between 0 and 1\n</code></pre> <p>Returns:</p> Type Description <code>    - list of spline tangents evaluated at time t.</code>"},{"location":"api/#npblender.Spline.to_object","title":"to_object","text":"<pre><code>to_object(data, update=False)\n</code></pre> <p>Transfer the attributes to a blender mesh object.</p> Arguments <pre><code>- spec (str or data) : the mesh to set the attributes to\n- attributes (array of st = None) : the attributes to transfer (all if None)\n- update (bool=False) : update the attributes values without trying to create them\n</code></pre>"},{"location":"api/mesh/","title":"Mesh","text":"<p>               Bases: <code>Geometry</code></p> <p>Initialize a Mesh Geometry object.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array_like</code> <p>The vertices of the mesh (default is None).</p> <code>None</code> <code>corners</code> <code>array_like of int</code> <p>Corners, i.e., indices on the array of points (default is None).</p> <code>None</code> <code>faces</code> <code>array_like of int</code> <p>Sizes of the faces; the sum of this array must be equal to the length of the corners array (default is None).</p> <code>None</code> <code>edges</code> <code>array_like of tuple of int</code> <p>List of edges defined by pairs of vertex indices (default is None).</p> <code>None</code> <code>materials</code> <code>str or list of str</code> <p>List of materials used in the geometry. If a single string is provided, it is converted to a list containing that string (default is None).</p> <code>None</code> <code>attr_from</code> <code>Geometry</code> <p>Domain attributes to copy from another Geometry object (default is None).</p> <code>None</code> <code>**attrs</code> <code>dict</code> <p>Additional geometry attributes.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>points</code> <code>Vertex</code> <p>The vertices of the mesh.</p> <code>corners</code> <code>Corner</code> <p>The corners of the mesh.</p> <code>faces</code> <code>Face</code> <p>The faces of the mesh.</p> <code>edges</code> <code>Edge</code> <p>The edges of the mesh.</p> <code>materials</code> <code>list of str</code> <p>The list of materials used in the geometry.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_geometry","title":"add_geometry","text":"<pre><code>add_geometry(points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs)\n</code></pre> <p>Add geometry components (vertices, corners, faces, edges) to the mesh.</p> <p>This method appends the specified geometry to the mesh without altering existing indices. It supports referencing existing vertices through corners or adding new vertices.</p> <p>Note: To add independent geometry with new vertices, use <code>Mesh.join_geometry</code> instead.</p> <p>Examples:</p> <pre><code>``` python\ncube = Mesh.cube()\n# Add a triangle on existing vertices\n# corners argument refers to cube vertices\ncube.add_geometry(corners=[0, 1, 2], faces=3)\n\n# Add a triangle with additional vertices\n# corners argument refers to the new vertices, passed values [0, 1, 2]\n# will be shifted to actual values [8, 9, 10]\ncube.join_geometry(points=[[0, 0, 0], [0, 1, 0], [1, 0, 0]], corners=[0, 1, 2], faces=3)\n```\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like of vectors</code> <p>Vertices to add to the mesh.</p> <code>None</code> <code>corners</code> <code>array-like of int</code> <p>Indices referring to vertices in the points array.</p> <code>None</code> <code>faces</code> <code>int, array-like of int, or list of lists</code> <p>Defines the faces topology: - If <code>corners</code> is provided:     - None: Single face made of all corners.     - int: All faces have the same size (must divide the number of corners).     - array-like: Face sizes; sum must equal the number of corners. - If <code>corners</code> is None:     - Must be a list of lists, each sublist is a list of corners.</p> <code>None</code> <code>edges</code> <code>array-like of pairs of int</code> <p>Edges defined by pairs of vertex indices.</p> <code>None</code> <code>safe_mode</code> <code>bool</code> <p>If True, perform a mesh integrity check after adding geometry.</p> <code>False</code> <code>**attrs</code> <code>dict</code> <p>Additional geometry attributes to apply.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys {'points', 'corners', 'faces', 'edges'} mapping to lists of added geometry indices.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If faces and corners lengths are inconsistent or invalid.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_materials","title":"add_materials","text":"<pre><code>add_materials(materials)\n</code></pre> <p>Add a materials list to the existing one.</p> <p>If a material already exist, it is not added another time.</p> Arguments <pre><code>- materials (list of strs) : the list of materials to append.\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_points","title":"add_points","text":"<pre><code>add_points(points, **attributes)\n</code></pre> <p>Add vertices.</p> Arguments <pre><code>- points (array of vectors) : the vertices to add\n- attributes (name=value) : value for named attributes\n</code></pre> <p>Returns:</p> Type Description <code>    - array of ints : indices of the added vertices</code>"},{"location":"api/mesh/#npblender.mesh.Mesh.arrow","title":"arrow  <code>classmethod</code>","text":"<pre><code>arrow(vector=(0, 0, 1), radius=0.05, angle=24.0, segments=8, adjust_norm=None, materials=None)\n</code></pre> <p>Create an arrow mesh oriented along a given vector.</p> <p>The arrow is composed of a cylindrical shaft and a conical head, proportionally scaled to the length of the input vector.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>array-like of float, shape (3,)</code> <p>Direction and length of the arrow. The norm of the vector defines the arrow length. Default is (0, 0, 1).</p> <code>(0, 0, 1)</code> <code>radius</code> <code>float</code> <p>Radius of the cylindrical shaft. Default is 0.05.</p> <code>0.05</code> <code>angle</code> <code>float</code> <p>Opening angle of the conical head in degrees. Default is 24.</p> <code>24.0</code> <code>segments</code> <code>int</code> <p>Number of segments around the circumference. Default is 8.</p> <code>8</code> <code>adjust_norm</code> <code>(callable, float, None)</code> <ul> <li>If callable: a function applied to the vector norm to adjust the arrow length.</li> <li>If float: the arrow length is clamped to this maximum.</li> <li>If None: use the norm of <code>vector</code> directly. Default is None.</li> </ul> <code>callable</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the arrow. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the arrow.</p> Notes <ul> <li>The shaft is created with <code>cylinder</code>.</li> <li>The head is created with <code>cone</code> using <code>fill_type='FANS'</code> for proper triangulation.</li> <li>The arrow is aligned to <code>vector</code> using <code>Rotation.look_at</code>.</li> <li>A small correction is applied to avoid overlap between shaft and head.</li> </ul> <p>Examples:</p> <p>Create a default arrow of length 1 along Z:</p> <pre><code>arrow = Mesh.arrow()\n</code></pre> <p>Create an arrow along vector (1, 2, 0.5) with custom shaft radius:</p> <pre><code>arrow = Mesh.arrow(vector=(1, 2, 0.5), radius=0.1)\n</code></pre> <p>Create an arrow clamped to maximum length 2:</p> <pre><code>arrow = Mesh.arrow(vector=(0, 0, 5), adjust_norm=2)\n</code></pre> See Also <p><code>cylinder</code> :     Used to create the arrow shaft. <code>cone</code> :     Used to create the arrow head. <code>Rotation.look_at</code> :     Utility to orient the arrow along a target vector.</p> <p>Caution: If <code>vector</code> has zero length, the arrow cannot be constructed properly.</p> <p>Note: The conical head radius is set to <code>3 * radius</code> by default, and its height is determined by the opening <code>angle</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_circle","title":"bl_circle  <code>classmethod</code>","text":"<pre><code>bl_circle(radius=1, segments=16, fill_tris=False, materials=None)\n</code></pre> <p>Create a circle mesh.</p> <p>Blender constructor for generating a circle primitive using <code>bmesh.ops.create_circle</code>.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the circle. Default is 1.</p> <code>1</code> <code>segments</code> <code>int</code> <p>Number of segments (vertices) forming the circle. Default is 16.</p> <code>16</code> <code>fill_tris</code> <code>bool</code> <p>If True, fills the circle with a triangle fan. Default is False.</p> <code>False</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the circle. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the circle.</p> Notes <ul> <li>The circle is created using <code>bmesh.ops.create_circle</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> <li>By default (<code>fill_tris=False</code>), the circle is an open ring. With <code>fill_tris=True</code>, the circle is filled with triangles (fan topology).</li> </ul> <p>Examples:</p> <p>Create an empty circle of radius 2 with 32 segments:</p> <pre><code>circle = Mesh.bl_circle(radius=2, segments=32)\n</code></pre> <p>Create a filled circle (disk) of radius 1 with 24 segments:</p> <pre><code>circle = Mesh.bl_circle(radius=1, segments=24, fill_tris=True)\n</code></pre> See Also <p><code>bmesh.ops.create_circle</code> :     BMesh operator used for creating a circle primitive.</p> <p>Note: UVs are automatically calculated when the circle is created.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_cone","title":"bl_cone  <code>classmethod</code>","text":"<pre><code>bl_cone(radius1=1, radius2=0, depth=2, segments=16, side_segments=1, cap_ends=True, cap_tris=False, materials=None)\n</code></pre> <p>Create a cone mesh.</p> <p>Blender constructor for generating a cone (or cylinder) primitive using <code>bmesh.ops.create_cone</code>.</p> <p>Parameters:</p> Name Type Description Default <code>radius1</code> <code>float</code> <p>Base radius of the cone. Default is 1.</p> <code>1</code> <code>radius2</code> <code>float</code> <p>Top radius of the cone. If set to 0, produces a true cone; if equal to <code>radius1</code>, produces a cylinder. Default is 0.</p> <code>0</code> <code>depth</code> <code>float</code> <p>Height of the cone along the Z axis. Default is 2.</p> <code>2</code> <code>segments</code> <code>int</code> <p>Number of segments around the circumference. Default is 16.</p> <code>16</code> <code>side_segments</code> <code>int</code> <p>Number of subdivisions along the vertical side edges. Default is 1 (no subdivision).</p> <code>1</code> <code>cap_ends</code> <code>bool</code> <p>If True, fill the top and bottom caps. Default is True.</p> <code>True</code> <code>cap_tris</code> <code>bool</code> <p>If True, fill the caps using triangle fans instead of n-gons. Default is False.</p> <code>False</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the cone. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the cone.</p> Notes <ul> <li>The cone is created using <code>bmesh.ops.create_cone</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> <li>When <code>side_segments &gt; 1</code>, vertical edges crossing the top and bottom are subdivided using <code>bmesh.ops.subdivide_edges</code>.</li> </ul> <p>Examples:</p> <p>Create a simple cone with radius 1 and height 2:</p> <pre><code>cone = Mesh.bl_cone(radius1=1, radius2=0, depth=2, segments=16)\n</code></pre> <p>Create a cylinder with 32 segments and subdivided sides:</p> <pre><code>cylinder = Mesh.bl_cone(radius1=1, radius2=1, depth=3,\n                        segments=32, side_segments=4)\n</code></pre> <p>Create a cone with filled caps using triangle fans:</p> <pre><code>cone = Mesh.bl_cone(radius1=1, radius2=0, depth=2,\n                    cap_ends=True, cap_tris=True)\n</code></pre> See Also <p><code>bmesh.ops.create_cone</code> :     BMesh operator used for creating cone and cylinder primitives. <code>bmesh.ops.subdivide_edges</code> :     BMesh operator used for subdividing vertical edges when <code>side_segments &gt; 1</code>.</p> <p>Note: UVs are automatically calculated when the cone is created.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_grid","title":"bl_grid  <code>classmethod</code>","text":"<pre><code>bl_grid(x_segments=1, y_segments=1, size=2, materials=None)\n</code></pre> <p>Create a grid mesh.</p> <p>Blender constructor for generating a grid primitive using <code>bmesh.ops.create_grid</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x_segments</code> <code>int</code> <p>Number of segments along the X axis. Default is 1.</p> <code>1</code> <code>y_segments</code> <code>int</code> <p>Number of segments along the Y axis. Default is 1.</p> <code>1</code> <code>size</code> <code>float or tuple of float</code> <p>Size of the grid. If a single float is given, the grid is square. If a tuple is given, defines the grid dimensions along X and Y. Default is 2.</p> <code>2</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the grid. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the grid.</p> Notes <ul> <li>The grid is created using <code>bmesh.ops.create_grid</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> </ul> <p>Examples:</p> <p>Create a 10x10 grid of size 5:</p> <pre><code>grid = Mesh.bl_grid(x_segments=10, y_segments=10, size=5)\n</code></pre> <p>Create a rectangular grid 4x8 of size (2, 5):</p> <pre><code>grid = Mesh.bl_grid(x_segments=4, y_segments=8, size=(2, 5))\n</code></pre> See Also <p><code>bmesh.ops.create_grid</code> :     BMesh operator used for creating a grid primitive.</p> <p>Note: UVs are automatically calculated when the grid is created.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.blender_data","title":"blender_data","text":"<pre><code>blender_data(readonly=False)\n</code></pre> <p>Context manager to access the Blender Mesh API with a temporary mesh.</p> <p>This method transfers the current mesh geometry to a temporary Blender Mesh data block, yields it for reading or modification, and optionally captures the changes back into the mesh.</p> <p>Example usage:     ```python     mesh = Mesh.Cube()</p> <pre><code>with mesh.blender_data() as data:\n    normals = np.array([poly.normal for poly in data.polygons])\n\nprint(normals)\n# Output:\n# [[-1. -0.  0.]\n#  [ 0.  1.  0.]\n#  [ 1. -0.  0.]\n#  [ 0. -1.  0.]\n#  [ 0.  0. -1.]\n#  [ 0. -0.  1.]]\n```\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>readonly</code> <code>bool</code> <p>If True, the geometry is not read back from the Blender Mesh after modification. Default is False.</p> <code>False</code> <p>Yields:</p> Type Description <code>Mesh</code> <p>A temporary Blender Mesh data block representing the mesh geometry.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bmesh","title":"bmesh","text":"<pre><code>bmesh(readonly=False)\n</code></pre> <p>Context manager to access and manipulate the mesh using Blender's BMesh API.</p> <p>This method creates a temporary BMesh from the mesh data, yields it for modification, and then writes back the changes to the mesh data unless in readonly mode.</p> <p>Example usage:     ```python     mesh = Mesh.Cube()</p> <pre><code># Move the vertices with bmesh\nwith mesh.bmesh() as bm:\n    for v in bm.verts:\n        v.co.x += 1.0\n\n# Move the vertices directly in numpy array\nmesh.points.position[:, 1] += 1\n\n# Cube moved along x and y\nmesh.to_object(\"Cube\")\n```\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>readonly</code> <code>bool</code> <p>If True, changes made to the BMesh are not written back to the mesh data (default is False).</p> <code>False</code> <p>Yields:</p> Type Description <code>BMesh</code> <p>A BMesh object representing the mesh data, which can be modified within the context.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.boolean","title":"boolean","text":"<pre><code>boolean(other, operation='DIFFERENCE')\n</code></pre> <p>Apply a boolean CSG operation with another mesh object and return the result.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Mesh</code> <p>The mesh used as the boolean operand.</p> required <code>operation</code> <code>(INTERSECT, UNION, DIFFERENCE)</code> <p>Type of boolean operation to perform. Default is 'DIFFERENCE'.</p> <code>'INTERSECT'</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance created from the object after applying the Boolean modifier.</p> Notes <ul> <li>Internally, a Blender Boolean modifier is added to <code>self</code>, pointing to <code>other</code>, and then applied via <code>bpy.ops.object.modifier_apply</code>.</li> <li>The result is read back as a new mesh using <code>Mesh.from_object</code>.</li> <li>Context managers <code>object</code> are used to obtain temporary Blender objects for both meshes.</li> </ul> <p>Examples:</p> <p>Subtract <code>B</code> from <code>A</code>:</p> <pre><code>result = A.boolean(B, operation='DIFFERENCE')\n</code></pre> <p>Compute the union:</p> <pre><code>result = A.boolean(B, operation='UNION')\n</code></pre> <p>Keep only the intersection:</p> <pre><code>result = A.boolean(B, operation='INTERSECT')\n</code></pre> See Also <p><code>Mesh.from_object</code> :     Converts a Blender object back into a mesh wrapper. <code>object</code> :     Context manager yielding a temporary Blender object.</p> <p>Warning: Applying the modifier is destructive to the underlying Blender object for <code>self</code> (its mesh data is changed). The method returns a new mesh instance representing the modified result.</p> <p>Caution: Ensure <code>operation</code> is one of {'INTERSECT', 'UNION', 'DIFFERENCE'}; other values are invalid for Blender's Boolean modifier.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bridge_loops","title":"bridge_loops","text":"<pre><code>bridge_loops(loop0, loop1, close=False, segments=1, **attributes)\n</code></pre> <p>Create a grid connecting two vertex loops of equal size.</p> <p>The operation selects the edges forming each loop and bridges them using <code>bmesh.ops.bridge_loops</code>. If <code>segments &gt; 1</code>, the newly created edges are subdivided to form a denser grid between the loops.</p> <p>Parameters:</p> Name Type Description Default <code>loop0</code> <code>array-like of int</code> <p>The first loop of vertex indices.</p> required <code>loop1</code> <code>array-like of int</code> <p>The second loop of vertex indices. Must have the same length as <code>loop0</code>.</p> required <code>close</code> <code>bool</code> <p>If True, the loops are treated as closed and the first vertex is appended at the end to close the cycle. Default is False.</p> <code>False</code> <code>segments</code> <code>int</code> <p>Number of segments to subdivide between the loops. Must be &gt;= 1. Default is 1 (no subdivision).</p> <code>1</code> <code>**attributes</code> <code>dict</code> <p>Additional attributes to set on the mesh after bridging (passed as keyword arguments).</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>Modifies the mesh in place. Returns <code>None</code>.</p> Notes <ul> <li>Edges belonging to each loop are identified by sorting endpoint pairs and matching them against the current BMesh edge list via a structured dtype view and <code>np.isin</code>.</li> <li>Bridging is performed with <code>bmesh.ops.bridge_loops</code>.</li> <li>When <code>segments &gt; 1</code>, subdivision of the bridge edges is performed with <code>bmesh.ops.subdivide_edges</code> using <code>cuts=segments - 1</code> and <code>use_grid_fill=False</code>.</li> </ul> <p>Examples:</p> <p>Bridge two loops with no subdivision:</p> <pre><code>obj.bridge_loops(loop0, loop1, segments=1)\n</code></pre> <p>Bridge two closed loops with 3 subdivisions:</p> <pre><code>obj.bridge_loops(loop0, loop1, close=True, segments=3)\n</code></pre> See Also <p>bmesh.ops.bridge_loops : BMesh operator for bridging edge loops. bmesh.ops.subdivide_edges : BMesh operator for subdividing edges.</p> <p>Warning: This function modifies the mesh in place and may create new vertices/edges/faces. Handle undo/history in Blender if needed.</p> <p>Caution: Both loops must have the same number of vertices for correct bridging.</p> <p>Note: When <code>close=True</code>, the first vertex of each loop is duplicated at the end to ensure cyclic connectivity.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bvh_tree","title":"bvh_tree","text":"<pre><code>bvh_tree(count=None)\n</code></pre> <p>Build a Blender BVH tree for fast spatial queries (ray casting, overlap, nearest point, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>If <code>None</code>, build a single BVH tree for the whole mesh. If an integer <code>count</code> is provided, the mesh is assumed to represent a batch of <code>count</code> sub-meshes laid out in a structured array, and a list of BVH trees (one per sub-mesh) is returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>BVHTree or list of BVHTree</code> <ul> <li>If <code>count</code> is <code>None</code>, a single <code>BVHTree</code> instance built from the current mesh.</li> <li>If <code>count</code> is an integer, a list of <code>BVHTree</code> objects, one for each sub-mesh.</li> </ul> Notes <ul> <li>Internally uses <code>mathutils.bvhtree.BVHTree.FromPolygons</code>.</li> <li>When <code>count</code> is given, vertices are reshaped to <code>(count, n, 3)</code> and faces are assumed to be identical across all sub-meshes.</li> <li><code>epsilon=0.0</code> is used for exact geometry.</li> </ul> <p>Examples:</p> <p>Build a single BVH tree:</p> <pre><code>tree = mesh.bvh_tree()\nloc, normal, index, dist = tree.ray_cast((0, 0, 10), (0, 0, -1))\n</code></pre> <p>Build multiple BVH trees for a batch of 5 sub-meshes:</p> <pre><code>trees = mesh.bvh_tree(count=5)\nfor t in trees:\n    print(t.find_nearest((0, 0, 0)))\n</code></pre> <p>Caution: When <code>count</code> is provided, the mesh must be structured consistently: faces are taken from the first sub-mesh and reused for all.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.capture","title":"capture","text":"<pre><code>capture(other)\n</code></pre> <p>Capture the data of another Mesh.</p> Arguments <pre><code>- other (Mesh) : the mesh to capture\n</code></pre> <p>Returns:</p> Type Description <code>    - self</code>"},{"location":"api/mesh/#npblender.mesh.Mesh.chain_link","title":"chain_link  <code>classmethod</code>","text":"<pre><code>chain_link(major_segments=48, minor_segments=12, radius=1.0, section=0.5, length=4.0, materials=None)\n</code></pre> <p>Create a single chain link (oval torus with straightened sides).</p> <p>The link is built from a torus of major radius <code>radius</code> and tube radius <code>section / 2</code>. If <code>length &gt; 2 * radius</code>, the torus is split in half, translated to open a gap of size <code>delta = length - 2 * radius</code>, mirrored, then the opposite borders are bridged to form the elongated link. UVs are adjusted to keep a clean seam layout.</p> <p>Parameters:</p> Name Type Description Default <code>major_segments</code> <code>int</code> <p>Number of segments around the major loop. Default is 48.</p> <code>48</code> <code>minor_segments</code> <code>int</code> <p>Number of segments around the tube section. Default is 12.</p> <code>12</code> <code>radius</code> <code>float</code> <p>Major radius of the link (half the distance between opposite sides on the long axis before elongation). Default is 1.0.</p> <code>1.0</code> <code>section</code> <code>float</code> <p>Diameter of the link cross-section (tube thickness). Default is 0.5.</p> <code>0.5</code> <code>length</code> <code>float</code> <p>Target overall length of the link along its long axis. If close to <code>2 * radius</code>, the result is essentially a pure torus. Default is 4.0.</p> <code>4.0</code> <code>materials</code> <code>list of str</code> <p>Material names to assign to the link. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the chain link.</p> Notes <ul> <li>Construction steps: 1) Create a torus with <code>torus</code>. 2) Delete approximately half the vertices on the negative Y side with     <code>delete_vertices</code>. 3) Duplicate and mirror the remaining half to the other side. 4) Bridge the facing border loops with     <code>bridge_loops</code> (twice, crossing). 5) Recompute and assign UVs using <code>grid_uv_map</code>     to distribute the texture coordinates and minimize stretching.</li> <li>When <code>length - 2 * radius</code> is smaller than ~<code>radius / 10</code>, the method returns the original torus since elongation would be negligible.</li> </ul> <p>Examples:</p> <p>Create a standard chain link:</p> <pre><code>link = Mesh.chain_link(major_segments=64, minor_segments=16,\n                    radius=0.5, section=0.12, length=1.6)\n</code></pre> <p>Create a thicker, longer link:</p> <pre><code>link = Mesh.chain_link(radius=1.0, section=0.25, length=3.0)\n</code></pre> See Also <p><code>torus</code> :     Base primitive used to start the link. <code>delete_vertices</code> :     Used to remove half of the torus before mirroring. <code>bridge_loops</code> :     Used to reconnect mirrored borders. <code>grid_uv_map</code> :     Generates UVs for the final link surface. <code>from_mesh</code> :     Utility for duplicating mesh halves before joining.</p> <p>Caution: Very small <code>section</code> relative to <code>major_segments</code> can create skinny triangles near the bridged areas. Increase segment counts or <code>section</code> for cleaner topology.</p> <p>Note: If <code>length &lt;= 2 * radius</code>, no elongation is performed and the result is (nearly) identical to a torus of the given parameters.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.check","title":"check","text":"<pre><code>check(title='Mesh Check', halt=True)\n</code></pre> <p>Check if mesh domains (corners, faces, edges) are consistent.</p> <p>This method verifies the consistency of the mesh domains by checking the validity of corners, faces, and edges relative to the number of points. In development mode, it raises an exception to prevent Blender from crashing if inconsistencies are found.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title prefix for error messages (default is \"Mesh Check\").</p> <code>'Mesh Check'</code> <code>halt</code> <code>bool</code> <p>If True, raise an exception on failure; otherwise, print a warning (default is True).</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if all checks pass; otherwise, raises an exception or prints an error.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the check fails and halt is True.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.circle","title":"circle  <code>classmethod</code>","text":"<pre><code>circle(radius=1, segments=16, fill_segments=0, cap='NONE', materials=None)\n</code></pre> <p>Create a circle mesh.</p> <p>The circle can be created as: - An open ring (<code>cap='NONE'</code>). - A filled n-gon (<code>cap='NGON'</code>). - A triangle fan (<code>cap='FANS'</code>).</p> <p>The argument <code>fill_segments</code> controls how the interior of the circle is filled: - If <code>fill_segments == 0</code> and <code>cap='NGON'</code>, the circle is filled with a single polygon. - If <code>fill_segments &gt; 0</code>, the circle is filled with concentric rings and triangle fans (not yet implemented in this method, but the behavior corresponds to <code>cap='FANS'</code>).</p> <p>Note: The <code>disk</code> method provides the same functionality with <code>cap='NGON'</code> as its default mode.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the circle. Default is 1.</p> <code>1</code> <code>segments</code> <code>int</code> <p>Number of segments (vertices) around the circle. Default is 16.</p> <code>16</code> <code>fill_segments</code> <code>int</code> <p>Number of internal subdivisions (concentric circles). If 0, the circle is filled with a single polygon when <code>cap='NGON'</code>. Default is 0.</p> <code>0</code> <code>cap</code> <code>(NONE, NGON, FANS)</code> <p>How to fill the interior of the circle. Default is 'NONE'.</p> <code>'NONE'</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the circle. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the circle.</p> Notes <ul> <li><code>cap='NONE'</code>: returns only the ring of edges.</li> <li><code>cap='NGON'</code>: fills the circle with a polygon face.</li> <li><code>cap='FANS'</code>: fills the circle with a fan of triangles around a central point.</li> <li>UV coordinates are generated with <code>disk_uv_map</code>.</li> <li>Fan topology is generated with <code>fans_corners</code>.</li> </ul> <p>Examples:</p> <p>Create an open circle with 32 segments:</p> <pre><code>circle = Mesh.circle(radius=1, segments=32, cap='NONE')\n</code></pre> <p>Create a filled disk using an n-gon:</p> <pre><code>circle = Mesh.circle(radius=2, segments=24, cap='NGON')\n</code></pre> <p>Create a filled disk with triangle fans:</p> <pre><code>circle = Mesh.circle(radius=1, segments=16, cap='FANS')\n</code></pre> See Also <p><code>disk</code> :     Equivalent method for creating disks (default <code>cap='NGON'</code>). <code>disk_uv_map</code> :     Generates UV coordinates for circular caps. <code>fans_corners</code> :     Generates corner topology for triangle fans.</p> <p>Caution: When using <code>cap='FANS'</code>, a new center vertex is added.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.clear_geometry","title":"clear_geometry","text":"<pre><code>clear_geometry()\n</code></pre> <p>Clear the geometry by deleting all geometric content.</p> <p>This method clears the points, corners, faces, and edges collections, effectively removing all geometric data from the mesh.</p> <p>Note:     The materials list associated with the mesh remains unchanged.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.cone","title":"cone  <code>classmethod</code>","text":"<pre><code>cone(vertices=32, side_segments=1, fill_segments=1, radius_top=0, radius_bottom=1, depth=2, fill_type='NGON', materials=None)\n</code></pre> <p>Create a cone (or cylinder) mesh.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>int</code> <p>Number of vertices around the circumference. Default is 32.</p> <code>32</code> <code>side_segments</code> <code>int</code> <p>Number of subdivisions along the vertical side edges. Default is 1 (no subdivision).</p> <code>1</code> <code>fill_segments</code> <code>int</code> <p>Number of concentric circles added to the caps. Currently unused. Default is 1.</p> <code>1</code> <code>radius_top</code> <code>float</code> <p>Radius of the top face. Default is 0 (cone).</p> <code>0</code> <code>radius_bottom</code> <code>float</code> <p>Radius of the bottom face. Default is 1.</p> <code>1</code> <code>depth</code> <code>float</code> <p>Height of the cone along the Z axis. Default is 2.</p> <code>2</code> <code>fill_type</code> <code>(NGON, FANS, NONE)</code> <p>Type of filling for the top and bottom caps: - <code>'NGON'</code>: fill with n-gons. - <code>'FANS'</code>: fill with triangle fans. - <code>'NONE'</code>: no cap filling. Default is <code>'NGON'</code>.</p> <code>'NGON'</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the cone.</p> Notes <ul> <li>If both <code>radius_top</code> and <code>radius_bottom</code> are zero, the result is an empty mesh.</li> <li>Internally calls <code>bl_cone</code> with <code>cap_ends</code> and <code>cap_tris</code> derived from <code>fill_type</code>.</li> <li>UVs are generated automatically by Blender's cone operator.</li> </ul> <p>Examples:</p> <p>Create a simple cone of height 2 and base radius 1:</p> <pre><code>cone = Mesh.cone(vertices=32, radius_top=0, radius_bottom=1, depth=2)\n</code></pre> <p>Create a cylinder with 16 vertices and subdivided sides:</p> <pre><code>cylinder = Mesh.cone(vertices=16, radius_top=1, radius_bottom=1,\n                    depth=3, side_segments=3)\n</code></pre> <p>Create a cone with triangle fan caps:</p> <pre><code>cone = Mesh.cone(vertices=24, radius_top=0, radius_bottom=2,\n                depth=4, fill_type='FANS')\n</code></pre> See Also <p><code>bl_cone</code> :     Low-level constructor for cones and cylinders. <code>bl_circle</code> :     For creating circle primitives with optional triangle fan filling.</p> <p>Note: Use <code>fill_type='NONE'</code> to create an open-ended cone or cylinder.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.cube","title":"cube  <code>classmethod</code>","text":"<pre><code>cube(size=2, materials=None)\n</code></pre> <p>Create a cube mesh.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>float or array-like of shape (3,)</code> <p>Size of the cube. If a single float is given, the cube is uniform in all dimensions. If an array of three floats is given, it specifies the size along the X, Y, and Z axes. Default is 2.</p> <code>2</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the cube. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the cube.</p> Notes <ul> <li>The cube is created centered at the origin with side length <code>size</code>.</li> <li>UV coordinates are assigned so that all six faces are unwrapped into a cross-like layout.</li> </ul> <p>Examples:</p> <p>Create a default cube of size 2:</p> <pre><code>cube = Mesh.cube()\n</code></pre> <p>Create a cube of size 5:</p> <pre><code>cube = Mesh.cube(size=5)\n</code></pre> <p>Create a rectangular box of dimensions (2, 3, 4):</p> <pre><code>box = Mesh.cube(size=(2, 3, 4))\n</code></pre> See Also <p><code>Mesh</code> :     The mesh class used to construct and manage geometry.</p> <p>Note: The cube is centered at the origin and scaled by <code>size/2</code> after construction.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.cylinder","title":"cylinder  <code>classmethod</code>","text":"<pre><code>cylinder(vertices=32, side_segments=1, radius=1, depth=2, fill_type='NGON', materials=None)\n</code></pre> <p>Create a cylinder mesh.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>int</code> <p>Number of vertices around the circumference. Default is 32.</p> <code>32</code> <code>side_segments</code> <code>int</code> <p>Number of subdivisions along the vertical side edges. Default is 1 (no subdivision).</p> <code>1</code> <code>radius</code> <code>float</code> <p>Radius of both the top and bottom faces. Default is 1.</p> <code>1</code> <code>depth</code> <code>float</code> <p>Height of the cylinder along the Z axis. Default is 2.</p> <code>2</code> <code>fill_type</code> <code>(NGON, FANS, NONE)</code> <p>Type of filling for the top and bottom caps: - <code>'NGON'</code>: fill with n-gons. - <code>'FANS'</code>: fill with triangle fans. - <code>'NONE'</code>: no cap filling. Default is <code>'NGON'</code>.</p> <code>'NGON'</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the cylinder.</p> Notes <ul> <li>Internally calls <code>bl_cone</code> with <code>radius1 = radius2 = radius</code>.</li> <li>UVs are generated automatically by Blender's cone operator.</li> </ul> <p>Examples:</p> <p>Create a default cylinder of radius 1 and height 2:</p> <pre><code>cyl = Mesh.cylinder()\n</code></pre> <p>Create a cylinder with 64 vertices and 4 vertical subdivisions:</p> <pre><code>cyl = Mesh.cylinder(vertices=64, side_segments=4, radius=2, depth=5)\n</code></pre> <p>Create an open cylinder without caps:</p> <pre><code>cyl = Mesh.cylinder(radius=1, depth=3, fill_type='NONE')\n</code></pre> See Also <p><code>bl_cone</code> :     Low-level constructor for cones and cylinders. <code>cone</code> :     Generalized method for cones and cylinders.</p> <p>Note: This method is a convenience wrapper for <code>bl_cone</code> with equal top and bottom radii.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.delete_faces","title":"delete_faces","text":"<pre><code>delete_faces(selection)\n</code></pre> <p>Delete only the selected faces from the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool</code> <p>Indices or boolean mask specifying which faces to delete.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Modifies the mesh in place. Returns <code>None</code>.</p> See Also <p><code>delete_loops</code> :     Method used internally to remove the corners and faces. <code>corners</code> :     Corner array of the mesh, used to identify face connectivity.</p> <p>Warning: This function permanently deletes faces and their associated corners. Handle undo/history in Blender if needed.</p> <p>Note: Only faces are removed. Edges and vertices remain in the mesh unless explicitly deleted by other operations.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.delete_vertices","title":"delete_vertices","text":"<pre><code>delete_vertices(points=None, faces=None, edges=None)\n</code></pre> <p>Delete vertices from the mesh, with optional selection by points, faces, or edges.</p> <p>A vertex is deleted if it is explicitly listed in <code>points</code>, or if it belongs to any of the given <code>faces</code> or <code>edges</code>.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like of int or bool</code> <p>Vertex indices (or boolean mask) specifying which vertices to delete directly.</p> <code>None</code> <code>faces</code> <code>array-like of int or bool</code> <p>Face indices (or boolean mask). Any vertex belonging to these faces will be deleted.</p> <code>None</code> <code>edges</code> <code>array-like of int or bool</code> <p>Edge indices (or boolean mask). Any vertex belonging to these edges will be deleted.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>Modifies the mesh in place. Returns <code>None</code>.</p> Notes <ul> <li>At least one of <code>points</code>, <code>faces</code>, or <code>edges</code> must be provided, otherwise the function does nothing.</li> <li>The deletion is executed using <code>bmesh.ops.delete</code> with <code>context='VERTS'</code>.</li> </ul> <p>Examples:</p> <p>Delete specific vertices:</p> <pre><code>obj.delete_vertices(points=[0, 1, 2])\n</code></pre> <p>Delete all vertices belonging to certain faces:</p> <pre><code>obj.delete_vertices(faces=[10, 11])\n</code></pre> <p>Delete all vertices belonging to certain edges:</p> <pre><code>obj.delete_vertices(edges=[5, 6, 7])\n</code></pre> See Also <p><code>bmesh.ops.delete</code> :     Blender BMesh operator used for deleting geometry.</p> <p>Warning: This function permanently removes vertices and any connected geometry (edges, faces). Handle undo/history in Blender if needed.</p> <p>Note: If multiple selectors (<code>points</code>, <code>faces</code>, <code>edges</code>) are provided, the union of all matched vertices will be deleted.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.disk","title":"disk  <code>classmethod</code>","text":"<pre><code>disk(radius=1, segments=16, fill_segments=0, cap='NGON', materials=None)\n</code></pre> <p>Create a disk mesh.</p> <p>This is equivalent to <code>circle</code>, but with <code>cap='NGON'</code> as the default filling mode.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the disk. Default is 1.</p> <code>1</code> <code>segments</code> <code>int</code> <p>Number of segments (vertices) around the disk. Default is 16.</p> <code>16</code> <code>fill_segments</code> <code>int</code> <p>Number of internal subdivisions (concentric circles). Default is 0 (single n-gon when <code>cap='NGON'</code>).</p> <code>0</code> <code>cap</code> <code>(NONE, NGON, FANS)</code> <p>How to fill the interior of the disk. Default is 'NGON'.</p> <code>'NONE'</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the disk. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the disk.</p> <p>Examples:</p> <p>Create a default disk of radius 2 with 32 segments:</p> <pre><code>disk = Mesh.disk(radius=2, segments=32)\n</code></pre> <p>Create a disk filled with triangle fans:</p> <pre><code>disk = Mesh.disk(radius=1, segments=16, cap='FANS')\n</code></pre> See Also <p><code>circle</code> :     General method for circle/disk creation with customizable cap. <code>disk_uv_map</code> :     Generates UV coordinates for circular caps. <code>fans_corners</code> :     Generates corner topology for triangle fans.</p> <p>Note: This method is a shorthand for <code>circle(..., cap='NGON')</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.dual","title":"dual","text":"<pre><code>dual(center='median')\n</code></pre> <p>Construct the dual mesh: one vertex per original face, and one face per original vertex (linking adjacent face-centers around that vertex).</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>(median, bounds, weighted)</code> <p>Method to compute the position of each dual vertex (i.e., the center of the corresponding original face): - <code>'median'</code>: face median center (<code>BMFace.calc_center_median</code>). - <code>'bounds'</code>: face bounds center (<code>BMFace.calc_center_bounds</code>). - <code>'weighted'</code>: area-weighted center (<code>BMFace.calc_center_median_weighted</code>). Default is <code>'median'</code>.</p> <code>'median'</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>The dual mesh, where: - points = centers of original faces, - faces  = polygons formed by chaining the adjacent original faces around each original vertex.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>center</code> is not one of <code>{'median', 'bounds', 'weighted'}</code>.</p> Notes <ul> <li>For each original face <code>f</code>, a dual vertex is computed using the chosen center method and stored at index <code>f.index</code>.</li> <li>For each original vertex <code>v</code>, its incident faces are ordered by walking across <code>v</code>\u2019s incident edges (each with exactly two linked faces) to form a cyclic sequence of face indices; this ordered loop becomes a polygon in the dual.</li> <li>Non-manifold or boundary configurations (edges with a number of linked faces different from 2) are skipped for that vertex; no dual face is created in such cases.</li> </ul> <p>Examples:</p> <p>Build the dual using area-weighted face centers:</p> <pre><code>d = mesh.dual(center='weighted')\n</code></pre> <p>Build the dual with bounds centers:</p> <pre><code>d = mesh.dual(center='bounds')\n</code></pre> See Also <p><code>triangulate</code> :     Triangulation can improve robustness before dualization. <code>remove_doubles</code> :     Helpful for cleaning geometry prior to constructing the dual.</p> <p>Caution: On meshes with boundaries or non-manifold edges, some vertices may not yield a valid cyclic ordering of adjacent faces; those dual faces are omitted.</p> <p>Note: Dualization does not, in general, invert perfectly (i.e., the dual of the dual is not guaranteed to reproduce the original mesh), especially in the presence of boundaries or irregular valences.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_faces","title":"extrude_faces","text":"<pre><code>extrude_faces(selection, offset=None, scale=1.0)\n</code></pre> <p>Extrude individual faces by duplicating them, optionally displacing them by <code>offset</code>, and connecting side faces.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Indices (or mask) of faces to extrude. If <code>None</code>, all faces are extruded.</p> required <code>offset</code> <code>(array - like, shape(3) or (N, 3))</code> <p>Extrusion vector(s). A single vector is broadcast to all faces. If <code>None</code>, each face is extruded along its own normal.</p> <code>None</code> <code>scale</code> <code>float</code> <p>Scale factor applied to <code>offset</code> (or to the face normal if <code>offset=None</code>). Default is 1.0.</p> <code>1.0</code> <code>dissolve</code> <code>bool</code> <p>Not implemented in this version. Placeholder for removing the starting faces after extrusion.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with two keys: - <code>'top'</code>: indices of the extruded (displaced) faces. - <code>'side'</code>: indices of the side faces connecting the original and new faces.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>offset</code> cannot be broadcast to shape <code>(len(faces), 3)</code>.</p> <code>AssertionError</code> <p>If a side edge of an extruded face does not have exactly two linked faces.</p> Notes <ul> <li>Uses <code>bmesh.ops.extrude_discrete_faces</code> to duplicate each selected face independently.</li> <li>If <code>offset</code> is <code>None</code>, displacement is along each face's local normal.</li> <li>Side faces are identified by checking edges linked to the extruded faces.</li> </ul> <p>Examples:</p> <p>Extrude all faces along their normals:</p> <pre><code>res = Mesh.extrude_faces(selection=None, scale=0.2)\n</code></pre> <p>Extrude a subset of faces by a fixed offset:</p> <pre><code>res = Mesh.extrude_faces(selection=[0, 2, 5], offset=(0, 0, 1))\n</code></pre> <p>Extrude faces with per-face offsets:</p> <pre><code>offs = np.random.randn(len(sel), 3) * 0.1\nres = Mesh.extrude_faces(selection=sel, offset=offs)\n</code></pre> See Also <p><code>extrude_vertices</code> :     Extrude isolated vertices. <code>extrude_loop</code> :     Extrude a vertex loop into a quad strip.</p> <p>Caution: If <code>offset</code> is given per-face, its length must match the number of extruded faces or broadcasting will fail.</p> <p>Note: Side face indices may be repeated if multiple extrusions share edges.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_loop","title":"extrude_loop","text":"<pre><code>extrude_loop(loop, offset, close=False, clockwise=False, **attributes)\n</code></pre> <p>Extrude a loop of vertices by duplicating the loop, offsetting it, and creating a quad strip between the original and the offset loop.</p> <p>Parameters:</p> Name Type Description Default <code>loop</code> <code>array-like of int</code> <p>Vertex indices defining the loop to extrude. Must contain at least 2 vertices.</p> required <code>offset</code> <code>(array - like, shape(3) or (N, 3))</code> <p>Extrusion vector(s). A single 3D vector is broadcast to all vertices in <code>loop</code>, or provide one vector per vertex (N == len(loop)).</p> required <code>close</code> <code>bool</code> <p>If True, treats the input as a closed loop and connects the last vertex back to the first when building side quads. Default is False.</p> <code>False</code> <code>clockwise</code> <code>bool</code> <p>Controls the orientation (winding) of the generated faces and the UV layout. Default is False.</p> <code>False</code> <code>**attributes</code> <code>dict</code> <p>Extra attributes intended for the new geometry (see Caution).</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary describing the created geometry as returned by <code>add_geometry</code>. Contains at least: - <code>'points'</code>: indices of the duplicated (offset) vertices. - <code>'corners'</code>: indices of the generated quad strip corners. - <code>'faces'</code>: face arity (4 for quads).</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>offset</code> is neither a single <code>(3,)</code> vector nor an array of shape <code>(len(loop), 3)</code>.</p> Notes <ul> <li>New vertices are computed as <code>points[loop] + offset</code> (with broadcasting if <code>offset</code> is a single vector).</li> <li>Side faces are constructed using the topology from <code>grid_corners</code> with two rows (original and offset loop).</li> <li>UVs for the side strip are generated by <code>grid_uv_map</code> with matching parameters.</li> </ul> <p>Examples:</p> <p>Extrude an open loop along a single vector:</p> <pre><code>new = Mesh.extrude_loop(loop, offset=(0, 0, 1), close=False)\n</code></pre> <p>Extrude a closed loop with per-vertex offsets and flipped winding:</p> <pre><code>offs = np.random.randn(len(loop), 3) * 0.02\nnew = Mesh.extrude_loop(loop, offset=offs, close=True, clockwise=True)\n</code></pre> See Also <p><code>extrude_vertices</code> :     Extrude isolated vertices with edges to their duplicates. <code>add_geometry</code> :     Adds the new points/corners/faces and returns their indices. <code>grid_corners</code> :     Builds the quad topology of the side strip. <code>grid_uv_map</code> :     Generates UVs for the side strip.</p> <p>Caution: <code>offset</code> must be either a single <code>(3,)</code> vector or an array of shape <code>(len(loop), 3)</code>. Any other shape will raise an error.</p> <p>Caution: The <code>attributes</code> kwargs are currently not forwarded to <code>add_geometry</code> in this implementation. If you need them applied, pass them through explicitly in the call to <code>add_geometry</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_region","title":"extrude_region","text":"<pre><code>extrude_region(selection, offset=(0, 0, 1), dissolve=False)\n</code></pre> <p>Extrude a connected face region, translate the new geometry by <code>offset</code>, and optionally dissolve the original faces.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Indices (or mask) of faces to extrude. If <code>None</code>, all faces are used.</p> required <code>offset</code> <code>array-like of float, shape (3,)</code> <p>Translation vector applied to the newly created vertices of the region. Default is (0, 0, 1).</p> <code>(0, 0, 1)</code> <code>dissolve</code> <code>bool</code> <p>If True, delete the original (pre-extrusion) faces after the region has been extruded. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with two keys: - <code>'top'</code>: indices of the newly extruded faces (translated region). - <code>'side'</code>: indices of the side faces that connect original and new faces.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If a side edge of an extruded face does not have exactly two linked faces (non-manifold condition).</p> Notes <ul> <li>Region extrusion is performed via <code>bmesh.ops.extrude_face_region</code>, then the new vertices are moved using <code>bmesh.ops.translate</code>.</li> <li>Side faces are discovered by scanning the edges of the extruded faces and collecting the adjacent face opposite to each extruded face.</li> </ul> <p>Examples:</p> <p>Extrude a region upward and keep the original faces:</p> <pre><code>res = Mesh.extrude_region(selection=[0, 1, 2], offset=(0, 0, 0.2), dissolve=False)\n</code></pre> <p>Extrude a region and dissolve the starting faces:</p> <pre><code>res = Mesh.extrude_region(selection=mask, offset=(0.1, 0, 0), dissolve=True)\n</code></pre> See Also <p><code>extrude_faces</code> :     Extrude faces individually (discrete), not as a connected region. <code>extrude_loop</code> :     Create a quad strip by offsetting a vertex loop. <code>extrude_vertices</code> :     Duplicate and connect selected vertices.</p> <p>Caution: <code>offset</code> must be a 3D vector. Non-3D inputs may cause the translation operator to fail.</p> <p>Note: With <code>dissolve=True</code>, the original faces are removed, leaving only the extruded shell.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_vertices","title":"extrude_vertices","text":"<pre><code>extrude_vertices(selection, offset, **attributes)\n</code></pre> <p>Extrude individual vertices by creating new points displaced by <code>offset</code> and connecting each original vertex to its duplicate with an edge.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Vertex indices or boolean mask selecting the vertices to extrude. If <code>None</code>, all vertices are extruded.</p> required <code>offset</code> <code>(array - like, shape(3) or (N, 3))</code> <p>Extrusion vector(s). Can be a single 3D vector applied to every selected vertex, or an array of vectors with one per selected vertex.</p> required <code>**attributes</code> <code>dict</code> <p>Optional attributes to attach to the created geometry (forwarded to <code>add_geometry</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary describing the created geometry as returned by <code>add_geometry</code>. Contains at least: - <code>'points'</code>: indices of newly added vertices. - <code>'edges'</code>: indices of newly added edges.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>offset</code> is neither a single <code>(3,)</code> vector nor an array of shape <code>(len(loop), 3)</code>.</p> Notes <ul> <li>New vertices are positioned at <code>points[selection] + offset</code>.</li> <li>One edge is created between each original vertex and its newly created counterpart using <code>edges_between</code>.</li> </ul> <p>Examples:</p> <p>Extrude all vertices by (0, 0, 1):</p> <pre><code>added = Mesh.extrude_vertices(selection=None, offset=(0, 0, 1))\n</code></pre> <p>Extrude a subset with per-vertex offsets:</p> <pre><code>sel = np.array([0, 2, 5, 7])\noffs = np.random.randn(len(sel), 3) * 0.1\nadded = Mesh.extrude_vertices(selection=sel, offset=offs)\n</code></pre> See Also <p><code>add_geometry</code> :     Adds new points/edges/faces and returns their indices. <code>edges_between</code> :     Builds edge pairs between two index arrays of equal length.</p> <p>Caution: When <code>offset</code> is an array, its length must match the number of selected vertices.</p> <p>Note: This operation creates only points and edges. Faces are not generated automatically.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.faces_neighbors","title":"faces_neighbors","text":"<pre><code>faces_neighbors()\n</code></pre> <p>Compute the neighboring faces for each face, defined as faces sharing at least one edge.</p> <p>Returns:</p> Type Description <code>list of list of int</code> <p>For each face (by index), a list of indices of adjacent faces.</p> Notes <ul> <li>Each face\u2019s neighbors are determined by scanning its incident edges and collecting the two faces linked to each edge.</li> <li>The current face index is excluded from its own neighbor list.</li> <li>Non-manifold edges (with more or fewer than two linked faces) are not expected; if present, results may be incomplete or inconsistent.</li> </ul> <p>Examples:</p> <p>Get adjacency information for all faces:</p> <pre><code>neighbors = mesh.faces_neighbors()\nfor i, ns in enumerate(neighbors):\n    print(f\"Face {i} neighbors: {ns}\")\n</code></pre> <p>Note: The output is a Python list of lists (not a NumPy array).</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.fill_cap","title":"fill_cap","text":"<pre><code>fill_cap(loop, mode='NGON', center=None, segments=1, clockwise=False, **attributes)\n</code></pre> <p>Fill a cap between vertices forming a loop.</p> <p>Supports two modes: - NGON: creates a single n-gon face from the loop. No center point is required. - FANS: creates a fan of triangles around a center point. The center can be: * <code>None</code>: automatically computed as the centroid of the loop. * <code>int</code>: the index of an existing vertex to use as center. * <code>array-like</code>: explicit coordinates of the center, which will be added as a new vertex.</p> <p>Parameters:</p> Name Type Description Default <code>loop</code> <code>array-like of int</code> <p>The vertex indices defining the loop.</p> required <code>mode</code> <code>(NGON, FANS)</code> <p>Fill mode to use. Default is 'NGON'.</p> <code>'NGON'</code> <code>center</code> <code>int or array - like or None</code> <p>Center of the cap (used only in 'FANS' mode). - <code>None</code>: computed centroid. - <code>int</code>: index of an existing vertex. - array-like: coordinates of a new vertex.</p> <code>None</code> <code>segments</code> <code>int</code> <p>Number of radial subdivisions for FANS mode. Must be &gt;= 1. Default is 1 (no subdivision).</p> <code>1</code> <code>clockwise</code> <code>bool</code> <p>Whether the loop is ordered clockwise. Default is False.</p> <code>False</code> <code>**attributes</code> <code>dict</code> <p>Additional attributes to add to the mesh (passed to <code>add_geometry</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the newly added geometry, as returned by <code>add_geometry</code>. Includes at least keys for 'faces' and 'corners'. In FANS mode, also includes the added 'points' if a new center is created.</p> Notes <ul> <li>In 'NGON' mode, a UV map is generated using <code>disk_uv_map</code>.</li> <li>In 'FANS' mode, the fan topology is created with <code>fans_corners</code> and UVs are generated with <code>disk_uv_map</code>.</li> <li>If <code>segments &gt; 1</code> in FANS mode, radial edges are subdivided using <code>split_edges</code>.</li> </ul> <p>Examples:</p> <p>Fill a loop with an n-gon:</p> <pre><code>obj.fill_cap(loop, mode='NGON')\n</code></pre> <p>Fill a loop with a triangle fan around an automatically computed center:</p> <pre><code>obj.fill_cap(loop, mode='FANS')\n</code></pre> <p>Fill a loop with a fan using an existing vertex as the center and add 3 subdivisions:</p> <pre><code>obj.fill_cap(loop, mode='FANS', center=42, segments=3)\n</code></pre> See Also <p><code>add_geometry</code> :     Method used to add the created geometry to the mesh. <code>split_edges</code> :     Used to subdivide radial edges in FANS mode. <code>disk_uv_map</code> :     Generates UV coordinates for circular caps. <code>fans_corners</code> :     Generates corner topology for FANS mode.</p> <p>Warning: This function modifies the mesh in place and may create new vertices, faces, and edges.</p> <p>Caution: In FANS mode, if <code>center=None</code>, a new vertex is added at the centroid of the loop.</p> <p>Note: The <code>segments</code> parameter only applies to FANS mode; NGON mode always produces a single polygon face.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d)\n</code></pre> <p>Create a Mesh instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Dictionary containing mesh data with keys 'materials', 'points', 'corners', 'faces', and 'edges'.</p> required <p>Returns:</p> Type Description <code>Mesh</code> <p>A new Mesh instance initialized with the data from the dictionary.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_mesh","title":"from_mesh  <code>classmethod</code>","text":"<pre><code>from_mesh(other, points=None, faces=None, edges=None)\n</code></pre> <p>Create a copy of a Mesh object, optionally excluding specified points, faces, or edges.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Mesh</code> <p>The source Mesh object to copy.</p> required <code>points</code> <code>array-like of int</code> <p>Indices of points to exclude from the copy.</p> <code>None</code> <code>faces</code> <code>array-like of int</code> <p>Indices of faces to exclude from the copy.</p> <code>None</code> <code>edges</code> <code>array-like of int</code> <p>Indices of edges to exclude from the copy.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new Mesh instance copied from the source, with specified elements excluded.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_mesh_data","title":"from_mesh_data  <code>classmethod</code>","text":"<pre><code>from_mesh_data(data)\n</code></pre> <p>Initialize the geometry from a Blender Mesh data.</p> <p>This method creates and returns an instance of the mesh class initialized with vertices, edges, faces, corners, materials, and attributes extracted from the provided Blender mesh data.</p> <p>Args:     data: Blender mesh data or object that can be processed           by the blender.get_mesh function to obtain a Blender Mesh instance.</p> <p>Returns:     An instance of the mesh class initialized with the geometry     and attributes from the Blender Mesh.</p> <p>Raises:     ImportError: If the local blender module cannot be imported.     Any exceptions raised by blender.get_mesh if the data is invalid.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_model","title":"from_model  <code>classmethod</code>","text":"<pre><code>from_model(model, materials=None)\n</code></pre> <p>Create a Mesh instance from various types of input models.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str, bpy.types.Object, dict, Mesh, or bpy.types.Mesh</code> <p>The input model to create the Mesh from. It can be: - A string or Blender object to be evaluated and converted. - A dictionary representing the mesh data. - An existing Mesh instance. - A Blender Mesh data block.</p> required <code>materials</code> <code>list or None</code> <p>Materials to associate with the mesh (currently unused in this method).</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>The created Mesh instance based on the input model.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the type of the model is not supported.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_object","title":"from_object  <code>classmethod</code>","text":"<pre><code>from_object(obj, evaluated=False)\n</code></pre> <p>Create a Mesh instance from an existing Blender object.</p> <p>This method initializes a mesh from a Blender object, optionally using the evaluated version of the object (i.e., after applying modifiers).</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str or Object</code> <p>The Blender object or its name from which to create the mesh.</p> required <code>evaluated</code> <code>bool</code> <p>If True, use the evaluated object with modifiers applied. If False, use the raw mesh data. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new Mesh instance created from the specified Blender object.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the local blender module cannot be imported.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_islands","title":"get_islands","text":"<pre><code>get_islands()\n</code></pre> <p>Compute connected components of faces (islands) and assign an island ID to each face.</p> <p>Returns:</p> Type Description <code>ndarray of int, shape (n_faces,)</code> <p>Array of island IDs, one per face. Faces in the same connected component share the same integer ID. Empty mesh returns an empty list.</p> Notes <ul> <li>Islands are defined as groups of faces connected through shared edges.</li> <li>A breadth-first search (BFS) is used to traverse each connected component.</li> <li>IDs are assigned sequentially starting from 0.</li> </ul> <p>Examples:</p> <p>Get island IDs for all faces:</p> <pre><code>ids = mesh.get_islands()\nprint(\"Unique islands:\", np.unique(ids))\n</code></pre> <p>Map faces by island:</p> <pre><code>ids = mesh.get_islands()\nfor island_id in np.unique(ids):\n    faces = np.where(ids == island_id)[0]\n    print(f\"Island {island_id}: faces {faces}\")\n</code></pre> <p>Note: Non-manifold meshes are still handled, but faces that share only a vertex (not an edge) are considered separate islands.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_material_index","title":"get_material_index","text":"<pre><code>get_material_index(mat_name)\n</code></pre> <p>Return the index of a material name.</p> <p>If the material doesn't exist, it is created</p> Arguments <pre><code>- mat_name (str) : material name\n</code></pre> <p>Returns:</p> Type Description <code>    - int : index of the material name in the materials list</code>"},{"location":"api/mesh/#npblender.mesh.Mesh.grid","title":"grid  <code>classmethod</code>","text":"<pre><code>grid(size_x=1, size_y=1, vertices_x=3, vertices_y=3, materials=None)\n</code></pre> <p>Create a rectangular grid mesh.</p> <p>The grid is constructed in the XY plane with indexing set to <code>'ij'</code>, meaning the generated arrays have shape <code>(vertices_x, vertices_y)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>size_x</code> <code>float</code> <p>Size of the grid along the X axis. Default is 1.</p> <code>1</code> <code>size_y</code> <code>float</code> <p>Size of the grid along the Y axis. Default is 1.</p> <code>1</code> <code>vertices_x</code> <code>int</code> <p>Number of vertices along the X axis. Must be &gt;= 2. Default is 3.</p> <code>3</code> <code>vertices_y</code> <code>int</code> <p>Number of vertices along the Y axis. Must be &gt;= 2. Default is 3.</p> <code>3</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the grid. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the rectangular grid.</p> Notes <ul> <li>The grid is created with <code>'ij'</code> indexing, so coordinates follow NumPy's <code>meshgrid(..., indexing='ij')</code> convention.</li> <li>UV coordinates are generated using <code>grid_uv_map</code>.</li> <li>The grid topology is built using <code>grid_corners</code>.</li> </ul> <p>Examples:</p> <p>Create a 2x2 grid with 10 vertices along X and 5 along Y:</p> <pre><code>grid = Mesh.grid(size_x=2, size_y=2, vertices_x=10, vertices_y=5)\n</code></pre> <p>Create a square grid of size 5 with default vertex count:</p> <pre><code>grid = Mesh.grid(size_x=5, size_y=5)\n</code></pre> See Also <p><code>grid_corners</code> :     Helper for constructing the corner topology of the grid. <code>grid_uv_map</code> :     Generates UV coordinates for a regular grid.</p> <p>Important: The grid is always created with <code>'ij'</code> indexing (shape = <code>(vertices_x, vertices_y)</code>).</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.icosphere","title":"icosphere  <code>classmethod</code>","text":"<pre><code>icosphere(radius=1, subdivisions=2, materials=None)\n</code></pre> <p>Create an icosphere mesh.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the icosphere. Default is 1.</p> <code>1</code> <code>subdivisions</code> <code>int</code> <p>Number of recursive subdivisions applied to the base icosahedron. Higher values yield smoother spheres. Clamped to a maximum of 10. Default is 2.</p> <code>2</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the icosphere. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the icosphere.</p> Notes <ul> <li>The icosphere is created using <code>bmesh.ops.create_icosphere</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> <li>Unlike a UV sphere, an icosphere has more uniform vertex distribution, making it suitable for certain simulation and subdivision tasks.</li> <li>Subdivisions are internally capped at 10 for performance reasons.</li> </ul> <p>Examples:</p> <p>Create a default icosphere of radius 1 with 2 subdivisions:</p> <pre><code>ico = Mesh.icosphere()\n</code></pre> <p>Create a larger icosphere with 4 subdivisions:</p> <pre><code>ico = Mesh.icosphere(radius=3, subdivisions=4)\n</code></pre> See Also <p><code>uvsphere</code> :     Sphere primitive based on UV parameterization. <code>bmesh.ops.create_icosphere</code> :     BMesh operator used for creating icospheres.</p> <p>Note: Use <code>uvsphere</code> when you require consistent UV mapping, and <code>icosphere</code> for uniform tessellation.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.inset_faces","title":"inset_faces","text":"<pre><code>inset_faces(selection, thickness=0.1, depth=0.0, use_even_offset=True, use_relative_offset=False)\n</code></pre> <p>Inset selected faces individually, optionally adding depth (local extrusion).</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Indices (or mask) of faces to inset. If <code>None</code>, all faces are used.</p> required <code>thickness</code> <code>float</code> <p>Inset thickness applied per face. Default is 0.1.</p> <code>0.1</code> <code>depth</code> <code>float</code> <p>Local extrusion depth along each face normal. Default is 0.0.</p> <code>0.0</code> <code>use_even_offset</code> <code>bool</code> <p>Keep thickness consistent across faces (even offset). Default is True.</p> <code>True</code> <code>use_relative_offset</code> <code>bool</code> <p>Scale thickness relative to face size. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with: - <code>'top'</code>: indices of the original (selected) faces. - <code>'side'</code>: indices of the new faces created by the inset operation (typically the rim/side faces around each inset).</p> Notes <ul> <li>Implementation uses <code>bmesh.ops.inset_individual</code>.</li> <li>The <code>'top'</code> entry mirrors the input selection; <code>'side'</code> comes from <code>d[\"faces\"]</code> returned by the BMesh operator.</li> </ul> <p>Examples:</p> <p>Inset a set of faces with even offset:</p> <pre><code>res = Mesh.inset_faces(selection=[0, 2, 5], thickness=0.05, depth=0.0)\n</code></pre> <p>Inset all faces with relative offset and a small depth:</p> <pre><code>res = Mesh.inset_faces(selection=None, thickness=0.02,\n                    depth=0.01, use_relative_offset=True)\n</code></pre> See Also <p><code>extrude_faces</code> :     Extrude faces discretely instead of insetting. <code>extrude_region</code> :     Extrude connected face regions.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.join","title":"join","text":"<pre><code>join(*others)\n</code></pre> <p>Join other Mesh instances into this mesh.</p> <p>This method appends the geometry and materials of the given meshes to the current mesh, updating indices to maintain consistency.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Mesh</code> <p>One or more Mesh instances to be joined with the current mesh.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>self</code> <code>Mesh</code> <p>The updated mesh instance with joined geometry.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other, **kwargs)\n</code></pre> <p>Capture the attributes from another geometry.</p> <p>Other can be a different geometry, in that case, only domains with the same name are captured. kwargs allows to filter the domains to capture:</p> <pre><code>mesh.join_attributes(other_mesh, faces=False)\nmesh.join_attributes(curve)\n</code></pre> <p>Returns:     - self</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.join_geometry","title":"join_geometry","text":"<pre><code>join_geometry(points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs)\n</code></pre> <p>Join geometry defined by components into the current mesh.</p> <p>This method creates a new independent mesh from the provided geometry components (points, corners, faces, edges) which do not refer to existing vertices. The new mesh is then joined to the current mesh instance.</p> <p>To add geometry using existing vertices, see <code>Mesh.add_geometry</code>.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>iterable</code> <p>Iterable of points (vertices) to add to the mesh.</p> <code>None</code> <code>corners</code> <code>iterable</code> <p>Iterable of corner indices defining the mesh topology.</p> <code>None</code> <code>faces</code> <code>iterable</code> <p>Iterable of faces defined by indices of corners.</p> <code>None</code> <code>edges</code> <code>iterable</code> <p>Iterable of edges defined by indices of vertices.</p> <code>None</code> <code>safe_mode</code> <code>bool</code> <p>Flag to enable safe mode operations (currently unused).</p> <code>False</code> <code>**attrs</code> <code>dict</code> <p>Additional attributes to be passed to the geometry addition.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>self</code> <code>Mesh</code> <p>The current mesh instance with the new geometry joined.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.line","title":"line  <code>classmethod</code>","text":"<pre><code>line(start=(0, 0, 0), end=(0, 0, 1), segments=1, materials=None)\n</code></pre> <p>Create a mesh representing a straight line (or multiple lines) subdivided into segments.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>array-like of float, shape (..., 3)</code> <p>Coordinates of the start point(s). Can be a single 3D vector or an array of multiple vectors. Default is (0, 0, 0).</p> <code>(0, 0, 0)</code> <code>end</code> <code>array-like of float, shape (..., 3)</code> <p>Coordinates of the end point(s). Can be a single 3D vector or an array of multiple vectors with the same shape as <code>start</code>. Default is (0, 0, 1).</p> <code>(0, 0, 1)</code> <code>segments</code> <code>int</code> <p>Number of line segments (subdivisions) between each pair of start and end points. Must be &gt;= 1. Default is 1.</p> <code>1</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the line mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the subdivided line(s).</p> Notes <ul> <li>The function interpolates <code>segments + 1</code> points between <code>start</code> and <code>end</code> using <code>np.linspace</code>.</li> <li>If <code>start</code> and <code>end</code> are arrays of shape <code>(N, 3)</code>, the method generates <code>N</code> independent polylines, each subdivided into <code>segments</code>.</li> <li>For higher-dimensional batched input, the function reshapes the grid and constructs edges using <code>col_edges</code>.</li> </ul> <p>Examples:</p> <p>Create a simple line with 5 segments between (0, 0, 0) and (0, 0, 1):</p> <pre><code>line = Mesh.line(start=(0, 0, 0), end=(0, 0, 1), segments=5)\n</code></pre> <p>Create three parallel lines defined by arrays of start and end points:</p> <pre><code>starts = np.array([[0, 0, 0],\n                [1, 0, 0],\n                [2, 0, 0]])\nends = np.array([[0, 0, 1],\n                [1, 0, 1],\n                [2, 0, 1]])\nlines = Mesh.line(start=starts, end=ends, segments=4)\n</code></pre> See Also <p><code>border_edges</code> :     Helper for constructing consecutive edges in a single polyline. <code>col_edges</code> :     Helper for constructing edges in multi-dimensional point grids.</p> <p>Note: The line mesh consists only of vertices and edges, no faces are created.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.load_models","title":"load_models  <code>staticmethod</code>","text":"<pre><code>load_models(*specs)\n</code></pre> <p>Load a geometry or geometries from specifications.</p> <p>The specs can be:     - a Blender collection     - a Blender object     - a Geometry</p> Arguments <pre><code>- specs (list of objects / collections) : the models to load\n</code></pre> <p>Returns:</p> Type Description <code>    - list of geometries</code>"},{"location":"api/mesh/#npblender.mesh.Mesh.load_object","title":"load_object  <code>staticmethod</code>","text":"<pre><code>load_object(name)\n</code></pre> <p>Load a Blender object and returns either a Mesh or a Curve.</p> Arguments <pre><code>- name (str or bpy.types.Object) : the object to load\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh or Curve</code>"},{"location":"api/mesh/#npblender.mesh.Mesh.monkey","title":"monkey  <code>classmethod</code>","text":"<pre><code>monkey(materials=None)\n</code></pre> <p>Create the famous Blender \"Suzanne\" monkey mesh.</p> <p>Parameters:</p> Name Type Description Default <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the Suzanne primitive.</p> Notes <ul> <li>The monkey head is created using <code>bmesh.ops.create_monkey</code>.</li> <li>Suzanne is often used as a test model and is considered Blender\u2019s mascot.</li> </ul> <p>Examples:</p> <p>Create a Suzanne mesh:</p> <pre><code>monkey = Mesh.monkey()\n</code></pre> See Also <p><code>bmesh.ops.create_monkey</code> :     BMesh operator used to generate the Suzanne primitive.</p> <p>Note: Suzanne is widely used as a benchmark and test object in Blender.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.multiply","title":"multiply","text":"<pre><code>multiply(count, in_place=True)\n</code></pre> <p>Duplicate the geometry.</p> <p>Multiplying is a way to efficiently duplicate the geometry a great number of times. Once duplicated, the vertices can be reshapped to address each instance individually.</p> <pre><code>count = 16\n\ncube = Mesh.Cube() * count\n\n# Shape the points as 16 blocks of 8 vertices\npoints = np.reshape(cube.points.position, (16, 8, 3))\n\n# Place the cubes in a circle\nags = np.linspace(0, 2*np.pi, count, endpoint=False)\npoints[..., 0] += 6 * np.cos(ags)[:, None]\npoints[..., 1] += 6 * np.sin(ags)[:, None]\n\ncube.to_object(\"Cubes\")\n</code></pre> Arguments <pre><code>- count (int=10) : number of instances\n- attributes (name=value) : value for named attributes\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/mesh/#npblender.mesh.Mesh.points_cloud","title":"points_cloud  <code>classmethod</code>","text":"<pre><code>points_cloud(points=None, materials=None)\n</code></pre> <p>Create a mesh containing only points at the given positions.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like of shape (N, 3)</code> <p>Coordinates of the points. If None, an empty mesh is created.</p> <code>None</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the given points.</p> Notes <ul> <li>This method does not create any edges or faces, only isolated points.</li> </ul> <p>Examples:</p> <p>Create a point cloud with three points:</p> <pre><code>pts = np.array([[0, 0, 0],\n                [1, 0, 0],\n                [0, 1, 0]])\ncloud = Mesh.points_cloud(points=pts)\n</code></pre> See Also <p><code>Mesh</code> :     The mesh class used to construct and manage geometry.</p> <p>Note: This constructor is useful for importing raw point data or initializing a mesh before adding edges and faces.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.pyramid","title":"pyramid  <code>classmethod</code>","text":"<pre><code>pyramid(size=1, materials=None)\n</code></pre> <p>Create a pyramid mesh.</p> <p>The pyramid is generated as a cone with 3 vertices at the base (a triangle) and an apex at the top.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>float</code> <p>Size of the pyramid. Determines both the base dimensions and the height. Default is 1.</p> <code>1</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the pyramid.</p> Notes <ul> <li>The base radius is scaled by <code>size * sqrt(3)/2</code> so that the pyramid has approximately unit proportions when <code>size=1</code>.</li> <li>Internally calls <code>cone</code> with <code>vertices=3</code>.</li> </ul> <p>Examples:</p> <p>Create a default pyramid of size 1:</p> <pre><code>pyramid = Mesh.pyramid()\n</code></pre> <p>Create a larger pyramid of size 5:</p> <pre><code>pyramid = Mesh.pyramid(size=5)\n</code></pre> See Also <p><code>cone</code> :     Generalized method for cones and pyramids. <code>bl_cone</code> :     Low-level constructor for cone-based primitives.</p> <p>Note: This method is equivalent to creating a triangular-based cone.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.remove_doubles","title":"remove_doubles","text":"<pre><code>remove_doubles(dist=0.001)\n</code></pre> <p>Merge duplicate vertices within a distance threshold.</p> <p>Parameters:</p> Name Type Description Default <code>dist</code> <code>float</code> <p>Maximum distance between vertices to be merged. Default is 0.001.</p> <code>0.001</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>The current mesh instance (<code>self</code>) with duplicate vertices removed.</p> Notes <ul> <li>Internally uses <code>bmesh.ops.remove_doubles</code>.</li> <li>All vertices in the mesh are considered for merging.</li> <li>Useful for cleaning geometry after operations that may generate coincident vertices (e.g., mirroring, joining, or extrusion).</li> </ul> <p>Examples:</p> <p>Remove doubles with default threshold:</p> <pre><code>mesh.remove_doubles()\n</code></pre> <p>Remove doubles with a larger threshold:</p> <pre><code>mesh.remove_doubles(dist=0.01)\n</code></pre> <p>Note: This method modifies the mesh in place and returns <code>self</code> for chaining.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.separate_faces","title":"separate_faces","text":"<pre><code>separate_faces(groups=None)\n</code></pre> <p>Split faces into isolated islands, either one per face or grouped by provided IDs.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>array-like of int, shape (n_faces,)</code> <p>Group IDs for each face. If <code>None</code>, each face is isolated as its own island. If provided, must be the same length as the number of faces.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh where faces are separated into independent islands with duplicated vertices.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>groups</code> is provided but its shape does not match <code>(n_faces,)</code>.</p> Notes <ul> <li>When <code>groups</code> is <code>None</code>, the output mesh has one disconnected island per face.</li> <li>When grouping, faces sharing the same group ID are kept together in the same island, with vertices duplicated so that each group is independent.</li> <li>Face attributes are preserved except for <code>'loop_total'</code> and <code>'loop_start'</code>.</li> </ul> <p>Examples:</p> <p>Separate every face:</p> <pre><code>islands = mesh.separate_faces()\n</code></pre> <p>Separate faces into two groups:</p> <pre><code>groups = np.array([0, 0, 1, 1, 1, 0])  # one group ID per face\nsplit = mesh.separate_faces(groups=groups)\n</code></pre> See Also <p><code>join_geometry</code> :     Utility to assemble new meshes from points, corners, faces, and attributes. <code>join</code> :     Used internally to accumulate separated islands.</p> <p>Caution: The number of groups must equal the number of faces in the mesh, otherwise a <code>ValueError</code> is raised.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.simplified","title":"simplified","text":"<pre><code>simplified(scale, dist=0.001)\n</code></pre> <p>Return a simplified copy of the mesh by merging close vertices, with a fallback to a cubic envelope if the result is too small.</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>float</code> <p>Scale factor applied to the distance threshold.</p> required <code>dist</code> <code>float</code> <p>Base merge distance for vertices. The effective threshold is <code>dist / scale</code>. Default is 0.001.</p> <code>0.001</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A simplified copy of the mesh. If the simplification produces fewer than 8 vertices, returns a cubic envelope instead.</p> Notes <ul> <li>The copy is created with <code>Mesh.from_mesh</code>.</li> <li>Duplicate vertices are merged with <code>remove_doubles</code>.</li> <li>If too few vertices remain, a fallback is generated using <code>get_cubic_envelop</code>.</li> </ul> <p>Examples:</p> <p>Simplify a mesh with scale factor 10:</p> <pre><code>simp = mesh.simplified(scale=10, dist=0.002)\n</code></pre> See Also <p><code>remove_doubles</code> :     Merges vertices within a distance threshold. <code>get_cubic_envelop</code> :     Provides a fallback cubic mesh when simplification collapses geometry.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.solidify","title":"solidify","text":"<pre><code>solidify(thickness=0.01, offset=-1)\n</code></pre> <p>Apply a Solidify modifier to give thickness to a surface mesh.</p> <p>Parameters:</p> Name Type Description Default <code>thickness</code> <code>float</code> <p>Thickness of the shell to generate. Positive values expand outward, negative values inward. Default is 0.01.</p> <code>0.01</code> <code>offset</code> <code>float</code> <p>Offset factor determining the solidification direction relative to the original surface: -1 \u2192 inward, 0 \u2192 centered, +1 \u2192 outward. Default is -1.</p> <code>-1</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance resulting from the solidify operation.</p> Notes <ul> <li>Internally creates a Blender Solidify modifier with <code>use_even_offset=True</code> for consistent thickness.</li> <li>The modifier is applied destructively via <code>bpy.ops.object.modifier_apply</code>, and the resulting mesh is retrieved with <code>Mesh.from_object</code>.</li> <li>Works best on manifold surfaces (open meshes may produce artifacts).</li> </ul> <p>Examples:</p> <p>Solidify a circular glass mesh:</p> <pre><code>glass = Mesh.circle(segments=128)\nglass.extrude_faces(0, -0.01)\nglass.extrude_faces(0, -2)\nglass.extrude_faces(0, -0.01)\nglass.points.translate((0, 0, 2))\n\nglass = glass.solidify(thickness=0.1)\nglass.to_object(\"Solidify\", shade_smooth=True)\n</code></pre> See Also <p><code>Mesh.from_object</code> :     Converts a Blender object back into a mesh wrapper. <code>object</code> :     Context manager yielding a temporary Blender object.</p> <p>Caution: Applying the modifier is destructive to the underlying Blender object; the method returns a new mesh instance of the result.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.solidify_socle","title":"solidify_socle","text":"<pre><code>solidify_socle(shape, z=0, bottom_material_index=0)\n</code></pre> <p>Build a solid base (\u201csocle\u201d) by extruding the outer boundary of a grid mesh down (or up) to a given Z level, then bridging the side wall.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple of int</code> <p>Grid shape <code>(nx, ny)</code> of the mesh topology (using <code>'ij'</code> indexing).</p> required <code>z</code> <code>float</code> <p>Target Z coordinate for the base ring (the new bottom boundary). Default is 0.</p> <code>0</code> <code>bottom_material_index</code> <code>int</code> <p>Material index assigned to the bottom face created by the operation. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>Modifies the mesh in place. Returns <code>None</code>. The bottom face indices produced by <code>add_geometry</code> are stored internally and their <code>material_index</code> is set to <code>bottom_material_index</code>.</p> Notes <ul> <li>The outer boundary loop is derived from the provided grid <code>shape</code> assuming a regular lattice of <code>nx * ny</code> points laid out with NumPy\u2019s <code>'ij'</code> indexing.</li> <li>A new ring of points is created at Z = <code>z</code> via <code>add_points</code>.</li> <li>The vertical side wall is created by bridging loops with <code>bridge_loops</code> using <code>close=True</code>.</li> <li>The bottom face material is assigned by ensuring and editing the optional <code>material_index</code> field on <code>self.faces</code>.</li> </ul> <p>Examples:</p> <p>Solidify a 20\u00d730 grid down to Z = -0.1 with material index 2:</p> <pre><code>Mesh.solidify_socle(shape=(20, 30), z=-0.1, bottom_material_index=2)\n</code></pre> See Also <p><code>add_points</code> :     Adds the new base ring vertices at Z = <code>z</code>. <code>add_geometry</code> :     Creates the bottom polygon from the added ring. <code>bridge_loops</code> :     Connects the side wall between original and new boundary loops.</p> <p>Caution: This method assumes the mesh vertices correspond to a regular <code>(nx, ny)</code> grid ordered consistently with <code>'ij'</code> indexing; inconsistent layouts will produce incorrect boundaries.</p> <p>Note: The function does not return the created face indices; it sets their <code>material_index</code> internally based on <code>bottom_material_index</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.split_edges","title":"split_edges","text":"<pre><code>split_edges(loop0, loop1, cuts=1)\n</code></pre> <p>Subdivide in place the edges whose endpoints match the pairs (loop0[i], loop1[i]) regardless of order (edges are treated as undirected).</p> <p>The inputs <code>loop0</code> and <code>loop1</code> can be: - scalars (a single vertex index), - sequences of the same length, - or a mix of both (a scalar is broadcast to match the length of the other).</p> <p>The vertex pairs are normalized by sorting (min, max) so that order does not matter, and then compared against the BMesh edge list to determine which edges should be subdivided.</p> <p>Parameters:</p> Name Type Description Default <code>loop0</code> <code>int or array-like of int</code> <p>First vertex (or list of vertices) of the edges to be selected. If scalar, it will be broadcast to the length of <code>loop1</code> if needed.</p> required <code>loop1</code> <code>int or array-like of int</code> <p>Second vertex (or list of vertices) of the edges to be selected. If scalar, it will be broadcast to the length of <code>loop0</code> if needed.</p> required <code>cuts</code> <code>int</code> <p>Number of cuts per selected edge, as defined by <code>bmesh.ops.subdivide_edges</code>. Default is <code>1</code>. Must be &gt;= 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>None</code> <p>Modifies the geometry in place. Returns <code>None</code>. If no edge matches the given pairs, the function returns immediately without modifying the mesh.</p> Notes <ul> <li>Edge selection is performed by constructing an array of sorted vertex pairs <code>(min(v0, v1), max(v0, v1))</code> and checking membership (via <code>np.isin</code> on a structured dtype view) against the BMesh edge list.</li> <li>Subdivision is executed with <code>bmesh.ops.subdivide_edges</code> and <code>use_grid_fill=False</code>.</li> </ul> <p>Examples:</p> <p>Subdivide a single edge (vertices 12 and 34) with 2 cuts:</p> <pre><code>obj = ...  # wrapper object providing .bmesh() and ._bm_edges(...)\nobj.split_edges(12, 34, cuts=2)\n</code></pre> <p>Subdivide multiple edges defined by pairs of vertices:</p> <pre><code>v0 = [1, 5, 9]\nv1 = [2, 6, 10]\nobj.split_edges(v0, v1, cuts=1)\n</code></pre> <p>Use a scalar broadcast against a vector:</p> <pre><code># All edges (7, x) for x in [8, 9, 10]\nobj.split_edges(7, [8, 9, 10], cuts=1)\n</code></pre> See Also <p>bmesh.ops.subdivide_edges : The underlying BMesh operator used for subdivision.</p> <p>Warning: This operation modifies the mesh in place and may create new vertices/edges/faces. Handle undo/history in Blender if needed.</p> <p>Caution: <code>use_grid_fill=False</code> prevents automatic grid filling. Depending on topology, additional n-gons or triangles may be introduced.</p> <p>Note: Edges are considered undirected: (a, b) and (b, a) are equivalent when matching edges.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_curve_REVIEW","title":"to_curve_REVIEW","text":"<pre><code>to_curve_REVIEW()\n</code></pre> <p>Convert mesh to curve</p> <p>Simple conversion when edges domain is defined</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize the Mesh object to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the serialized data of the mesh, including: - 'geometry': The type of geometry (always 'Mesh'). - 'materials': List of material names. - 'points': Serialized points data. - 'corners': Serialized corners data. - 'faces': Serialized faces data. - 'edges': Serialized edges data.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_mesh_data","title":"to_mesh_data","text":"<pre><code>to_mesh_data(data)\n</code></pre> <p>Write the geometry data from this mesh into a Blender Mesh instance.</p> <p>This method transfers the mesh's vertices, edges, faces, corners, materials, and custom attributes into the provided Blender Mesh data structure.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Blender Mesh instance</code> <p>The Blender Mesh object to which the geometry will be written.</p> required <p>Returns:</p> Type Description <code>None</code> Side Effects <p>Modifies the provided Blender Mesh instance by clearing its current geometry and populating it with the data from this mesh. Updates the mesh to reflect the changes.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_object","title":"to_object","text":"<pre><code>to_object(obj, shade_smooth=None, shapekeys=None, collection=None)\n</code></pre> <p>Create or update a Blender mesh object from this mesh data.</p> <p>This method creates a new Blender mesh object if it does not already exist, or updates the existing object's mesh data. It does not perform object type conversion; the existing object must be a mesh.</p> <p>After the object is created or updated, use 'update_object' to modify vertices.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str or Object</code> <p>The Blender object or its name to create or update.</p> required <code>shade_smooth</code> <code>bool or None</code> <p>If specified, sets the shading mode of the mesh polygons to smooth or flat.</p> <code>None</code> <code>shapekeys</code> <code>ShapeKeys or iterable of ShapeKeys</code> <p>Shape keys to apply to the mesh object.</p> <code>None</code> <code>collection</code> <code>Collection or None</code> <p>The collection to which the object should be linked.</p> <code>None</code> <p>Returns:</p> Type Description <code>Object</code> <p>The created or updated Blender mesh object.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.torus","title":"torus  <code>classmethod</code>","text":"<pre><code>torus(major_segments=48, minor_segments=12, major_radius=1.0, minor_radius=0.25, materials=None)\n</code></pre> <p>Create a torus mesh.</p> <p>Parameters:</p> Name Type Description Default <code>major_segments</code> <code>int</code> <p>Number of segments around the major (outer) radius. Default is 48.</p> <code>48</code> <code>minor_segments</code> <code>int</code> <p>Number of segments around the minor (inner) radius (the cross-section). Default is 12.</p> <code>12</code> <code>major_radius</code> <code>float</code> <p>The distance from the center of the torus to the center of the tube. Default is 1.</p> <code>1.0</code> <code>minor_radius</code> <code>float</code> <p>The radius of the tube itself. Default is 0.25.</p> <code>0.25</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the torus. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the torus.</p> Notes <ul> <li>The torus is constructed by sweeping a circle of radius <code>minor_radius</code> around a larger circle of radius <code>major_radius</code>.</li> <li>The transformation of the cross-section is handled by <code>Transformation</code> and <code>Rotation</code>.</li> <li>UV coordinates are generated using <code>grid_uv_map</code>, resulting in a square parameterization.</li> <li>Topology is constructed with <code>grid_corners</code> with both axes closed.</li> </ul> <p>Examples:</p> <p>Create a standard torus:</p> <pre><code>torus = Mesh.torus()\n</code></pre> <p>Create a torus with a larger tube and finer resolution:</p> <pre><code>torus = Mesh.torus(major_segments=64, minor_segments=32,\n                major_radius=2, minor_radius=0.5)\n</code></pre> See Also <p><code>grid_corners</code> :     Helper for constructing the corner topology of the torus grid. <code>grid_uv_map</code> :     Generates UV coordinates for grid-like surfaces. <code>Transformation</code> :     Used to position and orient the swept circle. <code>Rotation</code> :     Used to orient the minor circle along the sweep path.</p> <p>Note: UV coordinates are generated with an offset of \u03c0 to match Blender's default torus orientation.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.triangulate","title":"triangulate","text":"<pre><code>triangulate(selection=None)\n</code></pre> <p>Triangulate selected faces (or all faces) and return a new mesh.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Indices (or mask) of faces to triangulate. If <code>None</code>, all faces are triangulated. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh or None</code> <p>A new mesh instance with the selected faces triangulated. Returns <code>None</code> if no faces were selected.</p> Notes <ul> <li>Creates a copy of the current mesh with <code>Mesh.from_mesh</code>.</li> <li>Triangulation is applied in-place on the copy via <code>bmesh.ops.triangulate</code>.</li> <li>The original mesh is left unchanged.</li> </ul> <p>Examples:</p> <p>Triangulate all faces:</p> <pre><code>tri_mesh = mesh.triangulate()\n</code></pre> <p>Triangulate only a subset:</p> <pre><code>tri_mesh = mesh.triangulate(selection=[0, 5, 7])\n</code></pre> See Also <p><code>Mesh.from_mesh</code> :     Utility to duplicate the mesh before applying triangulation.</p> <p>Note: If <code>selection</code> is empty, the method returns <code>None</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.uvsphere","title":"uvsphere  <code>classmethod</code>","text":"<pre><code>uvsphere(segments=32, rings=16, radius=1, materials=None)\n</code></pre> <p>Create a UV sphere mesh.</p> <p>Parameters:</p> Name Type Description Default <code>segments</code> <code>int</code> <p>Number of longitudinal segments (meridians). Default is 32.</p> <code>32</code> <code>rings</code> <code>int</code> <p>Number of latitudinal rings (parallels). Default is 16.</p> <code>16</code> <code>radius</code> <code>float</code> <p>Radius of the sphere. Default is 1.</p> <code>1</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the sphere. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the UV sphere.</p> Notes <ul> <li>The sphere is created using <code>bmesh.ops.create_uvsphere</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> <li>The geometry is distributed evenly in the UV parameterization, which means denser vertices near the poles.</li> </ul> <p>Examples:</p> <p>Create a default UV sphere of radius 1:</p> <pre><code>sphere = Mesh.uvsphere()\n</code></pre> <p>Create a high-resolution sphere:</p> <pre><code>sphere = Mesh.uvsphere(segments=64, rings=32, radius=2)\n</code></pre> See Also <p><code>icosphere</code> :     Alternative sphere primitive with more uniform vertex distribution. <code>bmesh.ops.create_uvsphere</code> :     BMesh operator used for creating UV spheres.</p> <p>Note: Use <code>icosphere</code> if you need a more uniform tessellation without poles.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.vectors_field","title":"vectors_field  <code>classmethod</code>","text":"<pre><code>vectors_field(locations, vectors, radius=0.05, scale_length=1.0, angle=24.0, segments=8, head=None, adjust_norm=None, materials=None)\n</code></pre> <p>Create an arrow at each <code>location</code> oriented and scaled by the corresponding <code>vector</code>.</p> <p>Each arrow consists of a cylindrical shaft and a conical head aligned with the vector direction. Arrow length is derived from the vector norm, optionally transformed by <code>adjust_norm</code>. For very short vectors, the arrow is scaled down to preserve proportions.</p> <p>Parameters:</p> Name Type Description Default <code>locations</code> <code>array-like of shape (N, 3)</code> <p>Positions where arrows are placed.</p> required <code>vectors</code> <code>array-like of shape (N, 3)</code> <p>Direction (and base length) of each arrow. Must match the length of <code>locations</code>.</p> required <code>radius</code> <code>float</code> <p>Shaft radius for the arrows. Default is 0.05.</p> <code>0.05</code> <code>scale_length</code> <code>float</code> <p>Length threshold below which arrows are uniformly scaled down (radius and shaft) while keeping proportions. Default is 1.0.</p> <code>1.0</code> <code>angle</code> <code>float</code> <p>Opening angle (in degrees) of the conical head. Default is 24.</p> <code>24.0</code> <code>segments</code> <code>int</code> <p>Number of radial segments for both shaft and head. Default is 8.</p> <code>8</code> <code>head</code> <code>Mesh or None</code> <p>Optional mesh to use as the arrow head. If <code>None</code>, a cone is created. When provided, its Z size defines the head height.</p> <code>None</code> <code>adjust_norm</code> <code>(callable, float, None)</code> <p>Controls how vector norms are mapped to arrow lengths: - callable: applied to the array of norms. - float: acts as a maximum length (clamp). - None: use the raw norms. Default is None.</p> <code>callable</code> <code>materials</code> <code>list of str</code> <p>Material names to assign to created geometry. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A mesh containing all arrows.</p> Notes <ul> <li>The head radius is <code>3 * radius</code>; its height is derived from <code>angle</code> via <code>head_height = head_radius / tan(angle)</code>.</li> <li>Arrows with very small vectors are handled specially to avoid degenerate geometry (a minimum total length of approximately <code>2 * head_height</code> is enforced).</li> <li>Alignment is achieved with <code>Rotation.look_at</code>.</li> <li>The shaft is built from <code>cylinder</code>, and the head from <code>cone</code> (when <code>head is None</code>).</li> </ul> <p>Examples:</p> <p>Create a field of unit arrows from a grid:</p> <pre><code>P = np.stack(np.meshgrid(np.linspace(-1, 1, 5),\n                        np.linspace(-1, 1, 5),\n                        [0.0], indexing='ij'), axis=-1).reshape(-1, 3)\nV = np.tile(np.array([0, 0, 1.0]), (len(P), 1))\nfield = Mesh.vectors_field(P, V, radius=0.03, segments=12)\n</code></pre> <p>Clamp arrow lengths to 2 units:</p> <pre><code>field = Mesh.vectors_field(P, V * 5.0, adjust_norm=2.0)\n</code></pre> <p>Map norms nonlinearly (e.g., sqrt):</p> <pre><code>field = Mesh.vectors_field(P, V, adjust_norm=np.sqrt)\n</code></pre> See Also <p><code>arrow</code> :     Convenience method to create a single arrow. <code>cylinder</code> :     Used to create the arrow shafts. <code>cone</code> :     Used to create the arrow heads (when <code>head is None</code>). <code>Rotation.look_at</code> :     Used to orient arrows along their vectors.</p> <p>Caution: <code>locations</code> and <code>vectors</code> must have the same length (N). Mismatched inputs will lead to incorrect alignment or runtime errors.</p> <p>Note: Zero-length vectors are handled safely; corresponding arrows collapse to length 0 and are effectively omitted.</p>"}]}