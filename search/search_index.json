{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"npblender Documentation","text":"<p>Welcome to the npblender documentation. This project provides data structures and vectorized tools to manipulate Blender geometry and attributes efficiently with NumPy.</p> <p>API is documented here</p>"},{"location":"#about","title":"About","text":"<ul> <li>License: MIT  </li> <li>Author: Alain Bernard  </li> <li>Last updated: 2025-09-01</li> </ul>"},{"location":"api/","title":"npblender API","text":""},{"location":"api/#table-of-contents","title":"Table of Contents","text":""},{"location":"api/#geometry","title":"Geometry","text":"<ul> <li>Geometry : root class for actual geometries</li> <li>Mesh<ul> <li><code>points</code>: Vertex</li> <li><code>corners</code>: Corner</li> <li><code>edges</code>: Edge</li> <li><code>faces</code>: Face</li> </ul> </li> <li>Curve<ul> <li><code>points</code>: ControlPoint</li> <li><code>splines</code>: Spline</li> </ul> </li> <li>Cloud<ul> <li><code>points</code>: Point</li> </ul> </li> <li>Instances<ul> <li><code>points</code>: Point</li> </ul> </li> <li>Meshes<ul> <li><code>points</code>: Point</li> </ul> </li> </ul>"},{"location":"api/#maths","title":"Maths","text":"<ul> <li>Rotation</li> <li>Quaternion</li> <li>Transformation</li> <li>maths module</li> <li>distribs module</li> </ul>"},{"location":"api/#animation","title":"Animation","text":"<ul> <li>Camera : for camera culling</li> <li>engine : animation engine</li> <li>Animation : basic yet powerful Animation class</li> <li>Simulation : advanced simulation</li> </ul>"},{"location":"api/#misc","title":"Misc","text":"<ul> <li>[utils][npblender.utils]</li> </ul>"},{"location":"api/animation/","title":"Animation","text":""},{"location":"api/animation/#npblender.Animation","title":"Animation","text":"<pre><code>Animation(compute=None, reset=None, view=None)\n</code></pre>"},{"location":"api/camera/","title":"Camera","text":""},{"location":"api/camera/#npblender.Camera","title":"Camera","text":"<pre><code>Camera(camera=None)\n</code></pre>"},{"location":"api/camera/#npblender.Camera.distance_for_scale","title":"distance_for_scale","text":"<pre><code>distance_for_scale(size_max, scale=1.0, margin=0.0, fit_axis='auto')\n</code></pre> <p>Compute: - d0: distance at which an unscaled object of real size <code>size_max</code> exactly fits         the camera frame along <code>fit_axis</code> (largest dimension touches the borders). - d : distance such that the UNscaled object at distance d has the same apparent size         as the SCALED object (size_max * scale) at distance d0. (i.e. d = d0 / scale) - meters_per_pixel: world-space length at distance d that projects to exactly 1 pixel         (so two vertices closer than this fall onto the same pixel).</p> <p>Parameters:</p> Name Type Description Default <code>size_max</code> <code>float</code> <p>Largest real dimension of the mesh (Blender units).</p> required <code>scale</code> <code>float</code> <p>Geometry scale (&gt; 0) applied at distance d0.</p> <code>1.0</code> <code>margin</code> <code>float</code> <p>Extra margin around the frame (same convention as elsewhere).</p> <code>0.0</code> <code>fit_axis</code> <code>(auto, width, height)</code> <p>Which frame span to use to define \"exactly fits\". - \"auto\": min(width, height) - \"width\": frame width - \"height\": frame height</p> <code>\"auto\"</code> <p>Returns:</p> Name Type Description <code>d</code> <code>float</code> <p>Distance where the UNscaled object matches the apparent size of the SCALED one at d0 (d = d0 / scale).</p> <code>meters_per_pixel</code> <code>float</code> <p>World-space size corresponding to 1 pixel at distance d.</p> Notes <ul> <li>Uses Blender's view_frame on plane z = cam_z. width  = cam_x1 - cam_x0 height = cam_y1 - cam_y0</li> <li>Perspective: apparent_size \u221d size / distance equality \u21d2 size_max / d = (size_max * scale) / d0 \u21d2 d = d0 / scale.</li> </ul>"},{"location":"api/camera/#npblender.Camera.pixels_per_meter","title":"pixels_per_meter","text":"<pre><code>pixels_per_meter(distances)\n</code></pre> <p>Returns the number of pixels per meter given the distances</p> Arguments <ul> <li>distances (array of floats) : the distances</li> </ul> <p>Returns:</p> Type Description <code>- array of floats : the size of a meter in pixels</code>"},{"location":"api/camera/#npblender.Camera.visible_edges","title":"visible_edges","text":"<pre><code>visible_edges(mesh, radius=0.0, margin=0.0)\n</code></pre> <p>Mesh edges visibility</p> <p>The visibility of each point is computed with the given radius. An edge is considered invisible if both points are hidden for the same reason: both are left to the camera, or right, or behind...</p> <p>In the other case, the edge is considered as visible.</p> Arguments <p>mesh : Mesh     The mesh with points and edges radius : float     The radius of the camera margin : float     The margin of the camera</p> <p>Returns:</p> Name Type Description <code>vis</code> <code>array (n) of bools</code> <p>The visibility of each edge</p> <code>size</code> <code>array (n) of floats</code> <p>The size of the projected edges</p>"},{"location":"api/camera/#npblender.Camera.visible_faces","title":"visible_faces","text":"<pre><code>visible_faces(mesh, margin=0.0, back_face_culling=False)\n</code></pre> <p>Mesh faces visibility</p> <p>A face is considered invisible if all its points are hidden for the same reason: all are left to the camera, or right, or behind...</p> Arguments <p>mesh : Mesh     The mesh with points and faces margin : float     The margin of the camera back_face_culling : bool     If True, the back face is not considered as visible</p> <p>Returns:</p> Name Type Description <code>vis</code> <code>array (n) of bools</code> <p>The visibility of each face</p> <code>size</code> <code>array (n) of floats</code> <p>The size of the projected faces</p> <code>proj</code> <code>array (n, 3) of floats</code> <p>The projected position of each face</p>"},{"location":"api/camera/#npblender.Camera.visible_islands","title":"visible_islands","text":"<pre><code>visible_islands(mesh, islands, attribute='Island', margin=0.0)\n</code></pre> <p>Mesh islands visibility</p> <p>Islands are defined by an integer.</p> <p>Visibility is computed with the position and size of the islands</p> Arguments <p>mesh : Mesh     The mesh with points and faces islands: array of ints     One identifier per island attribute: attribute name     The attribute name to use for the islands margin : float     The margin of the camera</p> <p>Returns:</p> Type Description <code>    - couple of arrays : array[n, 7] of bools, array[n, 2] of floats</code>"},{"location":"api/camera/#npblender.Camera.visible_points","title":"visible_points","text":"<pre><code>visible_points(verts, radius=0.0, margin=0.0, normals=None, return_proj=False)\n</code></pre> <p>Compute the visibility of vertices.</p> <p>For each vertex, the following values are computed: - visible : vertex is visible (all bools below are False) - behind : vertex is behind the visible rectangle - left : vertex is left to the visible rectangle - right : vertex if right to the visible rectangle - above : vertex is above the visible rectangle - below : vertex is below the visible rectangle - back : normal points outards - distance : distance to the camera - size : apparent size (based on radius)</p> Arguments <pre><code>- verts (array of vectors) : vertex locations\n- radius (array of floats or float = 0.) : size at the locations\n- margin (float, default=0.) : margin factor around the camera\n- normals (array of vectors = None) : normal pointing outwards are not visible\n</code></pre> <p>Returns:</p> Type Description <code>    - couple of arrays : array[n, 7] of bools, array[n, 2] of floats</code>"},{"location":"api/cloud/","title":"Cloud","text":""},{"location":"api/cloud/#npblender.cloud.Cloud","title":"Cloud","text":"<pre><code>Cloud(points=None, attr_from=None, **attrs)\n</code></pre> <p>               Bases: <code>Geometry</code></p> <p>Point-cloud geometry container.</p> <p><code>Cloud</code> stores a set of points and their attributes, with helpers to import/export from Blender data (Mesh or PointCloud), join other clouds, apply basic transforms, and generate common point distributions.</p> <p>Attributes:</p> Name Type Description <code>points</code> <code>[Point][Point]</code> <p>Point domain storing per-point attributes (e.g., <code>position</code>, <code>normal</code>, ...).</p> Notes <ul> <li>This class focuses on point-only data. For topological data   (faces/edges), use <code>Mesh</code>.</li> <li>Blender interoperability accepts both <code>bpy.types.Mesh</code> and   <code>bpy.types.PointCloud</code> when reading, but writing currently targets a   Mesh data block (see <code>to_data</code>).</li> </ul> <p>Initialize an empty cloud, optionally with points and attributes.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like of shape (N, 3) or (N, D)</code> <p>Coordinates to append as <code>points.position</code>. If extra keys are present, pass them via <code>**attrs</code>.</p> <code>None</code> <code>attr_from</code> <code>object</code> <p>Source whose attribute schemas should be merged into this geometry, see <code>join_attributes</code>.</p> <code>None</code> <code>**attrs</code> <p>Additional per-point attributes to append alongside <code>points</code>.</p> <code>{}</code>"},{"location":"api/cloud/#npblender.cloud.Cloud.bounding_box","title":"bounding_box  <code>property</code>","text":"<pre><code>bounding_box\n</code></pre> <p>Axis-aligned bounding box of the point positions.</p> <p>Returns:</p> Type Description <code>tuple of numpy.ndarray</code> <p><code>(min_xyz, max_xyz)</code>. If empty, returns two zero vectors.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.bounding_box_dims","title":"bounding_box_dims  <code>property</code>","text":"<pre><code>bounding_box_dims\n</code></pre> <p>Extents of the axis-aligned bounding box.</p> <p>Returns:</p> Type Description <code>numpy.ndarray of shape (3,)</code> <p><code>max_xyz - min_xyz</code>.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.max_size","title":"max_size  <code>property</code>","text":"<pre><code>max_size\n</code></pre> <p>Maximum dimension of the bounding box.</p> <p>Returns:</p> Type Description <code>float</code> <p><code>max(bounding_box_dims)</code>.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.add_materials","title":"add_materials","text":"<pre><code>add_materials(materials)\n</code></pre> <p>Append material name(s) to the geometry.</p> <p>Parameters:</p> Name Type Description Default <code>materials</code> <code>str or sequence of str</code> <p>One name or a sequence of names to append.</p> required <p>Returns:</p> Type Description <code>None</code> Notes <p>This method does not deduplicate names; duplicates may be appended.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.apply_scale","title":"apply_scale","text":"<pre><code>apply_scale(scale, pivot=None)\n</code></pre> <p>Scale points (convenience wrapper).</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>ndarray</code> <p>Per-point or broadcastable scales.</p> required <code>pivot</code> <code>ndarray</code> <p>Optional pivot(s) for scaling.</p> <code>None</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.capture","title":"capture","text":"<pre><code>capture(other)\n</code></pre> <p>Capture another cloud's buffers (no copy).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Cloud</code> <p>Source cloud whose <code>points</code> buffer is adopted.</p> required <p>Returns:</p> Type Description <code>Cloud</code> <p><code>self</code>, for chaining.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.check","title":"check","text":"<pre><code>check(title='Geometry Check', halt=True)\n</code></pre> <p>Validate the geometry consistency.</p> <p>Placeholder in the base class: returns <code>True</code>. Subclasses may override to perform domain-level checks.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Label for messages or errors.</p> <code>\"Geometry Check\"</code> <code>halt</code> <code>bool</code> <p>Whether to raise on failure (in subclasses that implement checks).</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>Always <code>True</code> in the base class.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.clear_geometry","title":"clear_geometry","text":"<pre><code>clear_geometry()\n</code></pre> <p>Clear all point data (schemas kept, values cleared).</p> <p>Returns:</p> Type Description <code>None</code>"},{"location":"api/cloud/#npblender.cloud.Cloud.compute_attribute_on_domain","title":"compute_attribute_on_domain","text":"<pre><code>compute_attribute_on_domain(domain_from, attr, domain_to)\n</code></pre> <p>Transfer an attribute from one domain to another.</p> <p>Performs a domain mapping (e.g., points \u2192 faces) using the appropriate domain operator, and returns the computed array on the target domain.</p> <p>Parameters:</p> Name Type Description Default <code>domain_from</code> <code>str</code> <p>Source domain name (e.g., <code>\"points\"</code>, <code>\"faces\"</code>, <code>\"edges\"</code>, <code>\"corners\"</code>, <code>\"splines\"</code>).</p> required <code>attr</code> <code>str or ndarray</code> <p>Source attribute to transfer. If a string, it is looked up on the source domain; if an array, it must match the source domain length.</p> required <code>domain_to</code> <code>str</code> <p>Target domain name.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Attribute values on the target domain. If <code>domain_from == domain_to</code>, returns <code>attr</code> unchanged.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If either <code>domain_from</code> or <code>domain_to</code> is not a valid domain of this geometry.</p> <code>Exception</code> <p>If the requested mapping is not implemented.</p> Notes <p>Implemented mappings include: - points \u2192 faces: <code>Point.compute_attribute_on_faces</code> - points \u2192 edges: <code>Point.compute_attribute_on_edges</code> - points \u2192 corners: <code>Point.compute_attribute_on_corners</code> - points \u2192 splines: <code>Point.compute_attribute_on_splines</code> - faces \u2192 points: <code>Face.compute_attribute_on_points</code> - edges \u2192 points: <code>Edge.compute_attribute_on_points</code> - corners \u2192 points: <code>Corner.compute_attribute_on_points</code></p>"},{"location":"api/cloud/#npblender.cloud.Cloud.from_cloud","title":"from_cloud  <code>classmethod</code>","text":"<pre><code>from_cloud(other, selection=None)\n</code></pre> <p>Synonym of <code>from_geometry</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Cloud</code> required <code>selection</code> <code>selection or None</code> <code>None</code> <p>Returns:</p> Type Description <code>Cloud</code>"},{"location":"api/cloud/#npblender.cloud.Cloud.from_data","title":"from_data  <code>classmethod</code>","text":"<pre><code>from_data(data)\n</code></pre> <p>Initialize the cloud from Blender data (Mesh or PointCloud).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Mesh or PointCloud or str</code> <p>A Blender data-block or a resolvable identifier accepted by <code>blender.get_data</code>.</p> required <p>Returns:</p> Type Description <code>Cloud</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the data-block type is not supported.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d)\n</code></pre> <p>Deserialize a cloud from a dictionary produced by <code>to_dict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Serialized payload with at least the <code>\"points\"</code> key.</p> required <p>Returns:</p> Type Description <code>Cloud</code> <p>New instance with points loaded from <code>d</code>.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.from_geometry","title":"from_geometry  <code>classmethod</code>","text":"<pre><code>from_geometry(other, selection=None)\n</code></pre> <p>Build a cloud from another geometry that has a point domain.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>[Geometry][Geometry]</code> <p>Source geometry (must have a <code>points</code> domain).</p> required <code>selection</code> <code>selection or None</code> <p>Selection on points to keep; if provided, the complement is deleted after copying.</p> <code>None</code> <p>Returns:</p> Type Description <code>Cloud</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>other</code> has no <code>points</code> domain.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.from_object","title":"from_object  <code>classmethod</code>","text":"<pre><code>from_object(obj, evaluated=False)\n</code></pre> <p>Create a cloud from an existing Blender object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str or Object</code> <p>Object or name resolvable by <code>blender.get_object</code>.</p> required <code>evaluated</code> <code>bool</code> <p>If True, read from the evaluated object (modifiers applied).</p> <code>False</code> <p>Returns:</p> Type Description <code>Cloud</code>"},{"location":"api/cloud/#npblender.cloud.Cloud.get_cubic_envelop","title":"get_cubic_envelop","text":"<pre><code>get_cubic_envelop()\n</code></pre> <p>Return a cube mesh that encloses the geometry\u2019s bounding box.</p> <p>Uses the bounding box dimensions to build a cube via <code>Mesh.cube</code>, forwarding this geometry\u2019s <code>materials</code> if present.</p> <p>Returns:</p> Type Description <code>Mesh</code> <p>A cube mesh sized to the bounding box.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.get_material_index","title":"get_material_index","text":"<pre><code>get_material_index(mat_name)\n</code></pre> <p>Return the index of a material name, creating it if needed.</p> <p>Parameters:</p> Name Type Description Default <code>mat_name</code> <code>str</code> <p>Material name to look up or append.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index of <code>mat_name</code> in <code>self.materials</code>.</p> Notes <p>If <code>mat_name</code> is not present, it is appended to <code>self.materials</code> and the new index is returned.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.get_points_selection","title":"get_points_selection","text":"<pre><code>get_points_selection()\n</code></pre> <p>Selection of points relevant to operations.</p> <p>Returns <code>slice(None)</code> in the base class (all points). Subclasses (e.g., curves) may override to select only referenced points.</p> <p>Returns:</p> Type Description <code>slice</code> <p><code>slice(None)</code> by default.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.join","title":"join","text":"<pre><code>join(*others)\n</code></pre> <p>Append other clouds' points to this cloud.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Geometry</code> <p>One or more Geometries to concatenate.</p> <code>()</code> <p>Returns:</p> Type Description <code>Cloud</code> <p><code>self</code>, for chaining.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other, **kwargs)\n</code></pre> <p>Merge attribute schemas from another geometry.</p> <p>For each domain listed in <code>self.domain_names</code> and also present in <code>other</code>, copies (joins) the attribute definitions (names, dtypes, metadata) from <code>other</code> into this geometry's domains. Use keyword flags to include/exclude domains by name (e.g., <code>faces=False</code>).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Geometry or None</code> <p>Source geometry. If <code>None</code>, does nothing and returns <code>self</code>.</p> required <code>**kwargs</code> <p>Per-domain boolean switches to filter which domains to join.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>, for chaining.</p> <p>Examples:</p> <pre><code>mesh.join_attributes(other_mesh, faces=False)\ncurve.join_attributes(mesh)  # only common domains are merged\n</code></pre>"},{"location":"api/cloud/#npblender.cloud.Cloud.load_models","title":"load_models  <code>staticmethod</code>","text":"<pre><code>load_models(*specs)\n</code></pre> <p>Load multiple geometries from collections, objects, or instances.</p> <p>Accepts mixed inputs such as Blender collections, Blender objects, lists/ tuples of either, or already-instantiated <code>Mesh</code>/<code>Curve</code>. Returns a flat list of geometries discovered or constructed.</p> <p>This method is mainly intended to be used by <code>Instances</code> to load its models.</p> <p>Parameters:</p> Name Type Description Default <code>*specs</code> <p>Collections, objects, lists/tuples, or <code>Mesh</code>/<code>Curve</code> instances.</p> <code>()</code> <p>Returns:</p> Type Description <code>list</code> <p>List of geometries (<code>Mesh</code>/<code>Curve</code>).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a spec cannot be resolved to a geometry.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.load_object","title":"load_object  <code>staticmethod</code>","text":"<pre><code>load_object(name)\n</code></pre> <p>Load a Blender object and return a <code>Mesh</code> or a <code>Curve</code>.</p> <p>Resolves <code>name</code> to a Blender object, inspects its data type, and returns a matching geometry by calling the subclass' <code>from_object</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or Object</code> <p>Object name or object instance.</p> required <p>Returns:</p> Type Description <code>Mesh or Curve or None</code> <p>A <code>Mesh</code> or a <code>Curve</code>, or <code>None</code> if the object is not found.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the object exists but is neither a <code>bpy.types.Mesh</code> nor <code>bpy.types.Curve</code>.</p> <p>Examples:</p> <pre><code>geo = Geometry.load_object(\"MyObject\")\nif geo is not None:\n    print(type(geo).__name__)\n</code></pre>"},{"location":"api/cloud/#npblender.cloud.Cloud.object","title":"object","text":"<pre><code>object(index=0, readonly=True, **kwargs)\n</code></pre> <p>Temporary access to a Blender Object built from this geometry.</p> <p>Creates a transient object (named <code>\"BPBL Temp {index}\"</code> unless <code>index</code> is a string), selects and activates it, yields it for editing, then cleans up. If <code>readonly=True</code>, the edited object is captured back into <code>self</code>.</p> <p>This method can be used to set and apply a modifier (see exemple below).</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int or str</code> <p>Index or name used to label the temporary object.</p> <code>0</code> <code>readonly</code> <code>bool</code> <p>If <code>False</code>, re-capture the possibly edited object back into this geometry.</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>Keyword arguments passed to <code>self.to_object</code>.</p> <code>{}</code> <p>Yields:</p> Type Description <code>Object</code> <p>The temporary Blender object built from <code>self</code>.</p> <p>Examples:</p> <pre><code>plane = Mesh.Grid()\nwith plane.object(readonly=False) as obj:\n    mod = obj.modifiers.new(\"Solidify\", 'SOLIDIFY')\n    mod.thickness = .1\n    bpy.ops.object.modifier_apply(modifier=mod.name)\n\n# plane is now solidifed\n</code></pre>"},{"location":"api/cloud/#npblender.cloud.Cloud.rotate","title":"rotate","text":"<pre><code>rotate(rotation, pivot=None)\n</code></pre> <p>Rotate points (convenience wrapper).</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>ndarray or Rotation - like</code> <p>Rotation(s) to apply as <code>R @ v</code>.</p> required <code>pivot</code> <code>ndarray</code> <p>Optional pivot(s) for rotation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.to_data","title":"to_data","text":"<pre><code>to_data(data)\n</code></pre> <p>Write this cloud into a Blender Mesh data-block.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Mesh or str</code> <p>Target mesh data (or identifier resolvable by <code>blender.get_data</code>). The geometry is cleared and repopulated.</p> required <p>Returns:</p> Type Description <code>None</code> Notes <ul> <li>Vertices are created to match the point count; per-point attributes are written to <code>data.attributes</code>.</li> </ul> <p>Caution: This writes to a Mesh data-block (not PointCloud) because Blender\u2019s Python API does not allow changing the point count of a <code>PointCloud</code> at runtime.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize the cloud to a plain Python dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with keys: <code>\"geometry\"</code> (<code>\"Cloud\"</code>) and <code>\"points\"</code>.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.to_object","title":"to_object","text":"<pre><code>to_object(obj, point_cloud=False, collection=None)\n</code></pre> <p>Create or update a Blender object from this cloud.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str or Object</code> <p>Object or name. If it does not exist, it is created.</p> required <code>point_cloud</code> <code>bool</code> <p>If True, convert the created mesh object to a <code>PointCloud</code> object.</p> <code>False</code> <code>collection</code> <code>str or Collection or None</code> <p>Collection to link a newly created object into.</p> <code>None</code> <p>Returns:</p> Type Description <code>Object</code> <p>The created/updated Blender object.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.transform","title":"transform","text":"<pre><code>transform(transformation)\n</code></pre> <p>Apply a rotation matrix or batch of matrices.</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>transformation</code> <code>ndarray</code> <p>Rotation matrix or batch of rotation matrices.</p> required <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/cloud/#npblender.cloud.Cloud.transformation","title":"transformation","text":"<pre><code>transformation(rotation=None, scale=None, translation=None, pivot=None)\n</code></pre> <p>Apply rotation/scale/translation (with optional per-packet broadcasting).</p> <p>Operates in-place on <code>points.position</code> and, when present, Bezier handles (<code>points.handle_left</code>, <code>points.handle_right</code>). Shapes can represent packets of points: broadcasting rules are handled by <code>Point._get_shape_for_operation</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>ndarray or Rotation - like</code> <p>Rotation matrix/matrices applied as <code>R @ v</code>. Shape may broadcast over points (see notes).</p> <code>None</code> <code>scale</code> <code>ndarray</code> <p>Per-axis scaling. Shape may broadcast over points.</p> <code>None</code> <code>translation</code> <code>ndarray</code> <p>Per-point translation. Shape may broadcast over points.</p> <code>None</code> <code>pivot</code> <code>ndarray</code> <p>Pivot(s) subtracted before, and added after, the rotation/scale; same broadcasting rules as <code>scale</code>/<code>translation</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>, for chaining.</p> Notes <ul> <li>If handles exist, they are transformed consistently with positions.</li> </ul> <p>Examples:</p> <pre><code># 12 cubes laid out randomly with per-instance transforms\ncubes = Mesh.cube(size=1).multiply(12)\nT = np.random.uniform(-1, 1, (12, 3))\nS = np.random.uniform(0.5, 2.0, (12, 3))\nR = Rotation.from_euler(np.random.uniform(0, 2*np.pi, (12, 3)))\ncubes.transformation(rotation=R, scale=S, translation=T)\n</code></pre>"},{"location":"api/cloud/#npblender.cloud.Cloud.translate","title":"translate","text":"<pre><code>translate(translation)\n</code></pre> <p>Translate points (convenience wrapper).</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>ndarray</code> <p>Per-point or broadcastable translation vectors.</p> required <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/controlpoint/","title":"Controlpoint","text":""},{"location":"api/controlpoint/#npblender.domain.ControlPoint","title":"ControlPoint","text":"<pre><code>ControlPoint(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>Curve control point domain.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>(N, 3) float</code> <p>Control point positions.</p> <code>w</code> <code>(N,) float, optional</code> <p>Rational weight (NURBS).</p> <code>handle_left, handle_right</code> <code>(N, 3) float, optional</code> <p>Bezier handles in object space.</p> <code>handle_type_left, handle_type_right</code> <code>(N,) int, optional</code> <p>Bezier handle types.</p> <code>tilt</code> <code>(N,) float, optional</code> <p>Tilt (radians).</p> <code>radius</code> <code>(N,) float, optional</code> <p>Display radius.</p> <code>weight</code> <code>(N,) float, optional</code> <p>Generic user-defined weight.</p> See Also <p><code>Spline</code> : Spline domain grouping control points.</p> Notes <ul> <li>Scaling also applies to handles.</li> <li>Rotational transforms rotate handles using the transform's rotation   only (scales are not applied to handles).</li> </ul> <p>Examples:</p> <p>Average a control-point attribute on splines:</p> <pre><code>mean_tilt = cpoints.compute_attribute_on_splines(\"tilt\", splines)\n</code></pre> <p>Apply a transform that rotates handles consistently:</p> <pre><code>cpoints.transform(T)  # where T is a Transformation or Rotation\n</code></pre> <p>Initialize a domain array and its attribute schema.</p> <p>Initializes the storage from an existing array/domain or creates an empty structure. Optionally merges attribute definitions/values from another domain and keyword-provided attributes.</p> <p>Domains are never instancied directly but by owning geometries.</p> <p>Actual Domains are <code>Vertex</code>, [<code>Faces</code>][npblender.domain.Faces], <code>Corner</code>, <code>Edge</code>, <code>ControlPoint</code>, <code>Spline</code> and <code>Point</code>.</p> <p>Domains are initialized with their defaults attributes, for instance <code>position</code> for point domaines.</p> <p>Use attributes can be freely added. </p> <p>Note: user attributes are saved in Blender Mesh objects only, Blender Curve objects don't store user attributes.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>array - like or FieldArray or None</code> <p>Source data used to initialize the domain. If <code>None</code>, an empty domain is created and <code>_declare_attributes()</code> is called to register defaults.</p> <code>None</code> <code>mode</code> <code>(COPY, CAPTURE, EMPTY)</code> <p>Initialization mode. <code>'COPY'</code> duplicates the input data, <code>'CAPTURE'</code> references the input buffer when supported, <code>'EMPTY'</code> creates the structure without copying values.</p> <code>'COPY'</code> <code>selector</code> <code>Any</code> <p>Optional row/element selector applied to <code>a</code> prior to initialization.</p> <code>None</code> <code>attr_from</code> <code>Domain or Mapping or None</code> <p>Attribute schema (and possibly values) to merge into this domain.</p> <code>None</code> <code>**attrs</code> <p>Additional attribute name/value pairs to inject or override.</p> <code>{}</code> Notes <p>The effective attribute list results from <code>_declare_attributes()</code>, then <code>attr_from</code>, then <code>**attrs</code> (later entries take precedence).</p> <p>Examples:</p> <pre><code>cube = Mesh.cube() # points, corners, faces and edges domains are created\n# Adding named attribute to point domain\ncube.points.new_float('age')\n# Setting the age\ncube.points.age = np.random.uniforme(10, 10, len(cube.points))\n</code></pre>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.actual_names","title":"actual_names  <code>property</code>","text":"<pre><code>actual_names\n</code></pre> <p>Column names.</p> <p>Returns the actual field names, excluding optional fields.</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.all_names","title":"all_names  <code>property</code>","text":"<pre><code>all_names\n</code></pre> <p>Column names.</p> <p>Returns all the field names, including optional ones.</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Array structured dtype</p> <p>Returns the dtype property of the structured array.</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.transdom_names","title":"transdom_names  <code>property</code>","text":"<pre><code>transdom_names\n</code></pre> <p>List the names of trans-domain attributes.</p> <p>Returns:</p> Type Description <code>list of str</code> <p>Names of attributes flagged with <code>transdom=True</code>.</p> <p>Examples:</p> <pre><code>names = D.transdom_names()\n</code></pre>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.x","title":"x  <code>property</code> <code>writable</code>","text":"<pre><code>x\n</code></pre> <p>X coordinate accessor.</p> <p>Shorthand for <code>position[..., 0]</code>. Reading returns a view; assigning to this property writes into the underlying <code>position</code> field.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>View of shape <code>(...,)</code> selecting the x component of <code>position</code>.</p> <p>Examples:</p> <p>Read and write x in place:</p> <pre><code>xs = points.x              # view on position[..., 0]\npoints.x = xs + 1.0        # shift x by +1\n</code></pre> <p>Note: This is equivalent to <code>points.position[..., 0]</code>.</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.y","title":"y  <code>property</code> <code>writable</code>","text":"<pre><code>y\n</code></pre> <p>Y coordinate accessor.</p> <p>Shorthand for <code>position[..., 1]</code>. Reading returns a view; assigning to this property writes into the underlying <code>position</code> field.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>View of shape <code>(...,)</code> selecting the y component of <code>position</code>.</p> <p>Examples:</p> <pre><code>points.y = 0.0             # flatten all y to 0\n</code></pre>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.z","title":"z  <code>property</code> <code>writable</code>","text":"<pre><code>z\n</code></pre> <p>Z coordinate accessor.</p> <p>Shorthand for <code>position[..., 2]</code>. Reading returns a view; assigning to this property writes into the underlying <code>position</code> field.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>View of shape <code>(...,)</code> selecting the z component of <code>position</code>.</p> <p>Examples:</p> <pre><code>points.z += 2.5\n</code></pre>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.add","title":"add","text":"<pre><code>add(count, **fields)\n</code></pre> <p>Add count records</p> <p>New records are set with default values or values provided by the user in fields dict.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of records to add.</p> required <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.append","title":"append","text":"<pre><code>append(**fields)\n</code></pre> <p>Append values to the structured array.</p> <p>The number of records to append is determined by the number of fields provided in the fields dictionary. The values of the fields are copied to the new records.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.apply_scale","title":"apply_scale","text":"<pre><code>apply_scale(scale, pivot=None)\n</code></pre> <p>Apply per-axis scales to control points, and scale handles as well.</p> <p>First applies per-axis scaling to <code>position</code> via <code>apply_scale</code>, then, if Bezier handles are present, scales <code>handle_left</code> and <code>handle_right</code> by the same <code>scale</code>.</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>array-like of shape ``(..., 3)``</code> <p>Per-axis scale factors broadcastable to the domain size.</p> required <code>pivot</code> <code>array-like of shape ``(..., 3)`` or None</code> <p>Pivot location(s) for point scaling. If <code>None</code>, scales are applied about the origin.</p> <code>None</code> <p>Returns:</p> Type Description <code>ControlPoint</code> <p>Self (for chaining).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the operand cannot be aligned with the domain size (raised by <code>_get_shape_for_operation</code>).</p> <p>Examples:</p> <pre><code># Uniform scale per control point\ns = np.full((len(CP), 3), 0.5)\nCP.apply_scale(s)\n\n# Per-spline scale about per-spline pivot\nCP.apply_scale(scales, pivot=pivots)\n</code></pre>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.as_kwargs","title":"as_kwargs","text":"<pre><code>as_kwargs(selector=None, include=None, exclude=None)\n</code></pre> <p>Return a dictionary of field values formatted as kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>slice, int, list, or mask</code> <p>Optional selection of elements to extract.</p> <code>None</code> <code>include</code> <code>list[str]</code> <p>List of field names (original or python names) to include.</p> <code>None</code> <code>exclude</code> <code>list[str]</code> <p>List of field names (original or python names) to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Mapping from python-safe field names to array values.</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.compute_attribute_on_splines","title":"compute_attribute_on_splines","text":"<pre><code>compute_attribute_on_splines(attr, splines)\n</code></pre> <p>Average a per-control-point attribute over each spline.</p> <p>For every spline, computes the mean of the source control-point attribute over its range <code>[loop_start, loop_start + loop_total)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str or ndarray, shape ``(N, ...)``</code> <p>Control-point attribute to aggregate. If a string, the field is looked up on this domain; if an array, it must have length <code>N == len(self)</code>. The trailing item shape (<code>...</code>) is preserved.</p> required <code>splines</code> <code>Spline</code> <p>Spline domain providing <code>loop_start</code> and <code>loop_total</code> arrays.</p> required <p>Returns:</p> Type Description <code>ndarray, shape ``(len(splines), ...)``</code> <p>Spline-wise averaged attribute. The trailing item shape is preserved and the dtype follows the input attribute.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>attr</code> is scalar or its first dimension does not match <code>len(self)</code> (raised by <code>_check_attribute_to_compute</code>).</p> <code>IndexError</code> <p>If <code>splines.loop_start</code>/<code>loop_total</code> describe ranges outside <code>[0, len(self))</code>.</p> <code>TypeError</code> <p>If the attribute dtype cannot be averaged (e.g., integer arrays will fail on in-place division).</p> Notes <p>This routine computes an unweighted arithmetic mean of the attribute over each spline's control points.</p> <p>Examples:</p> <pre><code># Average tilt per spline from control points\nmean_tilt = cpoints.compute_attribute_on_splines(\"tilt\", splines)\n\n# Average a custom per-control-point float attribute\nmean_w = cpoints.compute_attribute_on_splines(weights, splines)\n</code></pre>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.copy_field","title":"copy_field","text":"<pre><code>copy_field(field_name, new_name, **infos)\n</code></pre> <p>Duplicate an existing field under a new name, with optional metadata overrides.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the existing field to copy.</p> required <code>new_name</code> <code>str</code> <p>The name of the new field to create.</p> required <code>infos</code> <code>keyword arguments</code> <p>Optional metadata (e.g. default, unit, description...) to override or supplement the original field's metadata.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the source field does not exist.</p> <code>ValueError</code> <p>If the target name already exists or is reserved.</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.delete","title":"delete","text":"<pre><code>delete(index)\n</code></pre> <p>Delete a selection of items from the array.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int, slice, or array-like</code> <p>The indices of the elements to delete from the current data.</p> required Notes <p>This operates only on the valid range <code>[0:self._length]</code>. The internal buffer is preserved (no reallocation).</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.dump","title":"dump","text":"<pre><code>dump(title='Dump', attributes=None, target='SCREEN')\n</code></pre> <p>Pretty-print or export domain content.</p> <p>Formats attribute values and prints to screen or builds a tabular dump suitable for spreadsheets.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title displayed in the report.</p> <code>'Dump'</code> <code>attributes</code> <code>Sequence[str] or None</code> <p>Subset of attribute names to include. If <code>None</code>, all attributes are shown.</p> <code>None</code> <code>target</code> <code>(SCREEN, ...)</code> <p>Output target. <code>'SCREEN'</code> prints to stdout; other targets may trigger file creation depending on the implementation.</p> <code>'SCREEN'</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>Domain(points).dump(title=\"Vertices\")\n</code></pre> <p>Note: Formatting adapts to the chosen <code>target</code>.</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.extend","title":"extend","text":"<pre><code>extend(other, join_fields=True)\n</code></pre> <p>Append multiple records from another array or FieldArray.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray or structured np.ndarray</code> <p>The array of records to append. Must have named fields matching a subset of the current array's fields.</p> required"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.filtered","title":"filtered","text":"<pre><code>filtered(selector, *, copy=False)\n</code></pre> <p>Return a FieldArray containing only the selected records.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>array\u2011like, slice or int</code> <p>Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice. It is applied to the current valid part of the buffer (<code>self._data[:self._length]</code>).</p> required <code>copy</code> <code>bool</code> <ul> <li>False    (default) =&gt; the new array shares the same memory                          (changes propagate both ways).</li> <li>True           =&gt; the data are physically copied.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>FieldArray</code> <p>A new instance holding exactly <code>len(selector)</code> records and inheriting the current field\u2011infos.</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.from_bl_attributes","title":"from_bl_attributes","text":"<pre><code>from_bl_attributes(bl_attributes)\n</code></pre> <p>Import attributes from a Blender attribute collection.</p> <p>Reads geometry attributes from a Blender data-block and creates/updates the corresponding domain attributes, resizing the domain if needed.</p> <p>Parameters:</p> Name Type Description Default <code>bl_attributes</code> <code>Mapping[str, Any]</code> <p>Blender attributes collection (name \u2192 attribute descriptor) providing at least <code>.domain</code>, <code>.is_internal</code>, <code>.data_type</code>, and <code>.data</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Note:*** Only external (non-internal) Blender attributes matching this</code> <code>domain are imported. Missing attributes are created with `transfer=True`.</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Build a FieldArray from a dictionary with field data and optional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, array - like or (array, dict)]</code> <p>Mapping field names to arrays or (array, infos). Infos must include NAME.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the data. Default: True.</p> required <p>Returns:</p> Type Description <code>FieldArray</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> <p>Get attribute by name.</p> <p>If name is not an actual field, return default value. Name can be an array. <pre><code>pos = field_array.get(\"position\", (0, 0, 1))\npos = field_array.get([[0, 0, 1], [0, 0, 0]])\n</code></pre></p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other)\n</code></pre> <p>Merge trans-domain attributes from another domain.</p> <p>Copies or aligns attributes from <code>other</code> into the current domain, excluding any attributes not flagged as trans-domain in <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain or None</code> <p>Source domain. If <code>None</code>, the call is a no-op.</p> required <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.join_fields","title":"join_fields","text":"<pre><code>join_fields(other, exclude=[])\n</code></pre> <p>Add all missing fields from another FieldArray.</p> <p>For every field in <code>other</code> that is not present in <code>self</code>, a new field is created with the same dtype and shape, and initialized with its default value across all existing records.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray</code> <p>Another FieldArray instance whose fields will be checked for missing fields.</p> required <p>Returns:</p> Type Description <code>self</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.make_buckets","title":"make_buckets","text":"<pre><code>make_buckets(attr)\n</code></pre> <p>Group items into buckets by attribute value.</p> <p>When a domain is to be considered as a collection of packets of various sizes, buckets mechanism groups pakets by size, allowing further operation with numpy vectorization.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>array - like or str</code> <p>Either an integer of shape <code>(N,)</code> or the name of an existing integer attribute in the domain.</p> required <p>Returns:</p> Type Description <code>list[ndarray(count, n)]</code> <p>A list of int arrays (count, n): count is the number of buckets of length n.</p> <p>Examples:</p> <pre><code>buckets = mesh.make_buckets('material')\nfor bucket in buckets:\n    print(bucket.shape)\n</code></pre> <p>Note: The bucket attribute can be read with <code>attr[bucket[:, 0]]</code>.</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.multiply","title":"multiply","text":"<pre><code>multiply(count)\n</code></pre> <p>Duplicate the current records <code>count</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of times to repeat the current records.</p> required Notes <p>This duplicates the current valid records (up to self._length). If the array is empty or count &lt;= 1, nothing happens.</p> Example: <p>If the array has 3 records and count == 4, the result will be:</p> <p>[rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_attribute","title":"new_attribute","text":"<pre><code>new_attribute(name, data_type, default, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Register a new attribute in the domain schema.</p> <p>Creates (or ensures) an attribute with a given name, logical data type, default value, and flags controlling Blender transfer and cross-domain propagation.</p> <p>Note: <code>data_type</code> argument is a Blender data type not a python data type. The data type name is compatible with Blender internal storage. <code>FLOAT</code>data type is implemented as <code>np.float32</code> and  'INT' as <code>np.int32</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name (Python identifier recommended).</p> required <code>data_type</code> <code>(FLOAT, INT, BOOL, VECTOR, VECTOR2, COLOR, QUATERNION, MATRIX, STRING, ...)</code> <p>Logical data type used by the domain.</p> <code>'FLOAT'</code> <code>default</code> <code>Any</code> <p>Default value for newly allocated elements.</p> required <code>optional</code> <code>bool</code> <p>If <code>True</code>, the attribute may be absent on some elements.</p> <code>False</code> <code>transfer</code> <code>bool</code> <p>If <code>True</code>, eligible to be transferred to Blender as a geometry attribute.</p> <code>True</code> <code>transdom</code> <code>bool</code> <p>If <code>True</code>, considered a trans-domain attribute that can be copied across compatible domains.</p> <code>True</code> See Also <p><code>new_float</code>, <code>new_vector</code>, <code>new_int</code>, <code>new_bool</code>, <code>new_color</code>, <code>new_vector2</code>, <code>new_quaternion</code>, <code>new_matrix</code></p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_bool","title":"new_bool","text":"<pre><code>new_bool(name, default=False, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a boolean attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>bool</code> <p>Default value.</p> <code>False</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_color","title":"new_color","text":"<pre><code>new_color(name, default=(0.5, 0.5, 0.5, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a color attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,) or (4,)</code> <p>Default color as RGB or RGBA.</p> <code>(0.5, 0.5, 0.5, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_field","title":"new_field","text":"<pre><code>new_field(name, dtype, shape=None, default=0, optional=False, **infos)\n</code></pre> <p>Add a field to the structured array.</p> Arguments <pre><code>- name (str) : field name\n- dtype (type) : a valid numpy dtype\n- shape (tuple = None) : the shape of the field\n- default (any = 0) : default value\n- optional (bool = False) : the field is created only when accessed\n- infos (dict) : field infos\n</code></pre>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_float","title":"new_float","text":"<pre><code>new_float(name, default=0.0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a scalar float attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>float</code> <p>Default value.</p> <code>0.0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_int","title":"new_int","text":"<pre><code>new_int(name, default=0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure an integer attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>int</code> <p>Default value.</p> <code>0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_matrix","title":"new_matrix","text":"<pre><code>new_matrix(name, default=np.eye(4), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a matrix attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array - like</code> <p>Default matrix. By convention this is a square matrix per element (e.g., <code>(3, 3)</code> rotation or <code>(4, 4)</code> transform).</p> <code>np.eye(4)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code> <code>order</code> required"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_quaternion","title":"new_quaternion","text":"<pre><code>new_quaternion(name, default=(0.0, 0.0, 0.0, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a quaternion attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (4,)</code> <p>Default quaternion in <code>(x, y, z, w)</code> convention.</p> <code>(0.0, 0.0, 0.0, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_vector","title":"new_vector","text":"<pre><code>new_vector(name, default=(0.0, 0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 3D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,)</code> <p>Default XYZ vector.</p> <code>(0.0, 0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_vector2","title":"new_vector2","text":"<pre><code>new_vector2(name, default=(0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 2D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (2,)</code> <p>Default XY vector.</p> <code>(0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.to_bl_attributes","title":"to_bl_attributes","text":"<pre><code>to_bl_attributes(attributes, update=False)\n</code></pre> <p>Export attributes to a Blender attribute collection.</p> <p>Writes eligible domain attributes to a Blender data-block, creating missing attributes and adjusting sizes as needed.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Any</code> <p>Blender attributes collection receiving the values.</p> required <code>update</code> <code>bool</code> <p>If <code>True</code>, update existing attributes in-place; otherwise create them when missing.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Caution:*** Only attributes with `transfer=True` are exported. Optional</code> <code>attributes are skipped.</code> <code>&gt; ***Caution:*** Curve domains user attributes are not saved.</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.to_dict","title":"to_dict","text":"<pre><code>to_dict(*, copy=True, with_infos=True)\n</code></pre> <p>Convert the array to a dictionary of fields or (field, infos) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Whether to copy the arrays.</p> <code>True</code> <code>with_infos</code> <code>bool</code> <p>If True, return (array, infos) for each field.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, array or (array, dict)]</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.transfer_attributes","title":"transfer_attributes","text":"<pre><code>transfer_attributes(other, shape=None, other_shape=None)\n</code></pre> <p>Transfer values of trans-domain attributes from another domain.</p> <p>Copies values for each trans-domain attribute present in <code>other</code> into the corresponding attributes of <code>self</code>, with optional reshaping for batched assignments.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain</code> <p>Source domain providing attribute values.</p> required <code>shape</code> <code>tuple of int or None</code> <p>Target reshape for <code>self</code> before assignment. If <code>None</code>, uses <code>(self._length,)</code>.</p> <code>None</code> <code>other_shape</code> <code>tuple of int or None</code> <p>Source reshape for <code>other</code> before assignment. If <code>None</code>, uses <code>(other._length,)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p> <code>&gt; ***Note:*** Each attribute is reshaped as `shape + item_shape` on `self`</code> <code>and `other_shape + item_shape` on `other` prior to assignment.</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.transform","title":"transform","text":"<pre><code>transform(transfo, pivot=None)\n</code></pre> <p>Apply a linear transform to control points; rotate handles consistently.</p> <p>Applies the transform to <code>position</code> via <code>transform</code>. If Bezier handles are present, applies only the rotation part to <code>handle_left</code> and <code>handle_right</code> (i.e., scales are not applied to handles). Broadcasting is resolved with</p> <p>Parameters:</p> Name Type Description Default <code>transfo</code> <code>(Transformation, Quaternion or Rotation)</code> <p>The transformtion to apply</p> required <code>pivot</code> <code>array-like of shape ``(..., 3)`` or None</code> <p>Pivot location(s). If <code>None</code>, transforms are applied about the origin.</p> <code>None</code> <p>Returns:</p> Type Description <code>ControlPoint</code> <p>Self (for chaining).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the operand cannot be aligned with the domain size (raised by <code>_get_shape_for_operation</code>).</p> <code>TypeError</code> <p>If <code>transfo</code> does not support the <code>@</code> operator with vectors or lacks a usable <code>rotation</code> component for handle updates.</p> <p>Examples:</p> <pre><code># Per-point rotations (as 3x3 matrices)\nR = npblender.Rotation.from_euler(\"XYZ\", np.random.uniform(0, 1, (len(CP), 3))).as_matrix()\nCP.transform(R)\n\n# Rotate per-spline around per-spline pivot\nCP.transform(R_chunks, pivot=pivots)\n</code></pre>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.translate","title":"translate","text":"<pre><code>translate(translation)\n</code></pre> <p>Translate points position by a vector or a batch of vectors.</p> <p>Supports per-domain translation (single vector), or grouped/batched translations that broadcast over buckets of equal size.</p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>array-like of shape ``(..., 3)``</code> <p>Translation vectors broadcastable to the domain size.</p> required <p>Returns:</p> Type Description <code>PointDomain</code> <p>Self (for chaining).</p> <p>Examples:</p> <pre><code># Per-point random translation\nD.translate(np.random.uniform(-0.1, 0.1, (len(D), 3)))\n\n```python\n# A mesh made of 8 cubes\ncubes = Mesh.cube(size=.2)*8\ntr = np.random.uniform(-1, 1, (8, 3))\n# Translate each cube individually\ncubes.points.translate(tr)\n</code></pre> <p>Caution: If a provided batch cannot be aligned with the domain, a <code>ValueError</code> is raised by <code>_get_shape_for_operation</code>.</p>"},{"location":"api/corner/","title":"Corner","text":""},{"location":"api/corner/#npblender.domain.Corner","title":"Corner","text":"<pre><code>Corner(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>Mesh corner (loop) domain.</p> <p>Stores, for each corner of each face, the index of the associated vertex and optional per-corner attributes (e.g., UVs).</p> <p>Attributes:</p> Name Type Description <code>vertex_index</code> <code>(M,) int</code> <p>Index of the referenced vertex in the point (vertex) array.</p> <code>UVMap</code> <code>(M, 2) float, optional</code> <p>UV coordinates (you may create additional maps via :meth:<code>new_uvmap</code>).</p> <p>Methods:</p> Name Description <code>check</code> <p>Validate that all vertex indices are &lt; <code>count</code>.</p> <code>new_uvmap</code> <p>Create and optionally initialize a new UV map attribute.</p> <code>compute_attribute_on_points</code> <p>Average a per-corner attribute back to points (vertices).</p> <p>Examples:</p> <p>Create a second UV map:</p> <pre><code>corners.new_uvmap(\"UV2\", value=(0.0, 0.0))\n</code></pre> <p>Accumulate per-corner shading to vertices:</p> <pre><code>v_attr = corners.compute_attribute_on_points(\"illum\", points)\n</code></pre> <p>Initialize a domain array and its attribute schema.</p> <p>Initializes the storage from an existing array/domain or creates an empty structure. Optionally merges attribute definitions/values from another domain and keyword-provided attributes.</p> <p>Domains are never instancied directly but by owning geometries.</p> <p>Actual Domains are <code>Vertex</code>, [<code>Faces</code>][npblender.domain.Faces], <code>Corner</code>, <code>Edge</code>, <code>ControlPoint</code>, <code>Spline</code> and <code>Point</code>.</p> <p>Domains are initialized with their defaults attributes, for instance <code>position</code> for point domaines.</p> <p>Use attributes can be freely added. </p> <p>Note: user attributes are saved in Blender Mesh objects only, Blender Curve objects don't store user attributes.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>array - like or FieldArray or None</code> <p>Source data used to initialize the domain. If <code>None</code>, an empty domain is created and <code>_declare_attributes()</code> is called to register defaults.</p> <code>None</code> <code>mode</code> <code>(COPY, CAPTURE, EMPTY)</code> <p>Initialization mode. <code>'COPY'</code> duplicates the input data, <code>'CAPTURE'</code> references the input buffer when supported, <code>'EMPTY'</code> creates the structure without copying values.</p> <code>'COPY'</code> <code>selector</code> <code>Any</code> <p>Optional row/element selector applied to <code>a</code> prior to initialization.</p> <code>None</code> <code>attr_from</code> <code>Domain or Mapping or None</code> <p>Attribute schema (and possibly values) to merge into this domain.</p> <code>None</code> <code>**attrs</code> <p>Additional attribute name/value pairs to inject or override.</p> <code>{}</code> Notes <p>The effective attribute list results from <code>_declare_attributes()</code>, then <code>attr_from</code>, then <code>**attrs</code> (later entries take precedence).</p> <p>Examples:</p> <pre><code>cube = Mesh.cube() # points, corners, faces and edges domains are created\n# Adding named attribute to point domain\ncube.points.new_float('age')\n# Setting the age\ncube.points.age = np.random.uniforme(10, 10, len(cube.points))\n</code></pre>"},{"location":"api/corner/#npblender.domain.Corner.actual_names","title":"actual_names  <code>property</code>","text":"<pre><code>actual_names\n</code></pre> <p>Column names.</p> <p>Returns the actual field names, excluding optional fields.</p>"},{"location":"api/corner/#npblender.domain.Corner.all_names","title":"all_names  <code>property</code>","text":"<pre><code>all_names\n</code></pre> <p>Column names.</p> <p>Returns all the field names, including optional ones.</p>"},{"location":"api/corner/#npblender.domain.Corner.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Array structured dtype</p> <p>Returns the dtype property of the structured array.</p>"},{"location":"api/corner/#npblender.domain.Corner.transdom_names","title":"transdom_names  <code>property</code>","text":"<pre><code>transdom_names\n</code></pre> <p>List the names of trans-domain attributes.</p> <p>Returns:</p> Type Description <code>list of str</code> <p>Names of attributes flagged with <code>transdom=True</code>.</p> <p>Examples:</p> <pre><code>names = D.transdom_names()\n</code></pre>"},{"location":"api/corner/#npblender.domain.Corner.add","title":"add","text":"<pre><code>add(count, **fields)\n</code></pre> <p>Add count records</p> <p>New records are set with default values or values provided by the user in fields dict.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of records to add.</p> required <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/corner/#npblender.domain.Corner.append","title":"append","text":"<pre><code>append(**fields)\n</code></pre> <p>Append values to the structured array.</p> <p>The number of records to append is determined by the number of fields provided in the fields dictionary. The values of the fields are copied to the new records.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/corner/#npblender.domain.Corner.as_kwargs","title":"as_kwargs","text":"<pre><code>as_kwargs(selector=None, include=None, exclude=None)\n</code></pre> <p>Return a dictionary of field values formatted as kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>slice, int, list, or mask</code> <p>Optional selection of elements to extract.</p> <code>None</code> <code>include</code> <code>list[str]</code> <p>List of field names (original or python names) to include.</p> <code>None</code> <code>exclude</code> <code>list[str]</code> <p>List of field names (original or python names) to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Mapping from python-safe field names to array values.</p>"},{"location":"api/corner/#npblender.domain.Corner.check","title":"check","text":"<pre><code>check(count, halt=True)\n</code></pre> <p>Validate corner indices against a vertex count.</p> <p>Verifies that all entries of <code>vertex_index</code> reference valid vertices (i.e., are strictly less than <code>count</code>). When invalid indices are detected, either raises or logs an error depending on <code>halt</code>.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of vertices in the referenced point/vertex domain.</p> required <code>halt</code> <code>bool</code> <p>If <code>True</code>, raise on failure; otherwise print a message and return <code>False</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the check passes or the domain is empty; <code>False</code> only when invalid and <code>halt</code> is <code>False</code>.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If invalid indices are found and <code>halt</code> is <code>True</code>.</p> <p>Examples:</p> <pre><code>ok = corners.check(count=len(vertices), halt=False)\nif not ok:\n    # fix topology or filter invalid corners\n    ...\n</code></pre>"},{"location":"api/corner/#npblender.domain.Corner.compute_attribute_on_points","title":"compute_attribute_on_points","text":"<pre><code>compute_attribute_on_points(attr, points)\n</code></pre> <p>Average a per-corner attribute back to points (vertices).</p> <p>For each vertex, computes the mean of the source attribute over all incident corners (as defined by <code>vertex_index</code>). The attribute is validated with <code>_check_attribute_to_compute</code>.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str or ndarray, shape ``(M, ...)``</code> <p>Corner attribute to average. If a string, the field is looked up on this domain; if an array, it must have length <code>M == len(self)</code>. The trailing item shape (<code>...</code>) is preserved.</p> required <code>points</code> <code>Vertex</code> <p>Vertex domain used to size the result (<code>len(points)</code>).</p> required <p>Returns:</p> Type Description <code>ndarray, shape ``(len(points), ...)``</code> <p>Per-vertex averaged attribute. The trailing item shape is preserved and the dtype follows the input attribute.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>attr</code> is scalar or its first dimension does not match <code>len(self)</code> (raised by <code>_check_attribute_to_compute</code>).</p> <code>IndexError</code> <p>If <code>vertex_index</code> contains indices outside <code>[0, len(points))</code>.</p> <code>TypeError</code> <p>If the attribute dtype cannot be averaged (e.g., non-numeric types).</p> Notes <p>This routine computes an unweighted arithmetic mean per vertex over all incident corners.</p> <p>Examples:</p> <pre><code># Accumulate per-corner illumination to vertices\nv_illum = corners.compute_attribute_on_points(\"illum\", vertices)\n\n# Average custom corner vectors per vertex\nv_vec = corners.compute_attribute_on_points(corner_vecs, vertices)\n</code></pre>"},{"location":"api/corner/#npblender.domain.Corner.copy_field","title":"copy_field","text":"<pre><code>copy_field(field_name, new_name, **infos)\n</code></pre> <p>Duplicate an existing field under a new name, with optional metadata overrides.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the existing field to copy.</p> required <code>new_name</code> <code>str</code> <p>The name of the new field to create.</p> required <code>infos</code> <code>keyword arguments</code> <p>Optional metadata (e.g. default, unit, description...) to override or supplement the original field's metadata.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the source field does not exist.</p> <code>ValueError</code> <p>If the target name already exists or is reserved.</p>"},{"location":"api/corner/#npblender.domain.Corner.delete","title":"delete","text":"<pre><code>delete(index)\n</code></pre> <p>Delete a selection of items from the array.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int, slice, or array-like</code> <p>The indices of the elements to delete from the current data.</p> required Notes <p>This operates only on the valid range <code>[0:self._length]</code>. The internal buffer is preserved (no reallocation).</p>"},{"location":"api/corner/#npblender.domain.Corner.dump","title":"dump","text":"<pre><code>dump(title='Dump', attributes=None, target='SCREEN')\n</code></pre> <p>Pretty-print or export domain content.</p> <p>Formats attribute values and prints to screen or builds a tabular dump suitable for spreadsheets.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title displayed in the report.</p> <code>'Dump'</code> <code>attributes</code> <code>Sequence[str] or None</code> <p>Subset of attribute names to include. If <code>None</code>, all attributes are shown.</p> <code>None</code> <code>target</code> <code>(SCREEN, ...)</code> <p>Output target. <code>'SCREEN'</code> prints to stdout; other targets may trigger file creation depending on the implementation.</p> <code>'SCREEN'</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>Domain(points).dump(title=\"Vertices\")\n</code></pre> <p>Note: Formatting adapts to the chosen <code>target</code>.</p>"},{"location":"api/corner/#npblender.domain.Corner.extend","title":"extend","text":"<pre><code>extend(other, join_fields=True)\n</code></pre> <p>Append multiple records from another array or FieldArray.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray or structured np.ndarray</code> <p>The array of records to append. Must have named fields matching a subset of the current array's fields.</p> required"},{"location":"api/corner/#npblender.domain.Corner.filtered","title":"filtered","text":"<pre><code>filtered(selector, *, copy=False)\n</code></pre> <p>Return a FieldArray containing only the selected records.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>array\u2011like, slice or int</code> <p>Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice. It is applied to the current valid part of the buffer (<code>self._data[:self._length]</code>).</p> required <code>copy</code> <code>bool</code> <ul> <li>False    (default) =&gt; the new array shares the same memory                          (changes propagate both ways).</li> <li>True           =&gt; the data are physically copied.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>FieldArray</code> <p>A new instance holding exactly <code>len(selector)</code> records and inheriting the current field\u2011infos.</p>"},{"location":"api/corner/#npblender.domain.Corner.from_bl_attributes","title":"from_bl_attributes","text":"<pre><code>from_bl_attributes(bl_attributes)\n</code></pre> <p>Import attributes from a Blender attribute collection.</p> <p>Reads geometry attributes from a Blender data-block and creates/updates the corresponding domain attributes, resizing the domain if needed.</p> <p>Parameters:</p> Name Type Description Default <code>bl_attributes</code> <code>Mapping[str, Any]</code> <p>Blender attributes collection (name \u2192 attribute descriptor) providing at least <code>.domain</code>, <code>.is_internal</code>, <code>.data_type</code>, and <code>.data</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Note:*** Only external (non-internal) Blender attributes matching this</code> <code>domain are imported. Missing attributes are created with `transfer=True`.</code>"},{"location":"api/corner/#npblender.domain.Corner.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Build a FieldArray from a dictionary with field data and optional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, array - like or (array, dict)]</code> <p>Mapping field names to arrays or (array, infos). Infos must include NAME.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the data. Default: True.</p> required <p>Returns:</p> Type Description <code>FieldArray</code>"},{"location":"api/corner/#npblender.domain.Corner.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> <p>Get attribute by name.</p> <p>If name is not an actual field, return default value. Name can be an array. <pre><code>pos = field_array.get(\"position\", (0, 0, 1))\npos = field_array.get([[0, 0, 1], [0, 0, 0]])\n</code></pre></p>"},{"location":"api/corner/#npblender.domain.Corner.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other)\n</code></pre> <p>Merge trans-domain attributes from another domain.</p> <p>Copies or aligns attributes from <code>other</code> into the current domain, excluding any attributes not flagged as trans-domain in <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain or None</code> <p>Source domain. If <code>None</code>, the call is a no-op.</p> required <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p>"},{"location":"api/corner/#npblender.domain.Corner.join_fields","title":"join_fields","text":"<pre><code>join_fields(other, exclude=[])\n</code></pre> <p>Add all missing fields from another FieldArray.</p> <p>For every field in <code>other</code> that is not present in <code>self</code>, a new field is created with the same dtype and shape, and initialized with its default value across all existing records.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray</code> <p>Another FieldArray instance whose fields will be checked for missing fields.</p> required <p>Returns:</p> Type Description <code>self</code>"},{"location":"api/corner/#npblender.domain.Corner.make_buckets","title":"make_buckets","text":"<pre><code>make_buckets(attr)\n</code></pre> <p>Group items into buckets by attribute value.</p> <p>When a domain is to be considered as a collection of packets of various sizes, buckets mechanism groups pakets by size, allowing further operation with numpy vectorization.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>array - like or str</code> <p>Either an integer of shape <code>(N,)</code> or the name of an existing integer attribute in the domain.</p> required <p>Returns:</p> Type Description <code>list[ndarray(count, n)]</code> <p>A list of int arrays (count, n): count is the number of buckets of length n.</p> <p>Examples:</p> <pre><code>buckets = mesh.make_buckets('material')\nfor bucket in buckets:\n    print(bucket.shape)\n</code></pre> <p>Note: The bucket attribute can be read with <code>attr[bucket[:, 0]]</code>.</p>"},{"location":"api/corner/#npblender.domain.Corner.multiply","title":"multiply","text":"<pre><code>multiply(count)\n</code></pre> <p>Duplicate the current records <code>count</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of times to repeat the current records.</p> required Notes <p>This duplicates the current valid records (up to self._length). If the array is empty or count &lt;= 1, nothing happens.</p> Example: <p>If the array has 3 records and count == 4, the result will be:</p> <p>[rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]</p>"},{"location":"api/corner/#npblender.domain.Corner.new_attribute","title":"new_attribute","text":"<pre><code>new_attribute(name, data_type, default, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Register a new attribute in the domain schema.</p> <p>Creates (or ensures) an attribute with a given name, logical data type, default value, and flags controlling Blender transfer and cross-domain propagation.</p> <p>Note: <code>data_type</code> argument is a Blender data type not a python data type. The data type name is compatible with Blender internal storage. <code>FLOAT</code>data type is implemented as <code>np.float32</code> and  'INT' as <code>np.int32</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name (Python identifier recommended).</p> required <code>data_type</code> <code>(FLOAT, INT, BOOL, VECTOR, VECTOR2, COLOR, QUATERNION, MATRIX, STRING, ...)</code> <p>Logical data type used by the domain.</p> <code>'FLOAT'</code> <code>default</code> <code>Any</code> <p>Default value for newly allocated elements.</p> required <code>optional</code> <code>bool</code> <p>If <code>True</code>, the attribute may be absent on some elements.</p> <code>False</code> <code>transfer</code> <code>bool</code> <p>If <code>True</code>, eligible to be transferred to Blender as a geometry attribute.</p> <code>True</code> <code>transdom</code> <code>bool</code> <p>If <code>True</code>, considered a trans-domain attribute that can be copied across compatible domains.</p> <code>True</code> See Also <p><code>new_float</code>, <code>new_vector</code>, <code>new_int</code>, <code>new_bool</code>, <code>new_color</code>, <code>new_vector2</code>, <code>new_quaternion</code>, <code>new_matrix</code></p>"},{"location":"api/corner/#npblender.domain.Corner.new_bool","title":"new_bool","text":"<pre><code>new_bool(name, default=False, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a boolean attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>bool</code> <p>Default value.</p> <code>False</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/corner/#npblender.domain.Corner.new_color","title":"new_color","text":"<pre><code>new_color(name, default=(0.5, 0.5, 0.5, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a color attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,) or (4,)</code> <p>Default color as RGB or RGBA.</p> <code>(0.5, 0.5, 0.5, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/corner/#npblender.domain.Corner.new_field","title":"new_field","text":"<pre><code>new_field(name, dtype, shape=None, default=0, optional=False, **infos)\n</code></pre> <p>Add a field to the structured array.</p> Arguments <pre><code>- name (str) : field name\n- dtype (type) : a valid numpy dtype\n- shape (tuple = None) : the shape of the field\n- default (any = 0) : default value\n- optional (bool = False) : the field is created only when accessed\n- infos (dict) : field infos\n</code></pre>"},{"location":"api/corner/#npblender.domain.Corner.new_float","title":"new_float","text":"<pre><code>new_float(name, default=0.0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a scalar float attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>float</code> <p>Default value.</p> <code>0.0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/corner/#npblender.domain.Corner.new_int","title":"new_int","text":"<pre><code>new_int(name, default=0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure an integer attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>int</code> <p>Default value.</p> <code>0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/corner/#npblender.domain.Corner.new_matrix","title":"new_matrix","text":"<pre><code>new_matrix(name, default=np.eye(4), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a matrix attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array - like</code> <p>Default matrix. By convention this is a square matrix per element (e.g., <code>(3, 3)</code> rotation or <code>(4, 4)</code> transform).</p> <code>np.eye(4)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code> <code>order</code> required"},{"location":"api/corner/#npblender.domain.Corner.new_quaternion","title":"new_quaternion","text":"<pre><code>new_quaternion(name, default=(0.0, 0.0, 0.0, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a quaternion attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (4,)</code> <p>Default quaternion in <code>(x, y, z, w)</code> convention.</p> <code>(0.0, 0.0, 0.0, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/corner/#npblender.domain.Corner.new_uvmap","title":"new_uvmap","text":"<pre><code>new_uvmap(name, value=None)\n</code></pre> <p>Create (and optionally initialize) a per-corner UV map.</p> <p>Declares a new 2D UV attribute with the given <code>name</code>. If <code>value</code> is provided, assigns it to the whole array (broadcast rules apply).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name for the UV map.</p> required <code>value</code> <code>array-like of shape ``(2,)`` or ``(M, 2)`` or None</code> <p>Initial UV values; broadcastable to the corner count.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>value</code> cannot be broadcast to shape <code>(M, 2)</code>.</p> <code>TypeError</code> <p>If <code>value</code> has an incompatible dtype.</p> See Also <p><code>new_vector2</code> :     Registers a 2D vector attribute.</p>"},{"location":"api/corner/#npblender.domain.Corner.new_vector","title":"new_vector","text":"<pre><code>new_vector(name, default=(0.0, 0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 3D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,)</code> <p>Default XYZ vector.</p> <code>(0.0, 0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/corner/#npblender.domain.Corner.new_vector2","title":"new_vector2","text":"<pre><code>new_vector2(name, default=(0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 2D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (2,)</code> <p>Default XY vector.</p> <code>(0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/corner/#npblender.domain.Corner.to_bl_attributes","title":"to_bl_attributes","text":"<pre><code>to_bl_attributes(attributes, update=False)\n</code></pre> <p>Export attributes to a Blender attribute collection.</p> <p>Writes eligible domain attributes to a Blender data-block, creating missing attributes and adjusting sizes as needed.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Any</code> <p>Blender attributes collection receiving the values.</p> required <code>update</code> <code>bool</code> <p>If <code>True</code>, update existing attributes in-place; otherwise create them when missing.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Caution:*** Only attributes with `transfer=True` are exported. Optional</code> <code>attributes are skipped.</code> <code>&gt; ***Caution:*** Curve domains user attributes are not saved.</code>"},{"location":"api/corner/#npblender.domain.Corner.to_dict","title":"to_dict","text":"<pre><code>to_dict(*, copy=True, with_infos=True)\n</code></pre> <p>Convert the array to a dictionary of fields or (field, infos) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Whether to copy the arrays.</p> <code>True</code> <code>with_infos</code> <code>bool</code> <p>If True, return (array, infos) for each field.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, array or (array, dict)]</code>"},{"location":"api/corner/#npblender.domain.Corner.transfer_attributes","title":"transfer_attributes","text":"<pre><code>transfer_attributes(other, shape=None, other_shape=None)\n</code></pre> <p>Transfer values of trans-domain attributes from another domain.</p> <p>Copies values for each trans-domain attribute present in <code>other</code> into the corresponding attributes of <code>self</code>, with optional reshaping for batched assignments.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain</code> <p>Source domain providing attribute values.</p> required <code>shape</code> <code>tuple of int or None</code> <p>Target reshape for <code>self</code> before assignment. If <code>None</code>, uses <code>(self._length,)</code>.</p> <code>None</code> <code>other_shape</code> <code>tuple of int or None</code> <p>Source reshape for <code>other</code> before assignment. If <code>None</code>, uses <code>(other._length,)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p> <code>&gt; ***Note:*** Each attribute is reshaped as `shape + item_shape` on `self`</code> <code>and `other_shape + item_shape` on `other` prior to assignment.</code>"},{"location":"api/curve/","title":"Curve","text":""},{"location":"api/curve/#npblender.curve.Curve","title":"Curve","text":"<pre><code>Curve(points=None, splines=None, curve_type=POLY, materials=None, attr_from=None, **attrs)\n</code></pre> <p>               Bases: <code>Geometry</code></p> <p>Construct a curve geometry.</p> <p>Initializes empty domains by default, or builds a curve from provided control points and spline sizes/types. If both <code>points</code> and <code>splines</code> are already instances of <code>ControlPoint</code> and <code>Spline</code>, the curve is created as a view on these domains (no data copy). Otherwise, domains are allocated and populated via <code>add_splines</code>.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like or [`ControlPoint`](npblender.domain.ControlPoint)</code> <p>Control-point positions (and optional per-point attributes) used to populate the curve. If a <code>ControlPoint</code> domain is provided together with a <code>Spline</code> domain, the curve becomes a view on them.</p> <code>None</code> <code>splines</code> <code>array-like or [`Spline`](npblender.domain.Spline)</code> <p>Per-spline control-point counts (when building), or a ready-made <code>Spline</code> domain (to create a view).</p> <code>None</code> <code>curve_type</code> <code>int</code> <p>Default spline type for construction. One of <code>POLY</code>, <code>BEZIER</code>, <code>NURBS</code>. Ignored when <code>points</code>/<code>splines</code> are full domains.</p> <code>POLY</code> <code>materials</code> <code>str or sequence of str</code> <p>Material names used by the curve. A single string is accepted and promoted to a one-element list.</p> <code>None</code> <code>attr_from</code> <code>object</code> <p>Source whose transferable attributes are joined into this geometry (see <code>join_attributes</code>).</p> <code>None</code> <code>**attrs</code> <p>Additional geometry attributes to forward to <code>add_splines</code> during construction.</p> <code>{}</code> Notes <ul> <li>When <code>points</code> and <code>splines</code> are provided as domains, the instance is a view: <code>self.is_view</code> is <code>True</code> if the sum of <code>splines.loop_total</code> differs from <code>len(points)</code>. Use <code>no_view</code> to materialize a standalone copy. :contentReference[oaicite:0]{index=0}</li> <li>Otherwise, the constructor allocates empty <code>ControlPoint</code> and <code>Spline</code> domains, joins attributes from <code>attr_from</code> if any, then calls <code>add_splines</code>. :contentReference[oaicite:1]{index=1}</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>Propagated from <code>add_splines</code> when <code>curve_type</code> is not a single value (e.g., a list). :contentReference[oaicite:2]{index=2}</p>"},{"location":"api/curve/#npblender.curve.Curve.bounding_box","title":"bounding_box  <code>property</code>","text":"<pre><code>bounding_box\n</code></pre> <p>Axis-aligned bounding box of the point positions.</p> <p>Returns:</p> Type Description <code>tuple of numpy.ndarray</code> <p><code>(min_xyz, max_xyz)</code>. If empty, returns two zero vectors.</p>"},{"location":"api/curve/#npblender.curve.Curve.bounding_box_dims","title":"bounding_box_dims  <code>property</code>","text":"<pre><code>bounding_box_dims\n</code></pre> <p>Extents of the axis-aligned bounding box.</p> <p>Returns:</p> Type Description <code>numpy.ndarray of shape (3,)</code> <p><code>max_xyz - min_xyz</code>.</p>"},{"location":"api/curve/#npblender.curve.Curve.length","title":"length  <code>property</code>","text":"<pre><code>length\n</code></pre> <p>Lengths of splines.</p> <p>Returns:</p> Type Description <code>array of floats</code>"},{"location":"api/curve/#npblender.curve.Curve.max_size","title":"max_size  <code>property</code>","text":"<pre><code>max_size\n</code></pre> <p>Maximum dimension of the bounding box.</p> <p>Returns:</p> Type Description <code>float</code> <p><code>max(bounding_box_dims)</code>.</p>"},{"location":"api/curve/#npblender.curve.Curve.add_bezier","title":"add_bezier","text":"<pre><code>add_bezier(points, splines=None, handle_left=None, handle_right=None, cyclic=False, **attrs)\n</code></pre> <p>Append Bezier spline(s).</p> <p>The arguments <code>splines</code> gives the length(s) of the bezier spline(s). If None: - the number of points is taken (one spline is added) - points.shape[1] is taken if the shape of points is (m, , 3)</p> <p>handle_left and handle_right must have the same shape as points if provided. If they aren't provided, they are computed.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>(ndarray, shape(N, 3) or (B, N, 3))</code> <p>Anchor positions (single spline or a batch).</p> required <code>splines</code> <code>int or 1D array of int or None</code> <p>Per-spline point counts. If <code>None</code>, inferred from <code>points</code>.</p> <code>None</code> <code>handle_left</code> <code>ndarray or None</code> <p>Left handles (same shape as <code>points</code>). Computed if omitted.</p> <code>None</code> <code>handle_right</code> <code>ndarray or None</code> <p>Right handles (same shape as <code>points</code>). Computed if omitted.</p> <code>None</code> <code>cyclic</code> <code>bool or 1D array of bool</code> <p>Whether each spline is closed (broadcastable to number of splines).</p> <code>False</code> <code>**attrs</code> <p>Additional attributes dispatched to points/splines.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Indices of appended points and splines.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>points</code> last dimension is not 3, or if handle shapes don\u2019t match.</p>"},{"location":"api/curve/#npblender.curve.Curve.add_materials","title":"add_materials","text":"<pre><code>add_materials(materials)\n</code></pre> <p>Append material name(s) to the geometry.</p> <p>Parameters:</p> Name Type Description Default <code>materials</code> <code>str or sequence of str</code> <p>One name or a sequence of names to append.</p> required <p>Returns:</p> Type Description <code>None</code> Notes <p>This method does not deduplicate names; duplicates may be appended.</p>"},{"location":"api/curve/#npblender.curve.Curve.add_poly","title":"add_poly","text":"<pre><code>add_poly(points, splines=None, curve_type=POLY, cyclic=False, w=1.0, **attrs)\n</code></pre> <p>Append Poly or NURBS spline(s).</p> <p>The arguments 'splines' gives the length(s) of the spline(s). If None: - the number of points is taken (one spline is added) - points.shape[1] is taken if the shape of points is (m, , 3)</p> <p>Non bezeier splines use 4D points. If the provided vectors are 4D, the argument w is ignored.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>Either <code>(N, 3|4)</code> or <code>(B, N, 3|4)</code>. If 4D, the 4th component is used as w.</p> required <code>splines</code> <code>int or 1D array of int or None</code> <p>Per-spline point counts. If <code>None</code>, inferred from <code>points</code>.</p> <code>None</code> <code>curve_type</code> <code>int</code> <p>[<code>POLY</code>][npblender.constants.POLY] or [<code>NURBS</code>][npblender.constants.NURBS].</p> <code>POLY</code> <code>cyclic</code> <code>bool or 1D array of bool</code> <p>Whether each spline is closed.</p> <code>False</code> <code>w</code> <code>float</code> <p>Default weight if <code>points</code> are 3D.</p> <code>1.0</code> <code>**attrs</code> <p>Additional attributes dispatched to points/splines.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Indices of appended points and splines.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>points</code> are neither 3D nor 4D vectors.</p>"},{"location":"api/curve/#npblender.curve.Curve.add_splines","title":"add_splines","text":"<pre><code>add_splines(points=None, splines=None, curve_type=POLY, **attrs)\n</code></pre> <p>Append new splines (Bezier, Poly, or NURBS) with their control points.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray or None</code> <p>Control-point coordinates. Shape depends on <code>splines</code> (see <code>add_bezier</code> and <code>add_poly</code>).</p> <code>None</code> <code>splines</code> <code>int or 1D array of int or None</code> <p>Per-spline sizes. If <code>None</code>, inferred from <code>points</code> shape.</p> <code>None</code> <code>curve_type</code> <code>int</code> <p>One of [<code>BEZIER</code>][npblender.constants.BEZIER], [<code>POLY</code>][npblender.constants.POLY], [<code>NURBS</code>][npblender.constants.NURBS].</p> <code>POLY</code> <code>**attrs</code> <p>Mixed per-point and per-spline attributes to broadcast and assign.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Keys <code>'points'</code> and <code>'splines'</code> with the indices of appended rows.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>curve_type</code> is not a single scalar value.</p>"},{"location":"api/curve/#npblender.curve.Curve.apply_scale","title":"apply_scale","text":"<pre><code>apply_scale(scale, pivot=None)\n</code></pre> <p>Scale points (convenience wrapper).</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>ndarray</code> <p>Per-point or broadcastable scales.</p> required <code>pivot</code> <code>ndarray</code> <p>Optional pivot(s) for scaling.</p> <code>None</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/curve/#npblender.curve.Curve.arc","title":"arc  <code>classmethod</code>","text":"<pre><code>arc(resolution=16, radius=1.0, start_angle=0.0, sweep_angle=7 * np.pi / 4, connect_center=False, invert_arc=False)\n</code></pre> <p>Build a polyline arc in the XY plane.</p> <p>The arc is sampled uniformly with <code>resolution</code> points between <code>start_angle</code> and <code>start_angle + sweep_angle</code>. If <code>invert_arc</code> is True, the parameterization is reversed (clockwise), producing the same locus but with swapped start/end angles. When <code>connect_center</code> is True, the center <code>(0, 0, 0)</code> is appended, and the spline is marked as cyclic to form a pie slice.</p> <p>Parameters:</p> Name Type Description Default <code>resolution</code> <code>int</code> <p>Number of samples along the arc (min 2).</p> <code>16</code> <code>radius</code> <code>float</code> <p>Arc radius.</p> <code>1.0</code> <code>start_angle</code> <code>float</code> <p>Start angle in radians.</p> <code>0.0</code> <code>sweep_angle</code> <code>float</code> <p>Signed sweep angle in radians.</p> <code>7\u03c0/4</code> <code>connect_center</code> <code>bool</code> <p>If True, append the origin and mark the spline cyclic (pie slice).</p> <code>False</code> <code>invert_arc</code> <code>bool</code> <p>If True, reverse the arc direction (clockwise).</p> <code>False</code> <p>Returns:</p> Type Description <code>Curve</code> <p>A curve with one POLY spline sampled in the XY plane.</p> See Also <p>Curve.circle, Curve.bezier_circle</p>"},{"location":"api/curve/#npblender.curve.Curve.bezier_circle","title":"bezier_circle  <code>classmethod</code>","text":"<pre><code>bezier_circle()\n</code></pre> <p>Unit circle approximated by 4 cubic Bezier arcs (cyclic).</p> <p>Returns:</p> Type Description <code>Curve</code> <p>Bezier circle with pre-set handles.</p>"},{"location":"api/curve/#npblender.curve.Curve.bezier_segment","title":"bezier_segment  <code>classmethod</code>","text":"<pre><code>bezier_segment(resolution=16, start=(-1, 0, 0), start_handle=(-0.5, 0.5, 0), end_handle=(0, 0, 0), end=(1, 0, 0))\n</code></pre> <p>Create a single two-point Bezier segment.</p> <p>Produces a Bezier spline with two control points located at <code>start</code> and <code>end</code>. The left/right handles are set from <code>start_handle</code> and <code>end_handle</code> (mirrored appropriately). The <code>resolution</code> argument is accepted for API symmetry but not used at construction; sampling and evaluation rely on the per-spline <code>resolution</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>resolution</code> <code>int</code> <p>Kept for API symmetry; not used during construction.</p> <code>16</code> <code>start</code> <code>(3,) float</code> <p>Start control point.</p> <code>(-1, 0, 0)</code> <code>start_handle</code> <code>(3,) float</code> <p>Handle associated to the start point (as right handle).</p> <code>(-0.5, 0.5, 0)</code> <code>end_handle</code> <code>(3,) float</code> <p>Handle associated to the end point (as left handle).</p> <code>(0, 0, 0)</code> <code>end</code> <code>(3,) float</code> <p>End control point.</p> <code>(1, 0, 0)</code> <p>Returns:</p> Type Description <code>Curve</code> <p>A curve with one BEZIER spline (open).</p> Notes <p>Handles are applied as: - <code>handle_right[0] = start_handle</code> - <code>handle_left[1]  = end_handle</code> The opposite handles are mirrored so that each handle is expressed in absolute coordinates.</p>"},{"location":"api/curve/#npblender.curve.Curve.blender_data","title":"blender_data","text":"<pre><code>blender_data(readonly=False)\n</code></pre> <p>Temporary access to a transient Blender <code>Curve</code> datablock.</p> <p>Yields a throwaway curve data populated from this instance; upon exit, reads back into <code>self</code> unless <code>readonly=True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>readonly</code> <code>bool</code> <p>If True, do not read back any change made to the temporary data.</p> <code>False</code> <p>Yields:</p> Type Description <code>Curve</code> <p>The temporary curve data.</p> <p>Examples:</p> <pre><code>curve = Curve.Spiral()\nwith curve.blender_data() as bcurve:\n    print(\"Number of points\", len(bcurve.splines[0].points))\n</code></pre>"},{"location":"api/curve/#npblender.curve.Curve.capture","title":"capture","text":"<pre><code>capture(other)\n</code></pre> <p>Capture another curve\u2019s buffers (no copy).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Curve</code> <p>Source whose internal buffers are adopted by this instance.</p> required <p>Returns:</p> Type Description <code>Curve</code> <p>Self.</p>"},{"location":"api/curve/#npblender.curve.Curve.check","title":"check","text":"<pre><code>check(title='Mesh Check', halt=True)\n</code></pre> <p>Validate internal spline bookkeeping.</p> <p>Delegates to <code>Spline.check</code>. When invalid and <code>halt=True</code>, raises; otherwise prints a message.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Label used in error messages.</p> <code>\"Mesh Check\"</code> <code>halt</code> <code>bool</code> <p>Whether to raise on failure.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if valid.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the check fails and <code>halt=True</code>.</p>"},{"location":"api/curve/#npblender.curve.Curve.circle","title":"circle  <code>classmethod</code>","text":"<pre><code>circle(resolution=32, radius=1.0)\n</code></pre> <p>Regular polygonal approximation of a circle (Poly, cyclic).</p> <p>Parameters:</p> Name Type Description Default <code>resolution</code> <code>int</code> <p>Number of points.</p> <code>32</code> <code>radius</code> <code>float</code> <p>Circle radius.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Curve</code>"},{"location":"api/curve/#npblender.curve.Curve.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Remove all points and splines (attributes kept, values cleared).</p> <p>Returns:</p> Type Description <code>None</code>"},{"location":"api/curve/#npblender.curve.Curve.compute_attribute_on_domain","title":"compute_attribute_on_domain","text":"<pre><code>compute_attribute_on_domain(domain_from, attr, domain_to)\n</code></pre> <p>Transfer an attribute from one domain to another.</p> <p>Performs a domain mapping (e.g., points \u2192 faces) using the appropriate domain operator, and returns the computed array on the target domain.</p> <p>Parameters:</p> Name Type Description Default <code>domain_from</code> <code>str</code> <p>Source domain name (e.g., <code>\"points\"</code>, <code>\"faces\"</code>, <code>\"edges\"</code>, <code>\"corners\"</code>, <code>\"splines\"</code>).</p> required <code>attr</code> <code>str or ndarray</code> <p>Source attribute to transfer. If a string, it is looked up on the source domain; if an array, it must match the source domain length.</p> required <code>domain_to</code> <code>str</code> <p>Target domain name.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Attribute values on the target domain. If <code>domain_from == domain_to</code>, returns <code>attr</code> unchanged.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If either <code>domain_from</code> or <code>domain_to</code> is not a valid domain of this geometry.</p> <code>Exception</code> <p>If the requested mapping is not implemented.</p> Notes <p>Implemented mappings include: - points \u2192 faces: <code>Point.compute_attribute_on_faces</code> - points \u2192 edges: <code>Point.compute_attribute_on_edges</code> - points \u2192 corners: <code>Point.compute_attribute_on_corners</code> - points \u2192 splines: <code>Point.compute_attribute_on_splines</code> - faces \u2192 points: <code>Face.compute_attribute_on_points</code> - edges \u2192 points: <code>Edge.compute_attribute_on_points</code> - corners \u2192 points: <code>Corner.compute_attribute_on_points</code></p>"},{"location":"api/curve/#npblender.curve.Curve.compute_bezier_handles","title":"compute_bezier_handles  <code>staticmethod</code>","text":"<pre><code>compute_bezier_handles(points, cyclic=False, eps=1e-06)\n</code></pre> <p>Compute cubic Bezier handles (left/right) from anchors using Catmull-Rom style tangents.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>(N,3) or (B,N,3) float32/float64</code> <p>OPEN storage (no duplicated first point).</p> required <code>cyclic</code> <code>bool</code> <p>If True, wrap neighbors; else use one-sided differences at ends.</p> <code>False</code> <code>eps</code> <code>float</code> <p>Small epsilon to guard against zero-length tangents.</p> <code>1e-06</code> <p>Returns:</p> Type Description <code>left, right : same shape as `points`</code> <p>left[i]  = P[i] - T[i] * (len_in[i]  / 3) right[i] = P[i] + T[i] * (len_out[i] / 3) with len_in = ||P[i] - P[i-1]|| and len_out = ||P[i+1] - P[i]|| (wrapped if cyclic).</p>"},{"location":"api/curve/#npblender.curve.Curve.delete_points","title":"delete_points","text":"<pre><code>delete_points(points=None, splines=None)\n</code></pre> <p>Delete points (and prune splines when emptied).</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>selection or None</code> <p>Points to delete.</p> <code>None</code> <code>splines</code> <code>selection or None</code> <p>Splines whose all points should be deleted.</p> <code>None</code> <p>Returns:</p> Type Description <code>Curve</code> <p>Self (for chaining).</p>"},{"location":"api/curve/#npblender.curve.Curve.delete_splines","title":"delete_splines","text":"<pre><code>delete_splines(splines=None)\n</code></pre> <p>Delete splines (and their points).</p> <p>Parameters:</p> Name Type Description Default <code>splines</code> <code>selection or None</code> <p>Splines to delete.</p> <code>None</code> <p>Returns:</p> Type Description <code>Curve</code> <p>Self (for chaining).</p>"},{"location":"api/curve/#npblender.curve.Curve.evaluate","title":"evaluate","text":"<pre><code>evaluate(t)\n</code></pre> <p>Evaluate positions along each spline at parameter(s) <code>t</code>.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float or ndarray</code> <p>Parametric coordinate(s) in <code>[0, 1]</code> per spline.</p> required <p>Returns:</p> Type Description <code>(ndarray, shape(..., 3))</code> <p>Evaluated positions.</p>"},{"location":"api/curve/#npblender.curve.Curve.for_each_bucket","title":"for_each_bucket","text":"<pre><code>for_each_bucket(func)\n</code></pre> <p>Iterate homogeneous spline buckets and apply <code>func</code>.</p> <p>Spline buckets share the same <code>(curve_type, N, cyclic, resolution)</code> signature. <code>func</code> is called with <code>(curve, curve_type, N, cyclic, resolution)</code> and must return a value; the generator yields <code>(bucket_indices, value)</code> pairs.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>Callback applied once per bucket.</p> required <p>Yields:</p> Type Description <code>tuple</code> <p><code>(bucket_indices, value)</code> for each bucket.</p>"},{"location":"api/curve/#npblender.curve.Curve.from_curve","title":"from_curve  <code>classmethod</code>","text":"<pre><code>from_curve(other, points=None, splines=None)\n</code></pre> <p>Copy a curve (optionally subsetting points and/or splines).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Curve</code> <p>Source curve.</p> required <code>points</code> <code>selection or None</code> <p>Points to exclude when copying (interpreted as mask if array of bool; see code for details).</p> <code>None</code> <code>splines</code> <code>selection or None</code> <p>Splines to exclude when copying.</p> <code>None</code> <p>Returns:</p> Type Description <code>Curve</code>"},{"location":"api/curve/#npblender.curve.Curve.from_curve_data","title":"from_curve_data  <code>classmethod</code>","text":"<pre><code>from_curve_data(data)\n</code></pre> <p>Build a curve from a Blender <code>Curve</code> datablock.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Curve</code> <p>Blender curve data.</p> required <p>Returns:</p> Type Description <code>Curve</code>"},{"location":"api/curve/#npblender.curve.Curve.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d)\n</code></pre> <p>Deserialize a curve from a dict produced by <code>to_dict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Serialized curve payload.</p> required <p>Returns:</p> Type Description <code>Curve</code>"},{"location":"api/curve/#npblender.curve.Curve.from_object","title":"from_object  <code>classmethod</code>","text":"<pre><code>from_object(obj, evaluated=False)\n</code></pre> <p>Build a curve from a Blender object holding curve data.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str or Object</code> <p>Object or object name.</p> required <code>evaluated</code> <code>bool</code> <p>If True, read the evaluated (modifier-applied) data via depsgraph.</p> <code>False</code> <p>Returns:</p> Type Description <code>Curve</code>"},{"location":"api/curve/#npblender.curve.Curve.get_cubic_envelop","title":"get_cubic_envelop","text":"<pre><code>get_cubic_envelop()\n</code></pre> <p>Return a cube mesh that encloses the geometry\u2019s bounding box.</p> <p>Uses the bounding box dimensions to build a cube via <code>Mesh.cube</code>, forwarding this geometry\u2019s <code>materials</code> if present.</p> <p>Returns:</p> Type Description <code>Mesh</code> <p>A cube mesh sized to the bounding box.</p>"},{"location":"api/curve/#npblender.curve.Curve.get_material_index","title":"get_material_index","text":"<pre><code>get_material_index(mat_name)\n</code></pre> <p>Return the index of a material name, creating it if needed.</p> <p>Parameters:</p> Name Type Description Default <code>mat_name</code> <code>str</code> <p>Material name to look up or append.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index of <code>mat_name</code> in <code>self.materials</code>.</p> Notes <p>If <code>mat_name</code> is not present, it is appended to <code>self.materials</code> and the new index is returned.</p>"},{"location":"api/curve/#npblender.curve.Curve.get_points_selection","title":"get_points_selection","text":"<pre><code>get_points_selection()\n</code></pre> <p>Indices/slice selecting the points actually referenced by the current splines.</p> <p>If the curve is a view (splines refer to a subset of points), returns a boolean mask selecting those rows in <code>points</code>. Otherwise returns <code>slice(None)</code>.</p> <p>Returns:</p> Type Description <code>slice or ndarray of bool</code> <p>Selection usable to index <code>self.points</code>.</p>"},{"location":"api/curve/#npblender.curve.Curve.join","title":"join","text":"<pre><code>join(*others)\n</code></pre> <p>Append other curves to this one (points, splines, and material mapping).</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Curve</code> <p>Curves to concatenate.</p> <code>()</code> <p>Returns:</p> Type Description <code>Curve</code> <p>Self (for chaining).</p>"},{"location":"api/curve/#npblender.curve.Curve.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other, **kwargs)\n</code></pre> <p>Merge attribute schemas from another geometry.</p> <p>For each domain listed in <code>self.domain_names</code> and also present in <code>other</code>, copies (joins) the attribute definitions (names, dtypes, metadata) from <code>other</code> into this geometry's domains. Use keyword flags to include/exclude domains by name (e.g., <code>faces=False</code>).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Geometry or None</code> <p>Source geometry. If <code>None</code>, does nothing and returns <code>self</code>.</p> required <code>**kwargs</code> <p>Per-domain boolean switches to filter which domains to join.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>, for chaining.</p> <p>Examples:</p> <pre><code>mesh.join_attributes(other_mesh, faces=False)\ncurve.join_attributes(mesh)  # only common domains are merged\n</code></pre>"},{"location":"api/curve/#npblender.curve.Curve.line","title":"line  <code>classmethod</code>","text":"<pre><code>line(start=(0, 0, 0), end=(0, 0, 1), resolution=2)\n</code></pre> <p>Build a straight polyline between two points.</p> <p>Generates <code>resolution</code> evenly spaced points from <code>start</code> to <code>end</code> (inclusive) and returns an open POLY spline.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>(3,) float</code> <p>Line start point.</p> <code>(0, 0, 0)</code> <code>end</code> <code>(3,) float</code> <p>Line end point.</p> <code>(0, 0, 1)</code> <code>resolution</code> <code>int</code> <p>Number of samples along the line (min 2).</p> <code>2</code> <p>Returns:</p> Type Description <code>Curve</code> <p>A curve with one POLY spline containing <code>resolution</code> points.</p> <p>Examples:</p> <pre><code>c = Curve.line(start=(0, 0, 0), end=(1, 0, 0), resolution=5)\nprint(len(c.points))\n</code></pre>"},{"location":"api/curve/#npblender.curve.Curve.load_models","title":"load_models  <code>staticmethod</code>","text":"<pre><code>load_models(*specs)\n</code></pre> <p>Load multiple geometries from collections, objects, or instances.</p> <p>Accepts mixed inputs such as Blender collections, Blender objects, lists/ tuples of either, or already-instantiated <code>Mesh</code>/<code>Curve</code>. Returns a flat list of geometries discovered or constructed.</p> <p>This method is mainly intended to be used by <code>Instances</code> to load its models.</p> <p>Parameters:</p> Name Type Description Default <code>*specs</code> <p>Collections, objects, lists/tuples, or <code>Mesh</code>/<code>Curve</code> instances.</p> <code>()</code> <p>Returns:</p> Type Description <code>list</code> <p>List of geometries (<code>Mesh</code>/<code>Curve</code>).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a spec cannot be resolved to a geometry.</p>"},{"location":"api/curve/#npblender.curve.Curve.load_object","title":"load_object  <code>staticmethod</code>","text":"<pre><code>load_object(name)\n</code></pre> <p>Load a Blender object and return a <code>Mesh</code> or a <code>Curve</code>.</p> <p>Resolves <code>name</code> to a Blender object, inspects its data type, and returns a matching geometry by calling the subclass' <code>from_object</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or Object</code> <p>Object name or object instance.</p> required <p>Returns:</p> Type Description <code>Mesh or Curve or None</code> <p>A <code>Mesh</code> or a <code>Curve</code>, or <code>None</code> if the object is not found.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the object exists but is neither a <code>bpy.types.Mesh</code> nor <code>bpy.types.Curve</code>.</p> <p>Examples:</p> <pre><code>geo = Geometry.load_object(\"MyObject\")\nif geo is not None:\n    print(type(geo).__name__)\n</code></pre>"},{"location":"api/curve/#npblender.curve.Curve.multiply","title":"multiply","text":"<pre><code>multiply(count, in_place=True)\n</code></pre> <p>Duplicate the whole curve <code>count</code> times (instancing-like expansion).</p> <p>Multiplying is a way to efficiently duplicate the geometry a great number of times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of copies to create.</p> required <code>in_place</code> <code>bool</code> <p>If True, expand this instance; otherwise return a new expanded curve.</p> <code>True</code> <p>Returns:</p> Type Description <code>Curve or None</code> <p>Self (in place) or a new curve; <code>None</code> if <code>count == 0</code>.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If <code>count</code> is not an integer.</p>"},{"location":"api/curve/#npblender.curve.Curve.no_view","title":"no_view","text":"<pre><code>no_view()\n</code></pre> <p>Materialize a view curve into an owned, self-consistent curve.</p> <p>Deep-copies the <code>splines</code> and gathers the referenced rows of <code>points</code> so that <code>sum(splines.loop_total) == len(points)</code> holds true.</p> <p>Returns:</p> Type Description <code>Curve</code> <p>Self (for chaining).</p>"},{"location":"api/curve/#npblender.curve.Curve.object","title":"object","text":"<pre><code>object(index=0, readonly=True, **kwargs)\n</code></pre> <p>Temporary access to a Blender Object built from this geometry.</p> <p>Creates a transient object (named <code>\"BPBL Temp {index}\"</code> unless <code>index</code> is a string), selects and activates it, yields it for editing, then cleans up. If <code>readonly=True</code>, the edited object is captured back into <code>self</code>.</p> <p>This method can be used to set and apply a modifier (see exemple below).</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int or str</code> <p>Index or name used to label the temporary object.</p> <code>0</code> <code>readonly</code> <code>bool</code> <p>If <code>False</code>, re-capture the possibly edited object back into this geometry.</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>Keyword arguments passed to <code>self.to_object</code>.</p> <code>{}</code> <p>Yields:</p> Type Description <code>Object</code> <p>The temporary Blender object built from <code>self</code>.</p> <p>Examples:</p> <pre><code>plane = Mesh.Grid()\nwith plane.object(readonly=False) as obj:\n    mod = obj.modifiers.new(\"Solidify\", 'SOLIDIFY')\n    mod.thickness = .1\n    bpy.ops.object.modifier_apply(modifier=mod.name)\n\n# plane is now solidifed\n</code></pre>"},{"location":"api/curve/#npblender.curve.Curve.quadratic_bezier","title":"quadratic_bezier  <code>classmethod</code>","text":"<pre><code>quadratic_bezier(resolution=16, start=(-1, 0, 0), middle=(0, 2, 0), end=(1, 0, 0))\n</code></pre> <p>Quadratic B\u00e9zier segment (not implemented).</p> <p>Intended to create a single quadratic B\u00e9zier curve defined by the control points <code>start</code>, <code>middle</code>, and <code>end</code>. Currently not implemented.</p> <p>Parameters:</p> Name Type Description Default <code>resolution</code> <code>int</code> <p>Suggested sampling resolution (unused in the current implementation).</p> <code>16</code> <code>start</code> <code>(3,) float</code> <p>Start control point.</p> <code>(-1, 0, 0)</code> <code>middle</code> <code>(3,) float</code> <p>Middle (control) point.</p> <code>(0, 2, 0)</code> <code>end</code> <code>(3,) float</code> <p>End control point.</p> <code>(1, 0, 0)</code> <p>Raises:</p> Type Description <code>Exception</code> <p>Always raised with the message \"Not implemented yet\".</p> <p>Examples:</p> <pre><code>try:\n    c = Curve.quadratic_bezier()\nexcept Exception as e:\n    print(e)  # \"Not implemented yet\"\n</code></pre>"},{"location":"api/curve/#npblender.curve.Curve.quadrilateral","title":"quadrilateral  <code>classmethod</code>","text":"<pre><code>quadrilateral(width=2.0, height=2.0)\n</code></pre> <p>Axis-aligned rectangle in the XY plane (closed polyline).</p> <p>Builds a cyclic POLY spline with four vertices: <code>(-w/2, -h/2) \u2192 (w/2, -h/2) \u2192 (w/2, h/2) \u2192 (-w/2, h/2)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>Rectangle width along X.</p> <code>2.0</code> <code>height</code> <code>float</code> <p>Rectangle height along Y.</p> <code>2.0</code> <p>Returns:</p> Type Description <code>Curve</code> <p>A curve with one cyclic POLY spline.</p> <p>Examples:</p> <pre><code>c = Curve.quadrilateral(width=1.0, height=0.5)\n</code></pre>"},{"location":"api/curve/#npblender.curve.Curve.rotate","title":"rotate","text":"<pre><code>rotate(rotation, pivot=None)\n</code></pre> <p>Rotate points (convenience wrapper).</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>ndarray or Rotation - like</code> <p>Rotation(s) to apply as <code>R @ v</code>.</p> required <code>pivot</code> <code>ndarray</code> <p>Optional pivot(s) for rotation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/curve/#npblender.curve.Curve.sample_attributes","title":"sample_attributes","text":"<pre><code>sample_attributes(t, names=None, cubic=False)\n</code></pre> <p>Sample point-domain attributes along the curve(s) at <code>t</code>.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float or ndarray</code> <p>Parametric coordinate(s) in <code>[0, 1]</code> per spline.</p> required <code>names</code> <code>sequence of str or None</code> <p>Attribute names to sample; if <code>None</code>, samples transferable point fields.</p> <code>None</code> <code>cubic</code> <code>bool</code> <p>Use cubic interpolation (typically for Bezier).</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, ndarray]</code> <p>Sampled arrays keyed by attribute name.</p>"},{"location":"api/curve/#npblender.curve.Curve.select","title":"select","text":"<pre><code>select(indices)\n</code></pre> <p>Convenience alias for subsetting splines: <code>curve[indices]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>selection</code> <p>Boolean mask, slice, or integer array indexing splines.</p> required <p>Returns:</p> Type Description <code>Curve</code> <p>A view on the selected splines (potentially a view curve).</p>"},{"location":"api/curve/#npblender.curve.Curve.spiral","title":"spiral  <code>classmethod</code>","text":"<pre><code>spiral(resolution=32, rotations=2.0, start_radius=1.0, end_radius=2.0, height=2.0, reverse=False)\n</code></pre> <p>Create a 3D polyline spiral in the XY plane with linear Z elevation.</p> <p>Samples a spiral with <code>1 + int(rotations * resolution)</code> points. The radius linearly interpolates from <code>start_radius</code> to <code>end_radius</code>. The angle evolves by <code>2\u03c0 * rotations</code> (clockwise unless <code>reverse=True</code>). The Z coordinate is linearly distributed from <code>0</code> to <code>height</code>.</p> <p>Parameters:</p> Name Type Description Default <code>resolution</code> <code>int</code> <p>Number of samples per full rotation.</p> <code>32</code> <code>rotations</code> <code>float</code> <p>Number of turns (can be fractional).</p> <code>2.0</code> <code>start_radius</code> <code>float</code> <p>Radius at the beginning of the spiral.</p> <code>1.0</code> <code>end_radius</code> <code>float</code> <p>Radius at the end of the spiral.</p> <code>2.0</code> <code>height</code> <code>float</code> <p>Final Z value (start is Z = 0).</p> <code>2.0</code> <code>reverse</code> <code>bool</code> <p>If True, swap the trigonometric direction of the spiral.</p> <code>False</code> <p>Returns:</p> Type Description <code>Curve</code> <p>A curve with a single POLY spline.</p> <p>Examples:</p> <pre><code>c = Curve.spiral(resolution=64, rotations=3.5, start_radius=0.5, end_radius=3.0, height=5.0)\n</code></pre>"},{"location":"api/curve/#npblender.curve.Curve.star","title":"star  <code>classmethod</code>","text":"<pre><code>star(points=8, inner_radius=1.0, outer_radius=2.0, twist=0.0)\n</code></pre> <p>Create a star polygon (alternating outer/inner vertices) in the XY plane.</p> <p>Builds a cyclic POLY spline with <code>2 * points</code> vertices alternating between <code>outer_radius</code> and <code>inner_radius</code>. The inner vertices are rotated by <code>\u03c0 / points + twist</code> to control the star lobes' alignment.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>int</code> <p>Number of star tips (minimum 3).</p> <code>8</code> <code>inner_radius</code> <code>float</code> <p>Radius of inner vertices.</p> <code>1.0</code> <code>outer_radius</code> <code>float</code> <p>Radius of outer vertices (tips).</p> <code>2.0</code> <code>twist</code> <code>float</code> <p>Additional rotation (radians) applied to inner vertices.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Curve</code> <p>A curve with one cyclic POLY spline forming a star.</p> See Also <p>Curve.circle, Curve.arc</p>"},{"location":"api/curve/#npblender.curve.Curve.tangent","title":"tangent","text":"<pre><code>tangent(t, normalize=True)\n</code></pre> <p>Evaluate tangents along each spline at parameter(s) <code>t</code>.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float or ndarray</code> <p>Parametric coordinate(s) in <code>[0, 1]</code> per spline.</p> required <code>normalize</code> <code>bool</code> <p>If True, return unit tangents.</p> <code>True</code> <p>Returns:</p> Type Description <code>(ndarray, shape(..., 3))</code> <p>Tangent vectors.</p>"},{"location":"api/curve/#npblender.curve.Curve.to_bezier","title":"to_bezier","text":"<pre><code>to_bezier(control_count=None, resolution=16)\n</code></pre> <p>Convert all splines to Bezier.</p> <p>Parameters:</p> Name Type Description Default <code>control_count</code> <code>int or None</code> <p>Number of anchors per spline. If <code>None</code>, keep the current <code>loop_total</code>. For cyclic splines, anchors are sampled on <code>[0, 1)</code> (no duplicate).</p> <code>None</code> <code>resolution</code> <code>int</code> <p>Per-segment resolution written to <code>splines.resolution</code> (&gt;= 1).</p> <code>16</code> <p>Returns:</p> Type Description <code>Curve</code> <p>A new Bezier curve.</p>"},{"location":"api/curve/#npblender.curve.Curve.to_curve_data","title":"to_curve_data","text":"<pre><code>to_curve_data(data)\n</code></pre> <p>Write this curve into an existing Blender <code>Curve</code> datablock.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Curve</code> <p>Target Blender curve data (cleared and repopulated).</p> required"},{"location":"api/curve/#npblender.curve.Curve.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize the curve to a plain Python dict.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Keys: <code>geometry</code>, <code>materials</code>, <code>points</code>, <code>splines</code>.</p>"},{"location":"api/curve/#npblender.curve.Curve.to_mesh","title":"to_mesh","text":"<pre><code>to_mesh(profile=None, caps=True, use_radius=True, camera_culling=False)\n</code></pre> <p>Convert the curve to a mesh (optionally sweeping a profile).</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Curve or None</code> <p>Profile curve to sweep along each spline. If <code>None</code>, outputs edges only.</p> <code>None</code> <code>caps</code> <code>bool</code> <p>Close ends when the profile is cyclic and the path is open.</p> <code>True</code> <code>use_radius</code> <code>bool</code> <p>Use per-point <code>radius</code> to scale the profile (when applicable).</p> <code>True</code> <code>camera_culling</code> <code>bool or Camera</code> <p>If truthy, drop splines that would be sub-pixel using a camera model.</p> <code>False</code> <p>Returns:</p> Type Description <code>[Mesh][Mesh]</code> <p>The generated mesh.</p>"},{"location":"api/curve/#npblender.curve.Curve.to_object","title":"to_object","text":"<pre><code>to_object(obj, collection=None)\n</code></pre> <p>Create or update a Blender curve object from this geometry.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str or Object</code> <p>Target object or name (created if it doesn't exist).</p> required <code>collection</code> <code>Collection or None</code> <p>Collection to link a newly created object into.</p> <code>None</code> <p>Returns:</p> Type Description <code>Object</code> <p>The Blender curve object.</p> Notes <p>The object type must be Curve. Type conversion is not performed.</p>"},{"location":"api/curve/#npblender.curve.Curve.to_poly","title":"to_poly","text":"<pre><code>to_poly(resolution=None)\n</code></pre> <p>Convert all splines to Poly.</p> <p>Parameters:</p> Name Type Description Default <code>resolution</code> <code>int or None</code> <p>If <code>None</code>, Bezier splines are split using their per-spline resolution and poly splines are left unchanged. If an integer, resample all splines to that resolution (cyclic splines have no duplicate endpoint).</p> <code>None</code> <p>Returns:</p> Type Description <code>Curve</code> <p>A new curve with <code>curve_type = POLY</code>.</p>"},{"location":"api/curve/#npblender.curve.Curve.transform","title":"transform","text":"<pre><code>transform(transformation)\n</code></pre> <p>Apply a rotation matrix or batch of matrices.</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>transformation</code> <code>ndarray</code> <p>Rotation matrix or batch of rotation matrices.</p> required <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/curve/#npblender.curve.Curve.transformation","title":"transformation","text":"<pre><code>transformation(rotation=None, scale=None, translation=None, pivot=None)\n</code></pre> <p>Apply rotation/scale/translation (with optional per-packet broadcasting).</p> <p>Operates in-place on <code>points.position</code> and, when present, Bezier handles (<code>points.handle_left</code>, <code>points.handle_right</code>). Shapes can represent packets of points: broadcasting rules are handled by <code>Point._get_shape_for_operation</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>ndarray or Rotation - like</code> <p>Rotation matrix/matrices applied as <code>R @ v</code>. Shape may broadcast over points (see notes).</p> <code>None</code> <code>scale</code> <code>ndarray</code> <p>Per-axis scaling. Shape may broadcast over points.</p> <code>None</code> <code>translation</code> <code>ndarray</code> <p>Per-point translation. Shape may broadcast over points.</p> <code>None</code> <code>pivot</code> <code>ndarray</code> <p>Pivot(s) subtracted before, and added after, the rotation/scale; same broadcasting rules as <code>scale</code>/<code>translation</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>, for chaining.</p> Notes <ul> <li>If handles exist, they are transformed consistently with positions.</li> </ul> <p>Examples:</p> <pre><code># 12 cubes laid out randomly with per-instance transforms\ncubes = Mesh.cube(size=1).multiply(12)\nT = np.random.uniform(-1, 1, (12, 3))\nS = np.random.uniform(0.5, 2.0, (12, 3))\nR = Rotation.from_euler(np.random.uniform(0, 2*np.pi, (12, 3)))\ncubes.transformation(rotation=R, scale=S, translation=T)\n</code></pre>"},{"location":"api/curve/#npblender.curve.Curve.translate","title":"translate","text":"<pre><code>translate(translation)\n</code></pre> <p>Translate points (convenience wrapper).</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>ndarray</code> <p>Per-point or broadcastable translation vectors.</p> required <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/curve/#npblender.curve.Curve.xyfunction","title":"xyfunction  <code>classmethod</code>","text":"<pre><code>xyfunction(func, x0=0.0, x1=1.0, resolution=100, materials=None)\n</code></pre> <p>Sample a 2D function y = f(x) as a polyline in the XY plane.</p> <p>Evaluates <code>y = func(x)</code> for <code>x</code> uniformly spaced in <code>[x0, x1]</code> and creates a POLY spline with points <code>(x, y, 0)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>A function mapping an array of X values to Y values (vectorized).</p> required <code>x0</code> <code>float</code> <p>Start of the X interval.</p> <code>0.0</code> <code>x1</code> <code>float</code> <p>End of the X interval.</p> <code>1.0</code> <code>resolution</code> <code>int</code> <p>Number of samples in <code>[x0, x1]</code>.</p> <code>100</code> <code>materials</code> <code>str or sequence of str or None</code> <p>Optional material(s) to attach to the curve.</p> <code>None</code> <p>Returns:</p> Type Description <code>Curve</code> <p>A curve with one POLY spline sampled from <code>func</code>.</p> <p>Examples:</p> <pre><code>import numpy as np\n\ndef f(x):\n    return np.sin(2 * np.pi * x)\n\nc = Curve.xyfunction(f, x0=0.0, x1=1.0, resolution=200)\n</code></pre>"},{"location":"api/distribs/","title":"Distribs","text":""},{"location":"api/distribs/#npblender.maths.distribs","title":"distribs","text":"<p>Module Name: distribs Author: Alain Bernard Version: 0.1.0 Created: 2025-07-18 Last updated: 2025-09-02</p> <p>Summary:     Distribution functions on curves, surfaces and volumes.</p>"},{"location":"api/distribs/#npblender.maths.distribs.arc_dist","title":"arc_dist","text":"<pre><code>arc_dist(radius=1.0, scale=None, center=(0, 0, 0), arc_center=0.0, arc_angle=PI / 2, use_vonmises=False, count=10, density=None, seed=None)\n</code></pre> <p>Distribute points along an arc of a circle.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Base radius of the arc.</p> <code>1.0</code> <code>scale</code> <code>float</code> <p>Standard deviation for Gaussian noise around the radius.</p> <code>None</code> <code>center</code> <code>(array_like, shape(D))</code> <p>Center of the arc (2D or 3D).</p> <code>(0, 0, 0)</code> <code>arc_center</code> <code>float</code> <p>Center angle (in radians) of the arc.</p> <code>0.0</code> <code>arc_angle</code> <code>float</code> <p>Total angle covered by the arc (in radians).</p> <code>TAU</code> <code>use_vonmises</code> <code>bool</code> <p>Whether to sample angles using a von Mises distribution.</p> <code>False</code> <code>count</code> <code>int</code> <p>Number of points to generate (ignored if density is given).</p> <code>10</code> <code>density</code> <code>float</code> <p>If specified, the number of points is sampled from a Poisson distribution of expected arc length \u00d7 density.</p> <code>None</code> <code>seed</code> <code>int or Generator</code> <p>Random seed.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys: - 'points': coordinates of sampled points - 'normals': normal unit vectors at each point - 'tangents': tangent unit vectors at each point - 'lengths': radius values used for each point - 'angles': angle values (in radians) used for each point</p>"},{"location":"api/distribs/#npblender.maths.distribs.ball_dist","title":"ball_dist","text":"<pre><code>ball_dist(radius=1.0, axis=(0, 0, 1), angle=np.pi, use_vonmises=False, center=(0, 0, 0), count=10, density=None, scale=None, seed=None, **kwargs)\n</code></pre> <p>Distribute points inside a spherical volume (ball or cap).</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the sphere.</p> <code>1.0</code> <code>axis</code> <code>array-like of shape (3,)</code> <p>Axis of the spherical cap (default is +Z).</p> <code>(0, 0, 1)</code> <code>angle</code> <code>float</code> <p>Angular aperture from the axis (0 to \u03c0).</p> <code>pi</code> <code>use_vonmises</code> <code>bool</code> <p>Use Von Mises distribution for angular sampling.</p> <code>False</code> <code>center</code> <code>array-like of shape (3,)</code> <p>Center of the sphere.</p> <code>(0, 0, 0)</code> <code>count</code> <code>int</code> <p>Number of points to generate (overridden by density if provided).</p> <code>10</code> <code>density</code> <code>float</code> <p>Target density (points per unit volume).</p> <code>None</code> <code>seed</code> <code>int or Generator</code> <p>Random seed.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>{     'points': (count, 3) array of positions,     'normals': (count, 3) array of radial directions,     'lengths': (count,) distances from center }</p>"},{"location":"api/distribs/#npblender.maths.distribs.circle_dist","title":"circle_dist","text":"<pre><code>circle_dist(radius=1.0, scale=None, center=(0, 0, 0), count=10, density=None, seed=None)\n</code></pre> <p>Distribute points along a full circle in the XY plane.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Base radius of the circle.</p> <code>1.0</code> <code>scale</code> <code>float</code> <p>Standard deviation for Gaussian noise around the radius.</p> <code>None</code> <code>center</code> <code>(array_like, shape(D))</code> <p>Center of the circle (2D or 3D).</p> <code>(0, 0, 0)</code> <code>count</code> <code>int</code> <p>Number of points to generate (ignored if density is given).</p> <code>10</code> <code>density</code> <code>float</code> <p>If specified, the number of points is sampled from a Poisson distribution of expected arc length \u00d7 density.</p> <code>None</code> <code>seed</code> <code>int or Generator</code> <p>Random seed.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys: - 'points': coordinates of sampled points - 'tangents': tangent unit vectors at each point - 'lengths': radius values used for each point - 'angles': angle values (in radians) used for each point</p>"},{"location":"api/distribs/#npblender.maths.distribs.cube_dist","title":"cube_dist","text":"<pre><code>cube_dist(size=1, center=(0, 0, 0), count=10, density=None, seed=None)\n</code></pre> <p>Distribute points uniformly inside a cube.</p> Arguments <ul> <li>size (float or array-like of 3 floats) : dimensions of the cube along each axis</li> <li>center (array-like of 3 floats) : center of the cube</li> <li>count (int) : number of points to generate (overridden by density if provided)</li> <li>density (float, optional) : number of points per unit volume (overrides count)</li> <li>seed (int or np.random.Generator, optional) : random seed</li> </ul> <p>Returns:</p> Type Description <code>- dict : { 'points': (count, 3) array of sampled positions }</code>"},{"location":"api/distribs/#npblender.maths.distribs.curve_dist_LATER","title":"curve_dist_LATER","text":"<pre><code>curve_dist_LATER(curve, t0=0.0, t1=1.0, count=10, density=None, seed=None)\n</code></pre> <p>Distribute points on a curve.</p> Arguments <ul> <li>curve (Curve) : the curve</li> <li>t0 (float = 0.) : start parameter</li> <li>t1 (float = 1.) : end parameter</li> <li>count (int = 10) : number of points to generate (overriden by density if not None)</li> <li>density (float = None) : density of points (overrides count if not None)</li> <li>seed (int = None) : random seed</li> </ul> <p>Returns:</p> Type Description <code>- dict : 'points', 'tangents'</code>"},{"location":"api/distribs/#npblender.maths.distribs.cylinder_dist","title":"cylinder_dist","text":"<pre><code>cylinder_dist(radius=1.0, scale=None, height=1.0, center=(0, 0, 0), arc_center=0.0, arc_angle=TAU, use_vonmises=False, count=10, density=None, seed=None)\n</code></pre> <p>Distribute points on the lateral surface of a cylinder.</p> <p>Points are placed on an arc of the circular base and uniformly along height.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Cylinder radius.</p> <code>1.0</code> <code>scale</code> <code>float</code> <p>Radial noise (used inside <code>arc_dist</code>).</p> <code>None</code> <code>height</code> <code>float</code> <p>Height of the cylinder (Z direction).</p> <code>1.0</code> <code>center</code> <code>(array_like, shape(3))</code> <p>Center of the cylinder.</p> <code>(0, 0, 0)</code> <code>arc_center</code> <code>float</code> <p>Center angle (in radians) for arc distribution.</p> <code>0.0</code> <code>arc_angle</code> <code>float</code> <p>Angular extent of the arc to sample.</p> <code>TAU</code> <code>use_vonmises</code> <code>bool</code> <p>Whether to use Von Mises distribution for angular sampling.</p> <code>False</code> <code>count</code> <code>int</code> <p>Number of points to sample (overridden by <code>density</code>).</p> <code>10</code> <code>density</code> <code>float</code> <p>Surface density of points per unit area (overrides <code>count</code>).</p> <code>None</code> <code>seed</code> <code>int or Generator</code> <p>Random seed or NumPy generator.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with: - 'points'   : (count, 3) sampled positions - 'tangents' : (count, 3) tangent vectors along arc - 'normals'  : (count, 3) surface normals (radial) - 'lengths'  : (count,) radial distances - 'angles'   : (count,) angular positions (radians)</p>"},{"location":"api/distribs/#npblender.maths.distribs.disk_dist","title":"disk_dist","text":"<pre><code>disk_dist(radius=1, outer_radius=None, center=None, normal=None, count=10, density=None, seed=None)\n</code></pre> <p>Distribute points uniformly on a 2D disk or annulus in the XY plane.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the disk (or inner radius if <code>outer_radius</code> is provided).</p> <code>1</code> <code>outer_radius</code> <code>float</code> <p>Outer radius of the disk. If given, points are sampled in an annular ring [radius, outer_radius].</p> <code>None</code> <code>center</code> <code>(array_like, shape(2) or (3,))</code> <p>Center of the disk if difference from (0, 0, 0)</p> <code>None</code> <code>normal</code> <code>normal</code> <p>Normal if different from Z</p> <code>None</code> <code>count</code> <code>int</code> <p>Number of points to generate (overridden by <code>density</code> if given).</p> <code>10</code> <code>density</code> <code>float</code> <p>Point density per unit area. Overrides <code>count</code> if provided.</p> <code>None</code> <code>seed</code> <code>int or Generator</code> <p>Random seed or NumPy random generator.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys: - 'points'   : (count, D) point positions - 'tangents' : (count, 3) unit tangent vectors in-plane - 'normals'  : (count, 3) normal vectors (Z-up) - 'lengths'  : (count,) radial distances from center - 'angles'   : (count,) polar angles in radians</p>"},{"location":"api/distribs/#npblender.maths.distribs.dome_dist","title":"dome_dist","text":"<pre><code>dome_dist(radius=1.0, scale=None, axis=(0, 0, 1), angle=np.pi / 2, use_vonmises=False, center=(0, 0, 0), count=10, density=None, seed=None)\n</code></pre> <p>Distribute points on a spherical cap (dome).</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the sphere.</p> <code>1.0</code> <code>scale</code> <code>float</code> <p>Standard deviation of radial noise.</p> <code>None</code> <code>axis</code> <code>(array_like, shape(3))</code> <p>Direction of the dome (default is +Z).</p> <code>(0, 0, 1)</code> <code>angle</code> <code>float</code> <p>Aperture angle of the dome (in radians), from center axis.</p> <code>\u03c0/2</code> <code>use_vonmises</code> <code>bool</code> <p>Whether to use Von Mises angular distribution.</p> <code>False</code> <code>center</code> <code>(array_like, shape(3))</code> <p>Center of the sphere.</p> <code>(0, 0, 0)</code> <code>count</code> <code>int</code> <p>Number of points to generate (overridden by <code>density</code> if provided).</p> <code>10</code> <code>density</code> <code>float</code> <p>Surface density of points per unit area.</p> <code>None</code> <code>seed</code> <code>int or Generator</code> <p>Random seed or generator.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>{     'points'  : (count, 3) array of sampled positions,     'normals' : (count, 3) unit vectors from center to points,     'lengths' : (count,) sampled distances from center }</p>"},{"location":"api/distribs/#npblender.maths.distribs.line_dist","title":"line_dist","text":"<pre><code>line_dist(point0=(-1, -1, -1), point1=(1, 1, 1), count=10, density=None, seed=None)\n</code></pre> <p>Distribute points randomly along a segment [point0, point1].</p> <p>Parameters:</p> Name Type Description Default <code>point0</code> <code>(array_like, shape(D))</code> <p>First endpoint of the segment.</p> <code>(-1, -1, -1)</code> <code>point1</code> <code>(array_like, shape(D))</code> <p>Second endpoint of the segment.</p> <code>(1, 1, 1)</code> <code>count</code> <code>int</code> <p>Number of points to generate (ignored if density is specified).</p> <code>10</code> <code>density</code> <code>bfloat</code> <p>If specified, determines point count via a Poisson distribution with mean = density * segment_length.</p> <code>None</code> <code>seed</code> <code>int or Generator</code> <p>Random seed.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict with:</code> <ul> <li>'points': ndarray of shape (count, D)</li> <li>'tangents': ndarray of shape (count, D)</li> </ul>"},{"location":"api/distribs/#npblender.maths.distribs.mesh_dist","title":"mesh_dist","text":"<pre><code>mesh_dist(mesh, selection=None, count=10, density=None, seed=None)\n</code></pre> <p>Distribute points on a mesh surface.</p> Arguments <ul> <li>mesh (Mesh) : mesh object</li> <li>selection (array of bools = None) : face selection mask</li> <li>count (int = 10) : number of points to generate (overridden by density if not None)</li> <li>density (float = None) : density of points (overrides count if not None)</li> <li>seed (int = None) : random seed</li> </ul> <p>Returns:</p> Type Description <code>- dict : { 'points': (count, 3), 'normals': (count, 3) }</code>"},{"location":"api/distribs/#npblender.maths.distribs.normal_dist","title":"normal_dist","text":"<pre><code>normal_dist(shape, scale, dim=3, seed=None)\n</code></pre> <p>Generate normally distributed points in random directions.</p> <p>Points are distributed isotropically around the origin, with a normal distribution of distances (mean 0, std = scale).</p> Arguments <ul> <li>shape (int or tuple) : shape of the returned array</li> <li>scale (int) : standard deviation</li> <li>dim (int in (1, 2, 3)) : dimension</li> <li>seed (int or Generator) : random seed</li> </ul> <p>Returns:</p> Type Description <code>- array of values in dim dimensions</code>"},{"location":"api/distribs/#npblender.maths.distribs.pie_dist","title":"pie_dist","text":"<pre><code>pie_dist(radius=1, outer_radius=None, center=None, normal=None, pie_center=0.0, pie_angle=PI / 2, use_vonmises=False, count=10, density=None, seed=None)\n</code></pre> <p>Distribute points uniformly inside a circular sector (\"pie\") in the XY plane.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Disk radius (or inner radius if <code>outer_radius</code> is specified).</p> <code>1</code> <code>outer_radius</code> <code>float</code> <p>Outer radius. If provided, defines a ring sector from <code>radius</code> to <code>outer_radius</code>.</p> <code>None</code> <code>center</code> <code>(array_like, shape(2) or (3,))</code> <p>Center of the pie if different from (0, 0, 0).</p> <code>None</code> <code>normal</code> <code>normal</code> <p>Normal if different from Z</p> <code>None</code> <code>pie_center</code> <code>float</code> <p>Central angle of the pie (radians).</p> <code>0.</code> <code>pie_angle</code> <code>float</code> <p>Total angular span of the pie (radians).</p> <code>TAU</code> <code>use_vonmises</code> <code>bool</code> <p>Whether to use a Von Mises distribution for angle sampling.</p> <code>False</code> <code>count</code> <code>int</code> <p>Number of points to generate (overridden by density if provided).</p> <code>10</code> <code>density</code> <code>float</code> <p>Point density per unit area. Overrides <code>count</code> if given.</p> <code>None</code> <code>seed</code> <code>int or Generator</code> <p>Random seed or NumPy Generator.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <ul> <li>'points'   : (count, D) array of points (D=2 or 3)</li> <li>'tangents' : (count, 3) array of direction vectors (XY tangent)</li> <li>'normals'  : (count, 3) array of Z-up normals</li> <li>'lengths'  : (count,) array of radial distances</li> <li>'angles'   : (count,) array of polar angles (radians)</li> </ul>"},{"location":"api/distribs/#npblender.maths.distribs.rect_dist","title":"rect_dist","text":"<pre><code>rect_dist(a=1, b=1, center=(0, 0, 0), count=10, density=None, seed=None)\n</code></pre> <p>Distribute points uniformly on a rectangle in the XY plane.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>Length of the rectangle along the X axis.</p> <code>1</code> <code>b</code> <code>float</code> <p>Length of the rectangle along the Y axis.</p> <code>1</code> <code>center</code> <code>(array_like, shape(2) or (3,))</code> <p>Center of the rectangle.</p> <code>(0, 0, 0)</code> <code>count</code> <code>int</code> <p>Number of points to generate (overridden by density if specified).</p> <code>10</code> <code>density</code> <code>float</code> <p>Point density per unit area. Overrides <code>count</code> if provided.</p> <code>None</code> <code>seed</code> <code>int or Generator</code> <p>Random seed or generator.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with: - 'points': (count, D) array of sampled points (D=2 or 3) - 'normals': (count, 3) array of normals (Z-up)</p>"},{"location":"api/distribs/#npblender.maths.distribs.shake_points","title":"shake_points","text":"<pre><code>shake_points(points, scale=None, seed=None)\n</code></pre> <p>Slightly displace points using isotropic normal noise.</p> <p>Each point is moved randomly in all directions according to a normal (Gaussian) distribution centered at its original position. If <code>scale</code> is None, the points are returned unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>(array_like, shape(..., D))</code> <p>Input array of points (D is typically 2 or 3).</p> required <code>scale</code> <code>bfloat or None</code> <p>Standard deviation of the displacement. If None, no displacement is applied.</p> <code>None</code> <code>seed</code> <code>int or Generator</code> <p>Random seed or NumPy random Generator for reproducibility.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>displaced</code> <code>(ndarray, shape(..., D))</code> <p>Array of displaced points.</p>"},{"location":"api/distribs/#npblender.maths.distribs.shake_vectors","title":"shake_vectors","text":"<pre><code>shake_vectors(vectors, scale=None, length_only=False, lengths=None, seed=None)\n</code></pre> <p>Slightly perturb a set of vectors.</p> <p>The noise is proportional to the original vector norms. This can affect either only the magnitudes (<code>length_only=True</code>) or both directions and magnitudes.</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>(array_like, shape(..., D))</code> <p>Input vectors to perturb.</p> required <code>scale</code> <code>bfloat or None</code> <p>Relative noise scale (as a fraction of the vector norm). If None, no perturbation is applied.</p> <code>None</code> <code>length_only</code> <code>bool</code> <p>If True, only the magnitudes are modified (direction remains unchanged).</p> <code>False</code> <code>lengths</code> <code>array_like</code> <p>Precomputed norms of the input vectors. Required only if <code>length_only=False</code>.</p> <code>None</code> <code>seed</code> <code>int or Generator</code> <p>Seed or NumPy random Generator for reproducibility.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>perturbed_vectors</code> <code>(ndarray, shape(..., D))</code> <p>The perturbed vectors.</p>"},{"location":"api/distribs/#npblender.maths.distribs.speed_dist","title":"speed_dist","text":"<pre><code>speed_dist(direction, speed, scale=None, mu=None, seed=None)\n</code></pre> <p>Generate velocity vectors distributed around a given direction.</p> <p>This uses a Von Mises-Fisher-like sampling in 2D or 3D, centered on the input direction, with angular dispersion controlled by <code>mu</code>.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>(N, D) array or (D,) array</code> <p>Target directions (2D or 3D), normalized or not.</p> required <code>speed</code> <code>float</code> <p>Base speed (magnitude of output vectors).</p> required <code>scale</code> <code>float</code> <p>Std deviation for speed variation (in modulus).</p> <code>None</code> <code>mu</code> <code>float</code> <p>Concentration parameter for angular dispersion (Von Mises). Higher = more concentrated.</p> <code>None</code> <code>seed</code> <code>int or Generator</code> <p>Random seed.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>speeds</code> <code>(N, D) array</code> <p>Velocity vectors.</p>"},{"location":"api/distribs/#npblender.maths.distribs.sphere_dist","title":"sphere_dist","text":"<pre><code>sphere_dist(radius=1.0, scale=None, center=(0, 0, 0), count=10, density=None, seed=None)\n</code></pre> <p>Distribute points on the surface of a sphere.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the sphere.</p> <code>1.0</code> <code>scale</code> <code>float</code> <p>Standard deviation of radial noise.</p> <code>None</code> <code>center</code> <code>(array_like, shape(3))</code> <p>Center of the sphere.</p> <code>(0, 0, 0)</code> <code>count</code> <code>int</code> <p>Number of points to generate (overridden if <code>density</code> is provided).</p> <code>10</code> <code>density</code> <code>float</code> <p>Surface density of points per unit area (overrides <code>count</code>).</p> <code>None</code> <code>seed</code> <code>int or Generator</code> <p>Random seed or NumPy Generator.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>{     'points'  : (count, 3) array of sampled positions,     'normals' : (count, 3) unit vectors from center to points,     'lengths' : (count,) sampled distances from center,     'thetas'  : (count,) azimuthal angles \u2208 [0, 2\u03c0),     'phis'    : (count,) polar angles \u2208 [\u2013\u03c0/2, \u03c0/2] }</p>"},{"location":"api/distribs/#npblender.maths.distribs.surface_dist","title":"surface_dist","text":"<pre><code>surface_dist(surface, count=10, density=None, seed=None)\n</code></pre> <p>Distribute points on a triangulated surface.</p> <p>The surface is passed as a dictionary with the following keys:     - 'triangles' : (n_faces, 3, 3) float array of triangle vertices     - 'areas'     : (n_faces,) float array of face areas     - 'normals'   : (n_faces, 3) float array of face normals</p> <p>Parameters:</p> Name Type Description Default <code>surface</code> <code>dict</code> <p>Surface description with triangles, areas, and normals.</p> required <code>count</code> <code>int</code> <p>Number of points to generate (overridden by density).</p> <code>10</code> <code>density</code> <code>float</code> <p>Point density per unit area (overrides count).</p> <code>None</code> <code>seed</code> <code>int</code> <p>Random seed.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>{     'points'  : (count, 3) sampled points on the surface,     'normals' : (count, 3) normals at each sampled point }</p>"},{"location":"api/distribs/#npblender.maths.distribs.triangle_dist","title":"triangle_dist","text":"<pre><code>triangle_dist(corners, count, rng=None)\n</code></pre> <p>Distribute points uniformly on a triangle.</p> <p>Parameters:</p> Name Type Description Default <code>corners</code> <code>(array_like, shape(3, 3))</code> <p>Coordinates of the three triangle corners.</p> required <code>count</code> <code>int</code> <p>Number of points to generate.</p> required <code>rng</code> <code>Generator</code> <p>Numpy random generator. Created if not provided.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>points</code> <code>(ndarray, shape(count, 3))</code> <p>Points uniformly distributed on the triangle.</p>"},{"location":"api/domain/","title":"Domain","text":""},{"location":"api/domain/#npblender.domain.Domain","title":"Domain","text":"<pre><code>Domain(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>Initialize a domain array and its attribute schema.</p> <p>Initializes the storage from an existing array/domain or creates an empty structure. Optionally merges attribute definitions/values from another domain and keyword-provided attributes.</p> <p>Domains are never instancied directly but by owning geometries.</p> <p>Actual Domains are <code>Vertex</code>, [<code>Faces</code>][npblender.domain.Faces], <code>Corner</code>, <code>Edge</code>, <code>ControlPoint</code>, <code>Spline</code> and <code>Point</code>.</p> <p>Domains are initialized with their defaults attributes, for instance <code>position</code> for point domaines.</p> <p>Use attributes can be freely added. </p> <p>Note: user attributes are saved in Blender Mesh objects only, Blender Curve objects don't store user attributes.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>array - like or FieldArray or None</code> <p>Source data used to initialize the domain. If <code>None</code>, an empty domain is created and <code>_declare_attributes()</code> is called to register defaults.</p> <code>None</code> <code>mode</code> <code>(COPY, CAPTURE, EMPTY)</code> <p>Initialization mode. <code>'COPY'</code> duplicates the input data, <code>'CAPTURE'</code> references the input buffer when supported, <code>'EMPTY'</code> creates the structure without copying values.</p> <code>'COPY'</code> <code>selector</code> <code>Any</code> <p>Optional row/element selector applied to <code>a</code> prior to initialization.</p> <code>None</code> <code>attr_from</code> <code>Domain or Mapping or None</code> <p>Attribute schema (and possibly values) to merge into this domain.</p> <code>None</code> <code>**attrs</code> <p>Additional attribute name/value pairs to inject or override.</p> <code>{}</code> Notes <p>The effective attribute list results from <code>_declare_attributes()</code>, then <code>attr_from</code>, then <code>**attrs</code> (later entries take precedence).</p> <p>Examples:</p> <pre><code>cube = Mesh.cube() # points, corners, faces and edges domains are created\n# Adding named attribute to point domain\ncube.points.new_float('age')\n# Setting the age\ncube.points.age = np.random.uniforme(10, 10, len(cube.points))\n</code></pre>"},{"location":"api/domain/#npblender.domain.Domain.actual_names","title":"actual_names  <code>property</code>","text":"<pre><code>actual_names\n</code></pre> <p>Column names.</p> <p>Returns the actual field names, excluding optional fields.</p>"},{"location":"api/domain/#npblender.domain.Domain.all_names","title":"all_names  <code>property</code>","text":"<pre><code>all_names\n</code></pre> <p>Column names.</p> <p>Returns all the field names, including optional ones.</p>"},{"location":"api/domain/#npblender.domain.Domain.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Array structured dtype</p> <p>Returns the dtype property of the structured array.</p>"},{"location":"api/domain/#npblender.domain.Domain.transdom_names","title":"transdom_names  <code>property</code>","text":"<pre><code>transdom_names\n</code></pre> <p>List the names of trans-domain attributes.</p> <p>Returns:</p> Type Description <code>list of str</code> <p>Names of attributes flagged with <code>transdom=True</code>.</p> <p>Examples:</p> <pre><code>names = D.transdom_names()\n</code></pre>"},{"location":"api/domain/#npblender.domain.Domain.add","title":"add","text":"<pre><code>add(count, **fields)\n</code></pre> <p>Add count records</p> <p>New records are set with default values or values provided by the user in fields dict.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of records to add.</p> required <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/domain/#npblender.domain.Domain.append","title":"append","text":"<pre><code>append(**fields)\n</code></pre> <p>Append values to the structured array.</p> <p>The number of records to append is determined by the number of fields provided in the fields dictionary. The values of the fields are copied to the new records.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/domain/#npblender.domain.Domain.as_kwargs","title":"as_kwargs","text":"<pre><code>as_kwargs(selector=None, include=None, exclude=None)\n</code></pre> <p>Return a dictionary of field values formatted as kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>slice, int, list, or mask</code> <p>Optional selection of elements to extract.</p> <code>None</code> <code>include</code> <code>list[str]</code> <p>List of field names (original or python names) to include.</p> <code>None</code> <code>exclude</code> <code>list[str]</code> <p>List of field names (original or python names) to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Mapping from python-safe field names to array values.</p>"},{"location":"api/domain/#npblender.domain.Domain.copy_field","title":"copy_field","text":"<pre><code>copy_field(field_name, new_name, **infos)\n</code></pre> <p>Duplicate an existing field under a new name, with optional metadata overrides.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the existing field to copy.</p> required <code>new_name</code> <code>str</code> <p>The name of the new field to create.</p> required <code>infos</code> <code>keyword arguments</code> <p>Optional metadata (e.g. default, unit, description...) to override or supplement the original field's metadata.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the source field does not exist.</p> <code>ValueError</code> <p>If the target name already exists or is reserved.</p>"},{"location":"api/domain/#npblender.domain.Domain.delete","title":"delete","text":"<pre><code>delete(index)\n</code></pre> <p>Delete a selection of items from the array.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int, slice, or array-like</code> <p>The indices of the elements to delete from the current data.</p> required Notes <p>This operates only on the valid range <code>[0:self._length]</code>. The internal buffer is preserved (no reallocation).</p>"},{"location":"api/domain/#npblender.domain.Domain.dump","title":"dump","text":"<pre><code>dump(title='Dump', attributes=None, target='SCREEN')\n</code></pre> <p>Pretty-print or export domain content.</p> <p>Formats attribute values and prints to screen or builds a tabular dump suitable for spreadsheets.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title displayed in the report.</p> <code>'Dump'</code> <code>attributes</code> <code>Sequence[str] or None</code> <p>Subset of attribute names to include. If <code>None</code>, all attributes are shown.</p> <code>None</code> <code>target</code> <code>(SCREEN, ...)</code> <p>Output target. <code>'SCREEN'</code> prints to stdout; other targets may trigger file creation depending on the implementation.</p> <code>'SCREEN'</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>Domain(points).dump(title=\"Vertices\")\n</code></pre> <p>Note: Formatting adapts to the chosen <code>target</code>.</p>"},{"location":"api/domain/#npblender.domain.Domain.extend","title":"extend","text":"<pre><code>extend(other, join_fields=True)\n</code></pre> <p>Append multiple records from another array or FieldArray.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray or structured np.ndarray</code> <p>The array of records to append. Must have named fields matching a subset of the current array's fields.</p> required"},{"location":"api/domain/#npblender.domain.Domain.filtered","title":"filtered","text":"<pre><code>filtered(selector, *, copy=False)\n</code></pre> <p>Return a FieldArray containing only the selected records.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>array\u2011like, slice or int</code> <p>Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice. It is applied to the current valid part of the buffer (<code>self._data[:self._length]</code>).</p> required <code>copy</code> <code>bool</code> <ul> <li>False    (default) =&gt; the new array shares the same memory                          (changes propagate both ways).</li> <li>True           =&gt; the data are physically copied.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>FieldArray</code> <p>A new instance holding exactly <code>len(selector)</code> records and inheriting the current field\u2011infos.</p>"},{"location":"api/domain/#npblender.domain.Domain.from_bl_attributes","title":"from_bl_attributes","text":"<pre><code>from_bl_attributes(bl_attributes)\n</code></pre> <p>Import attributes from a Blender attribute collection.</p> <p>Reads geometry attributes from a Blender data-block and creates/updates the corresponding domain attributes, resizing the domain if needed.</p> <p>Parameters:</p> Name Type Description Default <code>bl_attributes</code> <code>Mapping[str, Any]</code> <p>Blender attributes collection (name \u2192 attribute descriptor) providing at least <code>.domain</code>, <code>.is_internal</code>, <code>.data_type</code>, and <code>.data</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Note:*** Only external (non-internal) Blender attributes matching this</code> <code>domain are imported. Missing attributes are created with `transfer=True`.</code>"},{"location":"api/domain/#npblender.domain.Domain.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Build a FieldArray from a dictionary with field data and optional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, array - like or (array, dict)]</code> <p>Mapping field names to arrays or (array, infos). Infos must include NAME.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the data. Default: True.</p> required <p>Returns:</p> Type Description <code>FieldArray</code>"},{"location":"api/domain/#npblender.domain.Domain.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> <p>Get attribute by name.</p> <p>If name is not an actual field, return default value. Name can be an array. <pre><code>pos = field_array.get(\"position\", (0, 0, 1))\npos = field_array.get([[0, 0, 1], [0, 0, 0]])\n</code></pre></p>"},{"location":"api/domain/#npblender.domain.Domain.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other)\n</code></pre> <p>Merge trans-domain attributes from another domain.</p> <p>Copies or aligns attributes from <code>other</code> into the current domain, excluding any attributes not flagged as trans-domain in <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain or None</code> <p>Source domain. If <code>None</code>, the call is a no-op.</p> required <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p>"},{"location":"api/domain/#npblender.domain.Domain.join_fields","title":"join_fields","text":"<pre><code>join_fields(other, exclude=[])\n</code></pre> <p>Add all missing fields from another FieldArray.</p> <p>For every field in <code>other</code> that is not present in <code>self</code>, a new field is created with the same dtype and shape, and initialized with its default value across all existing records.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray</code> <p>Another FieldArray instance whose fields will be checked for missing fields.</p> required <p>Returns:</p> Type Description <code>self</code>"},{"location":"api/domain/#npblender.domain.Domain.make_buckets","title":"make_buckets","text":"<pre><code>make_buckets(attr)\n</code></pre> <p>Group items into buckets by attribute value.</p> <p>When a domain is to be considered as a collection of packets of various sizes, buckets mechanism groups pakets by size, allowing further operation with numpy vectorization.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>array - like or str</code> <p>Either an integer of shape <code>(N,)</code> or the name of an existing integer attribute in the domain.</p> required <p>Returns:</p> Type Description <code>list[ndarray(count, n)]</code> <p>A list of int arrays (count, n): count is the number of buckets of length n.</p> <p>Examples:</p> <pre><code>buckets = mesh.make_buckets('material')\nfor bucket in buckets:\n    print(bucket.shape)\n</code></pre> <p>Note: The bucket attribute can be read with <code>attr[bucket[:, 0]]</code>.</p>"},{"location":"api/domain/#npblender.domain.Domain.multiply","title":"multiply","text":"<pre><code>multiply(count)\n</code></pre> <p>Duplicate the current records <code>count</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of times to repeat the current records.</p> required Notes <p>This duplicates the current valid records (up to self._length). If the array is empty or count &lt;= 1, nothing happens.</p> Example: <p>If the array has 3 records and count == 4, the result will be:</p> <p>[rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]</p>"},{"location":"api/domain/#npblender.domain.Domain.new_attribute","title":"new_attribute","text":"<pre><code>new_attribute(name, data_type, default, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Register a new attribute in the domain schema.</p> <p>Creates (or ensures) an attribute with a given name, logical data type, default value, and flags controlling Blender transfer and cross-domain propagation.</p> <p>Note: <code>data_type</code> argument is a Blender data type not a python data type. The data type name is compatible with Blender internal storage. <code>FLOAT</code>data type is implemented as <code>np.float32</code> and  'INT' as <code>np.int32</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name (Python identifier recommended).</p> required <code>data_type</code> <code>(FLOAT, INT, BOOL, VECTOR, VECTOR2, COLOR, QUATERNION, MATRIX, STRING, ...)</code> <p>Logical data type used by the domain.</p> <code>'FLOAT'</code> <code>default</code> <code>Any</code> <p>Default value for newly allocated elements.</p> required <code>optional</code> <code>bool</code> <p>If <code>True</code>, the attribute may be absent on some elements.</p> <code>False</code> <code>transfer</code> <code>bool</code> <p>If <code>True</code>, eligible to be transferred to Blender as a geometry attribute.</p> <code>True</code> <code>transdom</code> <code>bool</code> <p>If <code>True</code>, considered a trans-domain attribute that can be copied across compatible domains.</p> <code>True</code> See Also <p><code>new_float</code>, <code>new_vector</code>, <code>new_int</code>, <code>new_bool</code>, <code>new_color</code>, <code>new_vector2</code>, <code>new_quaternion</code>, <code>new_matrix</code></p>"},{"location":"api/domain/#npblender.domain.Domain.new_bool","title":"new_bool","text":"<pre><code>new_bool(name, default=False, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a boolean attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>bool</code> <p>Default value.</p> <code>False</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/domain/#npblender.domain.Domain.new_color","title":"new_color","text":"<pre><code>new_color(name, default=(0.5, 0.5, 0.5, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a color attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,) or (4,)</code> <p>Default color as RGB or RGBA.</p> <code>(0.5, 0.5, 0.5, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/domain/#npblender.domain.Domain.new_field","title":"new_field","text":"<pre><code>new_field(name, dtype, shape=None, default=0, optional=False, **infos)\n</code></pre> <p>Add a field to the structured array.</p> Arguments <pre><code>- name (str) : field name\n- dtype (type) : a valid numpy dtype\n- shape (tuple = None) : the shape of the field\n- default (any = 0) : default value\n- optional (bool = False) : the field is created only when accessed\n- infos (dict) : field infos\n</code></pre>"},{"location":"api/domain/#npblender.domain.Domain.new_float","title":"new_float","text":"<pre><code>new_float(name, default=0.0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a scalar float attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>float</code> <p>Default value.</p> <code>0.0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/domain/#npblender.domain.Domain.new_int","title":"new_int","text":"<pre><code>new_int(name, default=0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure an integer attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>int</code> <p>Default value.</p> <code>0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/domain/#npblender.domain.Domain.new_matrix","title":"new_matrix","text":"<pre><code>new_matrix(name, default=np.eye(4), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a matrix attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array - like</code> <p>Default matrix. By convention this is a square matrix per element (e.g., <code>(3, 3)</code> rotation or <code>(4, 4)</code> transform).</p> <code>np.eye(4)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code> <code>order</code> required"},{"location":"api/domain/#npblender.domain.Domain.new_quaternion","title":"new_quaternion","text":"<pre><code>new_quaternion(name, default=(0.0, 0.0, 0.0, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a quaternion attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (4,)</code> <p>Default quaternion in <code>(x, y, z, w)</code> convention.</p> <code>(0.0, 0.0, 0.0, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/domain/#npblender.domain.Domain.new_vector","title":"new_vector","text":"<pre><code>new_vector(name, default=(0.0, 0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 3D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,)</code> <p>Default XYZ vector.</p> <code>(0.0, 0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/domain/#npblender.domain.Domain.new_vector2","title":"new_vector2","text":"<pre><code>new_vector2(name, default=(0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 2D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (2,)</code> <p>Default XY vector.</p> <code>(0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/domain/#npblender.domain.Domain.to_bl_attributes","title":"to_bl_attributes","text":"<pre><code>to_bl_attributes(attributes, update=False)\n</code></pre> <p>Export attributes to a Blender attribute collection.</p> <p>Writes eligible domain attributes to a Blender data-block, creating missing attributes and adjusting sizes as needed.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Any</code> <p>Blender attributes collection receiving the values.</p> required <code>update</code> <code>bool</code> <p>If <code>True</code>, update existing attributes in-place; otherwise create them when missing.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Caution:*** Only attributes with `transfer=True` are exported. Optional</code> <code>attributes are skipped.</code> <code>&gt; ***Caution:*** Curve domains user attributes are not saved.</code>"},{"location":"api/domain/#npblender.domain.Domain.to_dict","title":"to_dict","text":"<pre><code>to_dict(*, copy=True, with_infos=True)\n</code></pre> <p>Convert the array to a dictionary of fields or (field, infos) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Whether to copy the arrays.</p> <code>True</code> <code>with_infos</code> <code>bool</code> <p>If True, return (array, infos) for each field.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, array or (array, dict)]</code>"},{"location":"api/domain/#npblender.domain.Domain.transfer_attributes","title":"transfer_attributes","text":"<pre><code>transfer_attributes(other, shape=None, other_shape=None)\n</code></pre> <p>Transfer values of trans-domain attributes from another domain.</p> <p>Copies values for each trans-domain attribute present in <code>other</code> into the corresponding attributes of <code>self</code>, with optional reshaping for batched assignments.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain</code> <p>Source domain providing attribute values.</p> required <code>shape</code> <code>tuple of int or None</code> <p>Target reshape for <code>self</code> before assignment. If <code>None</code>, uses <code>(self._length,)</code>.</p> <code>None</code> <code>other_shape</code> <code>tuple of int or None</code> <p>Source reshape for <code>other</code> before assignment. If <code>None</code>, uses <code>(other._length,)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p> <code>&gt; ***Note:*** Each attribute is reshaped as `shape + item_shape` on `self`</code> <code>and `other_shape + item_shape` on `other` prior to assignment.</code>"},{"location":"api/edge/","title":"Edge","text":""},{"location":"api/edge/#npblender.domain.Edge","title":"Edge","text":"<pre><code>Edge(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>Mesh edge domain.</p> <p>Represents undirected edges as pairs of vertex indices and provides utilities to validate, filter, and transfer attributes.</p> <p>Attributes:</p> Name Type Description <code>vertex0, vertex1</code> <code>(E,) int</code> <p>Endpoints of each edge.</p> Properties <p>vertices : (E, 2) int     View/setter exposing concatenated <code>(vertex0, vertex1)</code>.</p> <p>Methods:</p> Name Description <code>check</code> <p>Validate indices are &lt; <code>count</code> and no degenerate edges exist.</p> <code>remove_face_edges</code> <p>Remove edges that belong to a set of face edges.</p> <code>compute_attribute_on_points</code> <p>Average edge attributes back to points (each endpoint contributes).</p> <p>Examples:</p> <p>Remove edges already represented by faces:</p> <pre><code>edges.remove_face_edges(face_edges)\n</code></pre> <p>Average per-edge scalar to points:</p> <pre><code>p_attr = edges.compute_attribute_on_points(\"heat\", points)\n</code></pre> <p>Caution: <code>check()</code> raises if an endpoint index is out of range or if an edge uses the same vertex twice.</p> <p>Initialize a domain array and its attribute schema.</p> <p>Initializes the storage from an existing array/domain or creates an empty structure. Optionally merges attribute definitions/values from another domain and keyword-provided attributes.</p> <p>Domains are never instancied directly but by owning geometries.</p> <p>Actual Domains are <code>Vertex</code>, [<code>Faces</code>][npblender.domain.Faces], <code>Corner</code>, <code>Edge</code>, <code>ControlPoint</code>, <code>Spline</code> and <code>Point</code>.</p> <p>Domains are initialized with their defaults attributes, for instance <code>position</code> for point domaines.</p> <p>Use attributes can be freely added. </p> <p>Note: user attributes are saved in Blender Mesh objects only, Blender Curve objects don't store user attributes.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>array - like or FieldArray or None</code> <p>Source data used to initialize the domain. If <code>None</code>, an empty domain is created and <code>_declare_attributes()</code> is called to register defaults.</p> <code>None</code> <code>mode</code> <code>(COPY, CAPTURE, EMPTY)</code> <p>Initialization mode. <code>'COPY'</code> duplicates the input data, <code>'CAPTURE'</code> references the input buffer when supported, <code>'EMPTY'</code> creates the structure without copying values.</p> <code>'COPY'</code> <code>selector</code> <code>Any</code> <p>Optional row/element selector applied to <code>a</code> prior to initialization.</p> <code>None</code> <code>attr_from</code> <code>Domain or Mapping or None</code> <p>Attribute schema (and possibly values) to merge into this domain.</p> <code>None</code> <code>**attrs</code> <p>Additional attribute name/value pairs to inject or override.</p> <code>{}</code> Notes <p>The effective attribute list results from <code>_declare_attributes()</code>, then <code>attr_from</code>, then <code>**attrs</code> (later entries take precedence).</p> <p>Examples:</p> <pre><code>cube = Mesh.cube() # points, corners, faces and edges domains are created\n# Adding named attribute to point domain\ncube.points.new_float('age')\n# Setting the age\ncube.points.age = np.random.uniforme(10, 10, len(cube.points))\n</code></pre>"},{"location":"api/edge/#npblender.domain.Edge.actual_names","title":"actual_names  <code>property</code>","text":"<pre><code>actual_names\n</code></pre> <p>Column names.</p> <p>Returns the actual field names, excluding optional fields.</p>"},{"location":"api/edge/#npblender.domain.Edge.all_names","title":"all_names  <code>property</code>","text":"<pre><code>all_names\n</code></pre> <p>Column names.</p> <p>Returns all the field names, including optional ones.</p>"},{"location":"api/edge/#npblender.domain.Edge.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Array structured dtype</p> <p>Returns the dtype property of the structured array.</p>"},{"location":"api/edge/#npblender.domain.Edge.transdom_names","title":"transdom_names  <code>property</code>","text":"<pre><code>transdom_names\n</code></pre> <p>List the names of trans-domain attributes.</p> <p>Returns:</p> Type Description <code>list of str</code> <p>Names of attributes flagged with <code>transdom=True</code>.</p> <p>Examples:</p> <pre><code>names = D.transdom_names()\n</code></pre>"},{"location":"api/edge/#npblender.domain.Edge.vertices","title":"vertices  <code>property</code> <code>writable</code>","text":"<pre><code>vertices\n</code></pre> <p>Return per-edge vertex indices.</p> <p>Provides the connectivity of the edge domain as integer pairs of vertex indices. Each row corresponds to one edge, with the two endpoint indices given as an unordered pair.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Type Description <code>numpy.ndarray of shape ``(E, 2)`` and dtype int</code> <p>Array of vertex index pairs, one row per edge.</p> Notes <ul> <li>The order of indices in each pair is not significant: <code>(i, j)</code> and <code>(j, i)</code> denote the same undirected edge.</li> <li>This array can be used to look up endpoint positions from a point/vertex domain.</li> </ul> <p>Examples:</p> <pre><code># Get vertex index pairs for all edges\nedge_pairs = edges.vertices()\n\n# Use them to fetch endpoint coordinates\ncoords = points.position[edge_pairs]\n</code></pre>"},{"location":"api/edge/#npblender.domain.Edge.add","title":"add","text":"<pre><code>add(count, **fields)\n</code></pre> <p>Add count records</p> <p>New records are set with default values or values provided by the user in fields dict.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of records to add.</p> required <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/edge/#npblender.domain.Edge.append","title":"append","text":"<pre><code>append(**fields)\n</code></pre> <p>Append values to the structured array.</p> <p>The number of records to append is determined by the number of fields provided in the fields dictionary. The values of the fields are copied to the new records.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/edge/#npblender.domain.Edge.as_kwargs","title":"as_kwargs","text":"<pre><code>as_kwargs(selector=None, include=None, exclude=None)\n</code></pre> <p>Return a dictionary of field values formatted as kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>slice, int, list, or mask</code> <p>Optional selection of elements to extract.</p> <code>None</code> <code>include</code> <code>list[str]</code> <p>List of field names (original or python names) to include.</p> <code>None</code> <code>exclude</code> <code>list[str]</code> <p>List of field names (original or python names) to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Mapping from python-safe field names to array values.</p>"},{"location":"api/edge/#npblender.domain.Edge.check","title":"check","text":"<pre><code>check(count, halt=True)\n</code></pre> <p>Validate edge endpoint indices and detect degeneracies.</p> <p>Verifies that all edge endpoints are strictly less than <code>count</code> and that no edge uses the same vertex twice.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of vertices in the referenced point/vertex domain.</p> required <code>halt</code> <code>bool</code> <p>If <code>True</code>, raise on failure; otherwise print a message and return <code>False</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the check passes or the domain is empty; <code>False</code> only when invalid and <code>halt</code> is <code>False</code>.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an endpoint index is out of range or if a degenerate edge is found and <code>halt</code> is <code>True</code>.</p> <p>Examples:</p> <pre><code>ok = edges.check(count=len(points), halt=False)\nif not ok:\n    # inspect or fix edges, then retry\n    ...\n</code></pre>"},{"location":"api/edge/#npblender.domain.Edge.compute_attribute_on_points","title":"compute_attribute_on_points","text":"<pre><code>compute_attribute_on_points(attr, points)\n</code></pre> <p>Average an edge attribute back to points (endpoints).</p> <p>For each edge attribute value, accumulates it to both endpoints and divides by the number of incident contributions per point.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str or ndarray</code> <p>Name of the edge attribute to transfer, or an explicit array with shape <code>(E, ...)</code>.</p> required <code>points</code> <code>Point</code> <p>Target point/vertex domain (<code>len(points)</code> sets the output length).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of shape <code>(len(points), ...)</code> containing the averaged values.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>attr</code> is a string and no such edge attribute exists, or if the provided array length does not match <code>len(self)</code> (validated by <code>_check_attribute_to_compute</code>).</p> <code>IndexError</code> <p>If an endpoint index falls outside <code>[0, len(points))</code>.</p> <code>TypeError</code> <p>If the attribute dtype cannot be averaged (e.g., non-numeric types).</p> <p>Examples:</p> <pre><code># Average per-edge scalar \"heat\" to vertices\nv_heat = edges.compute_attribute_on_points(\"heat\", points)\n</code></pre>"},{"location":"api/edge/#npblender.domain.Edge.copy_field","title":"copy_field","text":"<pre><code>copy_field(field_name, new_name, **infos)\n</code></pre> <p>Duplicate an existing field under a new name, with optional metadata overrides.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the existing field to copy.</p> required <code>new_name</code> <code>str</code> <p>The name of the new field to create.</p> required <code>infos</code> <code>keyword arguments</code> <p>Optional metadata (e.g. default, unit, description...) to override or supplement the original field's metadata.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the source field does not exist.</p> <code>ValueError</code> <p>If the target name already exists or is reserved.</p>"},{"location":"api/edge/#npblender.domain.Edge.delete","title":"delete","text":"<pre><code>delete(index)\n</code></pre> <p>Delete a selection of items from the array.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int, slice, or array-like</code> <p>The indices of the elements to delete from the current data.</p> required Notes <p>This operates only on the valid range <code>[0:self._length]</code>. The internal buffer is preserved (no reallocation).</p>"},{"location":"api/edge/#npblender.domain.Edge.dump","title":"dump","text":"<pre><code>dump(title='Dump', attributes=None, target='SCREEN')\n</code></pre> <p>Pretty-print or export domain content.</p> <p>Formats attribute values and prints to screen or builds a tabular dump suitable for spreadsheets.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title displayed in the report.</p> <code>'Dump'</code> <code>attributes</code> <code>Sequence[str] or None</code> <p>Subset of attribute names to include. If <code>None</code>, all attributes are shown.</p> <code>None</code> <code>target</code> <code>(SCREEN, ...)</code> <p>Output target. <code>'SCREEN'</code> prints to stdout; other targets may trigger file creation depending on the implementation.</p> <code>'SCREEN'</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>Domain(points).dump(title=\"Vertices\")\n</code></pre> <p>Note: Formatting adapts to the chosen <code>target</code>.</p>"},{"location":"api/edge/#npblender.domain.Edge.extend","title":"extend","text":"<pre><code>extend(other, join_fields=True)\n</code></pre> <p>Append multiple records from another array or FieldArray.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray or structured np.ndarray</code> <p>The array of records to append. Must have named fields matching a subset of the current array's fields.</p> required"},{"location":"api/edge/#npblender.domain.Edge.filtered","title":"filtered","text":"<pre><code>filtered(selector, *, copy=False)\n</code></pre> <p>Return a FieldArray containing only the selected records.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>array\u2011like, slice or int</code> <p>Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice. It is applied to the current valid part of the buffer (<code>self._data[:self._length]</code>).</p> required <code>copy</code> <code>bool</code> <ul> <li>False    (default) =&gt; the new array shares the same memory                          (changes propagate both ways).</li> <li>True           =&gt; the data are physically copied.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>FieldArray</code> <p>A new instance holding exactly <code>len(selector)</code> records and inheriting the current field\u2011infos.</p>"},{"location":"api/edge/#npblender.domain.Edge.from_bl_attributes","title":"from_bl_attributes","text":"<pre><code>from_bl_attributes(bl_attributes)\n</code></pre> <p>Import attributes from a Blender attribute collection.</p> <p>Reads geometry attributes from a Blender data-block and creates/updates the corresponding domain attributes, resizing the domain if needed.</p> <p>Parameters:</p> Name Type Description Default <code>bl_attributes</code> <code>Mapping[str, Any]</code> <p>Blender attributes collection (name \u2192 attribute descriptor) providing at least <code>.domain</code>, <code>.is_internal</code>, <code>.data_type</code>, and <code>.data</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Note:*** Only external (non-internal) Blender attributes matching this</code> <code>domain are imported. Missing attributes are created with `transfer=True`.</code>"},{"location":"api/edge/#npblender.domain.Edge.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Build a FieldArray from a dictionary with field data and optional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, array - like or (array, dict)]</code> <p>Mapping field names to arrays or (array, infos). Infos must include NAME.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the data. Default: True.</p> required <p>Returns:</p> Type Description <code>FieldArray</code>"},{"location":"api/edge/#npblender.domain.Edge.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> <p>Get attribute by name.</p> <p>If name is not an actual field, return default value. Name can be an array. <pre><code>pos = field_array.get(\"position\", (0, 0, 1))\npos = field_array.get([[0, 0, 1], [0, 0, 0]])\n</code></pre></p>"},{"location":"api/edge/#npblender.domain.Edge.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other)\n</code></pre> <p>Merge trans-domain attributes from another domain.</p> <p>Copies or aligns attributes from <code>other</code> into the current domain, excluding any attributes not flagged as trans-domain in <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain or None</code> <p>Source domain. If <code>None</code>, the call is a no-op.</p> required <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p>"},{"location":"api/edge/#npblender.domain.Edge.join_fields","title":"join_fields","text":"<pre><code>join_fields(other, exclude=[])\n</code></pre> <p>Add all missing fields from another FieldArray.</p> <p>For every field in <code>other</code> that is not present in <code>self</code>, a new field is created with the same dtype and shape, and initialized with its default value across all existing records.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray</code> <p>Another FieldArray instance whose fields will be checked for missing fields.</p> required <p>Returns:</p> Type Description <code>self</code>"},{"location":"api/edge/#npblender.domain.Edge.make_buckets","title":"make_buckets","text":"<pre><code>make_buckets(attr)\n</code></pre> <p>Group items into buckets by attribute value.</p> <p>When a domain is to be considered as a collection of packets of various sizes, buckets mechanism groups pakets by size, allowing further operation with numpy vectorization.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>array - like or str</code> <p>Either an integer of shape <code>(N,)</code> or the name of an existing integer attribute in the domain.</p> required <p>Returns:</p> Type Description <code>list[ndarray(count, n)]</code> <p>A list of int arrays (count, n): count is the number of buckets of length n.</p> <p>Examples:</p> <pre><code>buckets = mesh.make_buckets('material')\nfor bucket in buckets:\n    print(bucket.shape)\n</code></pre> <p>Note: The bucket attribute can be read with <code>attr[bucket[:, 0]]</code>.</p>"},{"location":"api/edge/#npblender.domain.Edge.multiply","title":"multiply","text":"<pre><code>multiply(count)\n</code></pre> <p>Duplicate the current records <code>count</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of times to repeat the current records.</p> required Notes <p>This duplicates the current valid records (up to self._length). If the array is empty or count &lt;= 1, nothing happens.</p> Example: <p>If the array has 3 records and count == 4, the result will be:</p> <p>[rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]</p>"},{"location":"api/edge/#npblender.domain.Edge.new_attribute","title":"new_attribute","text":"<pre><code>new_attribute(name, data_type, default, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Register a new attribute in the domain schema.</p> <p>Creates (or ensures) an attribute with a given name, logical data type, default value, and flags controlling Blender transfer and cross-domain propagation.</p> <p>Note: <code>data_type</code> argument is a Blender data type not a python data type. The data type name is compatible with Blender internal storage. <code>FLOAT</code>data type is implemented as <code>np.float32</code> and  'INT' as <code>np.int32</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name (Python identifier recommended).</p> required <code>data_type</code> <code>(FLOAT, INT, BOOL, VECTOR, VECTOR2, COLOR, QUATERNION, MATRIX, STRING, ...)</code> <p>Logical data type used by the domain.</p> <code>'FLOAT'</code> <code>default</code> <code>Any</code> <p>Default value for newly allocated elements.</p> required <code>optional</code> <code>bool</code> <p>If <code>True</code>, the attribute may be absent on some elements.</p> <code>False</code> <code>transfer</code> <code>bool</code> <p>If <code>True</code>, eligible to be transferred to Blender as a geometry attribute.</p> <code>True</code> <code>transdom</code> <code>bool</code> <p>If <code>True</code>, considered a trans-domain attribute that can be copied across compatible domains.</p> <code>True</code> See Also <p><code>new_float</code>, <code>new_vector</code>, <code>new_int</code>, <code>new_bool</code>, <code>new_color</code>, <code>new_vector2</code>, <code>new_quaternion</code>, <code>new_matrix</code></p>"},{"location":"api/edge/#npblender.domain.Edge.new_bool","title":"new_bool","text":"<pre><code>new_bool(name, default=False, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a boolean attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>bool</code> <p>Default value.</p> <code>False</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/edge/#npblender.domain.Edge.new_color","title":"new_color","text":"<pre><code>new_color(name, default=(0.5, 0.5, 0.5, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a color attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,) or (4,)</code> <p>Default color as RGB or RGBA.</p> <code>(0.5, 0.5, 0.5, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/edge/#npblender.domain.Edge.new_field","title":"new_field","text":"<pre><code>new_field(name, dtype, shape=None, default=0, optional=False, **infos)\n</code></pre> <p>Add a field to the structured array.</p> Arguments <pre><code>- name (str) : field name\n- dtype (type) : a valid numpy dtype\n- shape (tuple = None) : the shape of the field\n- default (any = 0) : default value\n- optional (bool = False) : the field is created only when accessed\n- infos (dict) : field infos\n</code></pre>"},{"location":"api/edge/#npblender.domain.Edge.new_float","title":"new_float","text":"<pre><code>new_float(name, default=0.0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a scalar float attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>float</code> <p>Default value.</p> <code>0.0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/edge/#npblender.domain.Edge.new_int","title":"new_int","text":"<pre><code>new_int(name, default=0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure an integer attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>int</code> <p>Default value.</p> <code>0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/edge/#npblender.domain.Edge.new_matrix","title":"new_matrix","text":"<pre><code>new_matrix(name, default=np.eye(4), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a matrix attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array - like</code> <p>Default matrix. By convention this is a square matrix per element (e.g., <code>(3, 3)</code> rotation or <code>(4, 4)</code> transform).</p> <code>np.eye(4)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code> <code>order</code> required"},{"location":"api/edge/#npblender.domain.Edge.new_quaternion","title":"new_quaternion","text":"<pre><code>new_quaternion(name, default=(0.0, 0.0, 0.0, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a quaternion attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (4,)</code> <p>Default quaternion in <code>(x, y, z, w)</code> convention.</p> <code>(0.0, 0.0, 0.0, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/edge/#npblender.domain.Edge.new_vector","title":"new_vector","text":"<pre><code>new_vector(name, default=(0.0, 0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 3D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,)</code> <p>Default XYZ vector.</p> <code>(0.0, 0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/edge/#npblender.domain.Edge.new_vector2","title":"new_vector2","text":"<pre><code>new_vector2(name, default=(0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 2D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (2,)</code> <p>Default XY vector.</p> <code>(0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/edge/#npblender.domain.Edge.remove_face_edges","title":"remove_face_edges","text":"<pre><code>remove_face_edges(face_edges)\n</code></pre> <p>Remove edges that belong to a given face-edge set.</p> <p>Compares the (undirected) edge list of this domain to <code>face_edges</code> and deletes any matching edges. Both inputs are normalized internally so that edge order does not matter.</p> <p>This method is typically used when loading a mesh from an object to keep only free edges.</p> <p>Parameters:</p> Name Type Description Default <code>face_edges</code> <code>ndarray of shape ``(M, 2)`` and dtype int</code> <p>Vertex-index pairs representing edges built from faces (e.g., via <code>get_face_edges</code>).</p> required <p>Returns:</p> Type Description <code>None</code> Notes <ul> <li>If <code>face_edges</code> is empty, the method returns immediately.</li> <li>Matching is performed by viewing each pair as a structured item to allow fast set membership tests.</li> </ul>"},{"location":"api/edge/#npblender.domain.Edge.to_bl_attributes","title":"to_bl_attributes","text":"<pre><code>to_bl_attributes(attributes, update=False)\n</code></pre> <p>Export attributes to a Blender attribute collection.</p> <p>Writes eligible domain attributes to a Blender data-block, creating missing attributes and adjusting sizes as needed.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Any</code> <p>Blender attributes collection receiving the values.</p> required <code>update</code> <code>bool</code> <p>If <code>True</code>, update existing attributes in-place; otherwise create them when missing.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Caution:*** Only attributes with `transfer=True` are exported. Optional</code> <code>attributes are skipped.</code> <code>&gt; ***Caution:*** Curve domains user attributes are not saved.</code>"},{"location":"api/edge/#npblender.domain.Edge.to_dict","title":"to_dict","text":"<pre><code>to_dict(*, copy=True, with_infos=True)\n</code></pre> <p>Convert the array to a dictionary of fields or (field, infos) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Whether to copy the arrays.</p> <code>True</code> <code>with_infos</code> <code>bool</code> <p>If True, return (array, infos) for each field.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, array or (array, dict)]</code>"},{"location":"api/edge/#npblender.domain.Edge.transfer_attributes","title":"transfer_attributes","text":"<pre><code>transfer_attributes(other, shape=None, other_shape=None)\n</code></pre> <p>Transfer values of trans-domain attributes from another domain.</p> <p>Copies values for each trans-domain attribute present in <code>other</code> into the corresponding attributes of <code>self</code>, with optional reshaping for batched assignments.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain</code> <p>Source domain providing attribute values.</p> required <code>shape</code> <code>tuple of int or None</code> <p>Target reshape for <code>self</code> before assignment. If <code>None</code>, uses <code>(self._length,)</code>.</p> <code>None</code> <code>other_shape</code> <code>tuple of int or None</code> <p>Source reshape for <code>other</code> before assignment. If <code>None</code>, uses <code>(other._length,)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p> <code>&gt; ***Note:*** Each attribute is reshaped as `shape + item_shape` on `self`</code> <code>and `other_shape + item_shape` on `other` prior to assignment.</code>"},{"location":"api/engine/","title":"Engine","text":""},{"location":"api/engine/#npblender.engine","title":"engine","text":""},{"location":"api/engine/#npblender.engine--engine","title":"Engine","text":"<p>Main animation engine for npblender, managing animations, frame stepping, baking, and interaction with Blender's scene and rendering pipeline.</p> <p>Features: - Global animation management (add, run, reset) - Frame stepping with optional subframes - Baking system for saving and loading animation states - Integration with Blender's depsgraph and render handlers - Random number generation per frame for procedural animation - Support for viewport and render-time updates</p> <p>This module also provides a base <code>Animation</code> class which can be directly used with function-based animations, and Blender operators/panels for managing baked animations.</p>"},{"location":"api/engine/#npblender.engine.Engine","title":"Engine","text":"<pre><code>Engine()\n</code></pre>"},{"location":"api/engine/#npblender.engine.Engine.animation","title":"animation","text":"<pre><code>animation(animation, subframes=0)\n</code></pre> <p>Single animation</p> Arguments <ul> <li>animation (Animation)</li> <li>subframes (int = 0) : number of subframes</li> </ul>"},{"location":"api/engine/#npblender.engine.Engine.first_frame_reset","title":"first_frame_reset","text":"<pre><code>first_frame_reset()\n</code></pre> <p>Called when current frame is the first one</p>"},{"location":"api/engine/#npblender.engine.Engine.go","title":"go","text":"<pre><code>go(compute, reset=None, view=None, subframes=0)\n</code></pre> <p>Legacy behavior : animates with functions</p> Arguments <ul> <li>compute (function) : computation function</li> <li>reset (function = None) : reset function</li> <li>view (function = None) : view function</li> <li>subframes (int = 0) : subframes</li> </ul>"},{"location":"api/engine/#npblender.engine.Engine.step","title":"step","text":"<pre><code>step()\n</code></pre> <p>One step</p>"},{"location":"api/engine/#npblender.engine.npblenderBake","title":"npblenderBake","text":"<p>               Bases: <code>Operator</code></p> <p>Bake npblender animation</p>"},{"location":"api/engine/#npblender.engine.npblenderBakePanel","title":"npblenderBakePanel","text":"<p>               Bases: <code>Panel</code></p> <p>npblender animation bake control</p>"},{"location":"api/engine/#npblender.engine.npblenderDelBakeFiles","title":"npblenderDelBakeFiles","text":"<p>               Bases: <code>Operator</code></p> <p>Delete npblender bake files</p>"},{"location":"api/face/","title":"Face","text":""},{"location":"api/face/#npblender.domain.Face","title":"Face","text":"<pre><code>Face(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>Mesh face (polygon) domain.</p> <p>Inherits loop bookkeeping from :class:<code>FaceSplineDomain</code> and provides face-level operations: area/normal/centroid computation, edge extraction, attribute transfers, and topology-aware deletions.</p> <p>Attributes:</p> Name Type Description <code>loop_start</code> <code>(F,) int</code> <p>Starting corner index of each face.</p> <code>loop_total</code> <code>(F,) int</code> <p>Number of corners per face.</p> <code>material_index</code> <code>(F,) int, optional</code> <p>Material index per face.</p> <code>sharp_face</code> <code>(F,) bool, optional</code> <p>Sharp shading flag.</p> <p>Methods:</p> Name Description <code>delete_loops</code> <p>Delete faces and their incident corners; returns removed vertex indices.</p> <code>get_face_edges</code> <p>Edge list per face as ordered vertex-index pairs.</p> <code>get_edges</code> <p>Unique undirected edges present in the mesh faces.</p> <code>get_position</code> <p>Face centroids by averaging incident vertex positions.</p> <code>area_vectors</code> <p>Area-weighted normal vectors (unnormalized).</p> <code>area</code> <p>Face areas.</p> <code>normal</code> <p>Unit normals.</p> <code>sequences</code> <p>Per-face sequences of vertex indices.</p> <code>compute_attribute_on_points</code> <p>Average a face attribute back to points.</p> <p>Examples:</p> <p>Compute normals and areas:</p> <pre><code>n = faces.normal(corners, points)\nA = faces.area(corners, points)\n</code></pre> <p>Extract unique edges:</p> <pre><code>edges = faces.get_edges(corners)\n</code></pre> <p>Note: Area vectors are computed by triangulating polygons and summing triangle cross products.</p> <p>Warning: After deleting faces via :meth:<code>delete_loops</code>, update dependent domains accordingly (e.g., rebuild edges if needed).</p> <p>Initialize a domain array and its attribute schema.</p> <p>Initializes the storage from an existing array/domain or creates an empty structure. Optionally merges attribute definitions/values from another domain and keyword-provided attributes.</p> <p>Domains are never instancied directly but by owning geometries.</p> <p>Actual Domains are <code>Vertex</code>, [<code>Faces</code>][npblender.domain.Faces], <code>Corner</code>, <code>Edge</code>, <code>ControlPoint</code>, <code>Spline</code> and <code>Point</code>.</p> <p>Domains are initialized with their defaults attributes, for instance <code>position</code> for point domaines.</p> <p>Use attributes can be freely added. </p> <p>Note: user attributes are saved in Blender Mesh objects only, Blender Curve objects don't store user attributes.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>array - like or FieldArray or None</code> <p>Source data used to initialize the domain. If <code>None</code>, an empty domain is created and <code>_declare_attributes()</code> is called to register defaults.</p> <code>None</code> <code>mode</code> <code>(COPY, CAPTURE, EMPTY)</code> <p>Initialization mode. <code>'COPY'</code> duplicates the input data, <code>'CAPTURE'</code> references the input buffer when supported, <code>'EMPTY'</code> creates the structure without copying values.</p> <code>'COPY'</code> <code>selector</code> <code>Any</code> <p>Optional row/element selector applied to <code>a</code> prior to initialization.</p> <code>None</code> <code>attr_from</code> <code>Domain or Mapping or None</code> <p>Attribute schema (and possibly values) to merge into this domain.</p> <code>None</code> <code>**attrs</code> <p>Additional attribute name/value pairs to inject or override.</p> <code>{}</code> Notes <p>The effective attribute list results from <code>_declare_attributes()</code>, then <code>attr_from</code>, then <code>**attrs</code> (later entries take precedence).</p> <p>Examples:</p> <pre><code>cube = Mesh.cube() # points, corners, faces and edges domains are created\n# Adding named attribute to point domain\ncube.points.new_float('age')\n# Setting the age\ncube.points.age = np.random.uniforme(10, 10, len(cube.points))\n</code></pre>"},{"location":"api/face/#npblender.domain.Face.actual_names","title":"actual_names  <code>property</code>","text":"<pre><code>actual_names\n</code></pre> <p>Column names.</p> <p>Returns the actual field names, excluding optional fields.</p>"},{"location":"api/face/#npblender.domain.Face.all_names","title":"all_names  <code>property</code>","text":"<pre><code>all_names\n</code></pre> <p>Column names.</p> <p>Returns all the field names, including optional ones.</p>"},{"location":"api/face/#npblender.domain.Face.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Array structured dtype</p> <p>Returns the dtype property of the structured array.</p>"},{"location":"api/face/#npblender.domain.Face.next_loop_start","title":"next_loop_start  <code>property</code>","text":"<pre><code>next_loop_start\n</code></pre> <p>Offset to use for the next appended item.</p> <p>Returns:</p> Type Description <code>int</code> <p><code>loop_start[-1] + loop_total[-1]</code> if the domain is non-empty, otherwise <code>0</code>.</p> See Also <p><code>compute_loop_start</code></p>"},{"location":"api/face/#npblender.domain.Face.reversed_indices","title":"reversed_indices  <code>property</code>","text":"<pre><code>reversed_indices\n</code></pre> <p>Map each corner/control-point index back to its owning item.</p> <p>Returns:</p> Type Description <code>ndarray of shape ``(sum(loop_total),)``</code> <p>For index <code>k</code> in the flattened corner/control-point array, the value is the face/spline index that owns <code>k</code>.</p>"},{"location":"api/face/#npblender.domain.Face.transdom_names","title":"transdom_names  <code>property</code>","text":"<pre><code>transdom_names\n</code></pre> <p>List the names of trans-domain attributes.</p> <p>Returns:</p> Type Description <code>list of str</code> <p>Names of attributes flagged with <code>transdom=True</code>.</p> <p>Examples:</p> <pre><code>names = D.transdom_names()\n</code></pre>"},{"location":"api/face/#npblender.domain.Face.add","title":"add","text":"<pre><code>add(count, **fields)\n</code></pre> <p>Add count records</p> <p>New records are set with default values or values provided by the user in fields dict.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of records to add.</p> required <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/face/#npblender.domain.Face.append","title":"append","text":"<pre><code>append(**fields)\n</code></pre> <p>Append values to the structured array.</p> <p>The number of records to append is determined by the number of fields provided in the fields dictionary. The values of the fields are copied to the new records.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/face/#npblender.domain.Face.append_sizes","title":"append_sizes","text":"<pre><code>append_sizes(sizes, **fields)\n</code></pre> <p>Append new items given their sizes.</p> <p>If <code>loop_start</code> is not provided in <code>fields</code>, computes it from <code>sizes</code> using <code>compute_loop_start</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sizes</code> <code>array-like of int or None</code> <p>Number of corners/control-points for each new item.</p> required <code>**fields</code> <p>Additional per-item attributes to append (e.g., <code>material_index</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The value returned by <code>append(...)</code> (implementation-defined, often the indices/slice of appended items).</p> Notes <p>Passing <code>sizes=None</code> is a no-op and returns an empty list.</p>"},{"location":"api/face/#npblender.domain.Face.area","title":"area","text":"<pre><code>area(corners, points)\n</code></pre> <p>Compute face areas.</p> <p>Returns the scalar area of each polygonal face by taking half the Euclidean norm of its area-weighted normal vector (see <code>area_vectors</code>).</p> <p>Parameters:</p> Name Type Description Default <code>corners</code> <code>Corner</code> <p>Corner domain providing the per-corner <code>vertex_index</code>.</p> required <code>points</code> <code>Point</code> <p>Point (vertex) domain providing <code>position</code> of shape <code>(P, 3)</code>.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray of shape ``(F,)`` and dtype float</code> <p>Area per face.</p> Notes <ul> <li>Internally, faces are triangulated and triangle cross-products are summed to form area vectors; the area is half the vector norm. See <code>area_vectors</code> for details.</li> <li>Degenerate faces (zero area) produce zeros here.</li> </ul> See Also <p><code>area_vectors</code> <code>normal</code> <code>get_surface</code></p>"},{"location":"api/face/#npblender.domain.Face.as_kwargs","title":"as_kwargs","text":"<pre><code>as_kwargs(selector=None, include=None, exclude=None)\n</code></pre> <p>Return a dictionary of field values formatted as kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>slice, int, list, or mask</code> <p>Optional selection of elements to extract.</p> <code>None</code> <code>include</code> <code>list[str]</code> <p>List of field names (original or python names) to include.</p> <code>None</code> <code>exclude</code> <code>list[str]</code> <p>List of field names (original or python names) to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Mapping from python-safe field names to array values.</p>"},{"location":"api/face/#npblender.domain.Face.check","title":"check","text":"<pre><code>check(count, halt=True)\n</code></pre> <p>Validate loop counters against a reference element count.</p> <p>Verifies that the sum of <code>loop_total</code> equals <code>count</code> (i.e., the total number of referenced elements such as corners or control points).</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Expected total number of elements referenced by all items.</p> required <code>halt</code> <code>bool</code> <p>If <code>True</code>, raise on failure; otherwise print a message and return <code>False</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the check passes or the domain is empty; <code>False</code> only when invalid and <code>halt</code> is <code>False</code>.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If <code>sum(loop_total) != count</code> and <code>halt</code> is <code>True</code>.</p> <p>Examples:</p> <pre><code>ok = fs.check(count=len(corners), halt=False)\nif not ok:\n    # fix topology or sizes, then recompute\n    fs.update_loop_start()\n</code></pre>"},{"location":"api/face/#npblender.domain.Face.compute_attribute_on_points","title":"compute_attribute_on_points","text":"<pre><code>compute_attribute_on_points(attr, corners, points)\n</code></pre> <p>Average a per-face attribute back to points (vertices).</p> <p>For each face attribute value, accumulates it to all incident points (via corners) and divides by the number of incident contributions per point.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str or ndarray</code> <p>Name of the face attribute to transfer, or an explicit array of shape <code>(F, ...)</code>.</p> required <code>corners</code> <code>Corner</code> <p>Corner domain (provides <code>vertex_index</code>).</p> required <code>points</code> <code>Point</code> <p>Target point domain (length defines the number of output points).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of shape <code>(len(points), ...)</code> with the averaged values.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>attr</code> is a string and no such face attribute exists.</p> <code>IndexError</code> <p>If corner vertex indices fall outside <code>[0, len(points))</code>.</p>"},{"location":"api/face/#npblender.domain.Face.compute_loop_start","title":"compute_loop_start","text":"<pre><code>compute_loop_start(loop_total=None)\n</code></pre> <p>Compute offsets for one or many new items to append.</p> <p>Parameters:</p> Name Type Description Default <code>loop_total</code> <code>int or array-like of int or None</code> <p>Sizes of the items to add. If <code>None</code>, returns <code>None</code>. If a scalar, returns the single offset. If 1D array-like, returns one offset per size.</p> <code>None</code> <p>Returns:</p> Type Description <code>int or ndarray or None</code> <p>Offsets starting from <code>next_loop_start</code>, shaped like <code>loop_total</code>.</p> <p>Examples:</p> <pre><code># Prepare offsets for three faces of sizes 4, 5, 4\nstarts = fs.compute_loop_start([4, 5, 4])\nfs.append(loop_start=starts, loop_total=[4, 5, 4])\n</code></pre>"},{"location":"api/face/#npblender.domain.Face.copy_field","title":"copy_field","text":"<pre><code>copy_field(field_name, new_name, **infos)\n</code></pre> <p>Duplicate an existing field under a new name, with optional metadata overrides.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the existing field to copy.</p> required <code>new_name</code> <code>str</code> <p>The name of the new field to create.</p> required <code>infos</code> <code>keyword arguments</code> <p>Optional metadata (e.g. default, unit, description...) to override or supplement the original field's metadata.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the source field does not exist.</p> <code>ValueError</code> <p>If the target name already exists or is reserved.</p>"},{"location":"api/face/#npblender.domain.Face.delete","title":"delete","text":"<pre><code>delete(selection)\n</code></pre> <p>Delete selected items and maintain consistent offsets.</p> <p>After deleting items via <code>super().delete(selection)</code>, recomputes <code>loop_start</code> with <code>update_loop_start</code>.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>Any</code> <p>Boolean mask, integer index, slice, or array of indices.</p> required <p>Returns:</p> Type Description <code>None</code> See Also <p><code>update_loop_start</code></p>"},{"location":"api/face/#npblender.domain.Face.delete_loops","title":"delete_loops","text":"<pre><code>delete_loops(selection, corners)\n</code></pre> <p>Delete faces and their incident corners.</p> <p>Removes the selected faces and deletes the corresponding corner loops from <code>corners</code>. Returns the vertex indices (as stored on corners) that were removed with those loops.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>Any</code> <p>Face selection accepted by the domain (boolean mask, indices, slice, etc.).</p> required <code>corners</code> <code>Corner</code> <p>Corner domain holding at least the per-corner <code>vertex_index</code> array.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray of int</code> <p>The (possibly non-unique) vertex indices referenced by the deleted corners. If you need the unique set of affected vertices, apply <code>np.unique</code> on the result.</p> Notes <ul> <li>Internally calls <code>delete</code> on the face domain, which updates loop bookkeeping (see <code>update_loop_start</code>).</li> <li>Corners corresponding to the deleted faces are also removed via <code>corners.delete(...)</code>.</li> </ul> <p>Raises:</p> Type Description <code>IndexError</code> <p>If <code>selection</code> is out of bounds or if corner indices are inconsistent with the provided <code>corners</code> domain.</p>"},{"location":"api/face/#npblender.domain.Face.dump","title":"dump","text":"<pre><code>dump(title='Dump', attributes=None, target='SCREEN')\n</code></pre> <p>Pretty-print or export domain content.</p> <p>Formats attribute values and prints to screen or builds a tabular dump suitable for spreadsheets.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title displayed in the report.</p> <code>'Dump'</code> <code>attributes</code> <code>Sequence[str] or None</code> <p>Subset of attribute names to include. If <code>None</code>, all attributes are shown.</p> <code>None</code> <code>target</code> <code>(SCREEN, ...)</code> <p>Output target. <code>'SCREEN'</code> prints to stdout; other targets may trigger file creation depending on the implementation.</p> <code>'SCREEN'</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>Domain(points).dump(title=\"Vertices\")\n</code></pre> <p>Note: Formatting adapts to the chosen <code>target</code>.</p>"},{"location":"api/face/#npblender.domain.Face.extend","title":"extend","text":"<pre><code>extend(other, join_fields=True)\n</code></pre> <p>Append multiple records from another array or FieldArray.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray or structured np.ndarray</code> <p>The array of records to append. Must have named fields matching a subset of the current array's fields.</p> required"},{"location":"api/face/#npblender.domain.Face.filtered","title":"filtered","text":"<pre><code>filtered(selector, *, copy=False)\n</code></pre> <p>Return a FieldArray containing only the selected records.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>array\u2011like, slice or int</code> <p>Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice. It is applied to the current valid part of the buffer (<code>self._data[:self._length]</code>).</p> required <code>copy</code> <code>bool</code> <ul> <li>False    (default) =&gt; the new array shares the same memory                          (changes propagate both ways).</li> <li>True           =&gt; the data are physically copied.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>FieldArray</code> <p>A new instance holding exactly <code>len(selector)</code> records and inheriting the current field\u2011infos.</p>"},{"location":"api/face/#npblender.domain.Face.from_bl_attributes","title":"from_bl_attributes","text":"<pre><code>from_bl_attributes(bl_attributes)\n</code></pre> <p>Import attributes from a Blender attribute collection.</p> <p>Reads geometry attributes from a Blender data-block and creates/updates the corresponding domain attributes, resizing the domain if needed.</p> <p>Parameters:</p> Name Type Description Default <code>bl_attributes</code> <code>Mapping[str, Any]</code> <p>Blender attributes collection (name \u2192 attribute descriptor) providing at least <code>.domain</code>, <code>.is_internal</code>, <code>.data_type</code>, and <code>.data</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Note:*** Only external (non-internal) Blender attributes matching this</code> <code>domain are imported. Missing attributes are created with `transfer=True`.</code>"},{"location":"api/face/#npblender.domain.Face.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Build a FieldArray from a dictionary with field data and optional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, array - like or (array, dict)]</code> <p>Mapping field names to arrays or (array, infos). Infos must include NAME.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the data. Default: True.</p> required <p>Returns:</p> Type Description <code>FieldArray</code>"},{"location":"api/face/#npblender.domain.Face.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> <p>Get attribute by name.</p> <p>If name is not an actual field, return default value. Name can be an array. <pre><code>pos = field_array.get(\"position\", (0, 0, 1))\npos = field_array.get([[0, 0, 1], [0, 0, 0]])\n</code></pre></p>"},{"location":"api/face/#npblender.domain.Face.get_corner_indices","title":"get_corner_indices","text":"<pre><code>get_corner_indices()\n</code></pre> <p>Return the contiguous range of corner/control-point indices.</p> <p>For each item, expands its <code>[loop_start, loop_start + loop_total)</code> range and concatenates the result for all items.</p> <p>Returns:</p> Type Description <code>ndarray of shape ``(sum(loop_total),)``</code> <p>Absolute indices into the corner/control-point array.</p> Notes <p>A fast Numba kernel is used for vectorized cases; the scalar case is handled directly.</p>"},{"location":"api/face/#npblender.domain.Face.get_edges","title":"get_edges","text":"<pre><code>get_edges(corners)\n</code></pre> <p>Return the unique undirected edges present in the faces.</p> <p>Uses <code>get_face_edges</code> and deduplicates edges with <code>np.unique(..., axis=0)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>corners</code> <code>Corner</code> <p>Corner domain providing the <code>vertex_index</code> array.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray of shape (E, 2), dtype=int</code> <p>Unique vertex-index pairs for all edges.</p>"},{"location":"api/face/#npblender.domain.Face.get_face_edges","title":"get_face_edges","text":"<pre><code>get_face_edges(corners)\n</code></pre> <p>Build per-face edge list as ordered vertex-index pairs.</p> <p>For each corner loop of each face, returns the undirected edge as a pair <code>(min(v_prev, v_curr), max(v_prev, v_curr))</code> so that an edge appears in consistent order regardless of traversal direction.</p> <p>Parameters:</p> Name Type Description Default <code>corners</code> <code>Corner</code> <p>Corner domain providing the <code>vertex_index</code> array.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray of shape (M, 2), dtype=int</code> <p>One edge per corner (M is the total number of corners across faces).</p> See Also <p><code>get_edges</code>     Get the unique set of edges across all faces.</p>"},{"location":"api/face/#npblender.domain.Face.get_surface","title":"get_surface","text":"<pre><code>get_surface(corners, points)\n</code></pre> <p>Convenience bundle of per-face surface data.</p> <p>Returns a dictionary containing: - <code>normals</code> : (F, 3) float \u2014 unit normals, - <code>areas</code>   : (F,) float \u2014 face areas, - <code>sizes</code>   : (F,) int \u2014 number of corners per face (<code>loop_total</code>), - <code>verts</code>   : (P, 3) float \u2014 reference to point positions array.</p> <p>Parameters:</p> Name Type Description Default <code>corners</code> <code>Corner</code> required <code>points</code> <code>Point</code> required <p>Returns:</p> Type Description <code>dict</code> <p>Mapping with keys <code>normals</code>, <code>areas</code>, <code>sizes</code>, <code>verts</code>.</p>"},{"location":"api/face/#npblender.domain.Face.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other)\n</code></pre> <p>Merge trans-domain attributes from another domain.</p> <p>Copies or aligns attributes from <code>other</code> into the current domain, excluding any attributes not flagged as trans-domain in <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain or None</code> <p>Source domain. If <code>None</code>, the call is a no-op.</p> required <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p>"},{"location":"api/face/#npblender.domain.Face.join_fields","title":"join_fields","text":"<pre><code>join_fields(other, exclude=[])\n</code></pre> <p>Add all missing fields from another FieldArray.</p> <p>For every field in <code>other</code> that is not present in <code>self</code>, a new field is created with the same dtype and shape, and initialized with its default value across all existing records.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray</code> <p>Another FieldArray instance whose fields will be checked for missing fields.</p> required <p>Returns:</p> Type Description <code>self</code>"},{"location":"api/face/#npblender.domain.Face.make_buckets","title":"make_buckets","text":"<pre><code>make_buckets(attr)\n</code></pre> <p>Group items into buckets by attribute value.</p> <p>When a domain is to be considered as a collection of packets of various sizes, buckets mechanism groups pakets by size, allowing further operation with numpy vectorization.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>array - like or str</code> <p>Either an integer of shape <code>(N,)</code> or the name of an existing integer attribute in the domain.</p> required <p>Returns:</p> Type Description <code>list[ndarray(count, n)]</code> <p>A list of int arrays (count, n): count is the number of buckets of length n.</p> <p>Examples:</p> <pre><code>buckets = mesh.make_buckets('material')\nfor bucket in buckets:\n    print(bucket.shape)\n</code></pre> <p>Note: The bucket attribute can be read with <code>attr[bucket[:, 0]]</code>.</p>"},{"location":"api/face/#npblender.domain.Face.multiply","title":"multiply","text":"<pre><code>multiply(count)\n</code></pre> <p>Duplicate the current records <code>count</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of times to repeat the current records.</p> required Notes <p>This duplicates the current valid records (up to self._length). If the array is empty or count &lt;= 1, nothing happens.</p> Example: <p>If the array has 3 records and count == 4, the result will be:</p> <p>[rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]</p>"},{"location":"api/face/#npblender.domain.Face.new_attribute","title":"new_attribute","text":"<pre><code>new_attribute(name, data_type, default, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Register a new attribute in the domain schema.</p> <p>Creates (or ensures) an attribute with a given name, logical data type, default value, and flags controlling Blender transfer and cross-domain propagation.</p> <p>Note: <code>data_type</code> argument is a Blender data type not a python data type. The data type name is compatible with Blender internal storage. <code>FLOAT</code>data type is implemented as <code>np.float32</code> and  'INT' as <code>np.int32</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name (Python identifier recommended).</p> required <code>data_type</code> <code>(FLOAT, INT, BOOL, VECTOR, VECTOR2, COLOR, QUATERNION, MATRIX, STRING, ...)</code> <p>Logical data type used by the domain.</p> <code>'FLOAT'</code> <code>default</code> <code>Any</code> <p>Default value for newly allocated elements.</p> required <code>optional</code> <code>bool</code> <p>If <code>True</code>, the attribute may be absent on some elements.</p> <code>False</code> <code>transfer</code> <code>bool</code> <p>If <code>True</code>, eligible to be transferred to Blender as a geometry attribute.</p> <code>True</code> <code>transdom</code> <code>bool</code> <p>If <code>True</code>, considered a trans-domain attribute that can be copied across compatible domains.</p> <code>True</code> See Also <p><code>new_float</code>, <code>new_vector</code>, <code>new_int</code>, <code>new_bool</code>, <code>new_color</code>, <code>new_vector2</code>, <code>new_quaternion</code>, <code>new_matrix</code></p>"},{"location":"api/face/#npblender.domain.Face.new_bool","title":"new_bool","text":"<pre><code>new_bool(name, default=False, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a boolean attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>bool</code> <p>Default value.</p> <code>False</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/face/#npblender.domain.Face.new_color","title":"new_color","text":"<pre><code>new_color(name, default=(0.5, 0.5, 0.5, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a color attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,) or (4,)</code> <p>Default color as RGB or RGBA.</p> <code>(0.5, 0.5, 0.5, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/face/#npblender.domain.Face.new_field","title":"new_field","text":"<pre><code>new_field(name, dtype, shape=None, default=0, optional=False, **infos)\n</code></pre> <p>Add a field to the structured array.</p> Arguments <pre><code>- name (str) : field name\n- dtype (type) : a valid numpy dtype\n- shape (tuple = None) : the shape of the field\n- default (any = 0) : default value\n- optional (bool = False) : the field is created only when accessed\n- infos (dict) : field infos\n</code></pre>"},{"location":"api/face/#npblender.domain.Face.new_float","title":"new_float","text":"<pre><code>new_float(name, default=0.0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a scalar float attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>float</code> <p>Default value.</p> <code>0.0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/face/#npblender.domain.Face.new_int","title":"new_int","text":"<pre><code>new_int(name, default=0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure an integer attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>int</code> <p>Default value.</p> <code>0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/face/#npblender.domain.Face.new_matrix","title":"new_matrix","text":"<pre><code>new_matrix(name, default=np.eye(4), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a matrix attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array - like</code> <p>Default matrix. By convention this is a square matrix per element (e.g., <code>(3, 3)</code> rotation or <code>(4, 4)</code> transform).</p> <code>np.eye(4)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code> <code>order</code> required"},{"location":"api/face/#npblender.domain.Face.new_quaternion","title":"new_quaternion","text":"<pre><code>new_quaternion(name, default=(0.0, 0.0, 0.0, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a quaternion attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (4,)</code> <p>Default quaternion in <code>(x, y, z, w)</code> convention.</p> <code>(0.0, 0.0, 0.0, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/face/#npblender.domain.Face.new_vector","title":"new_vector","text":"<pre><code>new_vector(name, default=(0.0, 0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 3D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,)</code> <p>Default XYZ vector.</p> <code>(0.0, 0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/face/#npblender.domain.Face.new_vector2","title":"new_vector2","text":"<pre><code>new_vector2(name, default=(0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 2D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (2,)</code> <p>Default XY vector.</p> <code>(0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/face/#npblender.domain.Face.normal","title":"normal","text":"<pre><code>normal(corners, points)\n</code></pre> <p>Compute per-face unit normals.</p> <p>Returns a normalized area vector for each face (see <code>area_vectors</code>). The direction follows the winding of the face\u2019s corners.</p> <p>Parameters:</p> Name Type Description Default <code>corners</code> <code>Corner</code> <p>Corner domain providing the per-corner <code>vertex_index</code>.</p> required <code>points</code> <code>Point</code> <p>Point (vertex) domain providing <code>position</code> of shape <code>(P, 3)</code>.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray of shape ``(F, 3)`` and dtype float</code> <p>Unit normal per face.</p> Notes <ul> <li>Area vectors are obtained by triangulating polygons and summing triangle cross-products before normalization.</li> <li>Degenerate faces (zero area) yield undefined normals (NaNs or inf). You may sanitize with <code>np.nan_to_num</code> or mask faces where the area is zero.</li> </ul> See Also <p><code>area_vectors</code> <code>area</code> <code>get_surface</code></p>"},{"location":"api/face/#npblender.domain.Face.per_size","title":"per_size","text":"<pre><code>per_size()\n</code></pre> <p>Group items by their <code>loop_total</code> (polygon/control-point count).</p> <p>Returns a dictionary keyed by size (<code>3</code>, <code>4</code>, \u2026) where each entry contains: - <code>'start'</code> : array of <code>loop_start</code> values for items of that size. - <code>'indices'</code> : array mapping entry order back to item indices.</p> <p>Returns:</p> Type Description <code>dict[int, dict[str, ndarray]]</code> <p>Grouped start offsets and reverse indices for each size present.</p> Notes <p>Uses a Numba kernel to bucketize items efficiently.</p>"},{"location":"api/face/#npblender.domain.Face.position","title":"position","text":"<pre><code>position(corners, points)\n</code></pre> <p>Face centroids (mean of corner positions).</p> <p>Computes the arithmetic mean of corner positions per face.</p> <p>Parameters:</p> Name Type Description Default <code>corners</code> <code>Corner</code> required <code>points</code> <code>Point</code> required <p>Returns:</p> Type Description <code>numpy.ndarray of shape (F, 3), dtype=float</code> <p>Centroid of each face.</p>"},{"location":"api/face/#npblender.domain.Face.position_DEPRECATED","title":"position_DEPRECATED","text":"<pre><code>position_DEPRECATED(corners, points)\n</code></pre> <p>Centers of the faces</p> <p>Args:     verts (array (:, 3) of floats): The vertices</p> <p>Returns:     array (len(self), 3) of floats: The centers</p>"},{"location":"api/face/#npblender.domain.Face.sequences","title":"sequences","text":"<pre><code>sequences(corners)\n</code></pre> <p>Vertex-index sequences per face.</p> <p>Returns a Python list where each item is the ordered sequence of vertex indices for the corresponding face.</p> <p>Parameters:</p> Name Type Description Default <code>corners</code> <code>Corner</code> required <p>Returns:</p> Type Description <code>list[list[int]]</code> <p>Vertex index sequence for each face.</p>"},{"location":"api/face/#npblender.domain.Face.to_bl_attributes","title":"to_bl_attributes","text":"<pre><code>to_bl_attributes(attributes, update=False)\n</code></pre> <p>Export attributes to a Blender attribute collection.</p> <p>Writes eligible domain attributes to a Blender data-block, creating missing attributes and adjusting sizes as needed.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Any</code> <p>Blender attributes collection receiving the values.</p> required <code>update</code> <code>bool</code> <p>If <code>True</code>, update existing attributes in-place; otherwise create them when missing.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Caution:*** Only attributes with `transfer=True` are exported. Optional</code> <code>attributes are skipped.</code> <code>&gt; ***Caution:*** Curve domains user attributes are not saved.</code>"},{"location":"api/face/#npblender.domain.Face.to_dict","title":"to_dict","text":"<pre><code>to_dict(*, copy=True, with_infos=True)\n</code></pre> <p>Convert the array to a dictionary of fields or (field, infos) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Whether to copy the arrays.</p> <code>True</code> <code>with_infos</code> <code>bool</code> <p>If True, return (array, infos) for each field.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, array or (array, dict)]</code>"},{"location":"api/face/#npblender.domain.Face.transfer_attributes","title":"transfer_attributes","text":"<pre><code>transfer_attributes(other, shape=None, other_shape=None)\n</code></pre> <p>Transfer values of trans-domain attributes from another domain.</p> <p>Copies values for each trans-domain attribute present in <code>other</code> into the corresponding attributes of <code>self</code>, with optional reshaping for batched assignments.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain</code> <p>Source domain providing attribute values.</p> required <code>shape</code> <code>tuple of int or None</code> <p>Target reshape for <code>self</code> before assignment. If <code>None</code>, uses <code>(self._length,)</code>.</p> <code>None</code> <code>other_shape</code> <code>tuple of int or None</code> <p>Source reshape for <code>other</code> before assignment. If <code>None</code>, uses <code>(other._length,)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p> <code>&gt; ***Note:*** Each attribute is reshaped as `shape + item_shape` on `self`</code> <code>and `other_shape + item_shape` on `other` prior to assignment.</code>"},{"location":"api/face/#npblender.domain.Face.update_loop_start","title":"update_loop_start","text":"<pre><code>update_loop_start()\n</code></pre> <p>Recompute <code>loop_start</code> from <code>loop_total</code> (cumulative layout).</p> <p>Sets <code>loop_start</code> to a left-rolled cumulative sum of <code>loop_total</code>, so item i starts right after the end of item i-1.</p> <p>Returns:</p> Type Description <code>FaceSplineDomain</code> <p>Self (for chaining).</p> Notes <p>Call this after deletions / resizes to keep indices consistent.</p> See Also <p><code>compute_loop_start</code> :     Compute offsets for new items to be appended.</p>"},{"location":"api/geometry/","title":"Geometry","text":""},{"location":"api/geometry/#npblender.geometry.Geometry","title":"Geometry","text":"<p>Base class for concrete geometries.</p> <p><code>Geometry</code> defines common behaviors shared by actual geometries such as Mesh or Curve : attribute propagation across domains, Blender I/O helpers, simple transforms, and material bookkeeping. Concrete subclasses override <code>domain_names</code> and implement domain-specific logic.</p> <p>Attributes:</p> Name Type Description <code>domain_names</code> <code>list[str]</code> <p>Names of available domains in the concrete geometry. Overridden by subclasses (e.g., <code>[\"points\", \"corners\", \"faces\", \"edges\"]</code> for Mesh).</p> Notes <ul> <li>Subclasses are expected to provide the domains listed in <code>domain_names</code>   as attributes (e.g., <code>self.points</code>, <code>self.faces</code>, ...).</li> <li>Blender interoperability helpers (<code>load_object</code>, <code>load_models</code>, and   context managers) rely on the presence of <code>to_object</code> / <code>from_object</code>   implemented by subclasses.</li> </ul>"},{"location":"api/geometry/#npblender.geometry.Geometry.bounding_box","title":"bounding_box  <code>property</code>","text":"<pre><code>bounding_box\n</code></pre> <p>Axis-aligned bounding box of the point positions.</p> <p>Returns:</p> Type Description <code>tuple of numpy.ndarray</code> <p><code>(min_xyz, max_xyz)</code>. If empty, returns two zero vectors.</p>"},{"location":"api/geometry/#npblender.geometry.Geometry.bounding_box_dims","title":"bounding_box_dims  <code>property</code>","text":"<pre><code>bounding_box_dims\n</code></pre> <p>Extents of the axis-aligned bounding box.</p> <p>Returns:</p> Type Description <code>numpy.ndarray of shape (3,)</code> <p><code>max_xyz - min_xyz</code>.</p>"},{"location":"api/geometry/#npblender.geometry.Geometry.max_size","title":"max_size  <code>property</code>","text":"<pre><code>max_size\n</code></pre> <p>Maximum dimension of the bounding box.</p> <p>Returns:</p> Type Description <code>float</code> <p><code>max(bounding_box_dims)</code>.</p>"},{"location":"api/geometry/#npblender.geometry.Geometry.add_materials","title":"add_materials","text":"<pre><code>add_materials(materials)\n</code></pre> <p>Append material name(s) to the geometry.</p> <p>Parameters:</p> Name Type Description Default <code>materials</code> <code>str or sequence of str</code> <p>One name or a sequence of names to append.</p> required <p>Returns:</p> Type Description <code>None</code> Notes <p>This method does not deduplicate names; duplicates may be appended.</p>"},{"location":"api/geometry/#npblender.geometry.Geometry.apply_scale","title":"apply_scale","text":"<pre><code>apply_scale(scale, pivot=None)\n</code></pre> <p>Scale points (convenience wrapper).</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>ndarray</code> <p>Per-point or broadcastable scales.</p> required <code>pivot</code> <code>ndarray</code> <p>Optional pivot(s) for scaling.</p> <code>None</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/geometry/#npblender.geometry.Geometry.check","title":"check","text":"<pre><code>check(title='Geometry Check', halt=True)\n</code></pre> <p>Validate the geometry consistency.</p> <p>Placeholder in the base class: returns <code>True</code>. Subclasses may override to perform domain-level checks.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Label for messages or errors.</p> <code>\"Geometry Check\"</code> <code>halt</code> <code>bool</code> <p>Whether to raise on failure (in subclasses that implement checks).</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>Always <code>True</code> in the base class.</p>"},{"location":"api/geometry/#npblender.geometry.Geometry.compute_attribute_on_domain","title":"compute_attribute_on_domain","text":"<pre><code>compute_attribute_on_domain(domain_from, attr, domain_to)\n</code></pre> <p>Transfer an attribute from one domain to another.</p> <p>Performs a domain mapping (e.g., points \u2192 faces) using the appropriate domain operator, and returns the computed array on the target domain.</p> <p>Parameters:</p> Name Type Description Default <code>domain_from</code> <code>str</code> <p>Source domain name (e.g., <code>\"points\"</code>, <code>\"faces\"</code>, <code>\"edges\"</code>, <code>\"corners\"</code>, <code>\"splines\"</code>).</p> required <code>attr</code> <code>str or ndarray</code> <p>Source attribute to transfer. If a string, it is looked up on the source domain; if an array, it must match the source domain length.</p> required <code>domain_to</code> <code>str</code> <p>Target domain name.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Attribute values on the target domain. If <code>domain_from == domain_to</code>, returns <code>attr</code> unchanged.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If either <code>domain_from</code> or <code>domain_to</code> is not a valid domain of this geometry.</p> <code>Exception</code> <p>If the requested mapping is not implemented.</p> Notes <p>Implemented mappings include: - points \u2192 faces: <code>Point.compute_attribute_on_faces</code> - points \u2192 edges: <code>Point.compute_attribute_on_edges</code> - points \u2192 corners: <code>Point.compute_attribute_on_corners</code> - points \u2192 splines: <code>Point.compute_attribute_on_splines</code> - faces \u2192 points: <code>Face.compute_attribute_on_points</code> - edges \u2192 points: <code>Edge.compute_attribute_on_points</code> - corners \u2192 points: <code>Corner.compute_attribute_on_points</code></p>"},{"location":"api/geometry/#npblender.geometry.Geometry.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d)\n</code></pre> <p>Construct a geometry from a serialized payload.</p> <p>Dispatches to the appropriate subclass based on <code>d[\"geometry\"]</code> (supported: <code>\"Mesh\"</code>, <code>\"Curve\"</code>, <code>\"Cloud\"</code>, <code>\"Instances\"</code>, <code>\"Meshes\"</code>).</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Serialized geometry dictionary as produced by <code>to_dict()</code> of the corresponding subclass.</p> required <p>Returns:</p> Type Description <code>Geometry</code> <p>An instance of the appropriate subclass.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>d[\"geometry\"]</code> is unknown.</p>"},{"location":"api/geometry/#npblender.geometry.Geometry.get_cubic_envelop","title":"get_cubic_envelop","text":"<pre><code>get_cubic_envelop()\n</code></pre> <p>Return a cube mesh that encloses the geometry\u2019s bounding box.</p> <p>Uses the bounding box dimensions to build a cube via <code>Mesh.cube</code>, forwarding this geometry\u2019s <code>materials</code> if present.</p> <p>Returns:</p> Type Description <code>Mesh</code> <p>A cube mesh sized to the bounding box.</p>"},{"location":"api/geometry/#npblender.geometry.Geometry.get_material_index","title":"get_material_index","text":"<pre><code>get_material_index(mat_name)\n</code></pre> <p>Return the index of a material name, creating it if needed.</p> <p>Parameters:</p> Name Type Description Default <code>mat_name</code> <code>str</code> <p>Material name to look up or append.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index of <code>mat_name</code> in <code>self.materials</code>.</p> Notes <p>If <code>mat_name</code> is not present, it is appended to <code>self.materials</code> and the new index is returned.</p>"},{"location":"api/geometry/#npblender.geometry.Geometry.get_points_selection","title":"get_points_selection","text":"<pre><code>get_points_selection()\n</code></pre> <p>Selection of points relevant to operations.</p> <p>Returns <code>slice(None)</code> in the base class (all points). Subclasses (e.g., curves) may override to select only referenced points.</p> <p>Returns:</p> Type Description <code>slice</code> <p><code>slice(None)</code> by default.</p>"},{"location":"api/geometry/#npblender.geometry.Geometry.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other, **kwargs)\n</code></pre> <p>Merge attribute schemas from another geometry.</p> <p>For each domain listed in <code>self.domain_names</code> and also present in <code>other</code>, copies (joins) the attribute definitions (names, dtypes, metadata) from <code>other</code> into this geometry's domains. Use keyword flags to include/exclude domains by name (e.g., <code>faces=False</code>).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Geometry or None</code> <p>Source geometry. If <code>None</code>, does nothing and returns <code>self</code>.</p> required <code>**kwargs</code> <p>Per-domain boolean switches to filter which domains to join.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>, for chaining.</p> <p>Examples:</p> <pre><code>mesh.join_attributes(other_mesh, faces=False)\ncurve.join_attributes(mesh)  # only common domains are merged\n</code></pre>"},{"location":"api/geometry/#npblender.geometry.Geometry.load_models","title":"load_models  <code>staticmethod</code>","text":"<pre><code>load_models(*specs)\n</code></pre> <p>Load multiple geometries from collections, objects, or instances.</p> <p>Accepts mixed inputs such as Blender collections, Blender objects, lists/ tuples of either, or already-instantiated <code>Mesh</code>/<code>Curve</code>. Returns a flat list of geometries discovered or constructed.</p> <p>This method is mainly intended to be used by <code>Instances</code> to load its models.</p> <p>Parameters:</p> Name Type Description Default <code>*specs</code> <p>Collections, objects, lists/tuples, or <code>Mesh</code>/<code>Curve</code> instances.</p> <code>()</code> <p>Returns:</p> Type Description <code>list</code> <p>List of geometries (<code>Mesh</code>/<code>Curve</code>).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a spec cannot be resolved to a geometry.</p>"},{"location":"api/geometry/#npblender.geometry.Geometry.load_object","title":"load_object  <code>staticmethod</code>","text":"<pre><code>load_object(name)\n</code></pre> <p>Load a Blender object and return a <code>Mesh</code> or a <code>Curve</code>.</p> <p>Resolves <code>name</code> to a Blender object, inspects its data type, and returns a matching geometry by calling the subclass' <code>from_object</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or Object</code> <p>Object name or object instance.</p> required <p>Returns:</p> Type Description <code>Mesh or Curve or None</code> <p>A <code>Mesh</code> or a <code>Curve</code>, or <code>None</code> if the object is not found.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the object exists but is neither a <code>bpy.types.Mesh</code> nor <code>bpy.types.Curve</code>.</p> <p>Examples:</p> <pre><code>geo = Geometry.load_object(\"MyObject\")\nif geo is not None:\n    print(type(geo).__name__)\n</code></pre>"},{"location":"api/geometry/#npblender.geometry.Geometry.object","title":"object","text":"<pre><code>object(index=0, readonly=True, **kwargs)\n</code></pre> <p>Temporary access to a Blender Object built from this geometry.</p> <p>Creates a transient object (named <code>\"BPBL Temp {index}\"</code> unless <code>index</code> is a string), selects and activates it, yields it for editing, then cleans up. If <code>readonly=True</code>, the edited object is captured back into <code>self</code>.</p> <p>This method can be used to set and apply a modifier (see exemple below).</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int or str</code> <p>Index or name used to label the temporary object.</p> <code>0</code> <code>readonly</code> <code>bool</code> <p>If <code>False</code>, re-capture the possibly edited object back into this geometry.</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>Keyword arguments passed to <code>self.to_object</code>.</p> <code>{}</code> <p>Yields:</p> Type Description <code>Object</code> <p>The temporary Blender object built from <code>self</code>.</p> <p>Examples:</p> <pre><code>plane = Mesh.Grid()\nwith plane.object(readonly=False) as obj:\n    mod = obj.modifiers.new(\"Solidify\", 'SOLIDIFY')\n    mod.thickness = .1\n    bpy.ops.object.modifier_apply(modifier=mod.name)\n\n# plane is now solidifed\n</code></pre>"},{"location":"api/geometry/#npblender.geometry.Geometry.rotate","title":"rotate","text":"<pre><code>rotate(rotation, pivot=None)\n</code></pre> <p>Rotate points (convenience wrapper).</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>ndarray or Rotation - like</code> <p>Rotation(s) to apply as <code>R @ v</code>.</p> required <code>pivot</code> <code>ndarray</code> <p>Optional pivot(s) for rotation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/geometry/#npblender.geometry.Geometry.transform","title":"transform","text":"<pre><code>transform(transformation)\n</code></pre> <p>Apply a rotation matrix or batch of matrices.</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>transformation</code> <code>ndarray</code> <p>Rotation matrix or batch of rotation matrices.</p> required <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/geometry/#npblender.geometry.Geometry.transformation","title":"transformation","text":"<pre><code>transformation(rotation=None, scale=None, translation=None, pivot=None)\n</code></pre> <p>Apply rotation/scale/translation (with optional per-packet broadcasting).</p> <p>Operates in-place on <code>points.position</code> and, when present, Bezier handles (<code>points.handle_left</code>, <code>points.handle_right</code>). Shapes can represent packets of points: broadcasting rules are handled by <code>Point._get_shape_for_operation</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>ndarray or Rotation - like</code> <p>Rotation matrix/matrices applied as <code>R @ v</code>. Shape may broadcast over points (see notes).</p> <code>None</code> <code>scale</code> <code>ndarray</code> <p>Per-axis scaling. Shape may broadcast over points.</p> <code>None</code> <code>translation</code> <code>ndarray</code> <p>Per-point translation. Shape may broadcast over points.</p> <code>None</code> <code>pivot</code> <code>ndarray</code> <p>Pivot(s) subtracted before, and added after, the rotation/scale; same broadcasting rules as <code>scale</code>/<code>translation</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>, for chaining.</p> Notes <ul> <li>If handles exist, they are transformed consistently with positions.</li> </ul> <p>Examples:</p> <pre><code># 12 cubes laid out randomly with per-instance transforms\ncubes = Mesh.cube(size=1).multiply(12)\nT = np.random.uniform(-1, 1, (12, 3))\nS = np.random.uniform(0.5, 2.0, (12, 3))\nR = Rotation.from_euler(np.random.uniform(0, 2*np.pi, (12, 3)))\ncubes.transformation(rotation=R, scale=S, translation=T)\n</code></pre>"},{"location":"api/geometry/#npblender.geometry.Geometry.translate","title":"translate","text":"<pre><code>translate(translation)\n</code></pre> <p>Translate points (convenience wrapper).</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>ndarray</code> <p>Per-point or broadcastable translation vectors.</p> required <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/instances/","title":"Instances","text":""},{"location":"api/instances/#npblender.instances.Instances","title":"Instances","text":"<pre><code>Instances(points=None, models=None, model_index=None, attr_from=None, **attributes)\n</code></pre> <p>               Bases: <code>Geometry</code></p> <p>Instance container for duplicating geometries.</p> <p><code>Instances</code> manages a set of instance transforms (positions, optional scale and rotation) and a list of source models (meshes and/or curves). It can realize instances into concrete geometries or directly create Blender objects.</p> <p>Attributes:</p> Name Type Description <code>points</code> <code>[Point][Point]</code> <p>Per-instance attributes (e.g., <code>position</code>, optional <code>rotation</code>, <code>scale</code>, <code>model_index</code>, plus any user fields).</p> <code>models</code> <code>list[[Geometry][Geometry]]</code> <p>List of source models to instance (e.g., Mesh, [Curve][npblender.geometry.curve.Curve]).</p> <code>low_resols</code> <code>list[dict]</code> <p>Optional Level-of-Detail (LOD) entries, each as <code>{\"dist\": float, \"models\": list[Geometry]}</code>.</p> Notes <ul> <li>Each instance chooses its model via <code>points.model_index</code>.</li> </ul> <p>Create a new instance set.</p> <p>Initializes the per-instance point domain and captures model geometries.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like of shape (N, 3) or None</code> <p>Instance locations appended as <code>points.position</code>.</p> <code>None</code> <code>models</code> <code>Geometry or sequence of Geometry or None</code> <p>Model(s) to instance. If <code>None</code>, starts empty.</p> <code>None</code> <code>model_index</code> <code>int or array-like of int or None</code> <p>Model index per instance (broadcast rules apply).</p> <code>None</code> <code>attr_from</code> <code>Geometry or None</code> <p>Source geometry from which to join attribute schemas.</p> <code>None</code> <code>**attributes</code> <p>Additional per-instance attributes to append (e.g., <code>rotation</code>, <code>scale</code>).</p> <code>{}</code> Notes <ul> <li>Models are loaded via <code>Geometry.load_models</code>.</li> <li><code>low_resols</code> starts empty and can be populated with <code>add_low_resol</code>.</li> </ul>"},{"location":"api/instances/#npblender.instances.Instances.bounding_box","title":"bounding_box  <code>property</code>","text":"<pre><code>bounding_box\n</code></pre> <p>Axis-aligned bounding box of the point positions.</p> <p>Returns:</p> Type Description <code>tuple of numpy.ndarray</code> <p><code>(min_xyz, max_xyz)</code>. If empty, returns two zero vectors.</p>"},{"location":"api/instances/#npblender.instances.Instances.bounding_box_dims","title":"bounding_box_dims  <code>property</code>","text":"<pre><code>bounding_box_dims\n</code></pre> <p>Extents of the axis-aligned bounding box.</p> <p>Returns:</p> Type Description <code>numpy.ndarray of shape (3,)</code> <p><code>max_xyz - min_xyz</code>.</p>"},{"location":"api/instances/#npblender.instances.Instances.max_size","title":"max_size  <code>property</code>","text":"<pre><code>max_size\n</code></pre> <p>Maximum dimension of the bounding box.</p> <p>Returns:</p> Type Description <code>float</code> <p><code>max(bounding_box_dims)</code>.</p>"},{"location":"api/instances/#npblender.instances.Instances.add_low_resol","title":"add_low_resol","text":"<pre><code>add_low_resol(dist, models)\n</code></pre> <p>Register a Level-of-Detail (LOD) set.</p> <p>Associates a view distance threshold with a list of low-res models (same length and order as <code>self.models</code>).</p> <p>Parameters:</p> Name Type Description Default <code>dist</code> <code>float</code> <p>Distance threshold at which this LOD should be used.</p> required <code>models</code> <code>Geometry or sequence of Geometry</code> <p>One low-res model per source model.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the number of LOD models does not match <code>len(self.models)</code>.</p> <p>Returns:</p> Type Description <code>None</code>"},{"location":"api/instances/#npblender.instances.Instances.add_materials","title":"add_materials","text":"<pre><code>add_materials(materials)\n</code></pre> <p>Append material name(s) to the geometry.</p> <p>Parameters:</p> Name Type Description Default <code>materials</code> <code>str or sequence of str</code> <p>One name or a sequence of names to append.</p> required <p>Returns:</p> Type Description <code>None</code> Notes <p>This method does not deduplicate names; duplicates may be appended.</p>"},{"location":"api/instances/#npblender.instances.Instances.apply_scale","title":"apply_scale","text":"<pre><code>apply_scale(scale, pivot=None)\n</code></pre> <p>Scale points (convenience wrapper).</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>ndarray</code> <p>Per-point or broadcastable scales.</p> required <code>pivot</code> <code>ndarray</code> <p>Optional pivot(s) for scaling.</p> <code>None</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/instances/#npblender.instances.Instances.check","title":"check","text":"<pre><code>check(title='Instances Check', halt=True)\n</code></pre> <p>Validate model indices against the models list.</p> <p>Ensures that <code>max(points.model_index) &lt; len(models)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Prefix for diagnostic messages.</p> <code>\"Instances Check\"</code> <code>halt</code> <code>bool</code> <p>If True, raise on failure; otherwise print and return <code>False</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if valid (or no instances), <code>False</code> when invalid and <code>halt=False</code>.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If a model index is out of range and <code>halt=True</code>.</p>"},{"location":"api/instances/#npblender.instances.Instances.clear_geometry","title":"clear_geometry","text":"<pre><code>clear_geometry()\n</code></pre> <p>Clear all instances (keeps attribute schemas and models).</p> <p>Returns:</p> Type Description <code>None</code>"},{"location":"api/instances/#npblender.instances.Instances.compute_attribute_on_domain","title":"compute_attribute_on_domain","text":"<pre><code>compute_attribute_on_domain(domain_from, attr, domain_to)\n</code></pre> <p>Transfer an attribute from one domain to another.</p> <p>Performs a domain mapping (e.g., points \u2192 faces) using the appropriate domain operator, and returns the computed array on the target domain.</p> <p>Parameters:</p> Name Type Description Default <code>domain_from</code> <code>str</code> <p>Source domain name (e.g., <code>\"points\"</code>, <code>\"faces\"</code>, <code>\"edges\"</code>, <code>\"corners\"</code>, <code>\"splines\"</code>).</p> required <code>attr</code> <code>str or ndarray</code> <p>Source attribute to transfer. If a string, it is looked up on the source domain; if an array, it must match the source domain length.</p> required <code>domain_to</code> <code>str</code> <p>Target domain name.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Attribute values on the target domain. If <code>domain_from == domain_to</code>, returns <code>attr</code> unchanged.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If either <code>domain_from</code> or <code>domain_to</code> is not a valid domain of this geometry.</p> <code>Exception</code> <p>If the requested mapping is not implemented.</p> Notes <p>Implemented mappings include: - points \u2192 faces: <code>Point.compute_attribute_on_faces</code> - points \u2192 edges: <code>Point.compute_attribute_on_edges</code> - points \u2192 corners: <code>Point.compute_attribute_on_corners</code> - points \u2192 splines: <code>Point.compute_attribute_on_splines</code> - faces \u2192 points: <code>Face.compute_attribute_on_points</code> - edges \u2192 points: <code>Edge.compute_attribute_on_points</code> - corners \u2192 points: <code>Corner.compute_attribute_on_points</code></p>"},{"location":"api/instances/#npblender.instances.Instances.compute_low_resols","title":"compute_low_resols","text":"<pre><code>compute_low_resols(start_scale=0.1, scale=0.8, detail=1.0)\n</code></pre> <p>Auto-compute a LOD pyramid from current <code>models</code>.</p> <p>Uses a camera model to estimate view distances for a target on-screen scale. For meshes, generates simplified copies; for curves, converts to curve views.</p> <p>Parameters:</p> Name Type Description Default <code>start_scale</code> <code>float</code> <p>Initial relative on-screen scale.</p> <code>0.1</code> <code>scale</code> <code>float</code> <p>Multiplicative factor between consecutive LOD levels (clipped to 0.01\u20130.99).</p> <code>0.8</code> <code>detail</code> <code>float</code> <p>Detail factor forwarded to simplification (mesh-dependent).</p> <code>1.0</code> <p>Returns:</p> Type Description <code>None</code> Notes <ul> <li>Up to 10 levels are created, stopping when the max vertex count drops to \u2264 8.</li> <li>Each level is recorded via <code>add_low_resol</code>.</li> </ul>"},{"location":"api/instances/#npblender.instances.Instances.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d)\n</code></pre> <p>Deserialize an <code>Instances</code> object produced by <code>to_dict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Serialized payload with keys <code>\"points\"</code>, <code>\"models\"</code>, <code>\"low_resols\"</code>.</p> required <p>Returns:</p> Type Description <code>Instances</code> <p>New instance with points, models and LODs reconstructed.</p>"},{"location":"api/instances/#npblender.instances.Instances.get_cubic_envelop","title":"get_cubic_envelop","text":"<pre><code>get_cubic_envelop()\n</code></pre> <p>Return a cube mesh that encloses the geometry\u2019s bounding box.</p> <p>Uses the bounding box dimensions to build a cube via <code>Mesh.cube</code>, forwarding this geometry\u2019s <code>materials</code> if present.</p> <p>Returns:</p> Type Description <code>Mesh</code> <p>A cube mesh sized to the bounding box.</p>"},{"location":"api/instances/#npblender.instances.Instances.get_material_index","title":"get_material_index","text":"<pre><code>get_material_index(mat_name)\n</code></pre> <p>Return the index of a material name, creating it if needed.</p> <p>Parameters:</p> Name Type Description Default <code>mat_name</code> <code>str</code> <p>Material name to look up or append.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index of <code>mat_name</code> in <code>self.materials</code>.</p> Notes <p>If <code>mat_name</code> is not present, it is appended to <code>self.materials</code> and the new index is returned.</p>"},{"location":"api/instances/#npblender.instances.Instances.get_points_selection","title":"get_points_selection","text":"<pre><code>get_points_selection()\n</code></pre> <p>Selection of points relevant to operations.</p> <p>Returns <code>slice(None)</code> in the base class (all points). Subclasses (e.g., curves) may override to select only referenced points.</p> <p>Returns:</p> Type Description <code>slice</code> <p><code>slice(None)</code> by default.</p>"},{"location":"api/instances/#npblender.instances.Instances.join","title":"join","text":"<pre><code>join(*others)\n</code></pre> <p>Concatenate other instance sets into this one.</p> <p>Appends models and per-instance points; newly appended <code>model_index</code> values are offset by the previous model count.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Instances</code> <p>Other <code>Instances</code> objects to append.</p> <code>()</code> <p>Returns:</p> Type Description <code>Instances</code> <p><code>self</code>, for chaining.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If any argument is not an <code>Instances</code>.</p>"},{"location":"api/instances/#npblender.instances.Instances.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other, **kwargs)\n</code></pre> <p>Merge attribute schemas from another geometry.</p> <p>For each domain listed in <code>self.domain_names</code> and also present in <code>other</code>, copies (joins) the attribute definitions (names, dtypes, metadata) from <code>other</code> into this geometry's domains. Use keyword flags to include/exclude domains by name (e.g., <code>faces=False</code>).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Geometry or None</code> <p>Source geometry. If <code>None</code>, does nothing and returns <code>self</code>.</p> required <code>**kwargs</code> <p>Per-domain boolean switches to filter which domains to join.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>, for chaining.</p> <p>Examples:</p> <pre><code>mesh.join_attributes(other_mesh, faces=False)\ncurve.join_attributes(mesh)  # only common domains are merged\n</code></pre>"},{"location":"api/instances/#npblender.instances.Instances.load_models","title":"load_models  <code>staticmethod</code>","text":"<pre><code>load_models(*specs)\n</code></pre> <p>Load multiple geometries from collections, objects, or instances.</p> <p>Accepts mixed inputs such as Blender collections, Blender objects, lists/ tuples of either, or already-instantiated <code>Mesh</code>/<code>Curve</code>. Returns a flat list of geometries discovered or constructed.</p> <p>This method is mainly intended to be used by <code>Instances</code> to load its models.</p> <p>Parameters:</p> Name Type Description Default <code>*specs</code> <p>Collections, objects, lists/tuples, or <code>Mesh</code>/<code>Curve</code> instances.</p> <code>()</code> <p>Returns:</p> Type Description <code>list</code> <p>List of geometries (<code>Mesh</code>/<code>Curve</code>).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a spec cannot be resolved to a geometry.</p>"},{"location":"api/instances/#npblender.instances.Instances.load_object","title":"load_object  <code>staticmethod</code>","text":"<pre><code>load_object(name)\n</code></pre> <p>Load a Blender object and return a <code>Mesh</code> or a <code>Curve</code>.</p> <p>Resolves <code>name</code> to a Blender object, inspects its data type, and returns a matching geometry by calling the subclass' <code>from_object</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or Object</code> <p>Object name or object instance.</p> required <p>Returns:</p> Type Description <code>Mesh or Curve or None</code> <p>A <code>Mesh</code> or a <code>Curve</code>, or <code>None</code> if the object is not found.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the object exists but is neither a <code>bpy.types.Mesh</code> nor <code>bpy.types.Curve</code>.</p> <p>Examples:</p> <pre><code>geo = Geometry.load_object(\"MyObject\")\nif geo is not None:\n    print(type(geo).__name__)\n</code></pre>"},{"location":"api/instances/#npblender.instances.Instances.models_to_object","title":"models_to_object","text":"<pre><code>models_to_object(name='Models')\n</code></pre> <p>Dump all models (and their LODs) into a single Blender mesh object.</p> <p>Places each source model along +X with its LOD stack above it along +Z, then creates a single object with flat shading.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Object name.</p> <code>\"Models\"</code> <p>Returns:</p> Type Description <code>Object</code> <p>The created object.</p> <p>Examples:</p> <pre><code>obj = insts.models_to_object(\"AllModelsPreview\")\n</code></pre>"},{"location":"api/instances/#npblender.instances.Instances.multiply","title":"multiply","text":"<pre><code>multiply(count, in_place=True)\n</code></pre> <p>Duplicate the instance set <code>count</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of copies to create.</p> required <code>in_place</code> <code>bool</code> <p>If True, expand this instance; otherwise return a new expanded copy.</p> <code>True</code> <p>Returns:</p> Type Description <code>Instances or None</code> <p><code>self</code> (in place) or a new <code>Instances</code>; <code>None</code> if <code>count == 0</code>.</p> <p>Raises:</p> Type Description <code>(TypeError, ValueError)</code> <p>If <code>count</code> cannot be converted to <code>int</code>.</p>"},{"location":"api/instances/#npblender.instances.Instances.object","title":"object","text":"<pre><code>object(index=0, readonly=True, **kwargs)\n</code></pre> <p>Temporary access to a Blender Object built from this geometry.</p> <p>Creates a transient object (named <code>\"BPBL Temp {index}\"</code> unless <code>index</code> is a string), selects and activates it, yields it for editing, then cleans up. If <code>readonly=True</code>, the edited object is captured back into <code>self</code>.</p> <p>This method can be used to set and apply a modifier (see exemple below).</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int or str</code> <p>Index or name used to label the temporary object.</p> <code>0</code> <code>readonly</code> <code>bool</code> <p>If <code>False</code>, re-capture the possibly edited object back into this geometry.</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>Keyword arguments passed to <code>self.to_object</code>.</p> <code>{}</code> <p>Yields:</p> Type Description <code>Object</code> <p>The temporary Blender object built from <code>self</code>.</p> <p>Examples:</p> <pre><code>plane = Mesh.Grid()\nwith plane.object(readonly=False) as obj:\n    mod = obj.modifiers.new(\"Solidify\", 'SOLIDIFY')\n    mod.thickness = .1\n    bpy.ops.object.modifier_apply(modifier=mod.name)\n\n# plane is now solidifed\n</code></pre>"},{"location":"api/instances/#npblender.instances.Instances.realize","title":"realize","text":"<pre><code>realize(camera_culling=False)\n</code></pre> <p>Realize instances into concrete geometries.</p> <p>Duplicates each model for its selected instances, applies per-instance transform (translation, optional rotation/scale), and accumulates results into a Mesh and/or a [Curve][npblender.geometry.curve.Curve]. With <code>camera_culling=True</code>, hidden instances are skipped and LODs may be used.</p> <p>Parameters:</p> Name Type Description Default <code>camera_culling</code> <code>bool or object</code> <p>If truthy, perform visibility tests and LOD selection using a camera.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with keys: - <code>\"mesh\"</code> : a Mesh or <code>None</code> - <code>\"curve\"</code>: a [Curve][npblender.geometry.curve.Curve] or <code>None</code></p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If a model type is not supported (neither Mesh nor Curve).</p> <p>Examples:</p> <pre><code>insts = Instances(points=np.random.randn(100, 3), models=[Mesh.cube(), Curve.circle()])\ngeos = insts.realize(camera_culling=True)\nif geos[\"mesh\"] is not None:\n    geos[\"mesh\"].to_object(\"InstancedMesh\")\n</code></pre>"},{"location":"api/instances/#npblender.instances.Instances.rotate","title":"rotate","text":"<pre><code>rotate(rotation, pivot=None)\n</code></pre> <p>Rotate points (convenience wrapper).</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>ndarray or Rotation - like</code> <p>Rotation(s) to apply as <code>R @ v</code>.</p> required <code>pivot</code> <code>ndarray</code> <p>Optional pivot(s) for rotation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/instances/#npblender.instances.Instances.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize the instances to a plain dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Keys: - <code>\"geometry\"</code> = <code>\"Instances\"</code> - <code>\"points\"</code>   : point-domain payload - <code>\"models\"</code>   : list of serialized models - <code>\"low_resols\"</code> : list of serialized LOD levels</p>"},{"location":"api/instances/#npblender.instances.Instances.to_object","title":"to_object","text":"<pre><code>to_object(name, profile=None, caps=True, use_radius=True, shade_smooth=True, camera_culling=False)\n</code></pre> <p>Create Blender object(s) from realized instances.</p> <p>Realizes instances, converts curves to mesh when a profile is provided (or when culling requires meshing), and creates one or two Blender objects.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Base name for created objects.</p> required <code>profile</code> <code>Curve or None</code> <p>Profile to sweep along curve outputs (see [<code>Curve.to_mesh</code>][npblender.geometry.curve.Curve.to_mesh]).</p> <code>None</code> <code>caps</code> <code>bool</code> <p>Close ends when sweeping.</p> <code>True</code> <code>use_radius</code> <code>bool</code> <p>Use per-point radius when sweeping.</p> <code>True</code> <code>shade_smooth</code> <code>bool</code> <p>Smooth shading for the mesh object.</p> <code>True</code> <code>camera_culling</code> <code>bool</code> <p>If True, perform visibility tests and LOD selection.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Possibly contains: - <code>\"mesh\"</code> : the created mesh object (with optional \u201c - (M)\u201d suffix) - <code>\"curve\"</code>: the created curve object (with \u201c - (C)\u201d suffix if both exist)</p>"},{"location":"api/instances/#npblender.instances.Instances.transform","title":"transform","text":"<pre><code>transform(transformation)\n</code></pre> <p>Apply a rotation matrix or batch of matrices.</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>transformation</code> <code>ndarray</code> <p>Rotation matrix or batch of rotation matrices.</p> required <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/instances/#npblender.instances.Instances.transformation","title":"transformation","text":"<pre><code>transformation(rotation=None, scale=None, translation=None, pivot=None)\n</code></pre> <p>Apply rotation/scale/translation (with optional per-packet broadcasting).</p> <p>Operates in-place on <code>points.position</code> and, when present, Bezier handles (<code>points.handle_left</code>, <code>points.handle_right</code>). Shapes can represent packets of points: broadcasting rules are handled by <code>Point._get_shape_for_operation</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>ndarray or Rotation - like</code> <p>Rotation matrix/matrices applied as <code>R @ v</code>. Shape may broadcast over points (see notes).</p> <code>None</code> <code>scale</code> <code>ndarray</code> <p>Per-axis scaling. Shape may broadcast over points.</p> <code>None</code> <code>translation</code> <code>ndarray</code> <p>Per-point translation. Shape may broadcast over points.</p> <code>None</code> <code>pivot</code> <code>ndarray</code> <p>Pivot(s) subtracted before, and added after, the rotation/scale; same broadcasting rules as <code>scale</code>/<code>translation</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>, for chaining.</p> Notes <ul> <li>If handles exist, they are transformed consistently with positions.</li> </ul> <p>Examples:</p> <pre><code># 12 cubes laid out randomly with per-instance transforms\ncubes = Mesh.cube(size=1).multiply(12)\nT = np.random.uniform(-1, 1, (12, 3))\nS = np.random.uniform(0.5, 2.0, (12, 3))\nR = Rotation.from_euler(np.random.uniform(0, 2*np.pi, (12, 3)))\ncubes.transformation(rotation=R, scale=S, translation=T)\n</code></pre>"},{"location":"api/instances/#npblender.instances.Instances.translate","title":"translate","text":"<pre><code>translate(translation)\n</code></pre> <p>Translate points (convenience wrapper).</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>ndarray</code> <p>Per-point or broadcastable translation vectors.</p> required <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/maths/","title":"Maths","text":""},{"location":"api/maths/#npblender.maths","title":"maths","text":""},{"location":"api/maths/#npblender.maths.Easings","title":"Easings","text":"<pre><code>Easings(*items)\n</code></pre> <p>A chain of Easing segments. Each Easing defines a key at (t0, v0) and interpolation mode/easing/extrapolation to the NEXT key.</p>"},{"location":"api/maths/#npblender.maths.Easings._bezier_eval_segment","title":"_bezier_eval_segment  <code>staticmethod</code>","text":"<pre><code>_bezier_eval_segment(t_query, P0, P1, P2, P3, max_iter=10, tol=1e-06)\n</code></pre> <p>Evaluate cubic Bezier in (time,value) space. Pk = (tx, vy). Solve Bx(s)=t for s\u2208[0,1], then return By(s).</p>"},{"location":"api/maths/#npblender.maths.Easings._default_handles_for_segment","title":"_default_handles_for_segment","text":"<pre><code>_default_handles_for_segment(i_left, frac=1.0 / 3.0)\n</code></pre> <p>Compute default (right, left) handles for segment [i_left -&gt; i_left+1]. Returns P1 (right of left key) and P2 (left of right key) as (tx, vy) pairs.</p>"},{"location":"api/maths/#npblender.maths.Easings._endpoint_slope","title":"_endpoint_slope","text":"<pre><code>_endpoint_slope(i)\n</code></pre> <p>Estimate dv/dt at key i using surrounding keys. Monotone-clamped average of adjacent secants; endpoint -&gt; single secant.</p>"},{"location":"api/maths/#npblender.maths.Easings._segment_tangent_value","title":"_segment_tangent_value","text":"<pre><code>_segment_tangent_value(i_left, t, end='right')\n</code></pre> <p>Linear extrapolation using the tangent at the endpoint of segment [i_left -&gt; i_left+1]. end='right' uses slope at u=1; end='left' uses slope at u=0. Falls back to secant if slope is non-finite.</p>"},{"location":"api/maths/#npblender.maths.Easings.add","title":"add","text":"<pre><code>add(easing)\n</code></pre> <p>Insert keeping t0 strictly increasing (no duplicates).</p>"},{"location":"api/maths/#npblender.maths.Easings.bezier","title":"bezier  <code>classmethod</code>","text":"<pre><code>bezier(*points, extrapolation='CONSTANT', handle_type='AUTO')\n</code></pre> <p>Build a BEZIER easing chain from (t, v) points. - points: either (t, v), (t, v), ... or a single iterable of (t, v) - handle_type: 'AUTO' (recompute each time) or 'FREE' (fill None once) - extrapolation: 'CONSTANT' or 'LINEAR' Handles are computed via compute_bezier_handles() for a smooth curve.</p>"},{"location":"api/maths/#npblender.maths.Easings.compute_bezier_handles","title":"compute_bezier_handles","text":"<pre><code>compute_bezier_handles(frac=1.0 / 3.0)\n</code></pre> <p>Recompute default Bezier handles: - For a BEZIER key with handle_type 'AUTO' \u2192 always reset its handle(s). - For a BEZIER key with handle_type 'FREE' \u2192 set only if currently None. Right handle belongs to the left key of the segment; left handle to the right key.</p>"},{"location":"api/maths/#npblender.maths.Easings.evaluate","title":"evaluate","text":"<pre><code>evaluate(t)\n</code></pre> <p>Vectorized evaluation over t (scalar or array). For each interval [t_i, t_{i+1}), call the segment's interpolation; for the last key, use its extrapolation rule.</p>"},{"location":"api/maths/#npblender.maths.get_angled","title":"get_angled","text":"<pre><code>get_angled(vectors, angle, default=(0, 0, 1), keep_norm=False, twist=0.0, seed=None, eps=1e-06)\n</code></pre> <p>Return a vector making the given angle (radians) with each input vector. The direction around the cone is controlled by <code>twist</code> (angle in radians around the input direction). You can set twist='random' to sample a uniform angle in [0, 2*pi).</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>(array_like, shape(..., 3))</code> <p>Input vectors.</p> required <code>angle</code> <code>float or array_like, broadcastable to vectors[..., 0]</code> <p>Cone half-angle (radians) with respect to each input vector.</p> required <code>default</code> <code>(array_like, shape(3))</code> <p>Fallback direction when input vector is zero.</p> <code>(0, 0, 1)</code> <code>keep_norm</code> <code>bool</code> <p>If True, scale the result by ||vectors|| (zeros stay unit).</p> <code>False</code> <code>twist</code> <code>float or array_like or random</code> <p>Rotation (radians) around the input direction (choose the azimuth on the cone). If 'random', sample uniform in [0, 2*pi).</p> <code>0.0</code> <code>seed</code> <code>int or None</code> <p>RNG seed when twist='random'.</p> <code>None</code> <code>eps</code> <code>float</code> <p>Tolerance for near-colinearity with z-axis.</p> <code>1e-06</code> <p>Returns:</p> Name Type Description <code>w</code> <code>(ndarray, shape(..., 3))</code> <p>Output vectors.</p>"},{"location":"api/maths/#npblender.maths.get_axis","title":"get_axis","text":"<pre><code>get_axis(v, null=[0, 0, 1])\n</code></pre> <p>Normalize a vector or an array of vectors.</p> <p>The vector can be specified as a string naming an axis : 'x', '-z', ...</p> Arguments <pre><code>- v (vector or array of vectors or str) : the vector to normalize\n- null (vector=(0, 0, 1)) : value to set to null vectors\n</code></pre> <p>Returns:</p> Type Description <code>    - normalized vector(s), vector norm(s)</code>"},{"location":"api/maths/#npblender.maths.get_perp","title":"get_perp","text":"<pre><code>get_perp(vectors, default=(0, 0, 1), normalize=False)\n</code></pre> <p>Compute a perpendicular vector to each input vector.</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>array_like</code> <p>Input vectors of shape (..., 3).</p> required <code>default</code> <code>tuple or array_like</code> <p>Default perpendicular used when the vector is zero.</p> <code>(0, 0, 1)</code> <p>Returns:</p> Name Type Description <code>perp</code> <code>ndarray</code> <p>Perpendicular vectors of shape (..., 3).</p>"},{"location":"api/maths/#npblender.maths.maprange","title":"maprange","text":"<pre><code>maprange(t, t0=0.0, t1=1.0, v0=0.0, v1=1.0, factor=1.0, back=1.70158, amplitude=1.0, period=0.3, mode='LINEAR', easing='IN', normalized=False)\n</code></pre> <p>If normalized=True, <code>t</code> is already u\u2208[0,1] and we only remap to [v0,v1]. Otherwise we compute u = (t - t0) / (t1 - t0) first.</p>"},{"location":"api/maths/#npblender.maths.noise","title":"noise","text":"<pre><code>noise(coords, t=None, scale=1.0, octaves=5, lacunarity=2.0, gain=0.5, normalize=True, period=None, algo='fBM', perlin=0, out_dim=1, **kwargs)\n</code></pre> <p>Global noise API.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>array - like</code> <p>(N,) pour 1D, ou (N, dim) pour dim\u2208{1,2,3,4}.</p> required <code>t</code> <code>float = None</code> <p>Supplementary dimension</p> <code>None</code> <code>scale</code> <code>float = 1.0</code> <p>\u00c9chelle appliqu\u00e9e aux coordonn\u00e9es (coords * scale).</p> <code>1.0</code> <code>octaves</code> <code>float</code> <p>Nb d'octaves (peut \u00eatre non entier) pour fBM / variantes Musgrave.</p> <code>5</code> <code>lacunarity</code> <code>float</code> <p>Multiplicateur de fr\u00e9quence par octave.</p> <code>2.0</code> <code>gain</code> <code>float</code> <p>D\u00e9croissance d'amplitude (selon l'algo).</p> <code>0.5</code> <code>normalize</code> <code>bool</code> <p>Normalisation (utilis\u00e9e par fBM simple).</p> <code>True</code> <code>period</code> <code>int | tuple[int] | None</code> <p>P\u00e9riode (tiling) en cellules (propag\u00e9e par octave si applicable).</p> <code>None</code> <code>algo</code> <code>str</code> <p>'perlin', 'fBM' (ou 'fbm'), 'multifractal' ('multi'), 'ridged' ('ridged_multifractal'), 'hybrid' ('hybrid_multifractal'), 'hetero' ('hetero_terrain').</p> <code>'fBM'</code> <code>perlin</code> <code>Perlin | int</code> <p>Instance Perlin, ou seed (int). La dim est d\u00e9duite de coords.</p> <code>0</code> <code>out_dim</code> <code>int</code> <p>Number of dimensions in the result</p> <code>1</code> <code>**kwargs</code> <ul> <li>dimension (float, d\u00e9faut 1.0) : expos\u00e9 pour les variantes Musgrave</li> <li>offset (float) : utilis\u00e9 par 'ridged', 'hybrid', 'hetero' (d\u00e9fauts adapt\u00e9s)</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Valeurs de bruit shape (N,) ou shape(N, out_dim)</p>"},{"location":"api/maths/#see-also","title":"See also","text":"<ul> <li><code>Quaternion</code></li> <li><code>Rotation</code></li> <li><code>Transformation</code></li> </ul>"},{"location":"api/mesh/","title":"Mesh","text":""},{"location":"api/mesh/#npblender.mesh.Mesh","title":"Mesh","text":"<pre><code>Mesh(points=None, corners=None, faces=None, edges=None, materials=None, attr_from=None, **attrs)\n</code></pre> <p>               Bases: <code>Geometry</code></p> <p>Initialize a Mesh Geometry object.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array_like</code> <p>The vertices of the mesh (default is None).</p> <code>None</code> <code>corners</code> <code>array_like of int</code> <p>Corners, i.e., indices on the array of points (default is None).</p> <code>None</code> <code>faces</code> <code>array_like of int</code> <p>Sizes of the faces; the sum of this array must be equal to the length of the corners array (default is None).</p> <code>None</code> <code>edges</code> <code>array_like of tuple of int</code> <p>List of edges defined by pairs of vertex indices (default is None).</p> <code>None</code> <code>materials</code> <code>str or list of str</code> <p>List of materials used in the geometry. If a single string is provided, it is converted to a list containing that string (default is None).</p> <code>None</code> <code>attr_from</code> <code>Geometry</code> <p>Domain attributes to copy from another Geometry object (default is None).</p> <code>None</code> <code>**attrs</code> <code>dict</code> <p>Additional geometry attributes.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>points</code> <code>Vertex</code> <p>The vertices of the mesh.</p> <code>corners</code> <code>Corner</code> <p>The corners of the mesh.</p> <code>faces</code> <code>Face</code> <p>The faces of the mesh.</p> <code>edges</code> <code>Edge</code> <p>The edges of the mesh.</p> <code>materials</code> <code>list of str</code> <p>The list of materials used in the geometry.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bounding_box","title":"bounding_box  <code>property</code>","text":"<pre><code>bounding_box\n</code></pre> <p>Axis-aligned bounding box of the point positions.</p> <p>Returns:</p> Type Description <code>tuple of numpy.ndarray</code> <p><code>(min_xyz, max_xyz)</code>. If empty, returns two zero vectors.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bounding_box_dims","title":"bounding_box_dims  <code>property</code>","text":"<pre><code>bounding_box_dims\n</code></pre> <p>Extents of the axis-aligned bounding box.</p> <p>Returns:</p> Type Description <code>numpy.ndarray of shape (3,)</code> <p><code>max_xyz - min_xyz</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.max_size","title":"max_size  <code>property</code>","text":"<pre><code>max_size\n</code></pre> <p>Maximum dimension of the bounding box.</p> <p>Returns:</p> Type Description <code>float</code> <p><code>max(bounding_box_dims)</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_geometry","title":"add_geometry","text":"<pre><code>add_geometry(points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs)\n</code></pre> <p>Add geometry components (vertices, corners, faces, edges) to the mesh.</p> <p>This method appends the specified geometry to the mesh without altering existing indices. It supports referencing existing vertices through corners or adding new vertices.</p> <p>Note: To add independent geometry with new vertices, use <code>Mesh.join_geometry</code> instead.</p> <p>Examples:</p> <pre><code>``` python\ncube = Mesh.cube()\n# Add a triangle on existing vertices\n# corners argument refers to cube vertices\ncube.add_geometry(corners=[0, 1, 2], faces=3)\n\n# Add a triangle with additional vertices\n# corners argument refers to the new vertices, passed values [0, 1, 2]\n# will be shifted to actual values [8, 9, 10]\ncube.join_geometry(points=[[0, 0, 0], [0, 1, 0], [1, 0, 0]], corners=[0, 1, 2], faces=3)\n```\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like of vectors</code> <p>Vertices to add to the mesh.</p> <code>None</code> <code>corners</code> <code>array-like of int</code> <p>Indices referring to vertices in the points array.</p> <code>None</code> <code>faces</code> <code>int, array-like of int, or list of lists</code> <p>Defines the faces topology: - If <code>corners</code> is provided:     - None: Single face made of all corners.     - int: All faces have the same size (must divide the number of corners).     - array-like: Face sizes; sum must equal the number of corners. - If <code>corners</code> is None:     - Must be a list of lists, each sublist is a list of corners.</p> <code>None</code> <code>edges</code> <code>array-like of pairs of int</code> <p>Edges defined by pairs of vertex indices.</p> <code>None</code> <code>safe_mode</code> <code>bool</code> <p>If True, perform a mesh integrity check after adding geometry.</p> <code>False</code> <code>**attrs</code> <code>dict</code> <p>Additional geometry attributes to apply.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys {'points', 'corners', 'faces', 'edges'} mapping to lists of added geometry indices.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If faces and corners lengths are inconsistent or invalid.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_materials","title":"add_materials","text":"<pre><code>add_materials(materials)\n</code></pre> <p>Append material name(s) to the geometry.</p> <p>Parameters:</p> Name Type Description Default <code>materials</code> <code>str or sequence of str</code> <p>One name or a sequence of names to append.</p> required <p>Returns:</p> Type Description <code>None</code> Notes <p>This method does not deduplicate names; duplicates may be appended.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_points","title":"add_points","text":"<pre><code>add_points(points, **attributes)\n</code></pre> <p>Add vertices.</p> Arguments <pre><code>- points (array of vectors) : the vertices to add\n- attributes (name=value) : value for named attributes\n</code></pre> <p>Returns:</p> Type Description <code>    - array of ints : indices of the added vertices</code>"},{"location":"api/mesh/#npblender.mesh.Mesh.apply_scale","title":"apply_scale","text":"<pre><code>apply_scale(scale, pivot=None)\n</code></pre> <p>Scale points (convenience wrapper).</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>ndarray</code> <p>Per-point or broadcastable scales.</p> required <code>pivot</code> <code>ndarray</code> <p>Optional pivot(s) for scaling.</p> <code>None</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.arrow","title":"arrow  <code>classmethod</code>","text":"<pre><code>arrow(vector=(0, 0, 1), radius=0.05, angle=24.0, segments=8, adjust_norm=None, materials=None)\n</code></pre> <p>Create an arrow mesh oriented along a given vector.</p> <p>The arrow is composed of a cylindrical shaft and a conical head, proportionally scaled to the length of the input vector.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>array-like of float, shape (3,)</code> <p>Direction and length of the arrow. The norm of the vector defines the arrow length. Default is (0, 0, 1).</p> <code>(0, 0, 1)</code> <code>radius</code> <code>float</code> <p>Radius of the cylindrical shaft. Default is 0.05.</p> <code>0.05</code> <code>angle</code> <code>float</code> <p>Opening angle of the conical head in degrees. Default is 24.</p> <code>24.0</code> <code>segments</code> <code>int</code> <p>Number of segments around the circumference. Default is 8.</p> <code>8</code> <code>adjust_norm</code> <code>(callable, float, None)</code> <ul> <li>If callable: a function applied to the vector norm to adjust the arrow length.</li> <li>If float: the arrow length is clamped to this maximum.</li> <li>If None: use the norm of <code>vector</code> directly. Default is None.</li> </ul> <code>callable</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the arrow. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the arrow.</p> Notes <ul> <li>The shaft is created with <code>cylinder</code>.</li> <li>The head is created with <code>cone</code> using <code>fill_type='FANS'</code> for proper triangulation.</li> <li>The arrow is aligned to <code>vector</code> using <code>Rotation.look_at</code>.</li> <li>A small correction is applied to avoid overlap between shaft and head.</li> </ul> <p>Examples:</p> <p>Create a default arrow of length 1 along Z:</p> <pre><code>arrow = Mesh.arrow()\n</code></pre> <p>Create an arrow along vector (1, 2, 0.5) with custom shaft radius:</p> <pre><code>arrow = Mesh.arrow(vector=(1, 2, 0.5), radius=0.1)\n</code></pre> <p>Create an arrow clamped to maximum length 2:</p> <pre><code>arrow = Mesh.arrow(vector=(0, 0, 5), adjust_norm=2)\n</code></pre> See Also <p><code>cylinder</code> :     Used to create the arrow shaft. <code>cone</code> :     Used to create the arrow head. <code>Rotation.look_at</code> :     Utility to orient the arrow along a target vector.</p> <p>Caution: If <code>vector</code> has zero length, the arrow cannot be constructed properly.</p> <p>Note: The conical head radius is set to <code>3 * radius</code> by default, and its height is determined by the opening <code>angle</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_circle","title":"bl_circle  <code>classmethod</code>","text":"<pre><code>bl_circle(radius=1, segments=16, fill_tris=False, materials=None)\n</code></pre> <p>Create a circle mesh.</p> <p>Blender constructor for generating a circle primitive using <code>bmesh.ops.create_circle</code>.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the circle. Default is 1.</p> <code>1</code> <code>segments</code> <code>int</code> <p>Number of segments (vertices) forming the circle. Default is 16.</p> <code>16</code> <code>fill_tris</code> <code>bool</code> <p>If True, fills the circle with a triangle fan. Default is False.</p> <code>False</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the circle. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the circle.</p> Notes <ul> <li>The circle is created using <code>bmesh.ops.create_circle</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> <li>By default (<code>fill_tris=False</code>), the circle is an open ring. With <code>fill_tris=True</code>, the circle is filled with triangles (fan topology).</li> </ul> <p>Examples:</p> <p>Create an empty circle of radius 2 with 32 segments:</p> <pre><code>circle = Mesh.bl_circle(radius=2, segments=32)\n</code></pre> <p>Create a filled circle (disk) of radius 1 with 24 segments:</p> <pre><code>circle = Mesh.bl_circle(radius=1, segments=24, fill_tris=True)\n</code></pre> See Also <p><code>bmesh.ops.create_circle</code> :     BMesh operator used for creating a circle primitive.</p> <p>Note: UVs are automatically calculated when the circle is created.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_cone","title":"bl_cone  <code>classmethod</code>","text":"<pre><code>bl_cone(radius1=1, radius2=0, depth=2, segments=16, side_segments=1, cap_ends=True, cap_tris=False, materials=None)\n</code></pre> <p>Create a cone mesh.</p> <p>Blender constructor for generating a cone (or cylinder) primitive using <code>bmesh.ops.create_cone</code>.</p> <p>Parameters:</p> Name Type Description Default <code>radius1</code> <code>float</code> <p>Base radius of the cone. Default is 1.</p> <code>1</code> <code>radius2</code> <code>float</code> <p>Top radius of the cone. If set to 0, produces a true cone; if equal to <code>radius1</code>, produces a cylinder. Default is 0.</p> <code>0</code> <code>depth</code> <code>float</code> <p>Height of the cone along the Z axis. Default is 2.</p> <code>2</code> <code>segments</code> <code>int</code> <p>Number of segments around the circumference. Default is 16.</p> <code>16</code> <code>side_segments</code> <code>int</code> <p>Number of subdivisions along the vertical side edges. Default is 1 (no subdivision).</p> <code>1</code> <code>cap_ends</code> <code>bool</code> <p>If True, fill the top and bottom caps. Default is True.</p> <code>True</code> <code>cap_tris</code> <code>bool</code> <p>If True, fill the caps using triangle fans instead of n-gons. Default is False.</p> <code>False</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the cone. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the cone.</p> Notes <ul> <li>The cone is created using <code>bmesh.ops.create_cone</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> <li>When <code>side_segments &gt; 1</code>, vertical edges crossing the top and bottom are subdivided using <code>bmesh.ops.subdivide_edges</code>.</li> </ul> <p>Examples:</p> <p>Create a simple cone with radius 1 and height 2:</p> <pre><code>cone = Mesh.bl_cone(radius1=1, radius2=0, depth=2, segments=16)\n</code></pre> <p>Create a cylinder with 32 segments and subdivided sides:</p> <pre><code>cylinder = Mesh.bl_cone(radius1=1, radius2=1, depth=3,\n                        segments=32, side_segments=4)\n</code></pre> <p>Create a cone with filled caps using triangle fans:</p> <pre><code>cone = Mesh.bl_cone(radius1=1, radius2=0, depth=2,\n                    cap_ends=True, cap_tris=True)\n</code></pre> See Also <p><code>bmesh.ops.create_cone</code> :     BMesh operator used for creating cone and cylinder primitives. <code>bmesh.ops.subdivide_edges</code> :     BMesh operator used for subdividing vertical edges when <code>side_segments &gt; 1</code>.</p> <p>Note: UVs are automatically calculated when the cone is created.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_grid","title":"bl_grid  <code>classmethod</code>","text":"<pre><code>bl_grid(x_segments=1, y_segments=1, size=2, materials=None)\n</code></pre> <p>Create a grid mesh.</p> <p>Blender constructor for generating a grid primitive using <code>bmesh.ops.create_grid</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x_segments</code> <code>int</code> <p>Number of segments along the X axis. Default is 1.</p> <code>1</code> <code>y_segments</code> <code>int</code> <p>Number of segments along the Y axis. Default is 1.</p> <code>1</code> <code>size</code> <code>float or tuple of float</code> <p>Size of the grid. If a single float is given, the grid is square. If a tuple is given, defines the grid dimensions along X and Y. Default is 2.</p> <code>2</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the grid. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the grid.</p> Notes <ul> <li>The grid is created using <code>bmesh.ops.create_grid</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> </ul> <p>Examples:</p> <p>Create a 10x10 grid of size 5:</p> <pre><code>grid = Mesh.bl_grid(x_segments=10, y_segments=10, size=5)\n</code></pre> <p>Create a rectangular grid 4x8 of size (2, 5):</p> <pre><code>grid = Mesh.bl_grid(x_segments=4, y_segments=8, size=(2, 5))\n</code></pre> See Also <p><code>bmesh.ops.create_grid</code> :     BMesh operator used for creating a grid primitive.</p> <p>Note: UVs are automatically calculated when the grid is created.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.blender_data","title":"blender_data","text":"<pre><code>blender_data(readonly=False)\n</code></pre> <p>Context manager to access the Blender Mesh API with a temporary mesh.</p> <p>This method transfers the current mesh geometry to a temporary Blender Mesh data block, yields it for reading or modification, and optionally captures the changes back into the mesh.</p> <p>Example usage:     <pre><code>mesh = Mesh.Cube()\n\nwith mesh.blender_data() as data:\n    normals = np.array([poly.normal for poly in data.polygons])\n\nprint(normals)\n# Output:\n# [[-1. -0.  0.]\n#  [ 0.  1.  0.]\n#  [ 1. -0.  0.]\n#  [ 0. -1.  0.]\n#  [ 0.  0. -1.]\n#  [ 0. -0.  1.]]\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>readonly</code> <code>bool</code> <p>If True, the geometry is not read back from the Blender Mesh after modification. Default is False.</p> <code>False</code> <p>Yields:</p> Type Description <code>Mesh</code> <p>A temporary Blender Mesh data block representing the mesh geometry.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bmesh","title":"bmesh","text":"<pre><code>bmesh(readonly=False)\n</code></pre> <p>Context manager to access and manipulate the mesh using Blender's BMesh API.</p> <p>This method creates a temporary BMesh from the mesh data, yields it for modification, and then writes back the changes to the mesh data unless in readonly mode.</p> <p>Example usage:     <pre><code>mesh = Mesh.Cube()\n\n# Move the vertices with bmesh\nwith mesh.bmesh() as bm:\n    for v in bm.verts:\n        v.co.x += 1.0\n\n# Move the vertices directly in numpy array\nmesh.points.position[:, 1] += 1\n\n# Cube moved along x and y\nmesh.to_object(\"Cube\")\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>readonly</code> <code>bool</code> <p>If True, changes made to the BMesh are not written back to the mesh data (default is False).</p> <code>False</code> <p>Yields:</p> Type Description <code>BMesh</code> <p>A BMesh object representing the mesh data, which can be modified within the context.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.boolean","title":"boolean","text":"<pre><code>boolean(other, operation='DIFFERENCE')\n</code></pre> <p>Apply a boolean CSG operation with another mesh object and return the result.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Mesh</code> <p>The mesh used as the boolean operand.</p> required <code>operation</code> <code>(INTERSECT, UNION, DIFFERENCE)</code> <p>Type of boolean operation to perform. Default is 'DIFFERENCE'.</p> <code>'INTERSECT'</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance created from the object after applying the Boolean modifier.</p> Notes <ul> <li>Internally, a Blender Boolean modifier is added to <code>self</code>, pointing to <code>other</code>, and then applied via <code>bpy.ops.object.modifier_apply</code>.</li> <li>The result is read back as a new mesh using <code>Mesh.from_object</code>.</li> <li>Context managers <code>object</code> are used to obtain temporary Blender objects for both meshes.</li> </ul> <p>Examples:</p> <p>Subtract <code>B</code> from <code>A</code>:</p> <pre><code>result = A.boolean(B, operation='DIFFERENCE')\n</code></pre> <p>Compute the union:</p> <pre><code>result = A.boolean(B, operation='UNION')\n</code></pre> <p>Keep only the intersection:</p> <pre><code>result = A.boolean(B, operation='INTERSECT')\n</code></pre> See Also <p><code>Mesh.from_object</code> :     Converts a Blender object back into a mesh wrapper. <code>object</code> :     Context manager yielding a temporary Blender object.</p> <p>Warning: Applying the modifier is destructive to the underlying Blender object for <code>self</code> (its mesh data is changed). The method returns a new mesh instance representing the modified result.</p> <p>Caution: Ensure <code>operation</code> is one of {'INTERSECT', 'UNION', 'DIFFERENCE'}; other values are invalid for Blender's Boolean modifier.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bridge_loops","title":"bridge_loops","text":"<pre><code>bridge_loops(loop0, loop1, close=False, segments=1, **attributes)\n</code></pre> <p>Create a grid connecting two vertex loops of equal size.</p> <p>The operation selects the edges forming each loop and bridges them using <code>bmesh.ops.bridge_loops</code>. If <code>segments &gt; 1</code>, the newly created edges are subdivided to form a denser grid between the loops.</p> <p>Parameters:</p> Name Type Description Default <code>loop0</code> <code>array-like of int</code> <p>The first loop of vertex indices.</p> required <code>loop1</code> <code>array-like of int</code> <p>The second loop of vertex indices. Must have the same length as <code>loop0</code>.</p> required <code>close</code> <code>bool</code> <p>If True, the loops are treated as closed and the first vertex is appended at the end to close the cycle. Default is False.</p> <code>False</code> <code>segments</code> <code>int</code> <p>Number of segments to subdivide between the loops. Must be &gt;= 1. Default is 1 (no subdivision).</p> <code>1</code> <code>**attributes</code> <code>dict</code> <p>Additional attributes to set on the mesh after bridging (passed as keyword arguments).</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>Modifies the mesh in place. Returns <code>None</code>.</p> Notes <ul> <li>Edges belonging to each loop are identified by sorting endpoint pairs and matching them against the current BMesh edge list via a structured dtype view and <code>np.isin</code>.</li> <li>Bridging is performed with <code>bmesh.ops.bridge_loops</code>.</li> <li>When <code>segments &gt; 1</code>, subdivision of the bridge edges is performed with <code>bmesh.ops.subdivide_edges</code> using <code>cuts=segments - 1</code> and <code>use_grid_fill=False</code>.</li> </ul> <p>Examples:</p> <p>Bridge two loops with no subdivision:</p> <pre><code>obj.bridge_loops(loop0, loop1, segments=1)\n</code></pre> <p>Bridge two closed loops with 3 subdivisions:</p> <pre><code>obj.bridge_loops(loop0, loop1, close=True, segments=3)\n</code></pre> See Also <p>bmesh.ops.bridge_loops : BMesh operator for bridging edge loops. bmesh.ops.subdivide_edges : BMesh operator for subdividing edges.</p> <p>Warning: This function modifies the mesh in place and may create new vertices/edges/faces. Handle undo/history in Blender if needed.</p> <p>Caution: Both loops must have the same number of vertices for correct bridging.</p> <p>Note: When <code>close=True</code>, the first vertex of each loop is duplicated at the end to ensure cyclic connectivity.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bvh_tree","title":"bvh_tree","text":"<pre><code>bvh_tree(count=None)\n</code></pre> <p>Build a Blender BVH tree for fast spatial queries (ray casting, overlap, nearest point, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>If <code>None</code>, build a single BVH tree for the whole mesh. If an integer <code>count</code> is provided, the mesh is assumed to represent a batch of <code>count</code> sub-meshes laid out in a structured array, and a list of BVH trees (one per sub-mesh) is returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>BVHTree or list of BVHTree</code> <ul> <li>If <code>count</code> is <code>None</code>, a single <code>BVHTree</code> instance built from the current mesh.</li> <li>If <code>count</code> is an integer, a list of <code>BVHTree</code> objects, one for each sub-mesh.</li> </ul> Notes <ul> <li>Internally uses <code>mathutils.bvhtree.BVHTree.FromPolygons</code>.</li> <li>When <code>count</code> is given, vertices are reshaped to <code>(count, n, 3)</code> and faces are assumed to be identical across all sub-meshes.</li> <li><code>epsilon=0.0</code> is used for exact geometry.</li> </ul> <p>Examples:</p> <p>Build a single BVH tree:</p> <pre><code>tree = mesh.bvh_tree()\nloc, normal, index, dist = tree.ray_cast((0, 0, 10), (0, 0, -1))\n</code></pre> <p>Build multiple BVH trees for a batch of 5 sub-meshes:</p> <pre><code>trees = mesh.bvh_tree(count=5)\nfor t in trees:\n    print(t.find_nearest((0, 0, 0)))\n</code></pre> <p>Caution: When <code>count</code> is provided, the mesh must be structured consistently: faces are taken from the first sub-mesh and reused for all.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.capture","title":"capture","text":"<pre><code>capture(other)\n</code></pre> <p>Capture the data of another Mesh.</p> Arguments <pre><code>- other (Mesh) : the mesh to capture\n</code></pre> <p>Returns:</p> Type Description <code>    - self</code>"},{"location":"api/mesh/#npblender.mesh.Mesh.chain_link","title":"chain_link  <code>classmethod</code>","text":"<pre><code>chain_link(major_segments=48, minor_segments=12, radius=1.0, section=0.5, length=4.0, materials=None)\n</code></pre> <p>Create a single chain link (oval torus with straightened sides).</p> <p>The link is built from a torus of major radius <code>radius</code> and tube radius <code>section / 2</code>. If <code>length &gt; 2 * radius</code>, the torus is split in half, translated to open a gap of size <code>delta = length - 2 * radius</code>, mirrored, then the opposite borders are bridged to form the elongated link. UVs are adjusted to keep a clean seam layout.</p> <p>Parameters:</p> Name Type Description Default <code>major_segments</code> <code>int</code> <p>Number of segments around the major loop. Default is 48.</p> <code>48</code> <code>minor_segments</code> <code>int</code> <p>Number of segments around the tube section. Default is 12.</p> <code>12</code> <code>radius</code> <code>float</code> <p>Major radius of the link (half the distance between opposite sides on the long axis before elongation). Default is 1.0.</p> <code>1.0</code> <code>section</code> <code>float</code> <p>Diameter of the link cross-section (tube thickness). Default is 0.5.</p> <code>0.5</code> <code>length</code> <code>float</code> <p>Target overall length of the link along its long axis. If close to <code>2 * radius</code>, the result is essentially a pure torus. Default is 4.0.</p> <code>4.0</code> <code>materials</code> <code>list of str</code> <p>Material names to assign to the link. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the chain link.</p> Notes <ul> <li>Construction steps: 1) Create a torus with <code>torus</code>. 2) Delete approximately half the vertices on the negative Y side with     <code>delete_vertices</code>. 3) Duplicate and mirror the remaining half to the other side. 4) Bridge the facing border loops with     <code>bridge_loops</code> (twice, crossing). 5) Recompute and assign UVs using <code>grid_uv_map</code>     to distribute the texture coordinates and minimize stretching.</li> <li>When <code>length - 2 * radius</code> is smaller than ~<code>radius / 10</code>, the method returns the original torus since elongation would be negligible.</li> </ul> <p>Examples:</p> <p>Create a standard chain link:</p> <pre><code>link = Mesh.chain_link(major_segments=64, minor_segments=16,\n                    radius=0.5, section=0.12, length=1.6)\n</code></pre> <p>Create a thicker, longer link:</p> <pre><code>link = Mesh.chain_link(radius=1.0, section=0.25, length=3.0)\n</code></pre> See Also <p><code>torus</code> :     Base primitive used to start the link. <code>delete_vertices</code> :     Used to remove half of the torus before mirroring. <code>bridge_loops</code> :     Used to reconnect mirrored borders. <code>grid_uv_map</code> :     Generates UVs for the final link surface. <code>from_mesh</code> :     Utility for duplicating mesh halves before joining.</p> <p>Caution: Very small <code>section</code> relative to <code>major_segments</code> can create skinny triangles near the bridged areas. Increase segment counts or <code>section</code> for cleaner topology.</p> <p>Note: If <code>length &lt;= 2 * radius</code>, no elongation is performed and the result is (nearly) identical to a torus of the given parameters.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.check","title":"check","text":"<pre><code>check(title='Mesh Check', halt=True)\n</code></pre> <p>Check if mesh domains (corners, faces, edges) are consistent.</p> <p>This method verifies the consistency of the mesh domains by checking the validity of corners, faces, and edges relative to the number of points. In development mode, it raises an exception to prevent Blender from crashing if inconsistencies are found.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title prefix for error messages (default is \"Mesh Check\").</p> <code>'Mesh Check'</code> <code>halt</code> <code>bool</code> <p>If True, raise an exception on failure; otherwise, print a warning (default is True).</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if all checks pass; otherwise, raises an exception or prints an error.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the check fails and halt is True.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.circle","title":"circle  <code>classmethod</code>","text":"<pre><code>circle(radius=1, segments=16, fill_segments=0, cap='NONE', materials=None)\n</code></pre> <p>Create a circle mesh.</p> <p>The circle can be created as: - An open ring (<code>cap='NONE'</code>). - A filled n-gon (<code>cap='NGON'</code>). - A triangle fan (<code>cap='FANS'</code>).</p> <p>The argument <code>fill_segments</code> controls how the interior of the circle is filled: - If <code>fill_segments == 0</code> and <code>cap='NGON'</code>, the circle is filled with a single polygon. - If <code>fill_segments &gt; 0</code>, the circle is filled with concentric rings and triangle fans (not yet implemented in this method, but the behavior corresponds to <code>cap='FANS'</code>).</p> <p>Note: The <code>disk</code> method provides the same functionality with <code>cap='NGON'</code> as its default mode.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the circle. Default is 1.</p> <code>1</code> <code>segments</code> <code>int</code> <p>Number of segments (vertices) around the circle. Default is 16.</p> <code>16</code> <code>fill_segments</code> <code>int</code> <p>Number of internal subdivisions (concentric circles). If 0, the circle is filled with a single polygon when <code>cap='NGON'</code>. Default is 0.</p> <code>0</code> <code>cap</code> <code>(NONE, NGON, FANS)</code> <p>How to fill the interior of the circle. Default is 'NONE'.</p> <code>'NONE'</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the circle. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the circle.</p> Notes <ul> <li><code>cap='NONE'</code>: returns only the ring of edges.</li> <li><code>cap='NGON'</code>: fills the circle with a polygon face.</li> <li><code>cap='FANS'</code>: fills the circle with a fan of triangles around a central point.</li> <li>UV coordinates are generated with <code>disk_uv_map</code>.</li> <li>Fan topology is generated with <code>fans_corners</code>.</li> </ul> <p>Examples:</p> <p>Create an open circle with 32 segments:</p> <pre><code>circle = Mesh.circle(radius=1, segments=32, cap='NONE')\n</code></pre> <p>Create a filled disk using an n-gon:</p> <pre><code>circle = Mesh.circle(radius=2, segments=24, cap='NGON')\n</code></pre> <p>Create a filled disk with triangle fans:</p> <pre><code>circle = Mesh.circle(radius=1, segments=16, cap='FANS')\n</code></pre> See Also <p><code>disk</code> :     Equivalent method for creating disks (default <code>cap='NGON'</code>). <code>disk_uv_map</code> :     Generates UV coordinates for circular caps. <code>fans_corners</code> :     Generates corner topology for triangle fans.</p> <p>Caution: When using <code>cap='FANS'</code>, a new center vertex is added.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.clear_geometry","title":"clear_geometry","text":"<pre><code>clear_geometry()\n</code></pre> <p>Clear the geometry by deleting all geometric content.</p> <p>This method clears the points, corners, faces, and edges collections, effectively removing all geometric data from the mesh.</p> <p>Note:     The materials list associated with the mesh remains unchanged.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.compute_attribute_on_domain","title":"compute_attribute_on_domain","text":"<pre><code>compute_attribute_on_domain(domain_from, attr, domain_to)\n</code></pre> <p>Transfer an attribute from one domain to another.</p> <p>Performs a domain mapping (e.g., points \u2192 faces) using the appropriate domain operator, and returns the computed array on the target domain.</p> <p>Parameters:</p> Name Type Description Default <code>domain_from</code> <code>str</code> <p>Source domain name (e.g., <code>\"points\"</code>, <code>\"faces\"</code>, <code>\"edges\"</code>, <code>\"corners\"</code>, <code>\"splines\"</code>).</p> required <code>attr</code> <code>str or ndarray</code> <p>Source attribute to transfer. If a string, it is looked up on the source domain; if an array, it must match the source domain length.</p> required <code>domain_to</code> <code>str</code> <p>Target domain name.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Attribute values on the target domain. If <code>domain_from == domain_to</code>, returns <code>attr</code> unchanged.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If either <code>domain_from</code> or <code>domain_to</code> is not a valid domain of this geometry.</p> <code>Exception</code> <p>If the requested mapping is not implemented.</p> Notes <p>Implemented mappings include: - points \u2192 faces: <code>Point.compute_attribute_on_faces</code> - points \u2192 edges: <code>Point.compute_attribute_on_edges</code> - points \u2192 corners: <code>Point.compute_attribute_on_corners</code> - points \u2192 splines: <code>Point.compute_attribute_on_splines</code> - faces \u2192 points: <code>Face.compute_attribute_on_points</code> - edges \u2192 points: <code>Edge.compute_attribute_on_points</code> - corners \u2192 points: <code>Corner.compute_attribute_on_points</code></p>"},{"location":"api/mesh/#npblender.mesh.Mesh.cone","title":"cone  <code>classmethod</code>","text":"<pre><code>cone(vertices=32, side_segments=1, fill_segments=1, radius_top=0, radius_bottom=1, depth=2, fill_type='NGON', materials=None)\n</code></pre> <p>Create a cone (or cylinder) mesh.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>int</code> <p>Number of vertices around the circumference. Default is 32.</p> <code>32</code> <code>side_segments</code> <code>int</code> <p>Number of subdivisions along the vertical side edges. Default is 1 (no subdivision).</p> <code>1</code> <code>fill_segments</code> <code>int</code> <p>Number of concentric circles added to the caps. Currently unused. Default is 1.</p> <code>1</code> <code>radius_top</code> <code>float</code> <p>Radius of the top face. Default is 0 (cone).</p> <code>0</code> <code>radius_bottom</code> <code>float</code> <p>Radius of the bottom face. Default is 1.</p> <code>1</code> <code>depth</code> <code>float</code> <p>Height of the cone along the Z axis. Default is 2.</p> <code>2</code> <code>fill_type</code> <code>(NGON, FANS, NONE)</code> <p>Type of filling for the top and bottom caps: - <code>'NGON'</code>: fill with n-gons. - <code>'FANS'</code>: fill with triangle fans. - <code>'NONE'</code>: no cap filling. Default is <code>'NGON'</code>.</p> <code>'NGON'</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the cone.</p> Notes <ul> <li>If both <code>radius_top</code> and <code>radius_bottom</code> are zero, the result is an empty mesh.</li> <li>Internally calls <code>bl_cone</code> with <code>cap_ends</code> and <code>cap_tris</code> derived from <code>fill_type</code>.</li> <li>UVs are generated automatically by Blender's cone operator.</li> </ul> <p>Examples:</p> <p>Create a simple cone of height 2 and base radius 1:</p> <pre><code>cone = Mesh.cone(vertices=32, radius_top=0, radius_bottom=1, depth=2)\n</code></pre> <p>Create a cylinder with 16 vertices and subdivided sides:</p> <pre><code>cylinder = Mesh.cone(vertices=16, radius_top=1, radius_bottom=1,\n                    depth=3, side_segments=3)\n</code></pre> <p>Create a cone with triangle fan caps:</p> <pre><code>cone = Mesh.cone(vertices=24, radius_top=0, radius_bottom=2,\n                depth=4, fill_type='FANS')\n</code></pre> See Also <p><code>bl_cone</code> :     Low-level constructor for cones and cylinders. <code>bl_circle</code> :     For creating circle primitives with optional triangle fan filling.</p> <p>Note: Use <code>fill_type='NONE'</code> to create an open-ended cone or cylinder.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.cube","title":"cube  <code>classmethod</code>","text":"<pre><code>cube(size=2, materials=None)\n</code></pre> <p>Create a cube mesh.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>float or array-like of shape (3,)</code> <p>Size of the cube. If a single float is given, the cube is uniform in all dimensions. If an array of three floats is given, it specifies the size along the X, Y, and Z axes. Default is 2.</p> <code>2</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the cube. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the cube.</p> Notes <ul> <li>The cube is created centered at the origin with side length <code>size</code>.</li> <li>UV coordinates are assigned so that all six faces are unwrapped into a cross-like layout.</li> </ul> <p>Examples:</p> <p>Create a default cube of size 2:</p> <pre><code>cube = Mesh.cube()\n</code></pre> <p>Create a cube of size 5:</p> <pre><code>cube = Mesh.cube(size=5)\n</code></pre> <p>Create a rectangular box of dimensions (2, 3, 4):</p> <pre><code>box = Mesh.cube(size=(2, 3, 4))\n</code></pre> See Also <p><code>Mesh</code> :     The mesh class used to construct and manage geometry.</p> <p>Note: The cube is centered at the origin and scaled by <code>size/2</code> after construction.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.cylinder","title":"cylinder  <code>classmethod</code>","text":"<pre><code>cylinder(vertices=32, side_segments=1, radius=1, depth=2, fill_type='NGON', materials=None)\n</code></pre> <p>Create a cylinder mesh.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>int</code> <p>Number of vertices around the circumference. Default is 32.</p> <code>32</code> <code>side_segments</code> <code>int</code> <p>Number of subdivisions along the vertical side edges. Default is 1 (no subdivision).</p> <code>1</code> <code>radius</code> <code>float</code> <p>Radius of both the top and bottom faces. Default is 1.</p> <code>1</code> <code>depth</code> <code>float</code> <p>Height of the cylinder along the Z axis. Default is 2.</p> <code>2</code> <code>fill_type</code> <code>(NGON, FANS, NONE)</code> <p>Type of filling for the top and bottom caps: - <code>'NGON'</code>: fill with n-gons. - <code>'FANS'</code>: fill with triangle fans. - <code>'NONE'</code>: no cap filling. Default is <code>'NGON'</code>.</p> <code>'NGON'</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the cylinder.</p> Notes <ul> <li>Internally calls <code>bl_cone</code> with <code>radius1 = radius2 = radius</code>.</li> <li>UVs are generated automatically by Blender's cone operator.</li> </ul> <p>Examples:</p> <p>Create a default cylinder of radius 1 and height 2:</p> <pre><code>cyl = Mesh.cylinder()\n</code></pre> <p>Create a cylinder with 64 vertices and 4 vertical subdivisions:</p> <pre><code>cyl = Mesh.cylinder(vertices=64, side_segments=4, radius=2, depth=5)\n</code></pre> <p>Create an open cylinder without caps:</p> <pre><code>cyl = Mesh.cylinder(radius=1, depth=3, fill_type='NONE')\n</code></pre> See Also <p><code>bl_cone</code> :     Low-level constructor for cones and cylinders. <code>cone</code> :     Generalized method for cones and cylinders.</p> <p>Note: This method is a convenience wrapper for <code>bl_cone</code> with equal top and bottom radii.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.delete_faces","title":"delete_faces","text":"<pre><code>delete_faces(selection)\n</code></pre> <p>Delete only the selected faces from the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool</code> <p>Indices or boolean mask specifying which faces to delete.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Modifies the mesh in place. Returns <code>None</code>.</p> See Also <p><code>delete_loops</code> :     Method used internally to remove the corners and faces. <code>corners</code> :     Corner array of the mesh, used to identify face connectivity.</p> <p>Warning: This function permanently deletes faces and their associated corners. Handle undo/history in Blender if needed.</p> <p>Note: Only faces are removed. Edges and vertices remain in the mesh unless explicitly deleted by other operations.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.delete_vertices","title":"delete_vertices","text":"<pre><code>delete_vertices(points=None, faces=None, edges=None)\n</code></pre> <p>Delete vertices from the mesh, with optional selection by points, faces, or edges.</p> <p>A vertex is deleted if it is explicitly listed in <code>points</code>, or if it belongs to any of the given <code>faces</code> or <code>edges</code>.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like of int or bool</code> <p>Vertex indices (or boolean mask) specifying which vertices to delete directly.</p> <code>None</code> <code>faces</code> <code>array-like of int or bool</code> <p>Face indices (or boolean mask). Any vertex belonging to these faces will be deleted.</p> <code>None</code> <code>edges</code> <code>array-like of int or bool</code> <p>Edge indices (or boolean mask). Any vertex belonging to these edges will be deleted.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>Modifies the mesh in place. Returns <code>None</code>.</p> Notes <ul> <li>At least one of <code>points</code>, <code>faces</code>, or <code>edges</code> must be provided, otherwise the function does nothing.</li> <li>The deletion is executed using <code>bmesh.ops.delete</code> with <code>context='VERTS'</code>.</li> </ul> <p>Examples:</p> <p>Delete specific vertices:</p> <pre><code>obj.delete_vertices(points=[0, 1, 2])\n</code></pre> <p>Delete all vertices belonging to certain faces:</p> <pre><code>obj.delete_vertices(faces=[10, 11])\n</code></pre> <p>Delete all vertices belonging to certain edges:</p> <pre><code>obj.delete_vertices(edges=[5, 6, 7])\n</code></pre> See Also <p><code>bmesh.ops.delete</code> :     Blender BMesh operator used for deleting geometry.</p> <p>Warning: This function permanently removes vertices and any connected geometry (edges, faces). Handle undo/history in Blender if needed.</p> <p>Note: If multiple selectors (<code>points</code>, <code>faces</code>, <code>edges</code>) are provided, the union of all matched vertices will be deleted.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.disk","title":"disk  <code>classmethod</code>","text":"<pre><code>disk(radius=1, segments=16, fill_segments=0, cap='NGON', materials=None)\n</code></pre> <p>Create a disk mesh.</p> <p>This is equivalent to <code>circle</code>, but with <code>cap='NGON'</code> as the default filling mode.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the disk. Default is 1.</p> <code>1</code> <code>segments</code> <code>int</code> <p>Number of segments (vertices) around the disk. Default is 16.</p> <code>16</code> <code>fill_segments</code> <code>int</code> <p>Number of internal subdivisions (concentric circles). Default is 0 (single n-gon when <code>cap='NGON'</code>).</p> <code>0</code> <code>cap</code> <code>(NONE, NGON, FANS)</code> <p>How to fill the interior of the disk. Default is 'NGON'.</p> <code>'NONE'</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the disk. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the disk.</p> <p>Examples:</p> <p>Create a default disk of radius 2 with 32 segments:</p> <pre><code>disk = Mesh.disk(radius=2, segments=32)\n</code></pre> <p>Create a disk filled with triangle fans:</p> <pre><code>disk = Mesh.disk(radius=1, segments=16, cap='FANS')\n</code></pre> See Also <p><code>circle</code> :     General method for circle/disk creation with customizable cap. <code>disk_uv_map</code> :     Generates UV coordinates for circular caps. <code>fans_corners</code> :     Generates corner topology for triangle fans.</p> <p>Note: This method is a shorthand for <code>circle(..., cap='NGON')</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.dual","title":"dual","text":"<pre><code>dual(center='median')\n</code></pre> <p>Construct the dual mesh: one vertex per original face, and one face per original vertex (linking adjacent face-centers around that vertex).</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>(median, bounds, weighted)</code> <p>Method to compute the position of each dual vertex (i.e., the center of the corresponding original face): - <code>'median'</code>: face median center (<code>BMFace.calc_center_median</code>). - <code>'bounds'</code>: face bounds center (<code>BMFace.calc_center_bounds</code>). - <code>'weighted'</code>: area-weighted center (<code>BMFace.calc_center_median_weighted</code>). Default is <code>'median'</code>.</p> <code>'median'</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>The dual mesh, where: - points = centers of original faces, - faces  = polygons formed by chaining the adjacent original faces around each original vertex.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>center</code> is not one of <code>{'median', 'bounds', 'weighted'}</code>.</p> Notes <ul> <li>For each original face <code>f</code>, a dual vertex is computed using the chosen center method and stored at index <code>f.index</code>.</li> <li>For each original vertex <code>v</code>, its incident faces are ordered by walking across <code>v</code>\u2019s incident edges (each with exactly two linked faces) to form a cyclic sequence of face indices; this ordered loop becomes a polygon in the dual.</li> <li>Non-manifold or boundary configurations (edges with a number of linked faces different from 2) are skipped for that vertex; no dual face is created in such cases.</li> </ul> <p>Examples:</p> <p>Build the dual using area-weighted face centers:</p> <pre><code>d = mesh.dual(center='weighted')\n</code></pre> <p>Build the dual with bounds centers:</p> <pre><code>d = mesh.dual(center='bounds')\n</code></pre> See Also <p><code>triangulate</code> :     Triangulation can improve robustness before dualization. <code>remove_doubles</code> :     Helpful for cleaning geometry prior to constructing the dual.</p> <p>Caution: On meshes with boundaries or non-manifold edges, some vertices may not yield a valid cyclic ordering of adjacent faces; those dual faces are omitted.</p> <p>Note: Dualization does not, in general, invert perfectly (i.e., the dual of the dual is not guaranteed to reproduce the original mesh), especially in the presence of boundaries or irregular valences.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_faces","title":"extrude_faces","text":"<pre><code>extrude_faces(selection, offset=None, scale=1.0)\n</code></pre> <p>Extrude individual faces by duplicating them, optionally displacing them by <code>offset</code>, and connecting side faces.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Indices (or mask) of faces to extrude. If <code>None</code>, all faces are extruded.</p> required <code>offset</code> <code>(array - like, shape(3) or (N, 3))</code> <p>Extrusion vector(s). A single vector is broadcast to all faces. If <code>None</code>, each face is extruded along its own normal.</p> <code>None</code> <code>scale</code> <code>float</code> <p>Scale factor applied to <code>offset</code> (or to the face normal if <code>offset=None</code>). Default is 1.0.</p> <code>1.0</code> <code>dissolve</code> <code>bool</code> <p>Not implemented in this version. Placeholder for removing the starting faces after extrusion.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with two keys: - <code>'top'</code>: indices of the extruded (displaced) faces. - <code>'side'</code>: indices of the side faces connecting the original and new faces.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>offset</code> cannot be broadcast to shape <code>(len(faces), 3)</code>.</p> <code>AssertionError</code> <p>If a side edge of an extruded face does not have exactly two linked faces.</p> Notes <ul> <li>Uses <code>bmesh.ops.extrude_discrete_faces</code> to duplicate each selected face independently.</li> <li>If <code>offset</code> is <code>None</code>, displacement is along each face's local normal.</li> <li>Side faces are identified by checking edges linked to the extruded faces.</li> </ul> <p>Examples:</p> <p>Extrude all faces along their normals:</p> <pre><code>res = Mesh.extrude_faces(selection=None, scale=0.2)\n</code></pre> <p>Extrude a subset of faces by a fixed offset:</p> <pre><code>res = Mesh.extrude_faces(selection=[0, 2, 5], offset=(0, 0, 1))\n</code></pre> <p>Extrude faces with per-face offsets:</p> <pre><code>offs = np.random.randn(len(sel), 3) * 0.1\nres = Mesh.extrude_faces(selection=sel, offset=offs)\n</code></pre> See Also <p><code>extrude_vertices</code> :     Extrude isolated vertices. <code>extrude_loop</code> :     Extrude a vertex loop into a quad strip.</p> <p>Caution: If <code>offset</code> is given per-face, its length must match the number of extruded faces or broadcasting will fail.</p> <p>Note: Side face indices may be repeated if multiple extrusions share edges.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_loop","title":"extrude_loop","text":"<pre><code>extrude_loop(loop, offset, close=False, clockwise=False, **attributes)\n</code></pre> <p>Extrude a loop of vertices by duplicating the loop, offsetting it, and creating a quad strip between the original and the offset loop.</p> <p>Parameters:</p> Name Type Description Default <code>loop</code> <code>array-like of int</code> <p>Vertex indices defining the loop to extrude. Must contain at least 2 vertices.</p> required <code>offset</code> <code>(array - like, shape(3) or (N, 3))</code> <p>Extrusion vector(s). A single 3D vector is broadcast to all vertices in <code>loop</code>, or provide one vector per vertex (N == len(loop)).</p> required <code>close</code> <code>bool</code> <p>If True, treats the input as a closed loop and connects the last vertex back to the first when building side quads. Default is False.</p> <code>False</code> <code>clockwise</code> <code>bool</code> <p>Controls the orientation (winding) of the generated faces and the UV layout. Default is False.</p> <code>False</code> <code>**attributes</code> <code>dict</code> <p>Extra attributes intended for the new geometry (see Caution).</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary describing the created geometry as returned by <code>add_geometry</code>. Contains at least: - <code>'points'</code>: indices of the duplicated (offset) vertices. - <code>'corners'</code>: indices of the generated quad strip corners. - <code>'faces'</code>: face arity (4 for quads).</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>offset</code> is neither a single <code>(3,)</code> vector nor an array of shape <code>(len(loop), 3)</code>.</p> Notes <ul> <li>New vertices are computed as <code>points[loop] + offset</code> (with broadcasting if <code>offset</code> is a single vector).</li> <li>Side faces are constructed using the topology from <code>grid_corners</code> with two rows (original and offset loop).</li> <li>UVs for the side strip are generated by <code>grid_uv_map</code> with matching parameters.</li> </ul> <p>Examples:</p> <p>Extrude an open loop along a single vector:</p> <pre><code>new = Mesh.extrude_loop(loop, offset=(0, 0, 1), close=False)\n</code></pre> <p>Extrude a closed loop with per-vertex offsets and flipped winding:</p> <pre><code>offs = np.random.randn(len(loop), 3) * 0.02\nnew = Mesh.extrude_loop(loop, offset=offs, close=True, clockwise=True)\n</code></pre> See Also <p><code>extrude_vertices</code> :     Extrude isolated vertices with edges to their duplicates. <code>add_geometry</code> :     Adds the new points/corners/faces and returns their indices. <code>grid_corners</code> :     Builds the quad topology of the side strip. <code>grid_uv_map</code> :     Generates UVs for the side strip.</p> <p>Caution: <code>offset</code> must be either a single <code>(3,)</code> vector or an array of shape <code>(len(loop), 3)</code>. Any other shape will raise an error.</p> <p>Caution: The <code>attributes</code> kwargs are currently not forwarded to <code>add_geometry</code> in this implementation. If you need them applied, pass them through explicitly in the call to <code>add_geometry</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_region","title":"extrude_region","text":"<pre><code>extrude_region(selection, offset=(0, 0, 1), dissolve=False)\n</code></pre> <p>Extrude a connected face region, translate the new geometry by <code>offset</code>, and optionally dissolve the original faces.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Indices (or mask) of faces to extrude. If <code>None</code>, all faces are used.</p> required <code>offset</code> <code>array-like of float, shape (3,)</code> <p>Translation vector applied to the newly created vertices of the region. Default is (0, 0, 1).</p> <code>(0, 0, 1)</code> <code>dissolve</code> <code>bool</code> <p>If True, delete the original (pre-extrusion) faces after the region has been extruded. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with two keys: - <code>'top'</code>: indices of the newly extruded faces (translated region). - <code>'side'</code>: indices of the side faces that connect original and new faces.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If a side edge of an extruded face does not have exactly two linked faces (non-manifold condition).</p> Notes <ul> <li>Region extrusion is performed via <code>bmesh.ops.extrude_face_region</code>, then the new vertices are moved using <code>bmesh.ops.translate</code>.</li> <li>Side faces are discovered by scanning the edges of the extruded faces and collecting the adjacent face opposite to each extruded face.</li> </ul> <p>Examples:</p> <p>Extrude a region upward and keep the original faces:</p> <pre><code>res = Mesh.extrude_region(selection=[0, 1, 2], offset=(0, 0, 0.2), dissolve=False)\n</code></pre> <p>Extrude a region and dissolve the starting faces:</p> <pre><code>res = Mesh.extrude_region(selection=mask, offset=(0.1, 0, 0), dissolve=True)\n</code></pre> See Also <p><code>extrude_faces</code> :     Extrude faces individually (discrete), not as a connected region. <code>extrude_loop</code> :     Create a quad strip by offsetting a vertex loop. <code>extrude_vertices</code> :     Duplicate and connect selected vertices.</p> <p>Caution: <code>offset</code> must be a 3D vector. Non-3D inputs may cause the translation operator to fail.</p> <p>Note: With <code>dissolve=True</code>, the original faces are removed, leaving only the extruded shell.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_vertices","title":"extrude_vertices","text":"<pre><code>extrude_vertices(selection, offset, **attributes)\n</code></pre> <p>Extrude individual vertices by creating new points displaced by <code>offset</code> and connecting each original vertex to its duplicate with an edge.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Vertex indices or boolean mask selecting the vertices to extrude. If <code>None</code>, all vertices are extruded.</p> required <code>offset</code> <code>(array - like, shape(3) or (N, 3))</code> <p>Extrusion vector(s). Can be a single 3D vector applied to every selected vertex, or an array of vectors with one per selected vertex.</p> required <code>**attributes</code> <code>dict</code> <p>Optional attributes to attach to the created geometry (forwarded to <code>add_geometry</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary describing the created geometry as returned by <code>add_geometry</code>. Contains at least: - <code>'points'</code>: indices of newly added vertices. - <code>'edges'</code>: indices of newly added edges.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>offset</code> is neither a single <code>(3,)</code> vector nor an array of shape <code>(len(loop), 3)</code>.</p> Notes <ul> <li>New vertices are positioned at <code>points[selection] + offset</code>.</li> <li>One edge is created between each original vertex and its newly created counterpart using <code>edges_between</code>.</li> </ul> <p>Examples:</p> <p>Extrude all vertices by (0, 0, 1):</p> <pre><code>added = Mesh.extrude_vertices(selection=None, offset=(0, 0, 1))\n</code></pre> <p>Extrude a subset with per-vertex offsets:</p> <pre><code>sel = np.array([0, 2, 5, 7])\noffs = np.random.randn(len(sel), 3) * 0.1\nadded = Mesh.extrude_vertices(selection=sel, offset=offs)\n</code></pre> See Also <p><code>add_geometry</code> :     Adds new points/edges/faces and returns their indices. <code>edges_between</code> :     Builds edge pairs between two index arrays of equal length.</p> <p>Caution: When <code>offset</code> is an array, its length must match the number of selected vertices.</p> <p>Note: This operation creates only points and edges. Faces are not generated automatically.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.faces_neighbors","title":"faces_neighbors","text":"<pre><code>faces_neighbors()\n</code></pre> <p>Compute the neighboring faces for each face, defined as faces sharing at least one edge.</p> <p>Returns:</p> Type Description <code>list of list of int</code> <p>For each face (by index), a list of indices of adjacent faces.</p> Notes <ul> <li>Each face\u2019s neighbors are determined by scanning its incident edges and collecting the two faces linked to each edge.</li> <li>The current face index is excluded from its own neighbor list.</li> <li>Non-manifold edges (with more or fewer than two linked faces) are not expected; if present, results may be incomplete or inconsistent.</li> </ul> <p>Examples:</p> <p>Get adjacency information for all faces:</p> <pre><code>neighbors = mesh.faces_neighbors()\nfor i, ns in enumerate(neighbors):\n    print(f\"Face {i} neighbors: {ns}\")\n</code></pre> <p>Note: The output is a Python list of lists (not a NumPy array).</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.fill_cap","title":"fill_cap","text":"<pre><code>fill_cap(loop, mode='NGON', center=None, segments=1, clockwise=False, **attributes)\n</code></pre> <p>Fill a cap between vertices forming a loop.</p> <p>Supports two modes: - NGON: creates a single n-gon face from the loop. No center point is required. - FANS: creates a fan of triangles around a center point. The center can be: * <code>None</code>: automatically computed as the centroid of the loop. * <code>int</code>: the index of an existing vertex to use as center. * <code>array-like</code>: explicit coordinates of the center, which will be added as a new vertex.</p> <p>Parameters:</p> Name Type Description Default <code>loop</code> <code>array-like of int</code> <p>The vertex indices defining the loop.</p> required <code>mode</code> <code>(NGON, FANS)</code> <p>Fill mode to use. Default is 'NGON'.</p> <code>'NGON'</code> <code>center</code> <code>int or array - like or None</code> <p>Center of the cap (used only in 'FANS' mode). - <code>None</code>: computed centroid. - <code>int</code>: index of an existing vertex. - array-like: coordinates of a new vertex.</p> <code>None</code> <code>segments</code> <code>int</code> <p>Number of radial subdivisions for FANS mode. Must be &gt;= 1. Default is 1 (no subdivision).</p> <code>1</code> <code>clockwise</code> <code>bool</code> <p>Whether the loop is ordered clockwise. Default is False.</p> <code>False</code> <code>**attributes</code> <code>dict</code> <p>Additional attributes to add to the mesh (passed to <code>add_geometry</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the newly added geometry, as returned by <code>add_geometry</code>. Includes at least keys for 'faces' and 'corners'. In FANS mode, also includes the added 'points' if a new center is created.</p> Notes <ul> <li>In 'NGON' mode, a UV map is generated using <code>disk_uv_map</code>.</li> <li>In 'FANS' mode, the fan topology is created with <code>fans_corners</code> and UVs are generated with <code>disk_uv_map</code>.</li> <li>If <code>segments &gt; 1</code> in FANS mode, radial edges are subdivided using <code>split_edges</code>.</li> </ul> <p>Examples:</p> <p>Fill a loop with an n-gon:</p> <pre><code>obj.fill_cap(loop, mode='NGON')\n</code></pre> <p>Fill a loop with a triangle fan around an automatically computed center:</p> <pre><code>obj.fill_cap(loop, mode='FANS')\n</code></pre> <p>Fill a loop with a fan using an existing vertex as the center and add 3 subdivisions:</p> <pre><code>obj.fill_cap(loop, mode='FANS', center=42, segments=3)\n</code></pre> See Also <p><code>add_geometry</code> :     Method used to add the created geometry to the mesh. <code>split_edges</code> :     Used to subdivide radial edges in FANS mode. <code>disk_uv_map</code> :     Generates UV coordinates for circular caps. <code>fans_corners</code> :     Generates corner topology for FANS mode.</p> <p>Warning: This function modifies the mesh in place and may create new vertices, faces, and edges.</p> <p>Caution: In FANS mode, if <code>center=None</code>, a new vertex is added at the centroid of the loop.</p> <p>Note: The <code>segments</code> parameter only applies to FANS mode; NGON mode always produces a single polygon face.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d)\n</code></pre> <p>Create a Mesh instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Dictionary containing mesh data with keys 'materials', 'points', 'corners', 'faces', and 'edges'.</p> required <p>Returns:</p> Type Description <code>Mesh</code> <p>A new Mesh instance initialized with the data from the dictionary.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_mesh","title":"from_mesh  <code>classmethod</code>","text":"<pre><code>from_mesh(other, points=None, faces=None, edges=None)\n</code></pre> <p>Create a copy of a Mesh object, optionally excluding specified points, faces, or edges.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Mesh</code> <p>The source Mesh object to copy.</p> required <code>points</code> <code>array-like of int</code> <p>Indices of points to exclude from the copy.</p> <code>None</code> <code>faces</code> <code>array-like of int</code> <p>Indices of faces to exclude from the copy.</p> <code>None</code> <code>edges</code> <code>array-like of int</code> <p>Indices of edges to exclude from the copy.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new Mesh instance copied from the source, with specified elements excluded.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_mesh_data","title":"from_mesh_data  <code>classmethod</code>","text":"<pre><code>from_mesh_data(data)\n</code></pre> <p>Initialize the geometry from a Blender Mesh data.</p> <p>This method creates and returns an instance of the mesh class initialized with vertices, edges, faces, corners, materials, and attributes extracted from the provided Blender mesh data.</p> <p>Args:     data: Blender mesh data or object that can be processed           by the blender.get_mesh function to obtain a Blender Mesh instance.</p> <p>Returns:     An instance of the mesh class initialized with the geometry     and attributes from the Blender Mesh.</p> <p>Raises:     ImportError: If the local blender module cannot be imported.     Any exceptions raised by blender.get_mesh if the data is invalid.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_model","title":"from_model  <code>classmethod</code>","text":"<pre><code>from_model(model, materials=None)\n</code></pre> <p>Create a Mesh instance from various types of input models.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str, bpy.types.Object, dict, Mesh, or bpy.types.Mesh</code> <p>The input model to create the Mesh from. It can be: - A string or Blender object to be evaluated and converted. - A dictionary representing the mesh data. - An existing Mesh instance. - A Blender Mesh data block.</p> required <code>materials</code> <code>list or None</code> <p>Materials to associate with the mesh (currently unused in this method).</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>The created Mesh instance based on the input model.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the type of the model is not supported.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_object","title":"from_object  <code>classmethod</code>","text":"<pre><code>from_object(obj, evaluated=False)\n</code></pre> <p>Create a Mesh instance from an existing Blender object.</p> <p>This method initializes a mesh from a Blender object, optionally using the evaluated version of the object (i.e., after applying modifiers).</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str or Object</code> <p>The Blender object or its name from which to create the mesh.</p> required <code>evaluated</code> <code>bool</code> <p>If True, use the evaluated object with modifiers applied. If False, use the raw mesh data. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new Mesh instance created from the specified Blender object.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the local blender module cannot be imported.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_cubic_envelop","title":"get_cubic_envelop","text":"<pre><code>get_cubic_envelop()\n</code></pre> <p>Return a cube mesh that encloses the geometry\u2019s bounding box.</p> <p>Uses the bounding box dimensions to build a cube via <code>Mesh.cube</code>, forwarding this geometry\u2019s <code>materials</code> if present.</p> <p>Returns:</p> Type Description <code>Mesh</code> <p>A cube mesh sized to the bounding box.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_islands","title":"get_islands","text":"<pre><code>get_islands()\n</code></pre> <p>Compute connected components of faces (islands) and assign an island ID to each face.</p> <p>Returns:</p> Type Description <code>ndarray of int, shape (n_faces,)</code> <p>Array of island IDs, one per face. Faces in the same connected component share the same integer ID. Empty mesh returns an empty list.</p> Notes <ul> <li>Islands are defined as groups of faces connected through shared edges.</li> <li>A breadth-first search (BFS) is used to traverse each connected component.</li> <li>IDs are assigned sequentially starting from 0.</li> </ul> <p>Examples:</p> <p>Get island IDs for all faces:</p> <pre><code>ids = mesh.get_islands()\nprint(\"Unique islands:\", np.unique(ids))\n</code></pre> <p>Map faces by island:</p> <pre><code>ids = mesh.get_islands()\nfor island_id in np.unique(ids):\n    faces = np.where(ids == island_id)[0]\n    print(f\"Island {island_id}: faces {faces}\")\n</code></pre> <p>Note: Non-manifold meshes are still handled, but faces that share only a vertex (not an edge) are considered separate islands.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_material_index","title":"get_material_index","text":"<pre><code>get_material_index(mat_name)\n</code></pre> <p>Return the index of a material name, creating it if needed.</p> <p>Parameters:</p> Name Type Description Default <code>mat_name</code> <code>str</code> <p>Material name to look up or append.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index of <code>mat_name</code> in <code>self.materials</code>.</p> Notes <p>If <code>mat_name</code> is not present, it is appended to <code>self.materials</code> and the new index is returned.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_points_selection","title":"get_points_selection","text":"<pre><code>get_points_selection()\n</code></pre> <p>Selection of points relevant to operations.</p> <p>Returns <code>slice(None)</code> in the base class (all points). Subclasses (e.g., curves) may override to select only referenced points.</p> <p>Returns:</p> Type Description <code>slice</code> <p><code>slice(None)</code> by default.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.grid","title":"grid  <code>classmethod</code>","text":"<pre><code>grid(size_x=1, size_y=1, vertices_x=3, vertices_y=3, materials=None)\n</code></pre> <p>Create a rectangular grid mesh.</p> <p>The grid is constructed in the XY plane with indexing set to <code>'ij'</code>, meaning the generated arrays have shape <code>(vertices_x, vertices_y)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>size_x</code> <code>float</code> <p>Size of the grid along the X axis. Default is 1.</p> <code>1</code> <code>size_y</code> <code>float</code> <p>Size of the grid along the Y axis. Default is 1.</p> <code>1</code> <code>vertices_x</code> <code>int</code> <p>Number of vertices along the X axis. Must be &gt;= 2. Default is 3.</p> <code>3</code> <code>vertices_y</code> <code>int</code> <p>Number of vertices along the Y axis. Must be &gt;= 2. Default is 3.</p> <code>3</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the grid. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the rectangular grid.</p> Notes <ul> <li>The grid is created with <code>'ij'</code> indexing, so coordinates follow NumPy's <code>meshgrid(..., indexing='ij')</code> convention.</li> <li>UV coordinates are generated using <code>grid_uv_map</code>.</li> <li>The grid topology is built using <code>grid_corners</code>.</li> </ul> <p>Examples:</p> <p>Create a 2x2 grid with 10 vertices along X and 5 along Y:</p> <pre><code>grid = Mesh.grid(size_x=2, size_y=2, vertices_x=10, vertices_y=5)\n</code></pre> <p>Create a square grid of size 5 with default vertex count:</p> <pre><code>grid = Mesh.grid(size_x=5, size_y=5)\n</code></pre> See Also <p><code>grid_corners</code> :     Helper for constructing the corner topology of the grid. <code>grid_uv_map</code> :     Generates UV coordinates for a regular grid.</p> <p>Important: The grid is always created with <code>'ij'</code> indexing (shape = <code>(vertices_x, vertices_y)</code>).</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.icosphere","title":"icosphere  <code>classmethod</code>","text":"<pre><code>icosphere(radius=1, subdivisions=2, materials=None)\n</code></pre> <p>Create an icosphere mesh.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the icosphere. Default is 1.</p> <code>1</code> <code>subdivisions</code> <code>int</code> <p>Number of recursive subdivisions applied to the base icosahedron. Higher values yield smoother spheres. Clamped to a maximum of 10. Default is 2.</p> <code>2</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the icosphere. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the icosphere.</p> Notes <ul> <li>The icosphere is created using <code>bmesh.ops.create_icosphere</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> <li>Unlike a UV sphere, an icosphere has more uniform vertex distribution, making it suitable for certain simulation and subdivision tasks.</li> <li>Subdivisions are internally capped at 10 for performance reasons.</li> </ul> <p>Examples:</p> <p>Create a default icosphere of radius 1 with 2 subdivisions:</p> <pre><code>ico = Mesh.icosphere()\n</code></pre> <p>Create a larger icosphere with 4 subdivisions:</p> <pre><code>ico = Mesh.icosphere(radius=3, subdivisions=4)\n</code></pre> See Also <p><code>uvsphere</code> :     Sphere primitive based on UV parameterization. <code>bmesh.ops.create_icosphere</code> :     BMesh operator used for creating icospheres.</p> <p>Note: Use <code>uvsphere</code> when you require consistent UV mapping, and <code>icosphere</code> for uniform tessellation.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.inset_faces","title":"inset_faces","text":"<pre><code>inset_faces(selection, thickness=0.1, depth=0.0, use_even_offset=True, use_relative_offset=False)\n</code></pre> <p>Inset selected faces individually, optionally adding depth (local extrusion).</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Indices (or mask) of faces to inset. If <code>None</code>, all faces are used.</p> required <code>thickness</code> <code>float</code> <p>Inset thickness applied per face. Default is 0.1.</p> <code>0.1</code> <code>depth</code> <code>float</code> <p>Local extrusion depth along each face normal. Default is 0.0.</p> <code>0.0</code> <code>use_even_offset</code> <code>bool</code> <p>Keep thickness consistent across faces (even offset). Default is True.</p> <code>True</code> <code>use_relative_offset</code> <code>bool</code> <p>Scale thickness relative to face size. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with: - <code>'top'</code>: indices of the original (selected) faces. - <code>'side'</code>: indices of the new faces created by the inset operation (typically the rim/side faces around each inset).</p> Notes <ul> <li>Implementation uses <code>bmesh.ops.inset_individual</code>.</li> <li>The <code>'top'</code> entry mirrors the input selection; <code>'side'</code> comes from <code>d[\"faces\"]</code> returned by the BMesh operator.</li> </ul> <p>Examples:</p> <p>Inset a set of faces with even offset:</p> <pre><code>res = Mesh.inset_faces(selection=[0, 2, 5], thickness=0.05, depth=0.0)\n</code></pre> <p>Inset all faces with relative offset and a small depth:</p> <pre><code>res = Mesh.inset_faces(selection=None, thickness=0.02,\n                    depth=0.01, use_relative_offset=True)\n</code></pre> See Also <p><code>extrude_faces</code> :     Extrude faces discretely instead of insetting. <code>extrude_region</code> :     Extrude connected face regions.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.join","title":"join","text":"<pre><code>join(*others)\n</code></pre> <p>Join other Mesh instances into this mesh.</p> <p>This method appends the geometry and materials of the given meshes to the current mesh, updating indices to maintain consistency.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Mesh</code> <p>One or more Mesh instances to be joined with the current mesh.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>self</code> <code>Mesh</code> <p>The updated mesh instance with joined geometry.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other, **kwargs)\n</code></pre> <p>Merge attribute schemas from another geometry.</p> <p>For each domain listed in <code>self.domain_names</code> and also present in <code>other</code>, copies (joins) the attribute definitions (names, dtypes, metadata) from <code>other</code> into this geometry's domains. Use keyword flags to include/exclude domains by name (e.g., <code>faces=False</code>).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Geometry or None</code> <p>Source geometry. If <code>None</code>, does nothing and returns <code>self</code>.</p> required <code>**kwargs</code> <p>Per-domain boolean switches to filter which domains to join.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>, for chaining.</p> <p>Examples:</p> <pre><code>mesh.join_attributes(other_mesh, faces=False)\ncurve.join_attributes(mesh)  # only common domains are merged\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.join_geometry","title":"join_geometry","text":"<pre><code>join_geometry(points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs)\n</code></pre> <p>Join geometry defined by components into the current mesh.</p> <p>This method creates a new independent mesh from the provided geometry components (points, corners, faces, edges) which do not refer to existing vertices. The new mesh is then joined to the current mesh instance.</p> <p>To add geometry using existing vertices, see <code>Mesh.add_geometry</code>.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>iterable</code> <p>Iterable of points (vertices) to add to the mesh.</p> <code>None</code> <code>corners</code> <code>iterable</code> <p>Iterable of corner indices defining the mesh topology.</p> <code>None</code> <code>faces</code> <code>iterable</code> <p>Iterable of faces defined by indices of corners.</p> <code>None</code> <code>edges</code> <code>iterable</code> <p>Iterable of edges defined by indices of vertices.</p> <code>None</code> <code>safe_mode</code> <code>bool</code> <p>Flag to enable safe mode operations (currently unused).</p> <code>False</code> <code>**attrs</code> <code>dict</code> <p>Additional attributes to be passed to the geometry addition.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>self</code> <code>Mesh</code> <p>The current mesh instance with the new geometry joined.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.line","title":"line  <code>classmethod</code>","text":"<pre><code>line(start=(0, 0, 0), end=(0, 0, 1), segments=1, materials=None)\n</code></pre> <p>Create a mesh representing a straight line (or multiple lines) subdivided into segments.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>array-like of float, shape (..., 3)</code> <p>Coordinates of the start point(s). Can be a single 3D vector or an array of multiple vectors. Default is (0, 0, 0).</p> <code>(0, 0, 0)</code> <code>end</code> <code>array-like of float, shape (..., 3)</code> <p>Coordinates of the end point(s). Can be a single 3D vector or an array of multiple vectors with the same shape as <code>start</code>. Default is (0, 0, 1).</p> <code>(0, 0, 1)</code> <code>segments</code> <code>int</code> <p>Number of line segments (subdivisions) between each pair of start and end points. Must be &gt;= 1. Default is 1.</p> <code>1</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the line mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the subdivided line(s).</p> Notes <ul> <li>The function interpolates <code>segments + 1</code> points between <code>start</code> and <code>end</code> using <code>np.linspace</code>.</li> <li>If <code>start</code> and <code>end</code> are arrays of shape <code>(N, 3)</code>, the method generates <code>N</code> independent polylines, each subdivided into <code>segments</code>.</li> <li>For higher-dimensional batched input, the function reshapes the grid and constructs edges using <code>col_edges</code>.</li> </ul> <p>Examples:</p> <p>Create a simple line with 5 segments between (0, 0, 0) and (0, 0, 1):</p> <pre><code>line = Mesh.line(start=(0, 0, 0), end=(0, 0, 1), segments=5)\n</code></pre> <p>Create three parallel lines defined by arrays of start and end points:</p> <pre><code>starts = np.array([[0, 0, 0],\n                [1, 0, 0],\n                [2, 0, 0]])\nends = np.array([[0, 0, 1],\n                [1, 0, 1],\n                [2, 0, 1]])\nlines = Mesh.line(start=starts, end=ends, segments=4)\n</code></pre> See Also <p><code>border_edges</code> :     Helper for constructing consecutive edges in a single polyline. <code>col_edges</code> :     Helper for constructing edges in multi-dimensional point grids.</p> <p>Note: The line mesh consists only of vertices and edges, no faces are created.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.load_models","title":"load_models  <code>staticmethod</code>","text":"<pre><code>load_models(*specs)\n</code></pre> <p>Load multiple geometries from collections, objects, or instances.</p> <p>Accepts mixed inputs such as Blender collections, Blender objects, lists/ tuples of either, or already-instantiated <code>Mesh</code>/<code>Curve</code>. Returns a flat list of geometries discovered or constructed.</p> <p>This method is mainly intended to be used by <code>Instances</code> to load its models.</p> <p>Parameters:</p> Name Type Description Default <code>*specs</code> <p>Collections, objects, lists/tuples, or <code>Mesh</code>/<code>Curve</code> instances.</p> <code>()</code> <p>Returns:</p> Type Description <code>list</code> <p>List of geometries (<code>Mesh</code>/<code>Curve</code>).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a spec cannot be resolved to a geometry.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.load_object","title":"load_object  <code>staticmethod</code>","text":"<pre><code>load_object(name)\n</code></pre> <p>Load a Blender object and return a <code>Mesh</code> or a <code>Curve</code>.</p> <p>Resolves <code>name</code> to a Blender object, inspects its data type, and returns a matching geometry by calling the subclass' <code>from_object</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or Object</code> <p>Object name or object instance.</p> required <p>Returns:</p> Type Description <code>Mesh or Curve or None</code> <p>A <code>Mesh</code> or a <code>Curve</code>, or <code>None</code> if the object is not found.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the object exists but is neither a <code>bpy.types.Mesh</code> nor <code>bpy.types.Curve</code>.</p> <p>Examples:</p> <pre><code>geo = Geometry.load_object(\"MyObject\")\nif geo is not None:\n    print(type(geo).__name__)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.monkey","title":"monkey  <code>classmethod</code>","text":"<pre><code>monkey(materials=None)\n</code></pre> <p>Create the famous Blender \"Suzanne\" monkey mesh.</p> <p>Parameters:</p> Name Type Description Default <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the Suzanne primitive.</p> Notes <ul> <li>The monkey head is created using <code>bmesh.ops.create_monkey</code>.</li> <li>Suzanne is often used as a test model and is considered Blender\u2019s mascot.</li> </ul> <p>Examples:</p> <p>Create a Suzanne mesh:</p> <pre><code>monkey = Mesh.monkey()\n</code></pre> See Also <p><code>bmesh.ops.create_monkey</code> :     BMesh operator used to generate the Suzanne primitive.</p> <p>Note: Suzanne is widely used as a benchmark and test object in Blender.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.multiply","title":"multiply","text":"<pre><code>multiply(count, in_place=True)\n</code></pre> <p>Duplicate the geometry.</p> <p>Multiplying is a way to efficiently duplicate the geometry a great number of times. Once duplicated, the vertices can be reshapped to address each instance individually.</p> <pre><code>count = 16\n\ncube = Mesh.Cube() * count\n\n# Shape the points as 16 blocks of 8 vertices\npoints = np.reshape(cube.points.position, (16, 8, 3))\n\n# Place the cubes in a circle\nags = np.linspace(0, 2*np.pi, count, endpoint=False)\npoints[..., 0] += 6 * np.cos(ags)[:, None]\npoints[..., 1] += 6 * np.sin(ags)[:, None]\n\ncube.to_object(\"Cubes\")\n</code></pre> Arguments <pre><code>- count (int=10) : number of instances\n- attributes (name=value) : value for named attributes\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/mesh/#npblender.mesh.Mesh.object","title":"object","text":"<pre><code>object(index=0, readonly=True, **kwargs)\n</code></pre> <p>Temporary access to a Blender Object built from this geometry.</p> <p>Creates a transient object (named <code>\"BPBL Temp {index}\"</code> unless <code>index</code> is a string), selects and activates it, yields it for editing, then cleans up. If <code>readonly=True</code>, the edited object is captured back into <code>self</code>.</p> <p>This method can be used to set and apply a modifier (see exemple below).</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int or str</code> <p>Index or name used to label the temporary object.</p> <code>0</code> <code>readonly</code> <code>bool</code> <p>If <code>False</code>, re-capture the possibly edited object back into this geometry.</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>Keyword arguments passed to <code>self.to_object</code>.</p> <code>{}</code> <p>Yields:</p> Type Description <code>Object</code> <p>The temporary Blender object built from <code>self</code>.</p> <p>Examples:</p> <pre><code>plane = Mesh.Grid()\nwith plane.object(readonly=False) as obj:\n    mod = obj.modifiers.new(\"Solidify\", 'SOLIDIFY')\n    mod.thickness = .1\n    bpy.ops.object.modifier_apply(modifier=mod.name)\n\n# plane is now solidifed\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.points_cloud","title":"points_cloud  <code>classmethod</code>","text":"<pre><code>points_cloud(points=None, materials=None)\n</code></pre> <p>Create a mesh containing only points at the given positions.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like of shape (N, 3)</code> <p>Coordinates of the points. If None, an empty mesh is created.</p> <code>None</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the given points.</p> Notes <ul> <li>This method does not create any edges or faces, only isolated points.</li> </ul> <p>Examples:</p> <p>Create a point cloud with three points:</p> <pre><code>pts = np.array([[0, 0, 0],\n                [1, 0, 0],\n                [0, 1, 0]])\ncloud = Mesh.points_cloud(points=pts)\n</code></pre> See Also <p><code>Mesh</code> :     The mesh class used to construct and manage geometry.</p> <p>Note: This constructor is useful for importing raw point data or initializing a mesh before adding edges and faces.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.pyramid","title":"pyramid  <code>classmethod</code>","text":"<pre><code>pyramid(size=1, materials=None)\n</code></pre> <p>Create a pyramid mesh.</p> <p>The pyramid is generated as a cone with 3 vertices at the base (a triangle) and an apex at the top.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>float</code> <p>Size of the pyramid. Determines both the base dimensions and the height. Default is 1.</p> <code>1</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the pyramid.</p> Notes <ul> <li>The base radius is scaled by <code>size * sqrt(3)/2</code> so that the pyramid has approximately unit proportions when <code>size=1</code>.</li> <li>Internally calls <code>cone</code> with <code>vertices=3</code>.</li> </ul> <p>Examples:</p> <p>Create a default pyramid of size 1:</p> <pre><code>pyramid = Mesh.pyramid()\n</code></pre> <p>Create a larger pyramid of size 5:</p> <pre><code>pyramid = Mesh.pyramid(size=5)\n</code></pre> See Also <p><code>cone</code> :     Generalized method for cones and pyramids. <code>bl_cone</code> :     Low-level constructor for cone-based primitives.</p> <p>Note: This method is equivalent to creating a triangular-based cone.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.remove_doubles","title":"remove_doubles","text":"<pre><code>remove_doubles(dist=0.001)\n</code></pre> <p>Merge duplicate vertices within a distance threshold.</p> <p>Parameters:</p> Name Type Description Default <code>dist</code> <code>float</code> <p>Maximum distance between vertices to be merged. Default is 0.001.</p> <code>0.001</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>The current mesh instance (<code>self</code>) with duplicate vertices removed.</p> Notes <ul> <li>Internally uses <code>bmesh.ops.remove_doubles</code>.</li> <li>All vertices in the mesh are considered for merging.</li> <li>Useful for cleaning geometry after operations that may generate coincident vertices (e.g., mirroring, joining, or extrusion).</li> </ul> <p>Examples:</p> <p>Remove doubles with default threshold:</p> <pre><code>mesh.remove_doubles()\n</code></pre> <p>Remove doubles with a larger threshold:</p> <pre><code>mesh.remove_doubles(dist=0.01)\n</code></pre> <p>Note: This method modifies the mesh in place and returns <code>self</code> for chaining.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.rotate","title":"rotate","text":"<pre><code>rotate(rotation, pivot=None)\n</code></pre> <p>Rotate points (convenience wrapper).</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>ndarray or Rotation - like</code> <p>Rotation(s) to apply as <code>R @ v</code>.</p> required <code>pivot</code> <code>ndarray</code> <p>Optional pivot(s) for rotation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.separate_faces","title":"separate_faces","text":"<pre><code>separate_faces(groups=None)\n</code></pre> <p>Split faces into isolated islands, either one per face or grouped by provided IDs.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>array-like of int, shape (n_faces,)</code> <p>Group IDs for each face. If <code>None</code>, each face is isolated as its own island. If provided, must be the same length as the number of faces.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh where faces are separated into independent islands with duplicated vertices.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>groups</code> is provided but its shape does not match <code>(n_faces,)</code>.</p> Notes <ul> <li>When <code>groups</code> is <code>None</code>, the output mesh has one disconnected island per face.</li> <li>When grouping, faces sharing the same group ID are kept together in the same island, with vertices duplicated so that each group is independent.</li> <li>Face attributes are preserved except for <code>'loop_total'</code> and <code>'loop_start'</code>.</li> </ul> <p>Examples:</p> <p>Separate every face:</p> <pre><code>islands = mesh.separate_faces()\n</code></pre> <p>Separate faces into two groups:</p> <pre><code>groups = np.array([0, 0, 1, 1, 1, 0])  # one group ID per face\nsplit = mesh.separate_faces(groups=groups)\n</code></pre> See Also <p><code>join_geometry</code> :     Utility to assemble new meshes from points, corners, faces, and attributes. <code>join</code> :     Used internally to accumulate separated islands.</p> <p>Caution: The number of groups must equal the number of faces in the mesh, otherwise a <code>ValueError</code> is raised.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.simplified","title":"simplified","text":"<pre><code>simplified(scale, dist=0.001)\n</code></pre> <p>Return a simplified copy of the mesh by merging close vertices, with a fallback to a cubic envelope if the result is too small.</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>float</code> <p>Scale factor applied to the distance threshold.</p> required <code>dist</code> <code>float</code> <p>Base merge distance for vertices. The effective threshold is <code>dist / scale</code>. Default is 0.001.</p> <code>0.001</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A simplified copy of the mesh. If the simplification produces fewer than 8 vertices, returns a cubic envelope instead.</p> Notes <ul> <li>The copy is created with <code>Mesh.from_mesh</code>.</li> <li>Duplicate vertices are merged with <code>remove_doubles</code>.</li> <li>If too few vertices remain, a fallback is generated using <code>get_cubic_envelop</code>.</li> </ul> <p>Examples:</p> <p>Simplify a mesh with scale factor 10:</p> <pre><code>simp = mesh.simplified(scale=10, dist=0.002)\n</code></pre> See Also <p><code>remove_doubles</code> :     Merges vertices within a distance threshold. <code>get_cubic_envelop</code> :     Provides a fallback cubic mesh when simplification collapses geometry.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.solidify","title":"solidify","text":"<pre><code>solidify(thickness=0.01, offset=-1)\n</code></pre> <p>Apply a Solidify modifier to give thickness to a surface mesh.</p> <p>Parameters:</p> Name Type Description Default <code>thickness</code> <code>float</code> <p>Thickness of the shell to generate. Positive values expand outward, negative values inward. Default is 0.01.</p> <code>0.01</code> <code>offset</code> <code>float</code> <p>Offset factor determining the solidification direction relative to the original surface: -1 \u2192 inward, 0 \u2192 centered, +1 \u2192 outward. Default is -1.</p> <code>-1</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance resulting from the solidify operation.</p> Notes <ul> <li>Internally creates a Blender Solidify modifier with <code>use_even_offset=True</code> for consistent thickness.</li> <li>The modifier is applied destructively via <code>bpy.ops.object.modifier_apply</code>, and the resulting mesh is retrieved with <code>Mesh.from_object</code>.</li> <li>Works best on manifold surfaces (open meshes may produce artifacts).</li> </ul> <p>Examples:</p> <p>Solidify a circular glass mesh:</p> <pre><code>glass = Mesh.circle(segments=128)\nglass.extrude_faces(0, -0.01)\nglass.extrude_faces(0, -2)\nglass.extrude_faces(0, -0.01)\nglass.points.translate((0, 0, 2))\n\nglass = glass.solidify(thickness=0.1)\nglass.to_object(\"Solidify\", shade_smooth=True)\n</code></pre> See Also <p><code>Mesh.from_object</code> :     Converts a Blender object back into a mesh wrapper. <code>object</code> :     Context manager yielding a temporary Blender object.</p> <p>Caution: Applying the modifier is destructive to the underlying Blender object; the method returns a new mesh instance of the result.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.solidify_socle","title":"solidify_socle","text":"<pre><code>solidify_socle(shape, z=0, bottom_material_index=0)\n</code></pre> <p>Build a solid base (\u201csocle\u201d) by extruding the outer boundary of a grid mesh down (or up) to a given Z level, then bridging the side wall.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple of int</code> <p>Grid shape <code>(nx, ny)</code> of the mesh topology (using <code>'ij'</code> indexing).</p> required <code>z</code> <code>float</code> <p>Target Z coordinate for the base ring (the new bottom boundary). Default is 0.</p> <code>0</code> <code>bottom_material_index</code> <code>int</code> <p>Material index assigned to the bottom face created by the operation. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>Modifies the mesh in place. Returns <code>None</code>. The bottom face indices produced by <code>add_geometry</code> are stored internally and their <code>material_index</code> is set to <code>bottom_material_index</code>.</p> Notes <ul> <li>The outer boundary loop is derived from the provided grid <code>shape</code> assuming a regular lattice of <code>nx * ny</code> points laid out with NumPy\u2019s <code>'ij'</code> indexing.</li> <li>A new ring of points is created at Z = <code>z</code> via <code>add_points</code>.</li> <li>The vertical side wall is created by bridging loops with <code>bridge_loops</code> using <code>close=True</code>.</li> <li>The bottom face material is assigned by ensuring and editing the optional <code>material_index</code> field on <code>self.faces</code>.</li> </ul> <p>Examples:</p> <p>Solidify a 20\u00d730 grid down to Z = -0.1 with material index 2:</p> <pre><code>Mesh.solidify_socle(shape=(20, 30), z=-0.1, bottom_material_index=2)\n</code></pre> See Also <p><code>add_points</code> :     Adds the new base ring vertices at Z = <code>z</code>. <code>add_geometry</code> :     Creates the bottom polygon from the added ring. <code>bridge_loops</code> :     Connects the side wall between original and new boundary loops.</p> <p>Caution: This method assumes the mesh vertices correspond to a regular <code>(nx, ny)</code> grid ordered consistently with <code>'ij'</code> indexing; inconsistent layouts will produce incorrect boundaries.</p> <p>Note: The function does not return the created face indices; it sets their <code>material_index</code> internally based on <code>bottom_material_index</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.split_edges","title":"split_edges","text":"<pre><code>split_edges(loop0, loop1, cuts=1)\n</code></pre> <p>Subdivide in place the edges whose endpoints match the pairs (loop0[i], loop1[i]) regardless of order (edges are treated as undirected).</p> <p>The inputs <code>loop0</code> and <code>loop1</code> can be: - scalars (a single vertex index), - sequences of the same length, - or a mix of both (a scalar is broadcast to match the length of the other).</p> <p>The vertex pairs are normalized by sorting (min, max) so that order does not matter, and then compared against the BMesh edge list to determine which edges should be subdivided.</p> <p>Parameters:</p> Name Type Description Default <code>loop0</code> <code>int or array-like of int</code> <p>First vertex (or list of vertices) of the edges to be selected. If scalar, it will be broadcast to the length of <code>loop1</code> if needed.</p> required <code>loop1</code> <code>int or array-like of int</code> <p>Second vertex (or list of vertices) of the edges to be selected. If scalar, it will be broadcast to the length of <code>loop0</code> if needed.</p> required <code>cuts</code> <code>int</code> <p>Number of cuts per selected edge, as defined by <code>bmesh.ops.subdivide_edges</code>. Default is <code>1</code>. Must be &gt;= 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>None</code> <p>Modifies the geometry in place. Returns <code>None</code>. If no edge matches the given pairs, the function returns immediately without modifying the mesh.</p> Notes <ul> <li>Edge selection is performed by constructing an array of sorted vertex pairs <code>(min(v0, v1), max(v0, v1))</code> and checking membership (via <code>np.isin</code> on a structured dtype view) against the BMesh edge list.</li> <li>Subdivision is executed with <code>bmesh.ops.subdivide_edges</code> and <code>use_grid_fill=False</code>.</li> </ul> <p>Examples:</p> <p>Subdivide a single edge (vertices 12 and 34) with 2 cuts:</p> <pre><code>obj = ...  # wrapper object providing .bmesh() and ._bm_edges(...)\nobj.split_edges(12, 34, cuts=2)\n</code></pre> <p>Subdivide multiple edges defined by pairs of vertices:</p> <pre><code>v0 = [1, 5, 9]\nv1 = [2, 6, 10]\nobj.split_edges(v0, v1, cuts=1)\n</code></pre> <p>Use a scalar broadcast against a vector:</p> <pre><code># All edges (7, x) for x in [8, 9, 10]\nobj.split_edges(7, [8, 9, 10], cuts=1)\n</code></pre> See Also <p>bmesh.ops.subdivide_edges : The underlying BMesh operator used for subdivision.</p> <p>Warning: This operation modifies the mesh in place and may create new vertices/edges/faces. Handle undo/history in Blender if needed.</p> <p>Caution: <code>use_grid_fill=False</code> prevents automatic grid filling. Depending on topology, additional n-gons or triangles may be introduced.</p> <p>Note: Edges are considered undirected: (a, b) and (b, a) are equivalent when matching edges.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_curve_REVIEW","title":"to_curve_REVIEW","text":"<pre><code>to_curve_REVIEW()\n</code></pre> <p>Convert mesh to curve</p> <p>Simple conversion when edges domain is defined</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize the Mesh object to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the serialized data of the mesh, including: - 'geometry': The type of geometry (always 'Mesh'). - 'materials': List of material names. - 'points': Serialized points data. - 'corners': Serialized corners data. - 'faces': Serialized faces data. - 'edges': Serialized edges data.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_mesh_data","title":"to_mesh_data","text":"<pre><code>to_mesh_data(data)\n</code></pre> <p>Write the geometry data from this mesh into a Blender Mesh instance.</p> <p>This method transfers the mesh's vertices, edges, faces, corners, materials, and custom attributes into the provided Blender Mesh data structure.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Blender Mesh instance</code> <p>The Blender Mesh object to which the geometry will be written.</p> required <p>Returns:</p> Type Description <code>None</code> Side Effects <p>Modifies the provided Blender Mesh instance by clearing its current geometry and populating it with the data from this mesh. Updates the mesh to reflect the changes.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_object","title":"to_object","text":"<pre><code>to_object(obj, shade_smooth=None, shapekeys=None, collection=None)\n</code></pre> <p>Create or update a Blender mesh object from this mesh data.</p> <p>This method creates a new Blender mesh object if it does not already exist, or updates the existing object's mesh data. It does not perform object type conversion; the existing object must be a mesh.</p> <p>After the object is created or updated, use 'update_object' to modify vertices.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str or Object</code> <p>The Blender object or its name to create or update.</p> required <code>shade_smooth</code> <code>bool or None</code> <p>If specified, sets the shading mode of the mesh polygons to smooth or flat.</p> <code>None</code> <code>shapekeys</code> <code>ShapeKeys or iterable of ShapeKeys</code> <p>Shape keys to apply to the mesh object.</p> <code>None</code> <code>collection</code> <code>Collection or None</code> <p>The collection to which the object should be linked.</p> <code>None</code> <p>Returns:</p> Type Description <code>Object</code> <p>The created or updated Blender mesh object.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.torus","title":"torus  <code>classmethod</code>","text":"<pre><code>torus(major_segments=48, minor_segments=12, major_radius=1.0, minor_radius=0.25, materials=None)\n</code></pre> <p>Create a torus mesh.</p> <p>Parameters:</p> Name Type Description Default <code>major_segments</code> <code>int</code> <p>Number of segments around the major (outer) radius. Default is 48.</p> <code>48</code> <code>minor_segments</code> <code>int</code> <p>Number of segments around the minor (inner) radius (the cross-section). Default is 12.</p> <code>12</code> <code>major_radius</code> <code>float</code> <p>The distance from the center of the torus to the center of the tube. Default is 1.</p> <code>1.0</code> <code>minor_radius</code> <code>float</code> <p>The radius of the tube itself. Default is 0.25.</p> <code>0.25</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the torus. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the torus.</p> Notes <ul> <li>The torus is constructed by sweeping a circle of radius <code>minor_radius</code> around a larger circle of radius <code>major_radius</code>.</li> <li>The transformation of the cross-section is handled by <code>Transformation</code> and <code>Rotation</code>.</li> <li>UV coordinates are generated using <code>grid_uv_map</code>, resulting in a square parameterization.</li> <li>Topology is constructed with <code>grid_corners</code> with both axes closed.</li> </ul> <p>Examples:</p> <p>Create a standard torus:</p> <pre><code>torus = Mesh.torus()\n</code></pre> <p>Create a torus with a larger tube and finer resolution:</p> <pre><code>torus = Mesh.torus(major_segments=64, minor_segments=32,\n                major_radius=2, minor_radius=0.5)\n</code></pre> See Also <p><code>grid_corners</code> :     Helper for constructing the corner topology of the torus grid. <code>grid_uv_map</code> :     Generates UV coordinates for grid-like surfaces. <code>Transformation</code> :     Used to position and orient the swept circle. <code>Rotation</code> :     Used to orient the minor circle along the sweep path.</p> <p>Note: UV coordinates are generated with an offset of \u03c0 to match Blender's default torus orientation.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.transform","title":"transform","text":"<pre><code>transform(transformation)\n</code></pre> <p>Apply a rotation matrix or batch of matrices.</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>transformation</code> <code>ndarray</code> <p>Rotation matrix or batch of rotation matrices.</p> required <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.transformation","title":"transformation","text":"<pre><code>transformation(rotation=None, scale=None, translation=None, pivot=None)\n</code></pre> <p>Apply rotation/scale/translation (with optional per-packet broadcasting).</p> <p>Operates in-place on <code>points.position</code> and, when present, Bezier handles (<code>points.handle_left</code>, <code>points.handle_right</code>). Shapes can represent packets of points: broadcasting rules are handled by <code>Point._get_shape_for_operation</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>ndarray or Rotation - like</code> <p>Rotation matrix/matrices applied as <code>R @ v</code>. Shape may broadcast over points (see notes).</p> <code>None</code> <code>scale</code> <code>ndarray</code> <p>Per-axis scaling. Shape may broadcast over points.</p> <code>None</code> <code>translation</code> <code>ndarray</code> <p>Per-point translation. Shape may broadcast over points.</p> <code>None</code> <code>pivot</code> <code>ndarray</code> <p>Pivot(s) subtracted before, and added after, the rotation/scale; same broadcasting rules as <code>scale</code>/<code>translation</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>, for chaining.</p> Notes <ul> <li>If handles exist, they are transformed consistently with positions.</li> </ul> <p>Examples:</p> <pre><code># 12 cubes laid out randomly with per-instance transforms\ncubes = Mesh.cube(size=1).multiply(12)\nT = np.random.uniform(-1, 1, (12, 3))\nS = np.random.uniform(0.5, 2.0, (12, 3))\nR = Rotation.from_euler(np.random.uniform(0, 2*np.pi, (12, 3)))\ncubes.transformation(rotation=R, scale=S, translation=T)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.translate","title":"translate","text":"<pre><code>translate(translation)\n</code></pre> <p>Translate points (convenience wrapper).</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>ndarray</code> <p>Per-point or broadcastable translation vectors.</p> required <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.triangulate","title":"triangulate","text":"<pre><code>triangulate(selection=None)\n</code></pre> <p>Triangulate selected faces (or all faces) and return a new mesh.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Indices (or mask) of faces to triangulate. If <code>None</code>, all faces are triangulated. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh or None</code> <p>A new mesh instance with the selected faces triangulated. Returns <code>None</code> if no faces were selected.</p> Notes <ul> <li>Creates a copy of the current mesh with <code>Mesh.from_mesh</code>.</li> <li>Triangulation is applied in-place on the copy via <code>bmesh.ops.triangulate</code>.</li> <li>The original mesh is left unchanged.</li> </ul> <p>Examples:</p> <p>Triangulate all faces:</p> <pre><code>tri_mesh = mesh.triangulate()\n</code></pre> <p>Triangulate only a subset:</p> <pre><code>tri_mesh = mesh.triangulate(selection=[0, 5, 7])\n</code></pre> See Also <p><code>Mesh.from_mesh</code> :     Utility to duplicate the mesh before applying triangulation.</p> <p>Note: If <code>selection</code> is empty, the method returns <code>None</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.uvsphere","title":"uvsphere  <code>classmethod</code>","text":"<pre><code>uvsphere(segments=32, rings=16, radius=1, materials=None)\n</code></pre> <p>Create a UV sphere mesh.</p> <p>Parameters:</p> Name Type Description Default <code>segments</code> <code>int</code> <p>Number of longitudinal segments (meridians). Default is 32.</p> <code>32</code> <code>rings</code> <code>int</code> <p>Number of latitudinal rings (parallels). Default is 16.</p> <code>16</code> <code>radius</code> <code>float</code> <p>Radius of the sphere. Default is 1.</p> <code>1</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the sphere. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the UV sphere.</p> Notes <ul> <li>The sphere is created using <code>bmesh.ops.create_uvsphere</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> <li>The geometry is distributed evenly in the UV parameterization, which means denser vertices near the poles.</li> </ul> <p>Examples:</p> <p>Create a default UV sphere of radius 1:</p> <pre><code>sphere = Mesh.uvsphere()\n</code></pre> <p>Create a high-resolution sphere:</p> <pre><code>sphere = Mesh.uvsphere(segments=64, rings=32, radius=2)\n</code></pre> See Also <p><code>icosphere</code> :     Alternative sphere primitive with more uniform vertex distribution. <code>bmesh.ops.create_uvsphere</code> :     BMesh operator used for creating UV spheres.</p> <p>Note: Use <code>icosphere</code> if you need a more uniform tessellation without poles.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.vectors_field","title":"vectors_field  <code>classmethod</code>","text":"<pre><code>vectors_field(locations, vectors, radius=0.05, scale_length=1.0, angle=24.0, segments=8, head=None, adjust_norm=None, materials=None)\n</code></pre> <p>Create an arrow at each <code>location</code> oriented and scaled by the corresponding <code>vector</code>.</p> <p>Each arrow consists of a cylindrical shaft and a conical head aligned with the vector direction. Arrow length is derived from the vector norm, optionally transformed by <code>adjust_norm</code>. For very short vectors, the arrow is scaled down to preserve proportions.</p> <p>Parameters:</p> Name Type Description Default <code>locations</code> <code>array-like of shape (N, 3)</code> <p>Positions where arrows are placed.</p> required <code>vectors</code> <code>array-like of shape (N, 3)</code> <p>Direction (and base length) of each arrow. Must match the length of <code>locations</code>.</p> required <code>radius</code> <code>float</code> <p>Shaft radius for the arrows. Default is 0.05.</p> <code>0.05</code> <code>scale_length</code> <code>float</code> <p>Length threshold below which arrows are uniformly scaled down (radius and shaft) while keeping proportions. Default is 1.0.</p> <code>1.0</code> <code>angle</code> <code>float</code> <p>Opening angle (in degrees) of the conical head. Default is 24.</p> <code>24.0</code> <code>segments</code> <code>int</code> <p>Number of radial segments for both shaft and head. Default is 8.</p> <code>8</code> <code>head</code> <code>Mesh or None</code> <p>Optional mesh to use as the arrow head. If <code>None</code>, a cone is created. When provided, its Z size defines the head height.</p> <code>None</code> <code>adjust_norm</code> <code>(callable, float, None)</code> <p>Controls how vector norms are mapped to arrow lengths: - callable: applied to the array of norms. - float: acts as a maximum length (clamp). - None: use the raw norms. Default is None.</p> <code>callable</code> <code>materials</code> <code>list of str</code> <p>Material names to assign to created geometry. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A mesh containing all arrows.</p> Notes <ul> <li>The head radius is <code>3 * radius</code>; its height is derived from <code>angle</code> via <code>head_height = head_radius / tan(angle)</code>.</li> <li>Arrows with very small vectors are handled specially to avoid degenerate geometry (a minimum total length of approximately <code>2 * head_height</code> is enforced).</li> <li>Alignment is achieved with <code>Rotation.look_at</code>.</li> <li>The shaft is built from <code>cylinder</code>, and the head from <code>cone</code> (when <code>head is None</code>).</li> </ul> <p>Examples:</p> <p>Create a field of unit arrows from a grid:</p> <pre><code>P = np.stack(np.meshgrid(np.linspace(-1, 1, 5),\n                        np.linspace(-1, 1, 5),\n                        [0.0], indexing='ij'), axis=-1).reshape(-1, 3)\nV = np.tile(np.array([0, 0, 1.0]), (len(P), 1))\nfield = Mesh.vectors_field(P, V, radius=0.03, segments=12)\n</code></pre> <p>Clamp arrow lengths to 2 units:</p> <pre><code>field = Mesh.vectors_field(P, V * 5.0, adjust_norm=2.0)\n</code></pre> <p>Map norms nonlinearly (e.g., sqrt):</p> <pre><code>field = Mesh.vectors_field(P, V, adjust_norm=np.sqrt)\n</code></pre> See Also <p><code>arrow</code> :     Convenience method to create a single arrow. <code>cylinder</code> :     Used to create the arrow shafts. <code>cone</code> :     Used to create the arrow heads (when <code>head is None</code>). <code>Rotation.look_at</code> :     Used to orient arrows along their vectors.</p> <p>Caution: <code>locations</code> and <code>vectors</code> must have the same length (N). Mismatched inputs will lead to incorrect alignment or runtime errors.</p> <p>Note: Zero-length vectors are handled safely; corresponding arrows collapse to length 0 and are effectively omitted.</p>"},{"location":"api/meshes/","title":"Meshes","text":""},{"location":"api/meshes/#npblender.instances.Meshes","title":"Meshes","text":"<pre><code>Meshes(mesh=None, mesh_id=None, attr_from=None, **attributes)\n</code></pre> <p>               Bases: <code>Geometry</code></p> <p>Bucketed mesh instances.</p> <p><code>Meshes</code> looks like <code>instances</code>, the difference being the each instance is different: - <code>Instances</code> : each point instance points on a model with <code>model_index</code> - <code>Meshes</code> : each point refers to vertices within <code>Mesh.mesh</code> attributes</p> <p>To allow handling the individual pieces in with vectorization, the pieces are groupded in buckets of the same size (same number of vertices).</p> <p>It is possible to iterate on pieces sharing the same size:</p> <pre><code>for bucket, offset in meshes:\n    # bucket is an array (npieces, nverts) of vertex indices in `meshes.mesh.points`\n    # offset is the first point index in `meshes.points`\n    # meshes.points[offset:offset + bucket.shape[0]] represent all the bucket pieces\n    pass\n</code></pre> <p>Attributes:</p> Name Type Description <code>mesh</code> <code>[Mesh][Mesh]</code> <p>The source mesh containing all vertices (possibly many concatenated copies).</p> <code>points</code> <code>[Point][Point]</code> <p>Per-piece attributes. At least <code>position</code> is present (piece centroid).</p> <code>buckets</code> <code>list[ndarray]</code> <p>List of arrays with shape <code>(n_pieces, piece_vertex_count)</code> indexing rows into <code>mesh.points</code> for each bucket size.</p> Notes <p>Buckets are created by grouping vertices per piece size (same vertex count), then stacking each contiguous group into a 2D array; <code>points.position</code> holds the centroid of each row and the mesh is recentered so that row-local vertices are around the origin. :contentReference[oaicite:1]{index=1}</p> <p>Initialize bucketed mesh instances.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>[Mesh][Mesh] or None</code> <p>Mesh to be bucketized. If <code>None</code>, creates an empty container.</p> <code>None</code> <code>mesh_id</code> <code>array - like or None</code> <p>Per-vertex group id used to split the mesh into pieces (passed to <code>mesh.points.make_buckets</code>).</p> <code>None</code> <code>attr_from</code> <code>[Geometry][Geometry] or None</code> <p>Geometry to copy attribute schemas from (matching domain names).</p> <code>None</code> <code>**attributes</code> <p>Extra per-piece attributes appended to <code>points</code>.</p> <code>{}</code>"},{"location":"api/meshes/#npblender.instances.Meshes.bounding_box","title":"bounding_box  <code>property</code>","text":"<pre><code>bounding_box\n</code></pre> <p>Axis-aligned bounding box of the point positions.</p> <p>Returns:</p> Type Description <code>tuple of numpy.ndarray</code> <p><code>(min_xyz, max_xyz)</code>. If empty, returns two zero vectors.</p>"},{"location":"api/meshes/#npblender.instances.Meshes.bounding_box_dims","title":"bounding_box_dims  <code>property</code>","text":"<pre><code>bounding_box_dims\n</code></pre> <p>Extents of the axis-aligned bounding box.</p> <p>Returns:</p> Type Description <code>numpy.ndarray of shape (3,)</code> <p><code>max_xyz - min_xyz</code>.</p>"},{"location":"api/meshes/#npblender.instances.Meshes.max_size","title":"max_size  <code>property</code>","text":"<pre><code>max_size\n</code></pre> <p>Maximum dimension of the bounding box.</p> <p>Returns:</p> Type Description <code>float</code> <p><code>max(bounding_box_dims)</code>.</p>"},{"location":"api/meshes/#npblender.instances.Meshes.mesh_id","title":"mesh_id  <code>property</code>","text":"<pre><code>mesh_id\n</code></pre> <p>Per-piece identifiers aligned with the flattened bucket rows.</p> <p>Returns:</p> Type Description <code>numpy.ndarray of dtype int</code> <p>Vector of ids assigning each row (piece) to its bucket index. The length matches the concatenation of bucket rows (see iteration order). :contentReference[oaicite:7]{index=7}</p>"},{"location":"api/meshes/#npblender.instances.Meshes.add_materials","title":"add_materials","text":"<pre><code>add_materials(materials)\n</code></pre> <p>Append material name(s) to the geometry.</p> <p>Parameters:</p> Name Type Description Default <code>materials</code> <code>str or sequence of str</code> <p>One name or a sequence of names to append.</p> required <p>Returns:</p> Type Description <code>None</code> Notes <p>This method does not deduplicate names; duplicates may be appended.</p>"},{"location":"api/meshes/#npblender.instances.Meshes.apply_scale","title":"apply_scale","text":"<pre><code>apply_scale(scale, pivot=None)\n</code></pre> <p>Scale points (convenience wrapper).</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>ndarray</code> <p>Per-point or broadcastable scales.</p> required <code>pivot</code> <code>ndarray</code> <p>Optional pivot(s) for scaling.</p> <code>None</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/meshes/#npblender.instances.Meshes.check","title":"check","text":"<pre><code>check(title='Meshes Check', halt=True)\n</code></pre> <p>Validate internal consistency between buckets and points.</p> <p>Verifies that the total number of rows across all buckets equals <code>len(points)</code>. When invalid, prints diagnostics and either raises (if <code>halt=True</code>) or returns <code>False</code>.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Message prefix for diagnostics.</p> <code>\"Meshes Check\"</code> <code>halt</code> <code>bool</code> <p>If True, raise via assertion on failure.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True when consistent; False when inconsistent and <code>halt=False</code>.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If inconsistent and <code>halt=True</code>. :contentReference[oaicite:6]{index=6}</p>"},{"location":"api/meshes/#npblender.instances.Meshes.clear_geometry","title":"clear_geometry","text":"<pre><code>clear_geometry()\n</code></pre> <p>Reset to an empty state.</p> <p>Clears the mesh, empties <code>points</code>, and removes all buckets.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>contentReference[oaicite:17]{index=17}</code>"},{"location":"api/meshes/#npblender.instances.Meshes.compute_attribute_on_domain","title":"compute_attribute_on_domain","text":"<pre><code>compute_attribute_on_domain(domain_from, attr, domain_to)\n</code></pre> <p>Transfer an attribute from one domain to another.</p> <p>Performs a domain mapping (e.g., points \u2192 faces) using the appropriate domain operator, and returns the computed array on the target domain.</p> <p>Parameters:</p> Name Type Description Default <code>domain_from</code> <code>str</code> <p>Source domain name (e.g., <code>\"points\"</code>, <code>\"faces\"</code>, <code>\"edges\"</code>, <code>\"corners\"</code>, <code>\"splines\"</code>).</p> required <code>attr</code> <code>str or ndarray</code> <p>Source attribute to transfer. If a string, it is looked up on the source domain; if an array, it must match the source domain length.</p> required <code>domain_to</code> <code>str</code> <p>Target domain name.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Attribute values on the target domain. If <code>domain_from == domain_to</code>, returns <code>attr</code> unchanged.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If either <code>domain_from</code> or <code>domain_to</code> is not a valid domain of this geometry.</p> <code>Exception</code> <p>If the requested mapping is not implemented.</p> Notes <p>Implemented mappings include: - points \u2192 faces: <code>Point.compute_attribute_on_faces</code> - points \u2192 edges: <code>Point.compute_attribute_on_edges</code> - points \u2192 corners: <code>Point.compute_attribute_on_corners</code> - points \u2192 splines: <code>Point.compute_attribute_on_splines</code> - faces \u2192 points: <code>Face.compute_attribute_on_points</code> - edges \u2192 points: <code>Edge.compute_attribute_on_points</code> - corners \u2192 points: <code>Corner.compute_attribute_on_points</code></p>"},{"location":"api/meshes/#npblender.instances.Meshes.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d)\n</code></pre> <p>Deserialize a <code>Meshes</code> produced by <code>to_dict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Serialized payload.</p> required <p>Returns:</p> Type Description <code>Meshes</code> <p>Reconstructed instance with mesh, points and buckets restored. :contentReference[oaicite:11]{index=11}</p>"},{"location":"api/meshes/#npblender.instances.Meshes.from_mesh_islands","title":"from_mesh_islands  <code>classmethod</code>","text":"<pre><code>from_mesh_islands(mesh)\n</code></pre> <p>Build <code>Meshes</code> by splitting a mesh into face islands.</p> <p>Computes face islands on <code>mesh</code>, transfers the island id to the point domain, then uses it as <code>mesh_id</code> to create buckets.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>[Mesh][Mesh]</code> <p>Source mesh.</p> required <p>Returns:</p> Type Description <code>Meshes</code> <p>New instance with one piece per island. :contentReference[oaicite:9]{index=9}</p>"},{"location":"api/meshes/#npblender.instances.Meshes.from_meshes","title":"from_meshes  <code>classmethod</code>","text":"<pre><code>from_meshes(meshes)\n</code></pre> <p>Copy-construct a <code>Meshes</code> from another <code>Meshes</code>.</p> <p>Duplicates the source mesh, copies the bucket lists, and clones the per-piece point domain.</p> <p>Parameters:</p> Name Type Description Default <code>meshes</code> <code>Meshes</code> <p>Source <code>Meshes</code> to copy from.</p> required <p>Returns:</p> Type Description <code>Meshes</code> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>meshes</code> is not a <code>Meshes</code> instance. :contentReference[oaicite:8]{index=8}</p>"},{"location":"api/meshes/#npblender.instances.Meshes.get_cubic_envelop","title":"get_cubic_envelop","text":"<pre><code>get_cubic_envelop()\n</code></pre> <p>Return a cube mesh that encloses the geometry\u2019s bounding box.</p> <p>Uses the bounding box dimensions to build a cube via <code>Mesh.cube</code>, forwarding this geometry\u2019s <code>materials</code> if present.</p> <p>Returns:</p> Type Description <code>Mesh</code> <p>A cube mesh sized to the bounding box.</p>"},{"location":"api/meshes/#npblender.instances.Meshes.get_material_index","title":"get_material_index","text":"<pre><code>get_material_index(mat_name)\n</code></pre> <p>Return the index of a material name, creating it if needed.</p> <p>Parameters:</p> Name Type Description Default <code>mat_name</code> <code>str</code> <p>Material name to look up or append.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index of <code>mat_name</code> in <code>self.materials</code>.</p> Notes <p>If <code>mat_name</code> is not present, it is appended to <code>self.materials</code> and the new index is returned.</p>"},{"location":"api/meshes/#npblender.instances.Meshes.get_points_selection","title":"get_points_selection","text":"<pre><code>get_points_selection()\n</code></pre> <p>Selection of points relevant to operations.</p> <p>Returns <code>slice(None)</code> in the base class (all points). Subclasses (e.g., curves) may override to select only referenced points.</p> <p>Returns:</p> Type Description <code>slice</code> <p><code>slice(None)</code> by default.</p>"},{"location":"api/meshes/#npblender.instances.Meshes.join","title":"join","text":"<pre><code>join(*others)\n</code></pre> <p>Concatenate other <code>Meshes</code> into this one.</p> <p>Appends the other mesh data, then merges their buckets: rows with the same piece vertex count are concatenated; new sizes create new entries.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Meshes</code> <p>Other <code>Meshes</code> objects to append.</p> <code>()</code> <p>Returns:</p> Type Description <code>Meshes</code> <p><code>self</code>, for chaining.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If any input is not a <code>Meshes</code>. :contentReference[oaicite:13]{index=13}</p>"},{"location":"api/meshes/#npblender.instances.Meshes.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other, **kwargs)\n</code></pre> <p>Merge attribute schemas from another geometry.</p> <p>For each domain listed in <code>self.domain_names</code> and also present in <code>other</code>, copies (joins) the attribute definitions (names, dtypes, metadata) from <code>other</code> into this geometry's domains. Use keyword flags to include/exclude domains by name (e.g., <code>faces=False</code>).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Geometry or None</code> <p>Source geometry. If <code>None</code>, does nothing and returns <code>self</code>.</p> required <code>**kwargs</code> <p>Per-domain boolean switches to filter which domains to join.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>, for chaining.</p> <p>Examples:</p> <pre><code>mesh.join_attributes(other_mesh, faces=False)\ncurve.join_attributes(mesh)  # only common domains are merged\n</code></pre>"},{"location":"api/meshes/#npblender.instances.Meshes.load_models","title":"load_models  <code>staticmethod</code>","text":"<pre><code>load_models(*specs)\n</code></pre> <p>Load multiple geometries from collections, objects, or instances.</p> <p>Accepts mixed inputs such as Blender collections, Blender objects, lists/ tuples of either, or already-instantiated <code>Mesh</code>/<code>Curve</code>. Returns a flat list of geometries discovered or constructed.</p> <p>This method is mainly intended to be used by <code>Instances</code> to load its models.</p> <p>Parameters:</p> Name Type Description Default <code>*specs</code> <p>Collections, objects, lists/tuples, or <code>Mesh</code>/<code>Curve</code> instances.</p> <code>()</code> <p>Returns:</p> Type Description <code>list</code> <p>List of geometries (<code>Mesh</code>/<code>Curve</code>).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a spec cannot be resolved to a geometry.</p>"},{"location":"api/meshes/#npblender.instances.Meshes.load_object","title":"load_object  <code>staticmethod</code>","text":"<pre><code>load_object(name)\n</code></pre> <p>Load a Blender object and return a <code>Mesh</code> or a <code>Curve</code>.</p> <p>Resolves <code>name</code> to a Blender object, inspects its data type, and returns a matching geometry by calling the subclass' <code>from_object</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or Object</code> <p>Object name or object instance.</p> required <p>Returns:</p> Type Description <code>Mesh or Curve or None</code> <p>A <code>Mesh</code> or a <code>Curve</code>, or <code>None</code> if the object is not found.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the object exists but is neither a <code>bpy.types.Mesh</code> nor <code>bpy.types.Curve</code>.</p> <p>Examples:</p> <pre><code>geo = Geometry.load_object(\"MyObject\")\nif geo is not None:\n    print(type(geo).__name__)\n</code></pre>"},{"location":"api/meshes/#npblender.instances.Meshes.multiply","title":"multiply","text":"<pre><code>multiply(count, in_place=True)\n</code></pre> <p>Duplicate all pieces <code>count</code> times.</p> <p>Buckets are offset by the source mesh vertex count to index the newly appended mesh copies; both the <code>points</code> domain and the <code>mesh</code> are multiplied accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of copies to create.</p> required <code>in_place</code> <code>bool</code> <p>If True, expand this instance; otherwise return a new expanded copy.</p> <code>True</code> <p>Returns:</p> Type Description <code>Meshes or None</code> <p><code>self</code> (in place) or a new <code>Meshes</code>; <code>None</code> if <code>count == 0</code>. :contentReference[oaicite:14]{index=14}</p>"},{"location":"api/meshes/#npblender.instances.Meshes.object","title":"object","text":"<pre><code>object(index=0, readonly=True, **kwargs)\n</code></pre> <p>Temporary access to a Blender Object built from this geometry.</p> <p>Creates a transient object (named <code>\"BPBL Temp {index}\"</code> unless <code>index</code> is a string), selects and activates it, yields it for editing, then cleans up. If <code>readonly=True</code>, the edited object is captured back into <code>self</code>.</p> <p>This method can be used to set and apply a modifier (see exemple below).</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int or str</code> <p>Index or name used to label the temporary object.</p> <code>0</code> <code>readonly</code> <code>bool</code> <p>If <code>False</code>, re-capture the possibly edited object back into this geometry.</p> <code>True</code> <code>kwargs</code> <code>dict</code> <p>Keyword arguments passed to <code>self.to_object</code>.</p> <code>{}</code> <p>Yields:</p> Type Description <code>Object</code> <p>The temporary Blender object built from <code>self</code>.</p> <p>Examples:</p> <pre><code>plane = Mesh.Grid()\nwith plane.object(readonly=False) as obj:\n    mod = obj.modifiers.new(\"Solidify\", 'SOLIDIFY')\n    mod.thickness = .1\n    bpy.ops.object.modifier_apply(modifier=mod.name)\n\n# plane is now solidifed\n</code></pre>"},{"location":"api/meshes/#npblender.instances.Meshes.realize","title":"realize","text":"<pre><code>realize()\n</code></pre> <p>Realize the bucketed pieces into a concrete mesh.</p> <p>Copies the source mesh, joins per-piece point attributes (other than <code>position</code>) additively into the mesh per-vertex fields for each row, and applies per-piece transforms (rotation/scale/translation) to the vertices addressed by each bucket.</p> <p>Returns:</p> Type Description <code>[Mesh][Mesh]</code> <p>A mesh with all pieces transformed into world placement. :contentReference[oaicite:12]{index=12}</p>"},{"location":"api/meshes/#npblender.instances.Meshes.rotate","title":"rotate","text":"<pre><code>rotate(rotation, pivot=None)\n</code></pre> <p>Rotate points (convenience wrapper).</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>ndarray or Rotation - like</code> <p>Rotation(s) to apply as <code>R @ v</code>.</p> required <code>pivot</code> <code>ndarray</code> <p>Optional pivot(s) for rotation.</p> <code>None</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/meshes/#npblender.instances.Meshes.set_mesh_points_attribute","title":"set_mesh_points_attribute","text":"<pre><code>set_mesh_points_attribute(domain_name, name, value)\n</code></pre> <p>Broadcast a per-piece value to a per-vertex mesh attribute.</p> <p>Looks up <code>mesh.points[name]</code>, broadcasts <code>value</code> to <code>(len(self), *attr_shape)</code>, then writes the piece value to all vertices of each row in the buckets.</p> <p>Parameters:</p> Name Type Description Default <code>domain_name</code> <code>str</code> <p>Unused placeholder (kept for API symmetry).</p> required <code>name</code> <code>str</code> <p>Name of the mesh point attribute to write.</p> required <code>value</code> <code>array - like</code> <p>Value(s) per piece, broadcastable to the attribute shape.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the mesh point attribute <code>name</code> does not exist. :contentReference[oaicite:18]{index=18}</p>"},{"location":"api/meshes/#npblender.instances.Meshes.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize to a plain dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Keys: <code>\"geometry\" = \"Meshes\"</code>, <code>\"points\"</code>, <code>\"mesh\"</code>, <code>\"buckets\"</code>. :contentReference[oaicite:10]{index=10}</p>"},{"location":"api/meshes/#npblender.instances.Meshes.transform","title":"transform","text":"<pre><code>transform(transformation)\n</code></pre> <p>Apply a rotation matrix or batch of matrices.</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>transformation</code> <code>ndarray</code> <p>Rotation matrix or batch of rotation matrices.</p> required <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/meshes/#npblender.instances.Meshes.transformation","title":"transformation","text":"<pre><code>transformation(rotation=None, scale=None, translation=None, pivot=None)\n</code></pre> <p>Apply rotation/scale/translation (with optional per-packet broadcasting).</p> <p>Operates in-place on <code>points.position</code> and, when present, Bezier handles (<code>points.handle_left</code>, <code>points.handle_right</code>). Shapes can represent packets of points: broadcasting rules are handled by <code>Point._get_shape_for_operation</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>ndarray or Rotation - like</code> <p>Rotation matrix/matrices applied as <code>R @ v</code>. Shape may broadcast over points (see notes).</p> <code>None</code> <code>scale</code> <code>ndarray</code> <p>Per-axis scaling. Shape may broadcast over points.</p> <code>None</code> <code>translation</code> <code>ndarray</code> <p>Per-point translation. Shape may broadcast over points.</p> <code>None</code> <code>pivot</code> <code>ndarray</code> <p>Pivot(s) subtracted before, and added after, the rotation/scale; same broadcasting rules as <code>scale</code>/<code>translation</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>, for chaining.</p> Notes <ul> <li>If handles exist, they are transformed consistently with positions.</li> </ul> <p>Examples:</p> <pre><code># 12 cubes laid out randomly with per-instance transforms\ncubes = Mesh.cube(size=1).multiply(12)\nT = np.random.uniform(-1, 1, (12, 3))\nS = np.random.uniform(0.5, 2.0, (12, 3))\nR = Rotation.from_euler(np.random.uniform(0, 2*np.pi, (12, 3)))\ncubes.transformation(rotation=R, scale=S, translation=T)\n</code></pre>"},{"location":"api/meshes/#npblender.instances.Meshes.translate","title":"translate","text":"<pre><code>translate(translation)\n</code></pre> <p>Translate points (convenience wrapper).</p> <p>See: <code>transformation</code></p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>ndarray</code> <p>Per-point or broadcastable translation vectors.</p> required <p>Returns:</p> Type Description <code>Geometry</code> <p><code>self</code>.</p>"},{"location":"api/point/","title":"Point","text":""},{"location":"api/point/#npblender.domain.Point","title":"Point","text":"<pre><code>Point(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>Point domain for cloud and instances.</p> <p>Adds optional rotation/scale fields and a convenient kinematics initializer, along with several spatial distribution helpers.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>(N, 3) float</code> <p>Point positions.</p> <code>radius</code> <code>(N,) float, optional</code> <p>Point radius (e.g., for particle/cloud visualization).</p> <code>model_index</code> <code>(N,) int, optional</code> <p>Instance model index.</p> <code>euler</code> <code>(N, 3) float, optional</code> <p>Euler angles (radians).</p> <code>quat</code> <code>(N, 4) float, optional</code> <p>Quaternion rotation in (x, y, z, w) convention.</p> <code>scale</code> <code>(N, 3) float, optional</code> <p>Per-point scale.</p> Kinematics (created by <code>init_kinematics()</code>) <p>speed, accel, force : (N, 3) float     Linear kinematics fields. mass : (N,) float     Mass per point. moment : (N,) float     Moment of inertia proxy (placeholder). omega, torque : (N, 3) float     Angular velocity and torque. age : (N,) float     Age (seconds or user-defined units). locked : (N,) bool     Lock flag. last_pos : (N, 3) float     Previous position. viscosity : (N,) float     Drag coefficient.</p> Properties <p>has_rotation : bool     True if either <code>euler</code> or <code>quat</code> is present. rotation : Rotation or Quaternion     Combined rotation (quaternion \u2297 euler if both present).</p> Methods (selection) <p>init_kinematics()     Add standard kinematics fields. line_dist(), arc_dist(), circle_dist(), rect_dist(), pie_dist(), disk_dist(), cylinder_dist(), sphere_dist(), dome_dist(), cube_dist(), ball_dist()     Populate positions (and related attributes like tangent/normal)     from common geometric distributions. speed_along(), disk_speed(), shake_speed()     Generate velocity vectors according to distributions.</p> <p>Examples:</p> <p>Create a ring of instances with tangents:</p> <pre><code>pts = Point().circle_dist(radius=2.0, count=128, seed=0)\n# tangents and angles are appended automatically\n</code></pre> <p>Compose rotations and apply scale:</p> <pre><code>R = pts.rotation              # auto-composed from euler/quat\npts.apply_scale(0.5)\npts.transform(R)              # re-apply or chain with other transforms\n</code></pre> <p>Initialize a domain array and its attribute schema.</p> <p>Initializes the storage from an existing array/domain or creates an empty structure. Optionally merges attribute definitions/values from another domain and keyword-provided attributes.</p> <p>Domains are never instancied directly but by owning geometries.</p> <p>Actual Domains are <code>Vertex</code>, [<code>Faces</code>][npblender.domain.Faces], <code>Corner</code>, <code>Edge</code>, <code>ControlPoint</code>, <code>Spline</code> and <code>Point</code>.</p> <p>Domains are initialized with their defaults attributes, for instance <code>position</code> for point domaines.</p> <p>Use attributes can be freely added. </p> <p>Note: user attributes are saved in Blender Mesh objects only, Blender Curve objects don't store user attributes.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>array - like or FieldArray or None</code> <p>Source data used to initialize the domain. If <code>None</code>, an empty domain is created and <code>_declare_attributes()</code> is called to register defaults.</p> <code>None</code> <code>mode</code> <code>(COPY, CAPTURE, EMPTY)</code> <p>Initialization mode. <code>'COPY'</code> duplicates the input data, <code>'CAPTURE'</code> references the input buffer when supported, <code>'EMPTY'</code> creates the structure without copying values.</p> <code>'COPY'</code> <code>selector</code> <code>Any</code> <p>Optional row/element selector applied to <code>a</code> prior to initialization.</p> <code>None</code> <code>attr_from</code> <code>Domain or Mapping or None</code> <p>Attribute schema (and possibly values) to merge into this domain.</p> <code>None</code> <code>**attrs</code> <p>Additional attribute name/value pairs to inject or override.</p> <code>{}</code> Notes <p>The effective attribute list results from <code>_declare_attributes()</code>, then <code>attr_from</code>, then <code>**attrs</code> (later entries take precedence).</p> <p>Examples:</p> <pre><code>cube = Mesh.cube() # points, corners, faces and edges domains are created\n# Adding named attribute to point domain\ncube.points.new_float('age')\n# Setting the age\ncube.points.age = np.random.uniforme(10, 10, len(cube.points))\n</code></pre>"},{"location":"api/point/#npblender.domain.Point.actual_names","title":"actual_names  <code>property</code>","text":"<pre><code>actual_names\n</code></pre> <p>Column names.</p> <p>Returns the actual field names, excluding optional fields.</p>"},{"location":"api/point/#npblender.domain.Point.all_names","title":"all_names  <code>property</code>","text":"<pre><code>all_names\n</code></pre> <p>Column names.</p> <p>Returns all the field names, including optional ones.</p>"},{"location":"api/point/#npblender.domain.Point.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Array structured dtype</p> <p>Returns the dtype property of the structured array.</p>"},{"location":"api/point/#npblender.domain.Point.has_rotation","title":"has_rotation  <code>property</code>","text":"<pre><code>has_rotation\n</code></pre> <p>Whether this domain has an orientation field.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if either <code>euler</code> or <code>quat</code> exists in the attribute set, <code>False</code> otherwise.</p> See Also <p><code>rotation</code> :     Access the per-point rotation object. <code>get_rotation</code> :     Safe accessor that can return a default.</p>"},{"location":"api/point/#npblender.domain.Point.rotation","title":"rotation  <code>property</code>","text":"<pre><code>rotation\n</code></pre> <p>Per-point rotation object from Euler and/or quaternion.</p> <p>If both <code>euler</code> and <code>quat</code> exist, returns their composition (quaternion composed with Euler). If neither exists, returns an identity rotation with shape <code>(len(position),)</code>.</p> <p>Returns:</p> Type Description <code>Rotation</code> <p>The point rotation</p> See Also <p><code>has_rotation</code> :     Check if a rotation is available. <code>get_rotation</code> :     Return a default when no rotation is stored.</p> <p>Examples:</p> <pre><code>R = P.rotation           # rotation object (vectorized)\neul = R.as_euler()       # (N, 3)\nquat = R.as_quaternion() # (N, 4) in (x, y, z, w)\n</code></pre>"},{"location":"api/point/#npblender.domain.Point.transdom_names","title":"transdom_names  <code>property</code>","text":"<pre><code>transdom_names\n</code></pre> <p>List the names of trans-domain attributes.</p> <p>Returns:</p> Type Description <code>list of str</code> <p>Names of attributes flagged with <code>transdom=True</code>.</p> <p>Examples:</p> <pre><code>names = D.transdom_names()\n</code></pre>"},{"location":"api/point/#npblender.domain.Point.x","title":"x  <code>property</code> <code>writable</code>","text":"<pre><code>x\n</code></pre> <p>X coordinate accessor.</p> <p>Shorthand for <code>position[..., 0]</code>. Reading returns a view; assigning to this property writes into the underlying <code>position</code> field.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>View of shape <code>(...,)</code> selecting the x component of <code>position</code>.</p> <p>Examples:</p> <p>Read and write x in place:</p> <pre><code>xs = points.x              # view on position[..., 0]\npoints.x = xs + 1.0        # shift x by +1\n</code></pre> <p>Note: This is equivalent to <code>points.position[..., 0]</code>.</p>"},{"location":"api/point/#npblender.domain.Point.y","title":"y  <code>property</code> <code>writable</code>","text":"<pre><code>y\n</code></pre> <p>Y coordinate accessor.</p> <p>Shorthand for <code>position[..., 1]</code>. Reading returns a view; assigning to this property writes into the underlying <code>position</code> field.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>View of shape <code>(...,)</code> selecting the y component of <code>position</code>.</p> <p>Examples:</p> <pre><code>points.y = 0.0             # flatten all y to 0\n</code></pre>"},{"location":"api/point/#npblender.domain.Point.z","title":"z  <code>property</code> <code>writable</code>","text":"<pre><code>z\n</code></pre> <p>Z coordinate accessor.</p> <p>Shorthand for <code>position[..., 2]</code>. Reading returns a view; assigning to this property writes into the underlying <code>position</code> field.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>View of shape <code>(...,)</code> selecting the z component of <code>position</code>.</p> <p>Examples:</p> <pre><code>points.z += 2.5\n</code></pre>"},{"location":"api/point/#npblender.domain.Point.add","title":"add","text":"<pre><code>add(count, **fields)\n</code></pre> <p>Add count records</p> <p>New records are set with default values or values provided by the user in fields dict.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of records to add.</p> required <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/point/#npblender.domain.Point.append","title":"append","text":"<pre><code>append(**fields)\n</code></pre> <p>Append values to the structured array.</p> <p>The number of records to append is determined by the number of fields provided in the fields dictionary. The values of the fields are copied to the new records.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/point/#npblender.domain.Point.apply_scale","title":"apply_scale","text":"<pre><code>apply_scale(scale, pivot=None)\n</code></pre> <p>Apply per-axis scales to positions and multiply the <code>scale</code> attribute.</p> <p>Calls the base point scaling (<code>apply_scale</code>) to update <code>position</code> (optionally about <code>pivot</code>), then multiplies the per-point <code>scale</code> attribute when present.</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>array-like of shape ``(..., 3)``</code> <p>Per-axis scale factors broadcastable to the domain size.</p> required <code>pivot</code> <code>array-like of shape ``(..., 3)`` or None</code> <p>Pivot location(s). If <code>None</code>, scaling is applied about the origin.</p> <code>None</code> <p>Returns:</p> Type Description <code>Point</code> <p>Self (for chaining).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If broadcasting cannot align inputs with the domain (raised by <code>_get_shape_for_operation</code>).</p>"},{"location":"api/point/#npblender.domain.Point.as_kwargs","title":"as_kwargs","text":"<pre><code>as_kwargs(selector=None, include=None, exclude=None)\n</code></pre> <p>Return a dictionary of field values formatted as kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>slice, int, list, or mask</code> <p>Optional selection of elements to extract.</p> <code>None</code> <code>include</code> <code>list[str]</code> <p>List of field names (original or python names) to include.</p> <code>None</code> <code>exclude</code> <code>list[str]</code> <p>List of field names (original or python names) to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Mapping from python-safe field names to array values.</p>"},{"location":"api/point/#npblender.domain.Point.copy_field","title":"copy_field","text":"<pre><code>copy_field(field_name, new_name, **infos)\n</code></pre> <p>Duplicate an existing field under a new name, with optional metadata overrides.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the existing field to copy.</p> required <code>new_name</code> <code>str</code> <p>The name of the new field to create.</p> required <code>infos</code> <code>keyword arguments</code> <p>Optional metadata (e.g. default, unit, description...) to override or supplement the original field's metadata.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the source field does not exist.</p> <code>ValueError</code> <p>If the target name already exists or is reserved.</p>"},{"location":"api/point/#npblender.domain.Point.delete","title":"delete","text":"<pre><code>delete(index)\n</code></pre> <p>Delete a selection of items from the array.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int, slice, or array-like</code> <p>The indices of the elements to delete from the current data.</p> required Notes <p>This operates only on the valid range <code>[0:self._length]</code>. The internal buffer is preserved (no reallocation).</p>"},{"location":"api/point/#npblender.domain.Point.disk_speed","title":"disk_speed","text":"<pre><code>disk_speed(speed=1, max_speed=None, normal=None, seed=None)\n</code></pre> <p>Sample velocity vectors in a disk (2D radial distribution).</p> <p>Samples vectors lying in a plane (given by <code>normal</code>) with lengths in <code>[0, max_speed]</code> (or fixed <code>speed</code> if <code>max_speed</code> is <code>None</code>).</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Base radius or fixed magnitude when <code>max_speed</code> is <code>None</code>.</p> <code>1</code> <code>max_speed</code> <code>float or None</code> <p>Maximum radius; if provided, lengths are sampled in <code>[0, max_speed]</code>.</p> <code>None</code> <code>normal</code> <code>(3,) float or None</code> <p>Plane normal. If <code>None</code>, uses +Z.</p> <code>None</code> <code>seed</code> <code>int or None</code> <code>None</code> <p>Returns:</p> Type Description <code>ndarray of shape ``(N, 3)``</code> <p>Sampled velocity vectors.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If inputs are invalid (propagated from the backend).</p>"},{"location":"api/point/#npblender.domain.Point.dump","title":"dump","text":"<pre><code>dump(title='Dump', attributes=None, target='SCREEN')\n</code></pre> <p>Pretty-print or export domain content.</p> <p>Formats attribute values and prints to screen or builds a tabular dump suitable for spreadsheets.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title displayed in the report.</p> <code>'Dump'</code> <code>attributes</code> <code>Sequence[str] or None</code> <p>Subset of attribute names to include. If <code>None</code>, all attributes are shown.</p> <code>None</code> <code>target</code> <code>(SCREEN, ...)</code> <p>Output target. <code>'SCREEN'</code> prints to stdout; other targets may trigger file creation depending on the implementation.</p> <code>'SCREEN'</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>Domain(points).dump(title=\"Vertices\")\n</code></pre> <p>Note: Formatting adapts to the chosen <code>target</code>.</p>"},{"location":"api/point/#npblender.domain.Point.extend","title":"extend","text":"<pre><code>extend(other, join_fields=True)\n</code></pre> <p>Append multiple records from another array or FieldArray.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray or structured np.ndarray</code> <p>The array of records to append. Must have named fields matching a subset of the current array's fields.</p> required"},{"location":"api/point/#npblender.domain.Point.filtered","title":"filtered","text":"<pre><code>filtered(selector, *, copy=False)\n</code></pre> <p>Return a FieldArray containing only the selected records.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>array\u2011like, slice or int</code> <p>Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice. It is applied to the current valid part of the buffer (<code>self._data[:self._length]</code>).</p> required <code>copy</code> <code>bool</code> <ul> <li>False    (default) =&gt; the new array shares the same memory                          (changes propagate both ways).</li> <li>True           =&gt; the data are physically copied.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>FieldArray</code> <p>A new instance holding exactly <code>len(selector)</code> records and inheriting the current field\u2011infos.</p>"},{"location":"api/point/#npblender.domain.Point.from_bl_attributes","title":"from_bl_attributes","text":"<pre><code>from_bl_attributes(bl_attributes)\n</code></pre> <p>Import attributes from a Blender attribute collection.</p> <p>Reads geometry attributes from a Blender data-block and creates/updates the corresponding domain attributes, resizing the domain if needed.</p> <p>Parameters:</p> Name Type Description Default <code>bl_attributes</code> <code>Mapping[str, Any]</code> <p>Blender attributes collection (name \u2192 attribute descriptor) providing at least <code>.domain</code>, <code>.is_internal</code>, <code>.data_type</code>, and <code>.data</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Note:*** Only external (non-internal) Blender attributes matching this</code> <code>domain are imported. Missing attributes are created with `transfer=True`.</code>"},{"location":"api/point/#npblender.domain.Point.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Build a FieldArray from a dictionary with field data and optional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, array - like or (array, dict)]</code> <p>Mapping field names to arrays or (array, infos). Infos must include NAME.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the data. Default: True.</p> required <p>Returns:</p> Type Description <code>FieldArray</code>"},{"location":"api/point/#npblender.domain.Point.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> <p>Get attribute by name.</p> <p>If name is not an actual field, return default value. Name can be an array. <pre><code>pos = field_array.get(\"position\", (0, 0, 1))\npos = field_array.get([[0, 0, 1], [0, 0, 0]])\n</code></pre></p>"},{"location":"api/point/#npblender.domain.Point.get_rotation","title":"get_rotation","text":"<pre><code>get_rotation(default=None)\n</code></pre> <p>Return the per-point rotation or a default.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Any or None</code> <p>Value to return if no rotation field is present. If <code>None</code>, the method returns <code>None</code> when no rotation is available.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any or None</code> <p><code>rotation</code> if available; otherwise <code>default</code>.</p> See Also <p><code>has_rotation</code> <code>rotation</code></p>"},{"location":"api/point/#npblender.domain.Point.init_kinematics","title":"init_kinematics","text":"<pre><code>init_kinematics()\n</code></pre> <p>Create standard kinematics fields (linear &amp; angular).</p> <p>Declares common per-point kinematics attributes for simulation or procedural animation. This method does not modify positions or velocities; it only ensures attributes exist with sensible defaults.</p> Declared attributes <p>speed : (N, 3) float     Linear velocity. accel : (N, 3) float     Linear acceleration. mass : (N,) float, optional     Point mass (default 1.0). force : (N, 3) float     Accumulated external force. moment : (N,) float, optional     Rotational inertia proxy (scalar; simplification). omega : (N, 3) float, optional     Angular velocity (radians/second). torque : (N, 3) float, optional     Accumulated external torque. age : (N,) float, optional     Age/time since spawn (seconds). locked : (N,) bool, optional     Freeze flag for constraints/solvers. last_pos : (N, 3) float, optional     Previous position (for finite differences). viscosity : (N,) float, optional     Linear damping factor.</p> <p>Returns:</p> Type Description <code>None</code>"},{"location":"api/point/#npblender.domain.Point.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other)\n</code></pre> <p>Merge trans-domain attributes from another domain.</p> <p>Copies or aligns attributes from <code>other</code> into the current domain, excluding any attributes not flagged as trans-domain in <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain or None</code> <p>Source domain. If <code>None</code>, the call is a no-op.</p> required <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p>"},{"location":"api/point/#npblender.domain.Point.join_fields","title":"join_fields","text":"<pre><code>join_fields(other, exclude=[])\n</code></pre> <p>Add all missing fields from another FieldArray.</p> <p>For every field in <code>other</code> that is not present in <code>self</code>, a new field is created with the same dtype and shape, and initialized with its default value across all existing records.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray</code> <p>Another FieldArray instance whose fields will be checked for missing fields.</p> required <p>Returns:</p> Type Description <code>self</code>"},{"location":"api/point/#npblender.domain.Point.make_buckets","title":"make_buckets","text":"<pre><code>make_buckets(attr)\n</code></pre> <p>Group items into buckets by attribute value.</p> <p>When a domain is to be considered as a collection of packets of various sizes, buckets mechanism groups pakets by size, allowing further operation with numpy vectorization.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>array - like or str</code> <p>Either an integer of shape <code>(N,)</code> or the name of an existing integer attribute in the domain.</p> required <p>Returns:</p> Type Description <code>list[ndarray(count, n)]</code> <p>A list of int arrays (count, n): count is the number of buckets of length n.</p> <p>Examples:</p> <pre><code>buckets = mesh.make_buckets('material')\nfor bucket in buckets:\n    print(bucket.shape)\n</code></pre> <p>Note: The bucket attribute can be read with <code>attr[bucket[:, 0]]</code>.</p>"},{"location":"api/point/#npblender.domain.Point.multiply","title":"multiply","text":"<pre><code>multiply(count)\n</code></pre> <p>Duplicate the current records <code>count</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of times to repeat the current records.</p> required Notes <p>This duplicates the current valid records (up to self._length). If the array is empty or count &lt;= 1, nothing happens.</p> Example: <p>If the array has 3 records and count == 4, the result will be:</p> <p>[rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]</p>"},{"location":"api/point/#npblender.domain.Point.new_attribute","title":"new_attribute","text":"<pre><code>new_attribute(name, data_type, default, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Register a new attribute in the domain schema.</p> <p>Creates (or ensures) an attribute with a given name, logical data type, default value, and flags controlling Blender transfer and cross-domain propagation.</p> <p>Note: <code>data_type</code> argument is a Blender data type not a python data type. The data type name is compatible with Blender internal storage. <code>FLOAT</code>data type is implemented as <code>np.float32</code> and  'INT' as <code>np.int32</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name (Python identifier recommended).</p> required <code>data_type</code> <code>(FLOAT, INT, BOOL, VECTOR, VECTOR2, COLOR, QUATERNION, MATRIX, STRING, ...)</code> <p>Logical data type used by the domain.</p> <code>'FLOAT'</code> <code>default</code> <code>Any</code> <p>Default value for newly allocated elements.</p> required <code>optional</code> <code>bool</code> <p>If <code>True</code>, the attribute may be absent on some elements.</p> <code>False</code> <code>transfer</code> <code>bool</code> <p>If <code>True</code>, eligible to be transferred to Blender as a geometry attribute.</p> <code>True</code> <code>transdom</code> <code>bool</code> <p>If <code>True</code>, considered a trans-domain attribute that can be copied across compatible domains.</p> <code>True</code> See Also <p><code>new_float</code>, <code>new_vector</code>, <code>new_int</code>, <code>new_bool</code>, <code>new_color</code>, <code>new_vector2</code>, <code>new_quaternion</code>, <code>new_matrix</code></p>"},{"location":"api/point/#npblender.domain.Point.new_bool","title":"new_bool","text":"<pre><code>new_bool(name, default=False, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a boolean attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>bool</code> <p>Default value.</p> <code>False</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/point/#npblender.domain.Point.new_color","title":"new_color","text":"<pre><code>new_color(name, default=(0.5, 0.5, 0.5, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a color attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,) or (4,)</code> <p>Default color as RGB or RGBA.</p> <code>(0.5, 0.5, 0.5, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/point/#npblender.domain.Point.new_field","title":"new_field","text":"<pre><code>new_field(name, dtype, shape=None, default=0, optional=False, **infos)\n</code></pre> <p>Add a field to the structured array.</p> Arguments <pre><code>- name (str) : field name\n- dtype (type) : a valid numpy dtype\n- shape (tuple = None) : the shape of the field\n- default (any = 0) : default value\n- optional (bool = False) : the field is created only when accessed\n- infos (dict) : field infos\n</code></pre>"},{"location":"api/point/#npblender.domain.Point.new_float","title":"new_float","text":"<pre><code>new_float(name, default=0.0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a scalar float attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>float</code> <p>Default value.</p> <code>0.0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/point/#npblender.domain.Point.new_int","title":"new_int","text":"<pre><code>new_int(name, default=0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure an integer attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>int</code> <p>Default value.</p> <code>0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/point/#npblender.domain.Point.new_matrix","title":"new_matrix","text":"<pre><code>new_matrix(name, default=np.eye(4), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a matrix attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array - like</code> <p>Default matrix. By convention this is a square matrix per element (e.g., <code>(3, 3)</code> rotation or <code>(4, 4)</code> transform).</p> <code>np.eye(4)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code> <code>order</code> required"},{"location":"api/point/#npblender.domain.Point.new_quaternion","title":"new_quaternion","text":"<pre><code>new_quaternion(name, default=(0.0, 0.0, 0.0, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a quaternion attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (4,)</code> <p>Default quaternion in <code>(x, y, z, w)</code> convention.</p> <code>(0.0, 0.0, 0.0, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/point/#npblender.domain.Point.new_vector","title":"new_vector","text":"<pre><code>new_vector(name, default=(0.0, 0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 3D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,)</code> <p>Default XYZ vector.</p> <code>(0.0, 0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/point/#npblender.domain.Point.new_vector2","title":"new_vector2","text":"<pre><code>new_vector2(name, default=(0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 2D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (2,)</code> <p>Default XY vector.</p> <code>(0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/point/#npblender.domain.Point.shake_speed","title":"shake_speed","text":"<pre><code>shake_speed(speed, scale=None, length_only=False, seed=None)\n</code></pre> <p>Add random jitter to existing velocity vectors.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>str or ndarray</code> <p>A field name or an array of velocity vectors to perturb.</p> required <code>scale</code> <code>float or (3,) or None</code> <p>Jitter amount (broadcastable).</p> <code>None</code> <code>length_only</code> <code>bool</code> <p>If <code>True</code>, only magnitudes are perturbed; directions are preserved.</p> <code>False</code> <code>seed</code> <code>int or None</code> <code>None</code> <p>Returns:</p> Type Description <code>ndarray of shape ``(N, 3)``</code> <p>Jittered velocity vectors.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If inputs are invalid (propagated from the backend).</p> See Also <p><code>speed_along</code> <code>disk_speed</code></p>"},{"location":"api/point/#npblender.domain.Point.speed_along","title":"speed_along","text":"<pre><code>speed_along(speed=1, direction=(0, 0, 1), angle=np.pi / 2, scale=None, use_vonmises=False, seed=None)\n</code></pre> <p>Sample velocity vectors within a cone around a direction.</p> <p>Returns random 3D vectors with magnitudes given by <code>speed</code> and directions sampled within a cone of half-angle <code>angle</code> around <code>direction</code>. Useful to initialize per-point velocities.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float or (N,) or (N, 3)</code> <p>Target magnitudes (broadcastable).</p> <code>1</code> <code>direction</code> <code>(3,) or (N, 3)</code> <p>Cone axis per point (broadcastable).</p> <code>(0, 0, 1)</code> <code>angle</code> <code>float</code> <p>Cone half-angle (radians).</p> <code>pi/2</code> <code>scale</code> <code>(3,) float or None</code> <p>Optional anisotropic scaling of the cone.</p> <code>None</code> <code>use_vonmises</code> <code>bool</code> <p>If <code>True</code>, directions follow a Von Mises\u2013Fisher-like distribution.</p> <code>False</code> <code>seed</code> <code>int or None</code> <code>None</code> <p>Returns:</p> Type Description <code>ndarray of shape ``(N, 3)``</code> <p>Sampled velocity vectors.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If inputs cannot be broadcast/aligned (propagated from the backend).</p>"},{"location":"api/point/#npblender.domain.Point.to_bl_attributes","title":"to_bl_attributes","text":"<pre><code>to_bl_attributes(attributes, update=False)\n</code></pre> <p>Export attributes to a Blender attribute collection.</p> <p>Writes eligible domain attributes to a Blender data-block, creating missing attributes and adjusting sizes as needed.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Any</code> <p>Blender attributes collection receiving the values.</p> required <code>update</code> <code>bool</code> <p>If <code>True</code>, update existing attributes in-place; otherwise create them when missing.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Caution:*** Only attributes with `transfer=True` are exported. Optional</code> <code>attributes are skipped.</code> <code>&gt; ***Caution:*** Curve domains user attributes are not saved.</code>"},{"location":"api/point/#npblender.domain.Point.to_dict","title":"to_dict","text":"<pre><code>to_dict(*, copy=True, with_infos=True)\n</code></pre> <p>Convert the array to a dictionary of fields or (field, infos) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Whether to copy the arrays.</p> <code>True</code> <code>with_infos</code> <code>bool</code> <p>If True, return (array, infos) for each field.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, array or (array, dict)]</code>"},{"location":"api/point/#npblender.domain.Point.transfer_attributes","title":"transfer_attributes","text":"<pre><code>transfer_attributes(other, shape=None, other_shape=None)\n</code></pre> <p>Transfer values of trans-domain attributes from another domain.</p> <p>Copies values for each trans-domain attribute present in <code>other</code> into the corresponding attributes of <code>self</code>, with optional reshaping for batched assignments.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain</code> <p>Source domain providing attribute values.</p> required <code>shape</code> <code>tuple of int or None</code> <p>Target reshape for <code>self</code> before assignment. If <code>None</code>, uses <code>(self._length,)</code>.</p> <code>None</code> <code>other_shape</code> <code>tuple of int or None</code> <p>Source reshape for <code>other</code> before assignment. If <code>None</code>, uses <code>(other._length,)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p> <code>&gt; ***Note:*** Each attribute is reshaped as `shape + item_shape` on `self`</code> <code>and `other_shape + item_shape` on `other` prior to assignment.</code>"},{"location":"api/point/#npblender.domain.Point.transform","title":"transform","text":"<pre><code>transform(transfo, pivot=None)\n</code></pre> <p>Transform positions and compose stored orientation.</p> <p>First applies the linear transform to <code>position</code> via the base implementation (<code>transform</code>). Then, if a rotation field exists (<code>euler</code> or <code>quat</code>), composes it with <code>transfo</code>\u2019s rotation component and writes back to the same representation.</p> <p>Parameters:</p> Name Type Description Default <code>transfo</code> <code>array - like or object</code> <p>Transform(s) broadcastable to the domain size. Typical shapes include <code>(..., 3, 3)</code>; project transform types are also supported if they implement <code>@</code> with vectors and expose a <code>.rotation</code> component.</p> required <code>pivot</code> <code>array-like of shape ``(..., 3)`` or None</code> <p>Pivot location(s). If <code>None</code>, transforms are applied about the origin.</p> <code>None</code> <p>Returns:</p> Type Description <code>Point</code> <p>Self (for chaining).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If broadcasting cannot align inputs with the domain (raised by <code>_get_shape_for_operation</code>).</p> <code>TypeError</code> <p>If <code>transfo</code> does not support the <code>@</code> operator with vectors or lacks a usable rotation component.</p>"},{"location":"api/point/#npblender.domain.Point.translate","title":"translate","text":"<pre><code>translate(translation)\n</code></pre> <p>Translate points position by a vector or a batch of vectors.</p> <p>Supports per-domain translation (single vector), or grouped/batched translations that broadcast over buckets of equal size.</p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>array-like of shape ``(..., 3)``</code> <p>Translation vectors broadcastable to the domain size.</p> required <p>Returns:</p> Type Description <code>PointDomain</code> <p>Self (for chaining).</p> <p>Examples:</p> <pre><code># Per-point random translation\nD.translate(np.random.uniform(-0.1, 0.1, (len(D), 3)))\n\n```python\n# A mesh made of 8 cubes\ncubes = Mesh.cube(size=.2)*8\ntr = np.random.uniform(-1, 1, (8, 3))\n# Translate each cube individually\ncubes.points.translate(tr)\n</code></pre> <p>Caution: If a provided batch cannot be aligned with the domain, a <code>ValueError</code> is raised by <code>_get_shape_for_operation</code>.</p>"},{"location":"api/quaternion/","title":"Quaternion","text":""},{"location":"api/quaternion/#npblender.Quaternion","title":"Quaternion","text":"<pre><code>Quaternion(mat, *, copy=True)\n</code></pre> <p>               Bases: <code>Rotation</code></p> <p>Quaternion representation of rotations (unit, xyzw convention).</p> <p>This subclass of Rotation stores each rotation as a 4D unit quaternion, and implements all core operations (compose, inverse, apply) via matrix conversion when needed.</p> <p>Internal shape: (..., 4)</p> <p>Initialize an ItemsArray from any array-like input.</p> <p>The input must be broadcastable to the expected item shape defined by the subclass via <code>_item_shape</code>. Typical examples include arrays of vectors, matrices, or quaternions.</p> <p>Parameters:</p> Name Type Description Default <code>mat</code> <code>array_like</code> <p>Input data to be wrapped. Must be broadcastable to shape (..., *_item_shape). For example, if <code>_item_shape = (3,)</code>, acceptable inputs include: - [1, 2, 3]                         \u2192 broadcasted to shape (1, 3) - [[1, 2, 3], [4, 5, 6]]            \u2192 shape (2, 3) - np.ones((10, 1, 3))               \u2192 shape (10, 1, 3)</p> required <code>copy</code> <code>bool</code> <p>If True, the input is copied. If False, a view is kept (when safe), which avoids unnecessary allocations.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input is not broadcastable to the required item shape.</p>"},{"location":"api/quaternion/#npblender.Quaternion.shape","title":"shape  <code>property</code>","text":"<pre><code>shape\n</code></pre> <p>Batch shape (everything except the final item_shape).</p>"},{"location":"api/quaternion/#npblender.Quaternion.size","title":"size  <code>property</code>","text":"<pre><code>size\n</code></pre> <p>Number of individual items.</p>"},{"location":"api/quaternion/#npblender.Quaternion.angle_to","title":"angle_to","text":"<pre><code>angle_to(other, degrees=False)\n</code></pre> <p>Compute the angular distance between this quaternion and another rotation.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Rotation</code> <p>Another rotation (can be any subclass of Rotation).</p> required <code>degrees</code> <code>bool</code> <p>If True, returns the angle in degrees.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Rotation angle(s) needed to go from self to other, shape (...,).</p>"},{"location":"api/quaternion/#npblender.Quaternion.apply","title":"apply","text":"<pre><code>apply(vectors)\n</code></pre> <p>Apply the quaternion rotation to 3D vectors.</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>array_like(..., 3)</code> <p>Vectors to rotate. Must be broadcastable with the rotation batch shape.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Rotated vectors, same shape as input.</p> Notes <p>Uses the formula:     v_rot = q \u22c5 v \u22c5 q\u207b\u00b9 where v is a pure quaternion with w=0.</p> <p>Broadcasting is supported across batch dimensions.</p>"},{"location":"api/quaternion/#npblender.Quaternion.as_array","title":"as_array","text":"<pre><code>as_array(dtype=None)\n</code></pre> <p>View on the internal array (no copy).</p>"},{"location":"api/quaternion/#npblender.Quaternion.as_axis_angle","title":"as_axis_angle","text":"<pre><code>as_axis_angle(tol=1e-06, degrees=False)\n</code></pre> <p>Convert each quaternion to an axis\u2013angle pair.</p> <p>Parameters:</p> Name Type Description Default <code>tol</code> <code>float</code> <p>Numerical tolerance: angles below this are treated as zero.</p> <code>1e-6</code> <code>degrees</code> <code>bool</code> <p>If True, angles are returned in degrees instead of radians.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>axis</code> <code>ndarray(..., 3)</code> <p>Unit rotation axes.</p> <code>angle</code> <code>ndarray(...)</code> <p>Rotation angles.</p> Notes <ul> <li>Quaternions must be normalized.</li> <li>For angles close to zero, axis is set arbitrarily to [1, 0, 0].</li> </ul>"},{"location":"api/quaternion/#npblender.Quaternion.as_euler","title":"as_euler","text":"<pre><code>as_euler(order='XYZ', degrees=False)\n</code></pre> <p>Convert each quaternion to Euler/Tait\u2013Bryan angles.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>(XYZ, XZY, YXZ, YZX, ZXY, ZYX)</code> <p>Axis order used for the decomposition (uppercase = intrinsic/body-fixed).</p> <code>'XYZ'</code> <code>degrees</code> <code>bool</code> <p>If True, angles are returned in degrees instead of radians.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Euler angles of shape (..., 3), in the specified order.</p>"},{"location":"api/quaternion/#npblender.Quaternion.as_matrix","title":"as_matrix","text":"<pre><code>as_matrix()\n</code></pre> <p>Convert each quaternion to a 3\u00d73 rotation matrix.</p>"},{"location":"api/quaternion/#npblender.Quaternion.as_quaternion","title":"as_quaternion","text":"<pre><code>as_quaternion()\n</code></pre> <p>Return the raw quaternion array (xyzw, shape (..., 4)).</p>"},{"location":"api/quaternion/#npblender.Quaternion.broadcast_to","title":"broadcast_to","text":"<pre><code>broadcast_to(shape)\n</code></pre> <p>Broadcast the array to a new batch shape.</p> <p>This is equivalent to <code>np.broadcast_to(...)</code>, preserving the item shape. No copy is made.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple of int</code> <p>New shape for the batch dimensions.</p> required <p>Returns:</p> Type Description <code>ItemsArray</code> <p>A new view with broadcasted shape.</p>"},{"location":"api/quaternion/#npblender.Quaternion.compose","title":"compose","text":"<pre><code>compose(other)\n</code></pre> <p>Compose this quaternion with another rotation (self \u2218 other).</p> <p>Internally performs a Hamilton product: self @ other.as_quaternion()</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Rotation</code> <p>The second rotation to apply (any type: matrix, quaternion, ...).</p> required <p>Returns:</p> Type Description <code>Quaternion</code> <p>Composed rotation, of the same type as <code>self</code>.</p>"},{"location":"api/quaternion/#npblender.Quaternion.filter","title":"filter","text":"<pre><code>filter(mask, in_place=False)\n</code></pre> <p>Filter transformations using a boolean mask.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>array_like(...)</code> <p>Boolean mask matching the shape of the batch.</p> required <code>in_place</code> <code>bool</code> <p>If True, modifies the current instance. Otherwise, returns a new one.</p> <code>False</code> <p>Returns:</p> Type Description <code>ItemsArray</code> <p>Filtered array (or self if in_place is True).</p>"},{"location":"api/quaternion/#npblender.Quaternion.from_axis_angle","title":"from_axis_angle  <code>classmethod</code>","text":"<pre><code>from_axis_angle(axis, angle, *, normalize_axis=True, degrees=False)\n</code></pre> <p>Construct a Quaternion from an axis\u2013angle pair.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>array_like(..., 3)</code> <p>Rotation axis (x,\u202fy,\u202fz). Does not need to be unit length if <code>normalize_axis=True</code>.</p> required <code>angle</code> <code>array_like(...)</code> <p>Rotation angle (radians by default), broadcastable with <code>axis</code>.</p> required <code>normalize_axis</code> <code>bool</code> <p>Normalise the axis to unit length before conversion.</p> <code>True</code> <code>degrees</code> <code>bool</code> <p>Interpret <code>angle</code> in degrees instead of radians.</p> <code>False</code> <p>Returns:</p> Type Description <code>Quaternion</code> <p>Quaternion representing the given axis\u2013angle rotation.</p>"},{"location":"api/quaternion/#npblender.Quaternion.from_euler","title":"from_euler  <code>classmethod</code>","text":"<pre><code>from_euler(euler, *, order='XYZ', degrees=False)\n</code></pre> <p>Construct a Quaternion from Euler angles.</p> <p>Parameters:</p> Name Type Description Default <code>euler</code> <code>array_like(..., 3)</code> <p>Angles for the three axes, in the order specified by <code>order</code>.</p> required <code>order</code> <code>(XYZ, XZY, YXZ, YZX, ZXY, ZYX)</code> <p>Axis order (uppercase = intrinsic / body\u2011fixed convention).</p> <code>'XYZ'</code> <code>degrees</code> <code>bool</code> <p>If True, <code>euler</code> is interpreted in degrees instead of radians.</p> <code>False</code> <p>Returns:</p> Type Description <code>Quaternion</code> <p>Quaternion representing the composed rotation.</p>"},{"location":"api/quaternion/#npblender.Quaternion.from_euler_OLD","title":"from_euler_OLD  <code>classmethod</code>","text":"<pre><code>from_euler_OLD(euler, *, order='XYZ', degrees=False)\n</code></pre> <p>Construct a rotation from Euler/Tait\u2011Bryan angles.</p> <p>Parameters:</p> Name Type Description Default <code>euler</code> <code>array_like(..., 3)</code> <p>Angles for the three axes, in the order specified by <code>order</code>.</p> required <code>order</code> <code>(XYZ, XZY, YXZ, YZX, ZXY, ZYX)</code> <p>Axis order (uppercase = intrinsic / body\u2011fixed convention).</p> <code>'XYZ'</code> <code>degrees</code> <code>bool</code> <p>Interpret <code>euler</code> in degrees instead of radians.</p> <code>False</code> <p>Returns:</p> Type Description <code>Rotation</code> <p>Rotation instance representing the Euler angles.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>order</code> is not one of the supported axis permutations.</p> Notes <p>\u2022 Uses the right\u2011hand rule for each elemental rotation. \u2022 Broadcasting works: <code>euler</code> can have any leading batch shape.</p>"},{"location":"api/quaternion/#npblender.Quaternion.from_euler_OLD2","title":"from_euler_OLD2  <code>classmethod</code>","text":"<pre><code>from_euler_OLD2(euler, *, order='XYZ', degrees=False)\n</code></pre> <p>Construct a rotation from Euler angles using intrinsic XYZ order.</p>"},{"location":"api/quaternion/#npblender.Quaternion.from_matrix","title":"from_matrix  <code>classmethod</code>","text":"<pre><code>from_matrix(mat, *, normalize=True)\n</code></pre> <p>Construct a Quaternion from rotation matrices.</p> <p>Parameters:</p> Name Type Description Default <code>mat</code> <code>array_like(..., 3, 3)</code> <p>Input rotation matrices.</p> required <code>normalize</code> <code>bool</code> <p>If True, output quaternions are normalized.</p> <code>True</code> <p>Returns:</p> Type Description <code>Quaternion</code>"},{"location":"api/quaternion/#npblender.Quaternion.from_quaternion","title":"from_quaternion  <code>classmethod</code>","text":"<pre><code>from_quaternion(quat, *, normalize=True, tol=1e-05)\n</code></pre> <p>Construct a Quaternion from raw (x\u202fy\u202fz\u202fw) values.</p> <p>Parameters:</p> Name Type Description Default <code>quat</code> <code>array_like(..., 4)</code> <p>Input quaternions in (x, y, z, w) order. Must be broadcastable.</p> required <code>normalize</code> <code>bool</code> <p>If True, the input is renormalised to unit length.</p> <code>True</code> <code>tol</code> <code>float</code> <p>Tolerance for the norm check when <code>normalize=False</code>.</p> <code>1e-5</code> <p>Returns:</p> Type Description <code>Quaternion</code> <p>Instance storing the (possibly normalised) quaternions.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If shape is wrong or quaternions are not unit (when normalize=False).</p>"},{"location":"api/quaternion/#npblender.Quaternion.from_quaternion_MAUVAISE_CONVENTION","title":"from_quaternion_MAUVAISE_CONVENTION  <code>classmethod</code>","text":"<pre><code>from_quaternion_MAUVAISE_CONVENTION(quat, *, normalize=True, tol=1e-05)\n</code></pre> <p>Construct a Rotation from unit quaternions (xyzw convention).</p> <p>Parameters:</p> Name Type Description Default <code>quat</code> <code>array_like(..., 4)</code> <p>Input quaternions in (x, y, z, w) order. Must be broadcastable.</p> required <code>normalize</code> <code>bool</code> <p>If True, normalizes the input quaternions to unit norm.</p> <code>True</code> <code>tol</code> <code>float</code> <p>Tolerance used to check if quaternions are close to unit length (if normalize=False).</p> <code>1e-5</code> <p>Returns:</p> Type Description <code>Rotation</code> <p>Rotation instance representing the quaternions.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input shape is invalid or quaternions are not unit (when normalize=False).</p>"},{"location":"api/quaternion/#npblender.Quaternion.from_vectors","title":"from_vectors  <code>staticmethod</code>","text":"<pre><code>from_vectors(v_src, v_dst, normalized=False)\n</code></pre> <p>Constructs a rotation (as a quaternion) that rotates v_src onto v_dst.</p> <p>Parameters:</p> Name Type Description Default <code>v_src</code> <code>(array_like, shape(..., 3))</code> <p>Source vectors.</p> required <code>v_dst</code> <code>(array_like, shape(..., 3))</code> <p>Target vectors.</p> required <p>Returns:</p> Type Description <code>Rotation</code> <p>Rotation that aligns v_src with v_dst.</p>"},{"location":"api/quaternion/#npblender.Quaternion.identity","title":"identity  <code>classmethod</code>","text":"<pre><code>identity(shape=())\n</code></pre> <p>Return the identity quaternion (no rotation).</p>"},{"location":"api/quaternion/#npblender.Quaternion.interpolate","title":"interpolate","text":"<pre><code>interpolate(other, t)\n</code></pre> <p>Performs spherical linear interpolation (SLERP) between two rotations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Rotation</code> <p>The target rotation to interpolate to.</p> required <code>t</code> <code>float or ndarray</code> <p>Interpolation parameter(s), where 0 gives self and 1 gives other. Supports broadcasting over batch dimensions.</p> required <p>Returns:</p> Type Description <code>Quaternion</code> <p>Interpolated rotations as quaternions.</p>"},{"location":"api/quaternion/#npblender.Quaternion.inverse","title":"inverse","text":"<pre><code>inverse()\n</code></pre> <p>Return the inverse (conjugate) of the unit quaternion.</p>"},{"location":"api/quaternion/#npblender.Quaternion.is_identity","title":"is_identity","text":"<pre><code>is_identity(tol=1e-06)\n</code></pre> <p>Test whether each quaternion is (numerically) the identity rotation.</p> <p>Parameters:</p> Name Type Description Default <code>tol</code> <code>float</code> <p>Tolerance on the angular deviation from identity.</p> <code>1e-6</code> <p>Returns:</p> Type Description <code>bool or ndarray</code> <p>\u2022 If the quaternion is scalar (no batch), returns a single bool. \u2022 Otherwise, returns a boolean array with the same batch shape.</p>"},{"location":"api/quaternion/#npblender.Quaternion.look_at","title":"look_at  <code>staticmethod</code>","text":"<pre><code>look_at(v_src, v_dst, up=None, upward=(0, 0, 1), normalized=False)\n</code></pre> <p>Build a Rotation that aligns the local frame (v_src, up) to (v_dst, upward), preserving right-handedness.</p> <p>If <code>up</code> is None, only the forward direction is used (i.e. v_src \u2192 v_dst), and roll is undefined. The returned rotation minimizes the angular difference.</p> <p>Parameters:</p> Name Type Description Default <code>v_src</code> <code>(array_like, shape(..., 3))</code> <p>Source forward vector(s).</p> required <code>v_dst</code> <code>(array_like, shape(..., 3))</code> <p>Target forward vector(s).</p> required <code>up</code> <code>(array_like, shape(..., 3))</code> <p>Up vector(s) in the source frame. If None, only direction is used.</p> <code>None</code> <code>upward</code> <code>(array_like, shape(..., 3))</code> <p>Up vector(s) in the destination frame.</p> <code>(0, 0, 1)</code> <code>normalized</code> <code>bool</code> <p>If True, assume v_src and v_dst are already unit vectors.</p> <code>False</code> <p>Returns:</p> Type Description <code>Rotation</code> <p>Rotation matrix (3\u00d73 or batch of matrices) aligning v_src to v_dst.</p>"},{"location":"api/quaternion/#npblender.Quaternion.reshape","title":"reshape","text":"<pre><code>reshape(*new_shape)\n</code></pre> <p>Reshape the batch dimensions of the array, preserving the item shape.</p> <p>The total number of items must remain unchanged. This is equivalent to <code>np.reshape()</code> on the batch dimensions only, i.e., the trailing <code>_item_shape</code> is preserved.</p> <p>Parameters:</p> Name Type Description Default <code>*new_shape</code> <code>int</code> <p>New shape for the batch. Must satisfy <code>np.prod(new_shape) == self.size</code>.</p> <code>()</code> <p>Returns:</p> Type Description <code>ItemsArray</code> <p>A new reshaped view of the same data (no copy).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the total number of items does not match.</p>"},{"location":"api/quaternion/#npblender.Quaternion.resize","title":"resize","text":"<pre><code>resize(*new_shape, fill=0.0)\n</code></pre> <p>Resize the batch to a new shape, preserving item shape.</p> <p>If the total number of items remains unchanged, the underlying array is simply reshaped (no allocation). Otherwise, a new array is created and filled with the given value. Existing data is preserved as much as possible (copied in row-major order).</p> <p>Parameters:</p> Name Type Description Default <code>*new_shape</code> <code>int</code> <p>New shape for the batch (excluding the item shape). Can increase or decrease the number of items.</p> <code>()</code> <code>fill</code> <code>float</code> <p>Value used to initialize new items when the array is enlarged.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>ItemsArray</code> <p>The current instance (resized in place).</p>"},{"location":"api/quaternion/#npblender.Quaternion.wxyz_to_xyzw","title":"wxyz_to_xyzw  <code>staticmethod</code>","text":"<pre><code>wxyz_to_xyzw(array, normalize=True)\n</code></pre> <p>Convert quaternions from (w, x, y, z) to (x, y, z, w) order.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>(array_like, shape(..., 4))</code> <p>Input array of quaternions in (w, x, y, z) order.</p> required <code>normalize</code> <code>bool</code> <p>If True, normalize the quaternion(s) to unit length.</p> <code>True</code> <p>Returns:</p> Type Description <code>(ndarray, shape(..., 4))</code> <p>Array of quaternions in (x, y, z, w) order.</p> <code>&gt; ***Caution:*** This does not construct a `Quaternion` object,</code> <code>it only reorders the array.</code>"},{"location":"api/quaternion/#npblender.Quaternion.xyzw_to_wxyz","title":"xyzw_to_wxyz  <code>staticmethod</code>","text":"<pre><code>xyzw_to_wxyz(array)\n</code></pre> <p>Convert quaternions from (x, y, z, w) to (w, x, y, z) order.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>(array_like, shape(..., 4))</code> <p>Input array of quaternions in (x, y, z, w) order.</p> required <p>Returns:</p> Type Description <code>(ndarray, shape(..., 4))</code> <p>Array of quaternions in (w, x, y, z) order.</p> <code>&gt; ***Note:*** This does not normalize the quaternion(s).</code>"},{"location":"api/rotation/","title":"Rotation","text":""},{"location":"api/rotation/#npblender.Rotation","title":"Rotation","text":"<pre><code>Rotation(mat, *, copy=True)\n</code></pre> <p>               Bases: <code>ItemsArray</code></p> <p>Rotation represented as 3\u00d73 matrices.</p> <p>This class wraps batches of rotation matrices and provides methods for applying, composing and inverting them.</p> <p>All rotations must have shape (..., 3, 3) and be valid rotation matrices.</p> <p>Initialize an ItemsArray from any array-like input.</p> <p>The input must be broadcastable to the expected item shape defined by the subclass via <code>_item_shape</code>. Typical examples include arrays of vectors, matrices, or quaternions.</p> <p>Parameters:</p> Name Type Description Default <code>mat</code> <code>array_like</code> <p>Input data to be wrapped. Must be broadcastable to shape (..., *_item_shape). For example, if <code>_item_shape = (3,)</code>, acceptable inputs include: - [1, 2, 3]                         \u2192 broadcasted to shape (1, 3) - [[1, 2, 3], [4, 5, 6]]            \u2192 shape (2, 3) - np.ones((10, 1, 3))               \u2192 shape (10, 1, 3)</p> required <code>copy</code> <code>bool</code> <p>If True, the input is copied. If False, a view is kept (when safe), which avoids unnecessary allocations.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input is not broadcastable to the required item shape.</p>"},{"location":"api/rotation/#npblender.Rotation.shape","title":"shape  <code>property</code>","text":"<pre><code>shape\n</code></pre> <p>Batch shape (everything except the final item_shape).</p>"},{"location":"api/rotation/#npblender.Rotation.size","title":"size  <code>property</code>","text":"<pre><code>size\n</code></pre> <p>Number of individual items.</p>"},{"location":"api/rotation/#npblender.Rotation.angle_to","title":"angle_to","text":"<pre><code>angle_to(other, degrees=False)\n</code></pre> <p>Compute the angular distance between two rotations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Rotation</code> <p>The other rotation(s) to compare with.</p> required <code>degrees</code> <code>bool</code> <p>If True, return angle in degrees instead of radians.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Angle(s) of shape <code>(...)</code>, same batch shape as self and other (broadcasted), representing the rotation needed to go from <code>self</code> to <code>other</code>.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not a Rotation.</p>"},{"location":"api/rotation/#npblender.Rotation.apply","title":"apply","text":"<pre><code>apply(vectors)\n</code></pre> <p>Apply the rotation to a set of 3D vectors.</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>array_like(..., 3)</code> <p>Vectors to rotate. Must be broadcastable with the rotation batch shape.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Rotated vectors, same shape as input.</p>"},{"location":"api/rotation/#npblender.Rotation.as_array","title":"as_array","text":"<pre><code>as_array(dtype=None)\n</code></pre> <p>View on the internal array (no copy).</p>"},{"location":"api/rotation/#npblender.Rotation.as_axis_angle","title":"as_axis_angle","text":"<pre><code>as_axis_angle(tol=1e-06, degrees=False)\n</code></pre> <p>Convert each rotation matrix to an axis\u2013angle pair.</p> <p>Parameters:</p> Name Type Description Default <code>tol</code> <code>float</code> <p>Numerical tolerance to treat very small angles as zero.</p> <code>1e-6</code> <code>degrees</code> <code>bool</code> <p>If True, the returned angles are in degrees instead of radians.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>axis</code> <code>ndarray(..., 3)</code> <p>Unit vectors representing the rotation axes.</p> <code>angle</code> <code>ndarray(...)</code> <p>Rotation angles (same batch shape as <code>axis</code> without the last dimension).</p> Notes <p>\u2022 Uses the <code>xyzw</code> quaternion sign convention internally (but does not return quaternions). \u2022 When the angle is below <code>tol</code>, the axis is arbitrarily set to <code>[1, 0, 0]</code>. \u2022 The function is batch\u2011compatible and produces a separate array for the angles so that both outputs can be used independently:</p> <pre><code>axis, theta = R.as_axis_angle()\n</code></pre>"},{"location":"api/rotation/#npblender.Rotation.as_euler","title":"as_euler","text":"<pre><code>as_euler(order='XYZ', degrees=False)\n</code></pre> <p>Convert each rotation matrix to Euler angles (XYZ intrinsic order).</p>"},{"location":"api/rotation/#npblender.Rotation.as_matrix","title":"as_matrix","text":"<pre><code>as_matrix()\n</code></pre> <p>Return the underlying rotation matrices (view, no copy).</p>"},{"location":"api/rotation/#npblender.Rotation.as_quaternion","title":"as_quaternion","text":"<pre><code>as_quaternion()\n</code></pre> <p>Convert each rotation matrix to a quaternion (xyzw convention).</p> <p>Returns:</p> Type Description <code>Quaternion</code> <p>Quaternions of shape (..., 4), in (x, y, z, w) order.</p>"},{"location":"api/rotation/#npblender.Rotation.broadcast_to","title":"broadcast_to","text":"<pre><code>broadcast_to(shape)\n</code></pre> <p>Broadcast the array to a new batch shape.</p> <p>This is equivalent to <code>np.broadcast_to(...)</code>, preserving the item shape. No copy is made.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple of int</code> <p>New shape for the batch dimensions.</p> required <p>Returns:</p> Type Description <code>ItemsArray</code> <p>A new view with broadcasted shape.</p>"},{"location":"api/rotation/#npblender.Rotation.compose","title":"compose","text":"<pre><code>compose(other)\n</code></pre> <p>Compose this rotation with another Rotation instance.</p> <p>The resulting rotation applies <code>self</code> first, then <code>other</code>, i.e.:</p> <pre><code>composed = self \u2218 other  \u21d4  composed @ v == other @ (self @ v)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Rotation</code> <p>The second rotation to compose. Must be a Rotation instance.</p> required <p>Returns:</p> Type Description <code>Rotation</code> <p>The composed rotation. A new object is always returned.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>other</code> is not a Rotation instance.</p> Notes <p>\u2022 Fully supports broadcasting over batch dimensions. \u2022 This method is functionally equivalent to: <code>self @ other</code>.</p>"},{"location":"api/rotation/#npblender.Rotation.filter","title":"filter","text":"<pre><code>filter(mask, in_place=False)\n</code></pre> <p>Filter transformations using a boolean mask.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>array_like(...)</code> <p>Boolean mask matching the shape of the batch.</p> required <code>in_place</code> <code>bool</code> <p>If True, modifies the current instance. Otherwise, returns a new one.</p> <code>False</code> <p>Returns:</p> Type Description <code>ItemsArray</code> <p>Filtered array (or self if in_place is True).</p>"},{"location":"api/rotation/#npblender.Rotation.from_axis_angle","title":"from_axis_angle  <code>classmethod</code>","text":"<pre><code>from_axis_angle(axis, angle, *, normalize_axis=True, degrees=False)\n</code></pre> <p>Construct a rotation from an axis\u2013angle pair.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>array_like(..., 3)</code> <p>Rotation axis. Does not need to be unit length if <code>normalize_axis=True</code>.</p> required <code>angle</code> <code>array_like(...)</code> <p>Rotation angle, broadcastable to the batch shape of <code>axis</code>.</p> required <code>normalize_axis</code> <code>bool</code> <p>Normalise the axis to unit length before constructing the matrix.</p> <code>True</code> <code>degrees</code> <code>bool</code> <p>If True, <code>angle</code> is interpreted in degrees instead of radians.</p> <code>False</code> <p>Returns:</p> Type Description <code>Rotation</code> <p>Rotation instance representing the axis\u2013angle pair.</p> Notes <p>\u2022 Uses the right\u2011hand rule. \u2022 Supports arbitrary batch shapes; <code>axis</code> and <code>angle</code> are broadcast together.</p>"},{"location":"api/rotation/#npblender.Rotation.from_euler_OLD","title":"from_euler_OLD  <code>classmethod</code>","text":"<pre><code>from_euler_OLD(euler, *, order='XYZ', degrees=False)\n</code></pre> <p>Construct a rotation from Euler/Tait\u2011Bryan angles.</p> <p>Parameters:</p> Name Type Description Default <code>euler</code> <code>array_like(..., 3)</code> <p>Angles for the three axes, in the order specified by <code>order</code>.</p> required <code>order</code> <code>(XYZ, XZY, YXZ, YZX, ZXY, ZYX)</code> <p>Axis order (uppercase = intrinsic / body\u2011fixed convention).</p> <code>'XYZ'</code> <code>degrees</code> <code>bool</code> <p>Interpret <code>euler</code> in degrees instead of radians.</p> <code>False</code> <p>Returns:</p> Type Description <code>Rotation</code> <p>Rotation instance representing the Euler angles.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>order</code> is not one of the supported axis permutations.</p> Notes <p>\u2022 Uses the right\u2011hand rule for each elemental rotation. \u2022 Broadcasting works: <code>euler</code> can have any leading batch shape.</p>"},{"location":"api/rotation/#npblender.Rotation.from_euler_OLD2","title":"from_euler_OLD2  <code>classmethod</code>","text":"<pre><code>from_euler_OLD2(euler, *, order='XYZ', degrees=False)\n</code></pre> <p>Construct a rotation from Euler angles using intrinsic XYZ order.</p>"},{"location":"api/rotation/#npblender.Rotation.from_matrix","title":"from_matrix  <code>classmethod</code>","text":"<pre><code>from_matrix(mat, *, validate=True, tol=1e-05)\n</code></pre> <p>Construct a Rotation from raw 3\u00d73 matrices.</p> <p>Parameters:</p> Name Type Description Default <code>mat</code> <code>array_like(..., 3, 3)</code> <p>One or more candidate rotation matrices.</p> required <code>validate</code> <code>bool</code> <p>If True, checks that matrices are orthogonal and have determinant close to 1.</p> <code>True</code> <code>tol</code> <code>float</code> <p>Tolerance used for validation.</p> <code>1e-5</code> <p>Returns:</p> Type Description <code>Rotation</code> <p>New instance wrapping the validated (or unvalidated) matrices.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation is enabled and any matrix is not a proper rotation.</p>"},{"location":"api/rotation/#npblender.Rotation.from_quaternion","title":"from_quaternion  <code>classmethod</code>","text":"<pre><code>from_quaternion(quat, *, normalize=True, tol=1e-05)\n</code></pre> <p>Construct a Rotation from unit quaternions (x, y, z, w convention).</p> <p>Parameters:</p> Name Type Description Default <code>quat</code> <code>array_like(..., 4)</code> <p>Input quaternions in (x, y, z, w) order. Must be broadcastable.</p> required <code>normalize</code> <code>bool</code> <p>If True, normalizes the input quaternions to unit norm.</p> <code>True</code> <code>tol</code> <code>float</code> <p>Tolerance used to check if quaternions are close to unit length (if normalize=False).</p> <code>1e-5</code> <p>Returns:</p> Type Description <code>Rotation</code> <p>Rotation instance representing the quaternions.</p>"},{"location":"api/rotation/#npblender.Rotation.from_quaternion_MAUVAISE_CONVENTION","title":"from_quaternion_MAUVAISE_CONVENTION  <code>classmethod</code>","text":"<pre><code>from_quaternion_MAUVAISE_CONVENTION(quat, *, normalize=True, tol=1e-05)\n</code></pre> <p>Construct a Rotation from unit quaternions (xyzw convention).</p> <p>Parameters:</p> Name Type Description Default <code>quat</code> <code>array_like(..., 4)</code> <p>Input quaternions in (x, y, z, w) order. Must be broadcastable.</p> required <code>normalize</code> <code>bool</code> <p>If True, normalizes the input quaternions to unit norm.</p> <code>True</code> <code>tol</code> <code>float</code> <p>Tolerance used to check if quaternions are close to unit length (if normalize=False).</p> <code>1e-5</code> <p>Returns:</p> Type Description <code>Rotation</code> <p>Rotation instance representing the quaternions.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input shape is invalid or quaternions are not unit (when normalize=False).</p>"},{"location":"api/rotation/#npblender.Rotation.from_vectors","title":"from_vectors  <code>staticmethod</code>","text":"<pre><code>from_vectors(v_src, v_dst, normalized=False)\n</code></pre> <p>Constructs a rotation (as a quaternion) that rotates v_src onto v_dst.</p> <p>Parameters:</p> Name Type Description Default <code>v_src</code> <code>(array_like, shape(..., 3))</code> <p>Source vectors.</p> required <code>v_dst</code> <code>(array_like, shape(..., 3))</code> <p>Target vectors.</p> required <p>Returns:</p> Type Description <code>Rotation</code> <p>Rotation that aligns v_src with v_dst.</p>"},{"location":"api/rotation/#npblender.Rotation.identity","title":"identity  <code>classmethod</code>","text":"<pre><code>identity(shape=(), dtype=None)\n</code></pre> <p>Create an identity rotation for the given batch shape.</p>"},{"location":"api/rotation/#npblender.Rotation.interpolate","title":"interpolate","text":"<pre><code>interpolate(other, t)\n</code></pre> <p>Performs spherical linear interpolation (SLERP) between two rotations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Rotation</code> <p>The target rotation to interpolate to.</p> required <code>t</code> <code>float or ndarray</code> <p>Interpolation parameter(s), where 0 gives self and 1 gives other. Supports broadcasting over batch dimensions.</p> required <p>Returns:</p> Type Description <code>Quaternion</code> <p>Interpolated rotations as quaternions.</p>"},{"location":"api/rotation/#npblender.Rotation.inverse","title":"inverse","text":"<pre><code>inverse()\n</code></pre> <p>Return the inverse rotation (i.e., transpose of the matrix).</p> <p>Returns:</p> Type Description <code>Rotation</code> <p>Inverse of each rotation in the batch.</p>"},{"location":"api/rotation/#npblender.Rotation.is_identity","title":"is_identity","text":"<pre><code>is_identity(tol=1e-06)\n</code></pre> <p>Test whether each rotation in the batch is (numerically) the identity.</p> <p>Parameters:</p> Name Type Description Default <code>tol</code> <code>float</code> <p>Maximum absolute deviation allowed from the exact identity matrix.</p> <code>1e-6</code> <p>Returns:</p> Type Description <code>bool or ndarray</code> <p>\u2022 If the rotation is scalar (batch shape == ()), returns a single bool. \u2022 Otherwise, returns a boolean array with the same batch shape, where each element indicates whether the corresponding matrix is close to identity within <code>tol</code>.</p>"},{"location":"api/rotation/#npblender.Rotation.look_at","title":"look_at  <code>staticmethod</code>","text":"<pre><code>look_at(v_src, v_dst, up=None, upward=(0, 0, 1), normalized=False)\n</code></pre> <p>Build a Rotation that aligns the local frame (v_src, up) to (v_dst, upward), preserving right-handedness.</p> <p>If <code>up</code> is None, only the forward direction is used (i.e. v_src \u2192 v_dst), and roll is undefined. The returned rotation minimizes the angular difference.</p> <p>Parameters:</p> Name Type Description Default <code>v_src</code> <code>(array_like, shape(..., 3))</code> <p>Source forward vector(s).</p> required <code>v_dst</code> <code>(array_like, shape(..., 3))</code> <p>Target forward vector(s).</p> required <code>up</code> <code>(array_like, shape(..., 3))</code> <p>Up vector(s) in the source frame. If None, only direction is used.</p> <code>None</code> <code>upward</code> <code>(array_like, shape(..., 3))</code> <p>Up vector(s) in the destination frame.</p> <code>(0, 0, 1)</code> <code>normalized</code> <code>bool</code> <p>If True, assume v_src and v_dst are already unit vectors.</p> <code>False</code> <p>Returns:</p> Type Description <code>Rotation</code> <p>Rotation matrix (3\u00d73 or batch of matrices) aligning v_src to v_dst.</p>"},{"location":"api/rotation/#npblender.Rotation.reshape","title":"reshape","text":"<pre><code>reshape(*new_shape)\n</code></pre> <p>Reshape the batch dimensions of the array, preserving the item shape.</p> <p>The total number of items must remain unchanged. This is equivalent to <code>np.reshape()</code> on the batch dimensions only, i.e., the trailing <code>_item_shape</code> is preserved.</p> <p>Parameters:</p> Name Type Description Default <code>*new_shape</code> <code>int</code> <p>New shape for the batch. Must satisfy <code>np.prod(new_shape) == self.size</code>.</p> <code>()</code> <p>Returns:</p> Type Description <code>ItemsArray</code> <p>A new reshaped view of the same data (no copy).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the total number of items does not match.</p>"},{"location":"api/rotation/#npblender.Rotation.resize","title":"resize","text":"<pre><code>resize(*new_shape, fill=0.0)\n</code></pre> <p>Resize the batch to a new shape, preserving item shape.</p> <p>If the total number of items remains unchanged, the underlying array is simply reshaped (no allocation). Otherwise, a new array is created and filled with the given value. Existing data is preserved as much as possible (copied in row-major order).</p> <p>Parameters:</p> Name Type Description Default <code>*new_shape</code> <code>int</code> <p>New shape for the batch (excluding the item shape). Can increase or decrease the number of items.</p> <code>()</code> <code>fill</code> <code>float</code> <p>Value used to initialize new items when the array is enlarged.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>ItemsArray</code> <p>The current instance (resized in place).</p>"},{"location":"api/simulation/","title":"Simulation","text":""},{"location":"api/simulation/#npblender.Simulation","title":"Simulation","text":"<pre><code>Simulation(compute=None, reset=None, view=None)\n</code></pre> <p>               Bases: <code>Animation</code></p>"},{"location":"api/simulation/#npblender.Simulation.add_action","title":"add_action","text":"<pre><code>add_action(func, *args, start=0, duration=None, flags=0, **kwargs)\n</code></pre> <p>Add an action to the simulation</p> <p>To add an event, you can use &lt;#add_event&gt;.</p> Arguments <ul> <li>func (function) : function of template f(simulation, args, *kwargs)</li> <li>top (float = 0) : start time for the actiuon</li> <li>duration (float = None) : duration of the action (0: call once, None: never stops)</li> <li>after (bool = False) : exec the action after the exec_loop</li> </ul> <p>Returns:</p> Type Description <code>- Action : the action added to the simulation</code>"},{"location":"api/simulation/#npblender.Simulation.add_event","title":"add_event","text":"<pre><code>add_event(func, *args, start=0, flags=0, **kwargs)\n</code></pre> <p>Add an event to the simulation</p> <p>The event is executed once. To add an action called at each step, use &lt;#add_action&gt;.</p> Arguments <ul> <li>func (function) : function of template f(simulation, args, *kwargs)</li> <li>top (float = 0) : start time for the actiuon</li> <li>after (bool = False) : exec the action after the exec_loop</li> </ul> <p>Returns:</p> Type Description <code>- Action : the event added to the simulation</code>"},{"location":"api/simulation/#npblender.Simulation.change_attribute","title":"change_attribute","text":"<pre><code>change_attribute(attribute, value, incr=None, factor=None)\n</code></pre> <p>Modify a points attribute</p> <pre><code># gravity\nself.add_action(\"change_attribute\", \"accel\", value=(0, 0, -9.81))\n</code></pre>"},{"location":"api/simulation/#npblender.Simulation.newton_law","title":"newton_law","text":"<pre><code>newton_law(G=1, power=2, min_distance=0.001)\n</code></pre> <p>Newton's law between points</p> <p>The force between two points is given by:</p> <p>F = G.m1.m2 / dist**p</p>"},{"location":"api/simulation/#npblender.Simulation.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the simulation</p>"},{"location":"api/spline/","title":"Spline","text":""},{"location":"api/spline/#npblender.domain.Spline","title":"Spline","text":"<pre><code>Spline(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>Curve spline domain.</p> <p>Groups control points into splines and stores per-spline parameters (type, resolution, cyclic flags, and NURBS settings). Provides accessors to parametric functions and common evaluations.</p> <p>Attributes:</p> Name Type Description <code>loop_start</code> <code>(S,) int</code> <p>Starting control-point index of each spline.</p> <code>loop_total</code> <code>(S,) int</code> <p>Control-point count per spline.</p> <code>material_index</code> <code>(S,) int, optional</code> <p>Material index per spline.</p> <code>curve_type</code> <code>(S,) int</code> <p>One of constants <code>BEZIER</code>, <code>POLY</code>, <code>NURBS</code>.</p> <code>resolution</code> <code>(S,) int, optional</code> <p>Evaluation resolution (samples per segment).</p> <code>cyclic</code> <code>(S,) bool, optional</code> <p>Whether each spline is closed.</p> <code>order</code> <code>(S,) int, optional</code> <p>NURBS order.</p> <code>bezierpoint, endpoint</code> <code>(S,) bool, optional</code> <p>NURBS flags.</p> Properties <p>has_bezier : bool     True if any spline is Bezier. functions : list     List-like container of parametric spline functions (Bezier/Poly/NURBS). length : list of float     Length of each spline (delegates to <code>functions</code>).</p> <p>Methods:</p> Name Description <code>delete_splines</code> <p>Delete splines and their control points.</p> <code>add_splines</code> <p>Append new splines given control-point counts.</p> <code>tangent</code> <p>Evaluate tangents at parameter <code>t</code> in [0, 1].</p> <code>compute_attribute_on_points</code> <p>Broadcast per-spline attributes to control points.</p> <p>Examples:</p> <p>Build functions and sample tangents:</p> <pre><code>funcs = splines.functions\ntan = splines.tangent(0.25)\n</code></pre> <p>Append three splines with different sizes:</p> <pre><code>splines.add_splines([4, 6, 8], material_index=[0, 1, 1])\n</code></pre> <p>Note: <code>functions</code> relies on project spline implementations. Ensure control-point attributes (e.g., handles for Bezier, weights/order for NURBS) are present when required.</p> <p>Caution: <code>resolution</code> semantics differ for cyclic vs. non-cyclic splines (endpoints handling).</p> <p>Initialize a domain array and its attribute schema.</p> <p>Initializes the storage from an existing array/domain or creates an empty structure. Optionally merges attribute definitions/values from another domain and keyword-provided attributes.</p> <p>Domains are never instancied directly but by owning geometries.</p> <p>Actual Domains are <code>Vertex</code>, [<code>Faces</code>][npblender.domain.Faces], <code>Corner</code>, <code>Edge</code>, <code>ControlPoint</code>, <code>Spline</code> and <code>Point</code>.</p> <p>Domains are initialized with their defaults attributes, for instance <code>position</code> for point domaines.</p> <p>Use attributes can be freely added. </p> <p>Note: user attributes are saved in Blender Mesh objects only, Blender Curve objects don't store user attributes.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>array - like or FieldArray or None</code> <p>Source data used to initialize the domain. If <code>None</code>, an empty domain is created and <code>_declare_attributes()</code> is called to register defaults.</p> <code>None</code> <code>mode</code> <code>(COPY, CAPTURE, EMPTY)</code> <p>Initialization mode. <code>'COPY'</code> duplicates the input data, <code>'CAPTURE'</code> references the input buffer when supported, <code>'EMPTY'</code> creates the structure without copying values.</p> <code>'COPY'</code> <code>selector</code> <code>Any</code> <p>Optional row/element selector applied to <code>a</code> prior to initialization.</p> <code>None</code> <code>attr_from</code> <code>Domain or Mapping or None</code> <p>Attribute schema (and possibly values) to merge into this domain.</p> <code>None</code> <code>**attrs</code> <p>Additional attribute name/value pairs to inject or override.</p> <code>{}</code> Notes <p>The effective attribute list results from <code>_declare_attributes()</code>, then <code>attr_from</code>, then <code>**attrs</code> (later entries take precedence).</p> <p>Examples:</p> <pre><code>cube = Mesh.cube() # points, corners, faces and edges domains are created\n# Adding named attribute to point domain\ncube.points.new_float('age')\n# Setting the age\ncube.points.age = np.random.uniforme(10, 10, len(cube.points))\n</code></pre>"},{"location":"api/spline/#npblender.domain.Spline.actual_names","title":"actual_names  <code>property</code>","text":"<pre><code>actual_names\n</code></pre> <p>Column names.</p> <p>Returns the actual field names, excluding optional fields.</p>"},{"location":"api/spline/#npblender.domain.Spline.all_names","title":"all_names  <code>property</code>","text":"<pre><code>all_names\n</code></pre> <p>Column names.</p> <p>Returns all the field names, including optional ones.</p>"},{"location":"api/spline/#npblender.domain.Spline.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Array structured dtype</p> <p>Returns the dtype property of the structured array.</p>"},{"location":"api/spline/#npblender.domain.Spline.has_bezier","title":"has_bezier  <code>property</code>","text":"<pre><code>has_bezier\n</code></pre> <p>Check if the domain contains any B\u00e9zier splines.</p> <p>Evaluates the <code>curve_type</code> attribute and returns <code>True</code> if at least one spline in the domain is of type <code>BEZIER</code>.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the domain has at least one B\u00e9zier spline, <code>False</code> otherwise.</p> Notes <ul> <li>Useful for quickly testing whether B\u00e9zier-specific logic (e.g., handle attributes) must be considered.</li> <li>For mixed domains, the result is <code>True</code> as soon as one B\u00e9zier is present.</li> </ul> <p>Examples:</p> <pre><code>if splines.has_bezier:\n    print(\"Domain contains B\u00e9zier curves.\")\n</code></pre>"},{"location":"api/spline/#npblender.domain.Spline.next_loop_start","title":"next_loop_start  <code>property</code>","text":"<pre><code>next_loop_start\n</code></pre> <p>Offset to use for the next appended item.</p> <p>Returns:</p> Type Description <code>int</code> <p><code>loop_start[-1] + loop_total[-1]</code> if the domain is non-empty, otherwise <code>0</code>.</p> See Also <p><code>compute_loop_start</code></p>"},{"location":"api/spline/#npblender.domain.Spline.reversed_indices","title":"reversed_indices  <code>property</code>","text":"<pre><code>reversed_indices\n</code></pre> <p>Map each corner/control-point index back to its owning item.</p> <p>Returns:</p> Type Description <code>ndarray of shape ``(sum(loop_total),)``</code> <p>For index <code>k</code> in the flattened corner/control-point array, the value is the face/spline index that owns <code>k</code>.</p>"},{"location":"api/spline/#npblender.domain.Spline.transdom_names","title":"transdom_names  <code>property</code>","text":"<pre><code>transdom_names\n</code></pre> <p>List the names of trans-domain attributes.</p> <p>Returns:</p> Type Description <code>list of str</code> <p>Names of attributes flagged with <code>transdom=True</code>.</p> <p>Examples:</p> <pre><code>names = D.transdom_names()\n</code></pre>"},{"location":"api/spline/#npblender.domain.Spline.add","title":"add","text":"<pre><code>add(count, **fields)\n</code></pre> <p>Add count records</p> <p>New records are set with default values or values provided by the user in fields dict.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of records to add.</p> required <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/spline/#npblender.domain.Spline.append","title":"append","text":"<pre><code>append(**fields)\n</code></pre> <p>Append values to the structured array.</p> <p>The number of records to append is determined by the number of fields provided in the fields dictionary. The values of the fields are copied to the new records.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/spline/#npblender.domain.Spline.append_sizes","title":"append_sizes","text":"<pre><code>append_sizes(sizes, **fields)\n</code></pre> <p>Append new items given their sizes.</p> <p>If <code>loop_start</code> is not provided in <code>fields</code>, computes it from <code>sizes</code> using <code>compute_loop_start</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sizes</code> <code>array-like of int or None</code> <p>Number of corners/control-points for each new item.</p> required <code>**fields</code> <p>Additional per-item attributes to append (e.g., <code>material_index</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The value returned by <code>append(...)</code> (implementation-defined, often the indices/slice of appended items).</p> Notes <p>Passing <code>sizes=None</code> is a no-op and returns an empty list.</p>"},{"location":"api/spline/#npblender.domain.Spline.as_kwargs","title":"as_kwargs","text":"<pre><code>as_kwargs(selector=None, include=None, exclude=None)\n</code></pre> <p>Return a dictionary of field values formatted as kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>slice, int, list, or mask</code> <p>Optional selection of elements to extract.</p> <code>None</code> <code>include</code> <code>list[str]</code> <p>List of field names (original or python names) to include.</p> <code>None</code> <code>exclude</code> <code>list[str]</code> <p>List of field names (original or python names) to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Mapping from python-safe field names to array values.</p>"},{"location":"api/spline/#npblender.domain.Spline.check","title":"check","text":"<pre><code>check(count, halt=True)\n</code></pre> <p>Validate loop counters against a reference element count.</p> <p>Verifies that the sum of <code>loop_total</code> equals <code>count</code> (i.e., the total number of referenced elements such as corners or control points).</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Expected total number of elements referenced by all items.</p> required <code>halt</code> <code>bool</code> <p>If <code>True</code>, raise on failure; otherwise print a message and return <code>False</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the check passes or the domain is empty; <code>False</code> only when invalid and <code>halt</code> is <code>False</code>.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If <code>sum(loop_total) != count</code> and <code>halt</code> is <code>True</code>.</p> <p>Examples:</p> <pre><code>ok = fs.check(count=len(corners), halt=False)\nif not ok:\n    # fix topology or sizes, then recompute\n    fs.update_loop_start()\n</code></pre>"},{"location":"api/spline/#npblender.domain.Spline.compute_attribute_on_points","title":"compute_attribute_on_points","text":"<pre><code>compute_attribute_on_points(attr, points)\n</code></pre> <p>Expand spline attributes to control points.</p> <p>Broadcasts attributes defined per-spline into per-point arrays by repeating each spline\u2019s value over all its control points. This ensures compatibility when working in the control-point domain.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str or ndarray</code> <p>Attribute to expand. If a string, it is looked up in this domain. If an array, it must have length equal to the number of splines.</p> required <code>points</code> <code>ControlPoint</code> <p>Control-point domain that receives the expanded attributes. The result has length equal to <code>len(points)</code>.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of shape <code>(len(points), *attr_shape)</code> containing the broadcasted attribute values.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute is not found in this domain.</p> <code>ValueError</code> <p>If the provided attribute array shape does not match the number of splines.</p> Notes <ul> <li>Expansion uses the <code>loop_start</code> and <code>loop_total</code> arrays to map splines to their corresponding ranges of control points.</li> <li>This is the inverse of aggregating per-point attributes back to splines.</li> </ul> <p>Examples:</p> <pre><code># Broadcast per-spline weights to all control points\nw_points = splines.compute_attribute_on_points(\"weight\", cpoints)\n</code></pre>"},{"location":"api/spline/#npblender.domain.Spline.compute_loop_start","title":"compute_loop_start","text":"<pre><code>compute_loop_start(loop_total=None)\n</code></pre> <p>Compute offsets for one or many new items to append.</p> <p>Parameters:</p> Name Type Description Default <code>loop_total</code> <code>int or array-like of int or None</code> <p>Sizes of the items to add. If <code>None</code>, returns <code>None</code>. If a scalar, returns the single offset. If 1D array-like, returns one offset per size.</p> <code>None</code> <p>Returns:</p> Type Description <code>int or ndarray or None</code> <p>Offsets starting from <code>next_loop_start</code>, shaped like <code>loop_total</code>.</p> <p>Examples:</p> <pre><code># Prepare offsets for three faces of sizes 4, 5, 4\nstarts = fs.compute_loop_start([4, 5, 4])\nfs.append(loop_start=starts, loop_total=[4, 5, 4])\n</code></pre>"},{"location":"api/spline/#npblender.domain.Spline.copy_field","title":"copy_field","text":"<pre><code>copy_field(field_name, new_name, **infos)\n</code></pre> <p>Duplicate an existing field under a new name, with optional metadata overrides.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the existing field to copy.</p> required <code>new_name</code> <code>str</code> <p>The name of the new field to create.</p> required <code>infos</code> <code>keyword arguments</code> <p>Optional metadata (e.g. default, unit, description...) to override or supplement the original field's metadata.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the source field does not exist.</p> <code>ValueError</code> <p>If the target name already exists or is reserved.</p>"},{"location":"api/spline/#npblender.domain.Spline.delete","title":"delete","text":"<pre><code>delete(selection)\n</code></pre> <p>Delete selected items and maintain consistent offsets.</p> <p>After deleting items via <code>super().delete(selection)</code>, recomputes <code>loop_start</code> with <code>update_loop_start</code>.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>Any</code> <p>Boolean mask, integer index, slice, or array of indices.</p> required <p>Returns:</p> Type Description <code>None</code> See Also <p><code>update_loop_start</code></p>"},{"location":"api/spline/#npblender.domain.Spline.delete_splines","title":"delete_splines","text":"<pre><code>delete_splines(selection, cpoints)\n</code></pre> <p>Delete splines and their associated control points.</p> <p>Removes the splines selected in this domain, and deletes the corresponding control points from the given control-point domain. Corner indices are retrieved first to ensure consistent cleanup.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of bool or int</code> <p>Indices or boolean mask selecting which splines to delete.</p> required <code>cpoints</code> <code>ControlPoint</code> <p>Control-point domain from which the corresponding points are removed.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>IndexError</code> <p>If any index in <code>selection</code> is out of bounds for this domain.</p> <code>ValueError</code> <p>If <code>selection</code> has an incompatible shape or type.</p> Notes <ul> <li>This operation modifies both the spline domain and the control-point domain in place.</li> <li>Deletion preserves consistency between splines and their control points.</li> </ul> <p>Examples:</p> <pre><code># Delete the first spline and its control points\nsplines.delete_splines([0], cpoints)\n</code></pre>"},{"location":"api/spline/#npblender.domain.Spline.dump","title":"dump","text":"<pre><code>dump(title='Dump', attributes=None, target='SCREEN')\n</code></pre> <p>Pretty-print or export domain content.</p> <p>Formats attribute values and prints to screen or builds a tabular dump suitable for spreadsheets.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title displayed in the report.</p> <code>'Dump'</code> <code>attributes</code> <code>Sequence[str] or None</code> <p>Subset of attribute names to include. If <code>None</code>, all attributes are shown.</p> <code>None</code> <code>target</code> <code>(SCREEN, ...)</code> <p>Output target. <code>'SCREEN'</code> prints to stdout; other targets may trigger file creation depending on the implementation.</p> <code>'SCREEN'</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>Domain(points).dump(title=\"Vertices\")\n</code></pre> <p>Note: Formatting adapts to the chosen <code>target</code>.</p>"},{"location":"api/spline/#npblender.domain.Spline.extend","title":"extend","text":"<pre><code>extend(other, join_fields=True)\n</code></pre> <p>Append multiple records from another array or FieldArray.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray or structured np.ndarray</code> <p>The array of records to append. Must have named fields matching a subset of the current array's fields.</p> required"},{"location":"api/spline/#npblender.domain.Spline.filtered","title":"filtered","text":"<pre><code>filtered(selector, *, copy=False)\n</code></pre> <p>Return a FieldArray containing only the selected records.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>array\u2011like, slice or int</code> <p>Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice. It is applied to the current valid part of the buffer (<code>self._data[:self._length]</code>).</p> required <code>copy</code> <code>bool</code> <ul> <li>False    (default) =&gt; the new array shares the same memory                          (changes propagate both ways).</li> <li>True           =&gt; the data are physically copied.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>FieldArray</code> <p>A new instance holding exactly <code>len(selector)</code> records and inheriting the current field\u2011infos.</p>"},{"location":"api/spline/#npblender.domain.Spline.from_bl_attributes","title":"from_bl_attributes","text":"<pre><code>from_bl_attributes(bl_attributes)\n</code></pre> <p>Import attributes from a Blender attribute collection.</p> <p>Reads geometry attributes from a Blender data-block and creates/updates the corresponding domain attributes, resizing the domain if needed.</p> <p>Parameters:</p> Name Type Description Default <code>bl_attributes</code> <code>Mapping[str, Any]</code> <p>Blender attributes collection (name \u2192 attribute descriptor) providing at least <code>.domain</code>, <code>.is_internal</code>, <code>.data_type</code>, and <code>.data</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Note:*** Only external (non-internal) Blender attributes matching this</code> <code>domain are imported. Missing attributes are created with `transfer=True`.</code>"},{"location":"api/spline/#npblender.domain.Spline.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Build a FieldArray from a dictionary with field data and optional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, array - like or (array, dict)]</code> <p>Mapping field names to arrays or (array, infos). Infos must include NAME.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the data. Default: True.</p> required <p>Returns:</p> Type Description <code>FieldArray</code>"},{"location":"api/spline/#npblender.domain.Spline.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> <p>Get attribute by name.</p> <p>If name is not an actual field, return default value. Name can be an array. <pre><code>pos = field_array.get(\"position\", (0, 0, 1))\npos = field_array.get([[0, 0, 1], [0, 0, 0]])\n</code></pre></p>"},{"location":"api/spline/#npblender.domain.Spline.get_corner_indices","title":"get_corner_indices","text":"<pre><code>get_corner_indices()\n</code></pre> <p>Return the contiguous range of corner/control-point indices.</p> <p>For each item, expands its <code>[loop_start, loop_start + loop_total)</code> range and concatenates the result for all items.</p> <p>Returns:</p> Type Description <code>ndarray of shape ``(sum(loop_total),)``</code> <p>Absolute indices into the corner/control-point array.</p> Notes <p>A fast Numba kernel is used for vectorized cases; the scalar case is handled directly.</p>"},{"location":"api/spline/#npblender.domain.Spline.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other)\n</code></pre> <p>Merge trans-domain attributes from another domain.</p> <p>Copies or aligns attributes from <code>other</code> into the current domain, excluding any attributes not flagged as trans-domain in <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain or None</code> <p>Source domain. If <code>None</code>, the call is a no-op.</p> required <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p>"},{"location":"api/spline/#npblender.domain.Spline.join_fields","title":"join_fields","text":"<pre><code>join_fields(other, exclude=[])\n</code></pre> <p>Add all missing fields from another FieldArray.</p> <p>For every field in <code>other</code> that is not present in <code>self</code>, a new field is created with the same dtype and shape, and initialized with its default value across all existing records.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray</code> <p>Another FieldArray instance whose fields will be checked for missing fields.</p> required <p>Returns:</p> Type Description <code>self</code>"},{"location":"api/spline/#npblender.domain.Spline.load_bl_attributes","title":"load_bl_attributes","text":"<pre><code>load_bl_attributes(data)\n</code></pre> <p>Load spline attributes from a Blender object.</p> <p>Reads attributes stored in a Blender data block and transfers those that belong to the spline domain into this domain. New attributes are created if they do not already exist.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ID or similar</code> <p>Blender object or data block exposing an <code>attributes</code> mapping.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If reading or assignment of an attribute fails.</p> <code>AssertionError</code> <p>If Blender provides inconsistent attribute sizes.</p> Notes <ul> <li>Only attributes with a matching domain and not marked as internal are imported.</li> <li>If an attribute does not exist yet, it is created with the appropriate data type and marked as transferable.</li> <li>The domain is resized once to match the size of Blender attributes.</li> </ul> <p>Examples:</p> <pre><code>import bpy\nfrom npblender.domain import Spline\n\ncurve = bpy.data.curves[\"MyCurve\"]\nsplines = Spline()\nsplines.load_bl_attributes(curve)\n</code></pre>"},{"location":"api/spline/#npblender.domain.Spline.make_buckets","title":"make_buckets","text":"<pre><code>make_buckets(attr)\n</code></pre> <p>Group items into buckets by attribute value.</p> <p>When a domain is to be considered as a collection of packets of various sizes, buckets mechanism groups pakets by size, allowing further operation with numpy vectorization.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>array - like or str</code> <p>Either an integer of shape <code>(N,)</code> or the name of an existing integer attribute in the domain.</p> required <p>Returns:</p> Type Description <code>list[ndarray(count, n)]</code> <p>A list of int arrays (count, n): count is the number of buckets of length n.</p> <p>Examples:</p> <pre><code>buckets = mesh.make_buckets('material')\nfor bucket in buckets:\n    print(bucket.shape)\n</code></pre> <p>Note: The bucket attribute can be read with <code>attr[bucket[:, 0]]</code>.</p>"},{"location":"api/spline/#npblender.domain.Spline.multiply","title":"multiply","text":"<pre><code>multiply(count)\n</code></pre> <p>Duplicate the current records <code>count</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of times to repeat the current records.</p> required Notes <p>This duplicates the current valid records (up to self._length). If the array is empty or count &lt;= 1, nothing happens.</p> Example: <p>If the array has 3 records and count == 4, the result will be:</p> <p>[rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]</p>"},{"location":"api/spline/#npblender.domain.Spline.new_attribute","title":"new_attribute","text":"<pre><code>new_attribute(name, data_type, default, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Register a new attribute in the domain schema.</p> <p>Creates (or ensures) an attribute with a given name, logical data type, default value, and flags controlling Blender transfer and cross-domain propagation.</p> <p>Note: <code>data_type</code> argument is a Blender data type not a python data type. The data type name is compatible with Blender internal storage. <code>FLOAT</code>data type is implemented as <code>np.float32</code> and  'INT' as <code>np.int32</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name (Python identifier recommended).</p> required <code>data_type</code> <code>(FLOAT, INT, BOOL, VECTOR, VECTOR2, COLOR, QUATERNION, MATRIX, STRING, ...)</code> <p>Logical data type used by the domain.</p> <code>'FLOAT'</code> <code>default</code> <code>Any</code> <p>Default value for newly allocated elements.</p> required <code>optional</code> <code>bool</code> <p>If <code>True</code>, the attribute may be absent on some elements.</p> <code>False</code> <code>transfer</code> <code>bool</code> <p>If <code>True</code>, eligible to be transferred to Blender as a geometry attribute.</p> <code>True</code> <code>transdom</code> <code>bool</code> <p>If <code>True</code>, considered a trans-domain attribute that can be copied across compatible domains.</p> <code>True</code> See Also <p><code>new_float</code>, <code>new_vector</code>, <code>new_int</code>, <code>new_bool</code>, <code>new_color</code>, <code>new_vector2</code>, <code>new_quaternion</code>, <code>new_matrix</code></p>"},{"location":"api/spline/#npblender.domain.Spline.new_bool","title":"new_bool","text":"<pre><code>new_bool(name, default=False, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a boolean attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>bool</code> <p>Default value.</p> <code>False</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/spline/#npblender.domain.Spline.new_color","title":"new_color","text":"<pre><code>new_color(name, default=(0.5, 0.5, 0.5, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a color attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,) or (4,)</code> <p>Default color as RGB or RGBA.</p> <code>(0.5, 0.5, 0.5, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/spline/#npblender.domain.Spline.new_field","title":"new_field","text":"<pre><code>new_field(name, dtype, shape=None, default=0, optional=False, **infos)\n</code></pre> <p>Add a field to the structured array.</p> Arguments <pre><code>- name (str) : field name\n- dtype (type) : a valid numpy dtype\n- shape (tuple = None) : the shape of the field\n- default (any = 0) : default value\n- optional (bool = False) : the field is created only when accessed\n- infos (dict) : field infos\n</code></pre>"},{"location":"api/spline/#npblender.domain.Spline.new_float","title":"new_float","text":"<pre><code>new_float(name, default=0.0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a scalar float attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>float</code> <p>Default value.</p> <code>0.0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/spline/#npblender.domain.Spline.new_int","title":"new_int","text":"<pre><code>new_int(name, default=0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure an integer attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>int</code> <p>Default value.</p> <code>0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/spline/#npblender.domain.Spline.new_matrix","title":"new_matrix","text":"<pre><code>new_matrix(name, default=np.eye(4), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a matrix attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array - like</code> <p>Default matrix. By convention this is a square matrix per element (e.g., <code>(3, 3)</code> rotation or <code>(4, 4)</code> transform).</p> <code>np.eye(4)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code> <code>order</code> required"},{"location":"api/spline/#npblender.domain.Spline.new_quaternion","title":"new_quaternion","text":"<pre><code>new_quaternion(name, default=(0.0, 0.0, 0.0, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a quaternion attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (4,)</code> <p>Default quaternion in <code>(x, y, z, w)</code> convention.</p> <code>(0.0, 0.0, 0.0, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/spline/#npblender.domain.Spline.new_vector","title":"new_vector","text":"<pre><code>new_vector(name, default=(0.0, 0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 3D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,)</code> <p>Default XYZ vector.</p> <code>(0.0, 0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/spline/#npblender.domain.Spline.new_vector2","title":"new_vector2","text":"<pre><code>new_vector2(name, default=(0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 2D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (2,)</code> <p>Default XY vector.</p> <code>(0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/spline/#npblender.domain.Spline.per_size","title":"per_size","text":"<pre><code>per_size()\n</code></pre> <p>Group items by their <code>loop_total</code> (polygon/control-point count).</p> <p>Returns a dictionary keyed by size (<code>3</code>, <code>4</code>, \u2026) where each entry contains: - <code>'start'</code> : array of <code>loop_start</code> values for items of that size. - <code>'indices'</code> : array mapping entry order back to item indices.</p> <p>Returns:</p> Type Description <code>dict[int, dict[str, ndarray]]</code> <p>Grouped start offsets and reverse indices for each size present.</p> Notes <p>Uses a Numba kernel to bucketize items efficiently.</p>"},{"location":"api/spline/#npblender.domain.Spline.to_bl_attributes","title":"to_bl_attributes","text":"<pre><code>to_bl_attributes(attributes, update=False)\n</code></pre> <p>Export attributes to a Blender attribute collection.</p> <p>Writes eligible domain attributes to a Blender data-block, creating missing attributes and adjusting sizes as needed.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Any</code> <p>Blender attributes collection receiving the values.</p> required <code>update</code> <code>bool</code> <p>If <code>True</code>, update existing attributes in-place; otherwise create them when missing.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Caution:*** Only attributes with `transfer=True` are exported. Optional</code> <code>attributes are skipped.</code> <code>&gt; ***Caution:*** Curve domains user attributes are not saved.</code>"},{"location":"api/spline/#npblender.domain.Spline.to_dict","title":"to_dict","text":"<pre><code>to_dict(*, copy=True, with_infos=True)\n</code></pre> <p>Convert the array to a dictionary of fields or (field, infos) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Whether to copy the arrays.</p> <code>True</code> <code>with_infos</code> <code>bool</code> <p>If True, return (array, infos) for each field.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, array or (array, dict)]</code>"},{"location":"api/spline/#npblender.domain.Spline.to_object","title":"to_object","text":"<pre><code>to_object(data, update=False)\n</code></pre> <p>Transfer spline attributes to a Blender object.</p> <p>Writes this domain\u2019s Blender attributes into the target Blender object or data block.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ID or similar</code> <p>Blender object or data block exposing an <code>attributes</code> mapping.</p> required <code>update</code> <code>bool</code> <p>If <code>True</code>, update existing attributes only. If <code>False</code>, create new attributes when they do not exist.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If attribute creation or assignment fails.</p> Notes <ul> <li>Only attributes flagged with <code>transfer=True</code> are exported.</li> <li>String attributes are currently skipped.</li> </ul> <p>Examples:</p> <pre><code>import bpy\nfrom npblender.domain import Spline\n\ncurve = bpy.data.curves[\"MyCurve\"]\nsplines = Spline()\nsplines.to_object(curve, update=False)\n</code></pre> <p>Caution: Blender does not save user-defined attributes inside curve objects. Attributes written here may be lost when saving and reopening the file.</p>"},{"location":"api/spline/#npblender.domain.Spline.transfer_attributes","title":"transfer_attributes","text":"<pre><code>transfer_attributes(other, shape=None, other_shape=None)\n</code></pre> <p>Transfer values of trans-domain attributes from another domain.</p> <p>Copies values for each trans-domain attribute present in <code>other</code> into the corresponding attributes of <code>self</code>, with optional reshaping for batched assignments.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain</code> <p>Source domain providing attribute values.</p> required <code>shape</code> <code>tuple of int or None</code> <p>Target reshape for <code>self</code> before assignment. If <code>None</code>, uses <code>(self._length,)</code>.</p> <code>None</code> <code>other_shape</code> <code>tuple of int or None</code> <p>Source reshape for <code>other</code> before assignment. If <code>None</code>, uses <code>(other._length,)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p> <code>&gt; ***Note:*** Each attribute is reshaped as `shape + item_shape` on `self`</code> <code>and `other_shape + item_shape` on `other` prior to assignment.</code>"},{"location":"api/spline/#npblender.domain.Spline.update_loop_start","title":"update_loop_start","text":"<pre><code>update_loop_start()\n</code></pre> <p>Recompute <code>loop_start</code> from <code>loop_total</code> (cumulative layout).</p> <p>Sets <code>loop_start</code> to a left-rolled cumulative sum of <code>loop_total</code>, so item i starts right after the end of item i-1.</p> <p>Returns:</p> Type Description <code>FaceSplineDomain</code> <p>Self (for chaining).</p> Notes <p>Call this after deletions / resizes to keep indices consistent.</p> See Also <p><code>compute_loop_start</code> :     Compute offsets for new items to be appended.</p>"},{"location":"api/transformation/","title":"Transformation","text":""},{"location":"api/transformation/#npblender.Transformation","title":"Transformation","text":"<pre><code>Transformation(mat, *, copy=True)\n</code></pre> <p>               Bases: <code>ItemsArray</code></p> <p>Initialize an ItemsArray from any array-like input.</p> <p>The input must be broadcastable to the expected item shape defined by the subclass via <code>_item_shape</code>. Typical examples include arrays of vectors, matrices, or quaternions.</p> <p>Parameters:</p> Name Type Description Default <code>mat</code> <code>array_like</code> <p>Input data to be wrapped. Must be broadcastable to shape (..., *_item_shape). For example, if <code>_item_shape = (3,)</code>, acceptable inputs include: - [1, 2, 3]                         \u2192 broadcasted to shape (1, 3) - [[1, 2, 3], [4, 5, 6]]            \u2192 shape (2, 3) - np.ones((10, 1, 3))               \u2192 shape (10, 1, 3)</p> required <code>copy</code> <code>bool</code> <p>If True, the input is copied. If False, a view is kept (when safe), which avoids unnecessary allocations.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input is not broadcastable to the required item shape.</p>"},{"location":"api/transformation/#npblender.Transformation.position","title":"position  <code>property</code> <code>writable</code>","text":"<pre><code>position\n</code></pre> <p>Access the translation component (view, not copy).</p>"},{"location":"api/transformation/#npblender.Transformation.rotation","title":"rotation  <code>property</code> <code>writable</code>","text":"<pre><code>rotation\n</code></pre> <p>Return the pure rotation part of the matrix.</p>"},{"location":"api/transformation/#npblender.Transformation.scale","title":"scale  <code>property</code> <code>writable</code>","text":"<pre><code>scale\n</code></pre> <p>Extract scale from transformation matrix (per axis).</p>"},{"location":"api/transformation/#npblender.Transformation.shape","title":"shape  <code>property</code>","text":"<pre><code>shape\n</code></pre> <p>Batch shape (everything except the final item_shape).</p>"},{"location":"api/transformation/#npblender.Transformation.size","title":"size  <code>property</code>","text":"<pre><code>size\n</code></pre> <p>Number of individual items.</p>"},{"location":"api/transformation/#npblender.Transformation.apply","title":"apply","text":"<pre><code>apply(vectors)\n</code></pre> <p>Apply the transformation(s) to 3D or 4D vectors.</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>array_like(..., 3) or (..., 4)</code> <p>Input vectors. If shape[-1] == 3, a 1 is appended to enable homogeneous transformation. If already 4D, used as-is.</p> required <p>Returns:</p> Name Type Description <code>transformed</code> <code>ndarray(..., 3 or 4)</code> <p>Transformed vectors. Shape is the broadcast of self.shape and vectors.shape[:-1].</p>"},{"location":"api/transformation/#npblender.Transformation.as_array","title":"as_array","text":"<pre><code>as_array(dtype=None)\n</code></pre> <p>View on the internal array (no copy).</p>"},{"location":"api/transformation/#npblender.Transformation.broadcast_to","title":"broadcast_to","text":"<pre><code>broadcast_to(shape)\n</code></pre> <p>Broadcast the array to a new batch shape.</p> <p>This is equivalent to <code>np.broadcast_to(...)</code>, preserving the item shape. No copy is made.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple of int</code> <p>New shape for the batch dimensions.</p> required <p>Returns:</p> Type Description <code>ItemsArray</code> <p>A new view with broadcasted shape.</p>"},{"location":"api/transformation/#npblender.Transformation.compose","title":"compose  <code>classmethod</code>","text":"<pre><code>compose(*transforms)\n</code></pre> <p>Compose multiple transformations together (right to left).</p> <p>Parameters:</p> Name Type Description Default <code>*transforms</code> <code>Transformation</code> <p>Any number of Transformation objects to compose. Composition is performed as <code>T1 @ T2 @ T3</code>, meaning <code>T3</code> is applied first.</p> <code>()</code> <p>Returns:</p> Type Description <code>Transformation</code> <p>The composed transformation.</p>"},{"location":"api/transformation/#npblender.Transformation.decompose","title":"decompose","text":"<pre><code>decompose()\n</code></pre> <p>Return rotation, scale, translation from each 4x4 transform.</p> <p>Returns:</p> Name Type Description <code>rot</code> <code>Rotation</code> <p>Rotation (orthonormal, no scale)</p> <code>scale</code> <code>ndarray(..., 3)</code> <p>Scale vector along each axis</p> <code>trans</code> <code>ndarray(..., 3)</code> <p>Translation vector</p>"},{"location":"api/transformation/#npblender.Transformation.filter","title":"filter","text":"<pre><code>filter(mask, in_place=False)\n</code></pre> <p>Filter transformations using a boolean mask.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>array_like(...)</code> <p>Boolean mask matching the shape of the batch.</p> required <code>in_place</code> <code>bool</code> <p>If True, modifies the current instance. Otherwise, returns a new one.</p> <code>False</code> <p>Returns:</p> Type Description <code>ItemsArray</code> <p>Filtered array (or self if in_place is True).</p>"},{"location":"api/transformation/#npblender.Transformation.from_components","title":"from_components  <code>classmethod</code>","text":"<pre><code>from_components(translation=None, rotation=None, scale=None)\n</code></pre> <p>Build a Transformation from translation, rotation, and scale.</p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>array_like(..., 3)</code> <p>Translation vector(s).  Default is <code>[0, 0, 0]</code>.</p> <code>None</code> <code>rotation</code> <code>None or array_like(..., 3, 3) or Rotation</code> <p>Rotation matrix/matrices.  If None, uses the identity.</p> <code>None</code> <code>scale</code> <code>array_like(..., 3)</code> <p>Per\u2011axis scale vector(s).  Default is <code>[1, 1, 1]</code>.</p> <code>None</code> Notes <p>All three inputs are broadcasted together.  The returned batch shape is the broadcasted shape of <code>translation[...,0]</code>, <code>scale[...,0]</code>, and <code>rotation[...,0,0]</code>.</p>"},{"location":"api/transformation/#npblender.Transformation.interpolate","title":"interpolate","text":"<pre><code>interpolate(other, t)\n</code></pre> <p>Interpolate between two transformations A and B using factor t.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Transformation</code> <p>The other transformation to interpolate with.</p> required <code>t</code> <code>float or array_like(...)</code> <p>Interpolation weight(s) in [0, 1]. Shape must be broadcastable.</p> required <p>Returns:</p> Type Description <code>Transformation</code> <p>Interpolated transformation(s).</p>"},{"location":"api/transformation/#npblender.Transformation.inverse","title":"inverse","text":"<pre><code>inverse()\n</code></pre> <p>Return the inverse of the transformation(s).</p> <p>Returns:</p> Type Description <code>Transformation</code> <p>A new Transformation representing the inverse.</p>"},{"location":"api/transformation/#npblender.Transformation.is_identity","title":"is_identity","text":"<pre><code>is_identity(eps=1e-05)\n</code></pre> <p>Return a boolean array indicating which matrices are identity.</p> <p>Parameters:</p> Name Type Description Default <code>eps</code> <code>float</code> <p>Tolerance for element-wise comparison. Default is global ZERO.</p> <code>1e-05</code> <p>Returns:</p> Name Type Description <code>mask</code> <code>ndarray of bool, shape == self.shape</code> <p>True where transformation is (approximately) the identity.</p>"},{"location":"api/transformation/#npblender.Transformation.normalize_rotation","title":"normalize_rotation","text":"<pre><code>normalize_rotation(in_place=False)\n</code></pre> <p>Orthonormalize the rotation part of each matrix via SVD.</p> <p>Parameters:</p> Name Type Description Default <code>in_place</code> <code>bool</code> <p>If True, modifies the current instance. Otherwise, returns a new one.</p> <code>False</code> <p>Returns:</p> Type Description <code>Transformation</code> <p>A Transformation with orthonormal rotation matrices.</p>"},{"location":"api/transformation/#npblender.Transformation.reshape","title":"reshape","text":"<pre><code>reshape(*new_shape)\n</code></pre> <p>Reshape the batch dimensions of the array, preserving the item shape.</p> <p>The total number of items must remain unchanged. This is equivalent to <code>np.reshape()</code> on the batch dimensions only, i.e., the trailing <code>_item_shape</code> is preserved.</p> <p>Parameters:</p> Name Type Description Default <code>*new_shape</code> <code>int</code> <p>New shape for the batch. Must satisfy <code>np.prod(new_shape) == self.size</code>.</p> <code>()</code> <p>Returns:</p> Type Description <code>ItemsArray</code> <p>A new reshaped view of the same data (no copy).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the total number of items does not match.</p>"},{"location":"api/transformation/#npblender.Transformation.resize","title":"resize","text":"<pre><code>resize(*new_shape, fill=0.0)\n</code></pre> <p>Resize the batch to a new shape, preserving item shape.</p> <p>If the total number of items remains unchanged, the underlying array is simply reshaped (no allocation). Otherwise, a new array is created and filled with the given value. Existing data is preserved as much as possible (copied in row-major order).</p> <p>Parameters:</p> Name Type Description Default <code>*new_shape</code> <code>int</code> <p>New shape for the batch (excluding the item shape). Can increase or decrease the number of items.</p> <code>()</code> <code>fill</code> <code>float</code> <p>Value used to initialize new items when the array is enlarged.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>ItemsArray</code> <p>The current instance (resized in place).</p>"},{"location":"api/vertex/","title":"Vertex","text":""},{"location":"api/vertex/#npblender.domain.Vertex","title":"Vertex","text":"<pre><code>Vertex(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>Vertex (mesh point) domain.</p> <p>This domain represents mesh vertices. It provides fast utilities to transfer (map/average) any per-vertex attribute onto other mesh domains  (faces, corners, edges).</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>(N, 3) float</code> <p>World-space vertex positions inherited from :class:<code>PointDomain</code>.</p> Notes <ul> <li>Attribute transfers are implemented with Numba-jitted kernels for   performance.</li> <li>When mapping to faces, values are averaged over all corners of each face.</li> </ul> <p>Examples:</p> <p>Map a per-vertex scalar to faces:</p> <pre><code>face_attr = vertices.compute_attribute_on_faces(\"mass\", corners, faces)\n</code></pre> <p>Map a per-vertex vector to edges:</p> <pre><code>edge_attr = vertices.compute_attribute_on_edges(\"normal\", edges)\n</code></pre> <p>Initialize a domain array and its attribute schema.</p> <p>Initializes the storage from an existing array/domain or creates an empty structure. Optionally merges attribute definitions/values from another domain and keyword-provided attributes.</p> <p>Domains are never instancied directly but by owning geometries.</p> <p>Actual Domains are <code>Vertex</code>, [<code>Faces</code>][npblender.domain.Faces], <code>Corner</code>, <code>Edge</code>, <code>ControlPoint</code>, <code>Spline</code> and <code>Point</code>.</p> <p>Domains are initialized with their defaults attributes, for instance <code>position</code> for point domaines.</p> <p>Use attributes can be freely added. </p> <p>Note: user attributes are saved in Blender Mesh objects only, Blender Curve objects don't store user attributes.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>array - like or FieldArray or None</code> <p>Source data used to initialize the domain. If <code>None</code>, an empty domain is created and <code>_declare_attributes()</code> is called to register defaults.</p> <code>None</code> <code>mode</code> <code>(COPY, CAPTURE, EMPTY)</code> <p>Initialization mode. <code>'COPY'</code> duplicates the input data, <code>'CAPTURE'</code> references the input buffer when supported, <code>'EMPTY'</code> creates the structure without copying values.</p> <code>'COPY'</code> <code>selector</code> <code>Any</code> <p>Optional row/element selector applied to <code>a</code> prior to initialization.</p> <code>None</code> <code>attr_from</code> <code>Domain or Mapping or None</code> <p>Attribute schema (and possibly values) to merge into this domain.</p> <code>None</code> <code>**attrs</code> <p>Additional attribute name/value pairs to inject or override.</p> <code>{}</code> Notes <p>The effective attribute list results from <code>_declare_attributes()</code>, then <code>attr_from</code>, then <code>**attrs</code> (later entries take precedence).</p> <p>Examples:</p> <pre><code>cube = Mesh.cube() # points, corners, faces and edges domains are created\n# Adding named attribute to point domain\ncube.points.new_float('age')\n# Setting the age\ncube.points.age = np.random.uniforme(10, 10, len(cube.points))\n</code></pre>"},{"location":"api/vertex/#npblender.domain.Vertex.actual_names","title":"actual_names  <code>property</code>","text":"<pre><code>actual_names\n</code></pre> <p>Column names.</p> <p>Returns the actual field names, excluding optional fields.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.all_names","title":"all_names  <code>property</code>","text":"<pre><code>all_names\n</code></pre> <p>Column names.</p> <p>Returns all the field names, including optional ones.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Array structured dtype</p> <p>Returns the dtype property of the structured array.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.transdom_names","title":"transdom_names  <code>property</code>","text":"<pre><code>transdom_names\n</code></pre> <p>List the names of trans-domain attributes.</p> <p>Returns:</p> Type Description <code>list of str</code> <p>Names of attributes flagged with <code>transdom=True</code>.</p> <p>Examples:</p> <pre><code>names = D.transdom_names()\n</code></pre>"},{"location":"api/vertex/#npblender.domain.Vertex.x","title":"x  <code>property</code> <code>writable</code>","text":"<pre><code>x\n</code></pre> <p>X coordinate accessor.</p> <p>Shorthand for <code>position[..., 0]</code>. Reading returns a view; assigning to this property writes into the underlying <code>position</code> field.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>View of shape <code>(...,)</code> selecting the x component of <code>position</code>.</p> <p>Examples:</p> <p>Read and write x in place:</p> <pre><code>xs = points.x              # view on position[..., 0]\npoints.x = xs + 1.0        # shift x by +1\n</code></pre> <p>Note: This is equivalent to <code>points.position[..., 0]</code>.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.y","title":"y  <code>property</code> <code>writable</code>","text":"<pre><code>y\n</code></pre> <p>Y coordinate accessor.</p> <p>Shorthand for <code>position[..., 1]</code>. Reading returns a view; assigning to this property writes into the underlying <code>position</code> field.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>View of shape <code>(...,)</code> selecting the y component of <code>position</code>.</p> <p>Examples:</p> <pre><code>points.y = 0.0             # flatten all y to 0\n</code></pre>"},{"location":"api/vertex/#npblender.domain.Vertex.z","title":"z  <code>property</code> <code>writable</code>","text":"<pre><code>z\n</code></pre> <p>Z coordinate accessor.</p> <p>Shorthand for <code>position[..., 2]</code>. Reading returns a view; assigning to this property writes into the underlying <code>position</code> field.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>View of shape <code>(...,)</code> selecting the z component of <code>position</code>.</p> <p>Examples:</p> <pre><code>points.z += 2.5\n</code></pre>"},{"location":"api/vertex/#npblender.domain.Vertex.add","title":"add","text":"<pre><code>add(count, **fields)\n</code></pre> <p>Add count records</p> <p>New records are set with default values or values provided by the user in fields dict.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of records to add.</p> required <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/vertex/#npblender.domain.Vertex.append","title":"append","text":"<pre><code>append(**fields)\n</code></pre> <p>Append values to the structured array.</p> <p>The number of records to append is determined by the number of fields provided in the fields dictionary. The values of the fields are copied to the new records.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/vertex/#npblender.domain.Vertex.apply_scale","title":"apply_scale","text":"<pre><code>apply_scale(scale, pivot=None)\n</code></pre> <p>Apply per-axis scales to points, optionally about a pivot.</p> <p>The scaling is broadcast across the domain using <code>_get_shape_for_operation</code>. If a pivot is given, points are moved to the local frame, scaled, then moved back.</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>array-like of shape ``(..., 3)``</code> <p>Per-axis scale factors broadcastable to the domain size.</p> required <code>pivot</code> <code>array-like of shape ``(..., 3)`` or None</code> <p>Pivot location(s). If <code>None</code>, scales are applied about the origin.</p> <code>None</code> <p>Returns:</p> Type Description <code>PointDomain</code> <p>Self (for chaining).</p> <p>Examples:</p> <pre><code># A mesh made of 8 cubes\ncubes = Mesh.cube(size=.2)*8\npv = np.random.uniform(-1, 1, (8, 3))\nsc = np.random.uniform(.1, 1, (8, 3))\n# Scale each cube individually\ncubes.points.apply_scale(sc, pivot=pv)\n</code></pre> <p>Note: If broadcasting fails, a <code>ValueError</code> is raised by <code>_get_shape_for_operation</code>.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.as_kwargs","title":"as_kwargs","text":"<pre><code>as_kwargs(selector=None, include=None, exclude=None)\n</code></pre> <p>Return a dictionary of field values formatted as kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>slice, int, list, or mask</code> <p>Optional selection of elements to extract.</p> <code>None</code> <code>include</code> <code>list[str]</code> <p>List of field names (original or python names) to include.</p> <code>None</code> <code>exclude</code> <code>list[str]</code> <p>List of field names (original or python names) to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Mapping from python-safe field names to array values.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.compute_attribute_on_corners","title":"compute_attribute_on_corners","text":"<pre><code>compute_attribute_on_corners(attr, corners)\n</code></pre> <p>Scatter a per-vertex attribute to corners.</p> <p>For each corner, copies the attribute of its associated vertex (via <code>corners.vertex_index</code>). The attribute is validated with <code>_check_attribute_to_compute</code>.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str or ndarray, shape ``(N, ...)``</code> <p>Vertex attribute to scatter. If a string, the field is looked up on this domain; if an array, it must have length <code>N == len(self)</code>.</p> required <code>corners</code> <code>Corner</code> <p>Corner domain providing the <code>vertex_index</code> mapping.</p> required <p>Returns:</p> Type Description <code>ndarray, shape ``(len(corners), ...)``</code> <p>Corner attribute array (one value per corner), preserving the trailing item shape and dtype.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>attr</code> is scalar or its first dimension does not match <code>len(self)</code> (raised by <code>_check_attribute_to_compute</code>).</p> <code>IndexError</code> <p>If <code>corners.vertex_index</code> contains indices outside <code>[0, len(self))</code>.</p> <p>Examples:</p> <pre><code># Duplicate per-vertex colors to corners\ncorner_col = V.compute_attribute_on_corners(\"color\", corners)\n</code></pre>"},{"location":"api/vertex/#npblender.domain.Vertex.compute_attribute_on_edges","title":"compute_attribute_on_edges","text":"<pre><code>compute_attribute_on_edges(attr, edges)\n</code></pre> <p>Average a per-vertex attribute over each edge.</p> <p>For every edge, returns the mean of the attribute at its two endpoint vertices (<code>(v0, v1)</code>). The attribute is validated with <code>_check_attribute_to_compute</code>.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str or ndarray, shape ``(N, ...)``</code> <p>Vertex attribute to average. If a string, the field is looked up on this domain; if an array, it must have length <code>N == len(self)</code>.</p> required <code>edges</code> <code>Edge</code> <p>Edge domain providing <code>vertex0</code> and <code>vertex1</code> index arrays.</p> required <p>Returns:</p> Type Description <code>ndarray, shape ``(len(edges), ...)``</code> <p>Edge-wise averaged attribute. The trailing item shape is preserved and the dtype follows the input attribute.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>attr</code> is scalar or its first dimension does not match <code>len(self)</code> (raised by <code>_check_attribute_to_compute</code>).</p> <code>IndexError</code> <p>If <code>edges.vertex0</code> or <code>edges.vertex1</code> contain indices outside <code>[0, len(self))</code>.</p> <code>TypeError</code> <p>If the attribute dtype is non-numeric or cannot be averaged (e.g., integer types with in-place division).</p> <p>Examples:</p> <pre><code># Edge midpoints from vertex positions\nedge_pos = V.compute_attribute_on_edges(\"position\", edges)\n\n# Average a custom per-vertex scalar on edges\nedge_w = V.compute_attribute_on_edges(weights, edges)\n</code></pre> <p>Note: The average is unweighted: <code>0.5 * (attr[v0] + attr[v1])</code>.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.compute_attribute_on_faces","title":"compute_attribute_on_faces","text":"<pre><code>compute_attribute_on_faces(attr, corners, faces)\n</code></pre> <p>Average a per-vertex attribute over each face.</p> <p>For every face, this computes the mean of the source vertex attribute over all its incident corners (i.e., the face-wise average). The input attribute can be given by name or as an array aligned with the vertex domain. The attribute is validated with <code>_check_attribute_to_compute</code>.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str or ndarray, shape ``(N, ...)``</code> <p>Vertex attribute to aggregate. If a string, the corresponding field is looked up on this domain; if an array, it must have length <code>N == len(self)</code>. Trailing item shape (<code>...</code>) is preserved.</p> required <code>corners</code> <code>Corner</code> <p>Corner domain providing the <code>vertex_index</code> mapping for the mesh.</p> required <code>faces</code> <code>Face</code> <p>Face domain providing <code>loop_start</code> and <code>loop_total</code> (polygon topology).</p> required <p>Returns:</p> Type Description <code>ndarray, shape ``(len(faces), ...)``</code> <p>Face-wise averaged attribute. The trailing item shape is preserved and the dtype follows the input attribute.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>attr</code> is scalar or its first dimension does not match <code>len(self)</code> (raised by <code>_check_attribute_to_compute</code>).</p> <code>IndexError</code> <p>If <code>corners.vertex_index</code> contains indices outside <code>[0, len(self))</code>.</p> <code>TypeError</code> <p>If the attribute dtype is non-numeric or cannot be averaged (e.g., integer types with in-place division).</p> Notes <p>This routine computes an unweighted arithmetic mean over each face's corners.</p> See Also <p><code>compute_attribute_on_corners</code> :     Scatter vertex attributes to corners. <code>compute_attribute_on_edges</code> :     Average vertex attributes on edges.</p> <p>Examples:</p> <pre><code># Face centroids (average of vertex positions)\nface_pos = V.compute_attribute_on_faces(\"position\", corners, faces)\n\n# Average any custom per-vertex float attribute\nface_weight = V.compute_attribute_on_faces(weights, corners, faces)\n</code></pre>"},{"location":"api/vertex/#npblender.domain.Vertex.copy_field","title":"copy_field","text":"<pre><code>copy_field(field_name, new_name, **infos)\n</code></pre> <p>Duplicate an existing field under a new name, with optional metadata overrides.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the existing field to copy.</p> required <code>new_name</code> <code>str</code> <p>The name of the new field to create.</p> required <code>infos</code> <code>keyword arguments</code> <p>Optional metadata (e.g. default, unit, description...) to override or supplement the original field's metadata.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the source field does not exist.</p> <code>ValueError</code> <p>If the target name already exists or is reserved.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.delete","title":"delete","text":"<pre><code>delete(index)\n</code></pre> <p>Delete a selection of items from the array.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int, slice, or array-like</code> <p>The indices of the elements to delete from the current data.</p> required Notes <p>This operates only on the valid range <code>[0:self._length]</code>. The internal buffer is preserved (no reallocation).</p>"},{"location":"api/vertex/#npblender.domain.Vertex.dump","title":"dump","text":"<pre><code>dump(title='Dump', attributes=None, target='SCREEN')\n</code></pre> <p>Pretty-print or export domain content.</p> <p>Formats attribute values and prints to screen or builds a tabular dump suitable for spreadsheets.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title displayed in the report.</p> <code>'Dump'</code> <code>attributes</code> <code>Sequence[str] or None</code> <p>Subset of attribute names to include. If <code>None</code>, all attributes are shown.</p> <code>None</code> <code>target</code> <code>(SCREEN, ...)</code> <p>Output target. <code>'SCREEN'</code> prints to stdout; other targets may trigger file creation depending on the implementation.</p> <code>'SCREEN'</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>Domain(points).dump(title=\"Vertices\")\n</code></pre> <p>Note: Formatting adapts to the chosen <code>target</code>.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.extend","title":"extend","text":"<pre><code>extend(other, join_fields=True)\n</code></pre> <p>Append multiple records from another array or FieldArray.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray or structured np.ndarray</code> <p>The array of records to append. Must have named fields matching a subset of the current array's fields.</p> required"},{"location":"api/vertex/#npblender.domain.Vertex.filtered","title":"filtered","text":"<pre><code>filtered(selector, *, copy=False)\n</code></pre> <p>Return a FieldArray containing only the selected records.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>array\u2011like, slice or int</code> <p>Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice. It is applied to the current valid part of the buffer (<code>self._data[:self._length]</code>).</p> required <code>copy</code> <code>bool</code> <ul> <li>False    (default) =&gt; the new array shares the same memory                          (changes propagate both ways).</li> <li>True           =&gt; the data are physically copied.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>FieldArray</code> <p>A new instance holding exactly <code>len(selector)</code> records and inheriting the current field\u2011infos.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.from_bl_attributes","title":"from_bl_attributes","text":"<pre><code>from_bl_attributes(bl_attributes)\n</code></pre> <p>Import attributes from a Blender attribute collection.</p> <p>Reads geometry attributes from a Blender data-block and creates/updates the corresponding domain attributes, resizing the domain if needed.</p> <p>Parameters:</p> Name Type Description Default <code>bl_attributes</code> <code>Mapping[str, Any]</code> <p>Blender attributes collection (name \u2192 attribute descriptor) providing at least <code>.domain</code>, <code>.is_internal</code>, <code>.data_type</code>, and <code>.data</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Note:*** Only external (non-internal) Blender attributes matching this</code> <code>domain are imported. Missing attributes are created with `transfer=True`.</code>"},{"location":"api/vertex/#npblender.domain.Vertex.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Build a FieldArray from a dictionary with field data and optional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, array - like or (array, dict)]</code> <p>Mapping field names to arrays or (array, infos). Infos must include NAME.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the data. Default: True.</p> required <p>Returns:</p> Type Description <code>FieldArray</code>"},{"location":"api/vertex/#npblender.domain.Vertex.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> <p>Get attribute by name.</p> <p>If name is not an actual field, return default value. Name can be an array. <pre><code>pos = field_array.get(\"position\", (0, 0, 1))\npos = field_array.get([[0, 0, 1], [0, 0, 0]])\n</code></pre></p>"},{"location":"api/vertex/#npblender.domain.Vertex.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other)\n</code></pre> <p>Merge trans-domain attributes from another domain.</p> <p>Copies or aligns attributes from <code>other</code> into the current domain, excluding any attributes not flagged as trans-domain in <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain or None</code> <p>Source domain. If <code>None</code>, the call is a no-op.</p> required <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p>"},{"location":"api/vertex/#npblender.domain.Vertex.join_fields","title":"join_fields","text":"<pre><code>join_fields(other, exclude=[])\n</code></pre> <p>Add all missing fields from another FieldArray.</p> <p>For every field in <code>other</code> that is not present in <code>self</code>, a new field is created with the same dtype and shape, and initialized with its default value across all existing records.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray</code> <p>Another FieldArray instance whose fields will be checked for missing fields.</p> required <p>Returns:</p> Type Description <code>self</code>"},{"location":"api/vertex/#npblender.domain.Vertex.make_buckets","title":"make_buckets","text":"<pre><code>make_buckets(attr)\n</code></pre> <p>Group items into buckets by attribute value.</p> <p>When a domain is to be considered as a collection of packets of various sizes, buckets mechanism groups pakets by size, allowing further operation with numpy vectorization.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>array - like or str</code> <p>Either an integer of shape <code>(N,)</code> or the name of an existing integer attribute in the domain.</p> required <p>Returns:</p> Type Description <code>list[ndarray(count, n)]</code> <p>A list of int arrays (count, n): count is the number of buckets of length n.</p> <p>Examples:</p> <pre><code>buckets = mesh.make_buckets('material')\nfor bucket in buckets:\n    print(bucket.shape)\n</code></pre> <p>Note: The bucket attribute can be read with <code>attr[bucket[:, 0]]</code>.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.multiply","title":"multiply","text":"<pre><code>multiply(count)\n</code></pre> <p>Duplicate the current records <code>count</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of times to repeat the current records.</p> required Notes <p>This duplicates the current valid records (up to self._length). If the array is empty or count &lt;= 1, nothing happens.</p> Example: <p>If the array has 3 records and count == 4, the result will be:</p> <p>[rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]</p>"},{"location":"api/vertex/#npblender.domain.Vertex.new_attribute","title":"new_attribute","text":"<pre><code>new_attribute(name, data_type, default, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Register a new attribute in the domain schema.</p> <p>Creates (or ensures) an attribute with a given name, logical data type, default value, and flags controlling Blender transfer and cross-domain propagation.</p> <p>Note: <code>data_type</code> argument is a Blender data type not a python data type. The data type name is compatible with Blender internal storage. <code>FLOAT</code>data type is implemented as <code>np.float32</code> and  'INT' as <code>np.int32</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name (Python identifier recommended).</p> required <code>data_type</code> <code>(FLOAT, INT, BOOL, VECTOR, VECTOR2, COLOR, QUATERNION, MATRIX, STRING, ...)</code> <p>Logical data type used by the domain.</p> <code>'FLOAT'</code> <code>default</code> <code>Any</code> <p>Default value for newly allocated elements.</p> required <code>optional</code> <code>bool</code> <p>If <code>True</code>, the attribute may be absent on some elements.</p> <code>False</code> <code>transfer</code> <code>bool</code> <p>If <code>True</code>, eligible to be transferred to Blender as a geometry attribute.</p> <code>True</code> <code>transdom</code> <code>bool</code> <p>If <code>True</code>, considered a trans-domain attribute that can be copied across compatible domains.</p> <code>True</code> See Also <p><code>new_float</code>, <code>new_vector</code>, <code>new_int</code>, <code>new_bool</code>, <code>new_color</code>, <code>new_vector2</code>, <code>new_quaternion</code>, <code>new_matrix</code></p>"},{"location":"api/vertex/#npblender.domain.Vertex.new_bool","title":"new_bool","text":"<pre><code>new_bool(name, default=False, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a boolean attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>bool</code> <p>Default value.</p> <code>False</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/vertex/#npblender.domain.Vertex.new_color","title":"new_color","text":"<pre><code>new_color(name, default=(0.5, 0.5, 0.5, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a color attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,) or (4,)</code> <p>Default color as RGB or RGBA.</p> <code>(0.5, 0.5, 0.5, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/vertex/#npblender.domain.Vertex.new_field","title":"new_field","text":"<pre><code>new_field(name, dtype, shape=None, default=0, optional=False, **infos)\n</code></pre> <p>Add a field to the structured array.</p> Arguments <pre><code>- name (str) : field name\n- dtype (type) : a valid numpy dtype\n- shape (tuple = None) : the shape of the field\n- default (any = 0) : default value\n- optional (bool = False) : the field is created only when accessed\n- infos (dict) : field infos\n</code></pre>"},{"location":"api/vertex/#npblender.domain.Vertex.new_float","title":"new_float","text":"<pre><code>new_float(name, default=0.0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a scalar float attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>float</code> <p>Default value.</p> <code>0.0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/vertex/#npblender.domain.Vertex.new_int","title":"new_int","text":"<pre><code>new_int(name, default=0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure an integer attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>int</code> <p>Default value.</p> <code>0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/vertex/#npblender.domain.Vertex.new_matrix","title":"new_matrix","text":"<pre><code>new_matrix(name, default=np.eye(4), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a matrix attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array - like</code> <p>Default matrix. By convention this is a square matrix per element (e.g., <code>(3, 3)</code> rotation or <code>(4, 4)</code> transform).</p> <code>np.eye(4)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code> <code>order</code> required"},{"location":"api/vertex/#npblender.domain.Vertex.new_quaternion","title":"new_quaternion","text":"<pre><code>new_quaternion(name, default=(0.0, 0.0, 0.0, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a quaternion attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (4,)</code> <p>Default quaternion in <code>(x, y, z, w)</code> convention.</p> <code>(0.0, 0.0, 0.0, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/vertex/#npblender.domain.Vertex.new_vector","title":"new_vector","text":"<pre><code>new_vector(name, default=(0.0, 0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 3D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,)</code> <p>Default XYZ vector.</p> <code>(0.0, 0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/vertex/#npblender.domain.Vertex.new_vector2","title":"new_vector2","text":"<pre><code>new_vector2(name, default=(0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 2D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (2,)</code> <p>Default XY vector.</p> <code>(0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/vertex/#npblender.domain.Vertex.to_bl_attributes","title":"to_bl_attributes","text":"<pre><code>to_bl_attributes(attributes, update=False)\n</code></pre> <p>Export attributes to a Blender attribute collection.</p> <p>Writes eligible domain attributes to a Blender data-block, creating missing attributes and adjusting sizes as needed.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Any</code> <p>Blender attributes collection receiving the values.</p> required <code>update</code> <code>bool</code> <p>If <code>True</code>, update existing attributes in-place; otherwise create them when missing.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Caution:*** Only attributes with `transfer=True` are exported. Optional</code> <code>attributes are skipped.</code> <code>&gt; ***Caution:*** Curve domains user attributes are not saved.</code>"},{"location":"api/vertex/#npblender.domain.Vertex.to_dict","title":"to_dict","text":"<pre><code>to_dict(*, copy=True, with_infos=True)\n</code></pre> <p>Convert the array to a dictionary of fields or (field, infos) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Whether to copy the arrays.</p> <code>True</code> <code>with_infos</code> <code>bool</code> <p>If True, return (array, infos) for each field.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, array or (array, dict)]</code>"},{"location":"api/vertex/#npblender.domain.Vertex.transfer_attributes","title":"transfer_attributes","text":"<pre><code>transfer_attributes(other, shape=None, other_shape=None)\n</code></pre> <p>Transfer values of trans-domain attributes from another domain.</p> <p>Copies values for each trans-domain attribute present in <code>other</code> into the corresponding attributes of <code>self</code>, with optional reshaping for batched assignments.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain</code> <p>Source domain providing attribute values.</p> required <code>shape</code> <code>tuple of int or None</code> <p>Target reshape for <code>self</code> before assignment. If <code>None</code>, uses <code>(self._length,)</code>.</p> <code>None</code> <code>other_shape</code> <code>tuple of int or None</code> <p>Source reshape for <code>other</code> before assignment. If <code>None</code>, uses <code>(other._length,)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p> <code>&gt; ***Note:*** Each attribute is reshaped as `shape + item_shape` on `self`</code> <code>and `other_shape + item_shape` on `other` prior to assignment.</code>"},{"location":"api/vertex/#npblender.domain.Vertex.transform","title":"transform","text":"<pre><code>transform(transfo, pivot=None)\n</code></pre> <p>Apply a linear transform (e.g., rotation or transformation) to points.</p> <p>If the transformation or pivot size is less than the domain size, the scale / pivot is applied on buckets of the same size if possible, otherwise an exception is raised.</p> <p>Parameters:</p> Name Type Description Default <code>transfo</code> <code>(Transformation, Rotation or Quaternion)</code> <p>Transform(s) broadcastable to the domain size. Typical shapes include <code>(..., 3, 3)</code>; project-specific transform types are also supported if they define the <code>@</code> operator with vectors.</p> required <code>pivot</code> <code>array-like of shape ``(..., 3)`` or None</code> <p>Pivot location(s). If <code>None</code>, transforms are applied about the origin.</p> <code>None</code> <p>Returns:</p> Type Description <code>PointDomain</code> <p>Self (for chaining).</p> <p>Examples:</p> <pre><code># A mesh made of 8 cubes\ncubes = Mesh.cube(size=1)*8\npv = np.random.uniform(-1, 1, (8, 3))\nrot = Rotation.from_euler(np.random.uniform(0, 2*np.pi, (8, 3)))\n# Transform the 8 cubes indivicually\ncubes.points.transform(rot, pivot=pv)\n</code></pre> Examples: <pre><code># A mesh made of 8 cubes\ncubes = Mesh.cube(size=1)*8\npv = np.random.uniform(-1, 1, (8, 3))\nrot = Rotation.from_euler(np.random.uniform(0, 2*np.pi, (8, 3)))\n# Transform the 8 cubes indivicually\ncubes.points.transform(rot, pivot=pv)\n</code></pre>"},{"location":"api/vertex/#npblender.domain.Vertex.translate","title":"translate","text":"<pre><code>translate(translation)\n</code></pre> <p>Translate points position by a vector or a batch of vectors.</p> <p>Supports per-domain translation (single vector), or grouped/batched translations that broadcast over buckets of equal size.</p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>array-like of shape ``(..., 3)``</code> <p>Translation vectors broadcastable to the domain size.</p> required <p>Returns:</p> Type Description <code>PointDomain</code> <p>Self (for chaining).</p> <p>Examples:</p> <pre><code># Per-point random translation\nD.translate(np.random.uniform(-0.1, 0.1, (len(D), 3)))\n\n```python\n# A mesh made of 8 cubes\ncubes = Mesh.cube(size=.2)*8\ntr = np.random.uniform(-1, 1, (8, 3))\n# Translate each cube individually\ncubes.points.translate(tr)\n</code></pre> <p>Caution: If a provided batch cannot be aligned with the domain, a <code>ValueError</code> is raised by <code>_get_shape_for_operation</code>.</p>"}]}