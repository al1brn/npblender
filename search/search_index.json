{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"npblender Documentation","text":"<p>Welcome to the npblender documentation. This project provides data structures and vectorized tools to manipulate Blender geometry and attributes efficiently with NumPy.</p> <p>API is documented here</p>"},{"location":"#about","title":"About","text":"<ul> <li>License: MIT  </li> <li>Author: Alain Bernard  </li> <li>Last updated: 2025-09-01</li> </ul>"},{"location":"api/","title":"npblender API","text":""},{"location":"api/#table-of-contents","title":"Table of Contents","text":""},{"location":"api/#domains","title":"Domains","text":"<ul> <li>Domain</li> <li>Vertex</li> <li>ControlPoint</li> <li>Point</li> <li>Corner</li> <li>Edge</li> <li>Face</li> <li>Spline</li> </ul>"},{"location":"api/#geometries","title":"Geometries","text":"<ul> <li>Geometry</li> <li>Mesh</li> <li>Curve</li> </ul>"},{"location":"api/controlpoint/","title":"Controlpoint","text":""},{"location":"api/controlpoint/#npblender.domain.ControlPoint","title":"ControlPoint","text":"<pre><code>ControlPoint(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>Curve control point domain.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>(N, 3) float</code> <p>Control point positions.</p> <code>w</code> <code>(N,) float, optional</code> <p>Rational weight (NURBS).</p> <code>handle_left, handle_right</code> <code>(N, 3) float, optional</code> <p>Bezier handles in object space.</p> <code>handle_type_left, handle_type_right</code> <code>(N,) int, optional</code> <p>Bezier handle types.</p> <code>tilt</code> <code>(N,) float, optional</code> <p>Tilt (radians).</p> <code>radius</code> <code>(N,) float, optional</code> <p>Display radius.</p> <code>weight</code> <code>(N,) float, optional</code> <p>Generic user-defined weight.</p> See Also <p><code>Spline</code> : Spline domain grouping control points.</p> Notes <ul> <li>Scaling also applies to handles.</li> <li>Rotational transforms rotate handles using the transform's rotation   only (scales are not applied to handles).</li> </ul> <p>Examples:</p> <p>Average a control-point attribute on splines:</p> <pre><code>mean_tilt = cpoints.compute_attribute_on_splines(\"tilt\", splines)\n</code></pre> <p>Apply a transform that rotates handles consistently:</p> <pre><code>cpoints.transform(T)  # where T is a Transformation or Rotation\n</code></pre> <p>Initialize a domain array and its attribute schema.</p> <p>Initializes the storage from an existing array/domain or creates an empty structure. Optionally merges attribute definitions/values from another domain and keyword-provided attributes.</p> <p>Domains are never instancied directly but by owning geometries.</p> <p>Actual Domains are <code>Vertex</code>, [<code>Faces</code>][npblender.domain.Faces], <code>Corner</code>, <code>Edge</code>, <code>ControlPoint</code>, <code>Spline</code> and <code>Point</code>.</p> <p>Domains are initialized with their defaults attributes, for instance <code>position</code> for point domaines.</p> <p>Use attributes can be freely added. </p> <p>Note: user attributes are saved in Blender Mesh objects only, Blender Curve objects don't store user attributes.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>array - like or FieldArray or None</code> <p>Source data used to initialize the domain. If <code>None</code>, an empty domain is created and <code>_declare_attributes()</code> is called to register defaults.</p> <code>None</code> <code>mode</code> <code>(COPY, CAPTURE, EMPTY)</code> <p>Initialization mode. <code>'COPY'</code> duplicates the input data, <code>'CAPTURE'</code> references the input buffer when supported, <code>'EMPTY'</code> creates the structure without copying values.</p> <code>'COPY'</code> <code>selector</code> <code>Any</code> <p>Optional row/element selector applied to <code>a</code> prior to initialization.</p> <code>None</code> <code>attr_from</code> <code>Domain or Mapping or None</code> <p>Attribute schema (and possibly values) to merge into this domain.</p> <code>None</code> <code>**attrs</code> <p>Additional attribute name/value pairs to inject or override.</p> <code>{}</code> Notes <p>The effective attribute list results from <code>_declare_attributes()</code>, then <code>attr_from</code>, then <code>**attrs</code> (later entries take precedence).</p> <p>Examples:</p> <pre><code>cube = Mesh.cube() # points, corners, faces and edges domains are created\n# Adding named attribute to point domain\ncube.points.new_float('age')\n# Setting the age\ncube.points.age = np.random.uniforme(10, 10, len(cube.points))\n</code></pre>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.actual_names","title":"actual_names  <code>property</code>","text":"<pre><code>actual_names\n</code></pre> <p>Column names.</p> <p>Returns the actual field names, excluding optional fields.</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.all_names","title":"all_names  <code>property</code>","text":"<pre><code>all_names\n</code></pre> <p>Column names.</p> <p>Returns all the field names, including optional ones.</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Array structured dtype</p> <p>Returns the dtype property of the structured array.</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.transdom_names","title":"transdom_names  <code>property</code>","text":"<pre><code>transdom_names\n</code></pre> <p>List the names of trans-domain attributes.</p> <p>Returns:</p> Type Description <code>list of str</code> <p>Names of attributes flagged with <code>transdom=True</code>.</p> <p>Examples:</p> <pre><code>names = D.transdom_names()\n</code></pre>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.x","title":"x  <code>property</code> <code>writable</code>","text":"<pre><code>x\n</code></pre> <p>X coordinate accessor.</p> <p>Shorthand for <code>position[..., 0]</code>. Reading returns a view; assigning to this property writes into the underlying <code>position</code> field.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>View of shape <code>(...,)</code> selecting the x component of <code>position</code>.</p> <p>Examples:</p> <p>Read and write x in place:</p> <pre><code>xs = points.x              # view on position[..., 0]\npoints.x = xs + 1.0        # shift x by +1\n</code></pre> <p>Note: This is equivalent to <code>points.position[..., 0]</code>.</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.y","title":"y  <code>property</code> <code>writable</code>","text":"<pre><code>y\n</code></pre> <p>Y coordinate accessor.</p> <p>Shorthand for <code>position[..., 1]</code>. Reading returns a view; assigning to this property writes into the underlying <code>position</code> field.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>View of shape <code>(...,)</code> selecting the y component of <code>position</code>.</p> <p>Examples:</p> <pre><code>points.y = 0.0             # flatten all y to 0\n</code></pre>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.z","title":"z  <code>property</code> <code>writable</code>","text":"<pre><code>z\n</code></pre> <p>Z coordinate accessor.</p> <p>Shorthand for <code>position[..., 2]</code>. Reading returns a view; assigning to this property writes into the underlying <code>position</code> field.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>View of shape <code>(...,)</code> selecting the z component of <code>position</code>.</p> <p>Examples:</p> <pre><code>points.z += 2.5\n</code></pre>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.add","title":"add","text":"<pre><code>add(count, **fields)\n</code></pre> <p>Add count records</p> <p>New records are set with default values or values provided by the user in fields dict.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of records to add.</p> required <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.append","title":"append","text":"<pre><code>append(**fields)\n</code></pre> <p>Append values to the structured array.</p> <p>The number of records to append is determined by the number of fields provided in the fields dictionary. The values of the fields are copied to the new records.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.apply_scale","title":"apply_scale","text":"<pre><code>apply_scale(scale, pivot=None)\n</code></pre> <p>Apply per-axis scales to control points, and scale handles as well.</p> <p>First applies per-axis scaling to <code>position</code> via <code>apply_scale</code>, then, if Bezier handles are present, scales <code>handle_left</code> and <code>handle_right</code> by the same <code>scale</code>.</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>array-like of shape ``(..., 3)``</code> <p>Per-axis scale factors broadcastable to the domain size.</p> required <code>pivot</code> <code>array-like of shape ``(..., 3)`` or None</code> <p>Pivot location(s) for point scaling. If <code>None</code>, scales are applied about the origin.</p> <code>None</code> <p>Returns:</p> Type Description <code>ControlPoint</code> <p>Self (for chaining).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the operand cannot be aligned with the domain size (raised by <code>_get_shape_for_operation</code>).</p> <p>Examples:</p> <pre><code># Uniform scale per control point\ns = np.full((len(CP), 3), 0.5)\nCP.apply_scale(s)\n\n# Per-spline scale about per-spline pivot\nCP.apply_scale(scales, pivot=pivots)\n</code></pre>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.as_kwargs","title":"as_kwargs","text":"<pre><code>as_kwargs(selector=None, include=None, exclude=None)\n</code></pre> <p>Return a dictionary of field values formatted as kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>slice, int, list, or mask</code> <p>Optional selection of elements to extract.</p> <code>None</code> <code>include</code> <code>list[str]</code> <p>List of field names (original or python names) to include.</p> <code>None</code> <code>exclude</code> <code>list[str]</code> <p>List of field names (original or python names) to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Mapping from python-safe field names to array values.</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.compute_attribute_on_splines","title":"compute_attribute_on_splines","text":"<pre><code>compute_attribute_on_splines(attr, splines)\n</code></pre> <p>Average a per-control-point attribute over each spline.</p> <p>For every spline, computes the mean of the source control-point attribute over its range <code>[loop_start, loop_start + loop_total)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str or ndarray, shape ``(N, ...)``</code> <p>Control-point attribute to aggregate. If a string, the field is looked up on this domain; if an array, it must have length <code>N == len(self)</code>. The trailing item shape (<code>...</code>) is preserved.</p> required <code>splines</code> <code>Spline</code> <p>Spline domain providing <code>loop_start</code> and <code>loop_total</code> arrays.</p> required <p>Returns:</p> Type Description <code>ndarray, shape ``(len(splines), ...)``</code> <p>Spline-wise averaged attribute. The trailing item shape is preserved and the dtype follows the input attribute.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>attr</code> is scalar or its first dimension does not match <code>len(self)</code> (raised by <code>_check_attribute_to_compute</code>).</p> <code>IndexError</code> <p>If <code>splines.loop_start</code>/<code>loop_total</code> describe ranges outside <code>[0, len(self))</code>.</p> <code>TypeError</code> <p>If the attribute dtype cannot be averaged (e.g., integer arrays will fail on in-place division).</p> Notes <p>This routine computes an unweighted arithmetic mean of the attribute over each spline's control points.</p> <p>Examples:</p> <pre><code># Average tilt per spline from control points\nmean_tilt = cpoints.compute_attribute_on_splines(\"tilt\", splines)\n\n# Average a custom per-control-point float attribute\nmean_w = cpoints.compute_attribute_on_splines(weights, splines)\n</code></pre>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.copy_field","title":"copy_field","text":"<pre><code>copy_field(field_name, new_name, **infos)\n</code></pre> <p>Duplicate an existing field under a new name, with optional metadata overrides.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the existing field to copy.</p> required <code>new_name</code> <code>str</code> <p>The name of the new field to create.</p> required <code>infos</code> <code>keyword arguments</code> <p>Optional metadata (e.g. default, unit, description...) to override or supplement the original field's metadata.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the source field does not exist.</p> <code>ValueError</code> <p>If the target name already exists or is reserved.</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.delete","title":"delete","text":"<pre><code>delete(index)\n</code></pre> <p>Delete a selection of items from the array.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int, slice, or array-like</code> <p>The indices of the elements to delete from the current data.</p> required Notes <p>This operates only on the valid range <code>[0:self._length]</code>. The internal buffer is preserved (no reallocation).</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.dump","title":"dump","text":"<pre><code>dump(title='Dump', attributes=None, target='SCREEN')\n</code></pre> <p>Pretty-print or export domain content.</p> <p>Formats attribute values and prints to screen or builds a tabular dump suitable for spreadsheets.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title displayed in the report.</p> <code>'Dump'</code> <code>attributes</code> <code>Sequence[str] or None</code> <p>Subset of attribute names to include. If <code>None</code>, all attributes are shown.</p> <code>None</code> <code>target</code> <code>(SCREEN, ...)</code> <p>Output target. <code>'SCREEN'</code> prints to stdout; other targets may trigger file creation depending on the implementation.</p> <code>'SCREEN'</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>Domain(points).dump(title=\"Vertices\")\n</code></pre> <p>Note: Formatting adapts to the chosen <code>target</code>.</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.extend","title":"extend","text":"<pre><code>extend(other, join_fields=True)\n</code></pre> <p>Append multiple records from another array or FieldArray.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray or structured np.ndarray</code> <p>The array of records to append. Must have named fields matching a subset of the current array's fields.</p> required"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.filtered","title":"filtered","text":"<pre><code>filtered(selector, *, copy=False)\n</code></pre> <p>Return a FieldArray containing only the selected records.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>array\u2011like, slice or int</code> <p>Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice. It is applied to the current valid part of the buffer (<code>self._data[:self._length]</code>).</p> required <code>copy</code> <code>bool</code> <ul> <li>False    (default) =&gt; the new array shares the same memory                          (changes propagate both ways).</li> <li>True           =&gt; the data are physically copied.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>FieldArray</code> <p>A new instance holding exactly <code>len(selector)</code> records and inheriting the current field\u2011infos.</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.from_bl_attributes","title":"from_bl_attributes","text":"<pre><code>from_bl_attributes(bl_attributes)\n</code></pre> <p>Import attributes from a Blender attribute collection.</p> <p>Reads geometry attributes from a Blender data-block and creates/updates the corresponding domain attributes, resizing the domain if needed.</p> <p>Parameters:</p> Name Type Description Default <code>bl_attributes</code> <code>Mapping[str, Any]</code> <p>Blender attributes collection (name \u2192 attribute descriptor) providing at least <code>.domain</code>, <code>.is_internal</code>, <code>.data_type</code>, and <code>.data</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Note:*** Only external (non-internal) Blender attributes matching this</code> <code>domain are imported. Missing attributes are created with `transfer=True`.</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Build a FieldArray from a dictionary with field data and optional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, array - like or (array, dict)]</code> <p>Mapping field names to arrays or (array, infos). Infos must include NAME.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the data. Default: True.</p> required <p>Returns:</p> Type Description <code>FieldArray</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> <p>Get attribute by name.</p> <p>If name is not an actual field, return default value. Name can be an array. <pre><code>pos = field_array.get(\"position\", (0, 0, 1))\npos = field_array.get([[0, 0, 1], [0, 0, 0]])\n</code></pre></p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other)\n</code></pre> <p>Merge trans-domain attributes from another domain.</p> <p>Copies or aligns attributes from <code>other</code> into the current domain, excluding any attributes not flagged as trans-domain in <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain or None</code> <p>Source domain. If <code>None</code>, the call is a no-op.</p> required <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.join_fields","title":"join_fields","text":"<pre><code>join_fields(other, exclude=[])\n</code></pre> <p>Add all missing fields from another FieldArray.</p> <p>For every field in <code>other</code> that is not present in <code>self</code>, a new field is created with the same dtype and shape, and initialized with its default value across all existing records.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray</code> <p>Another FieldArray instance whose fields will be checked for missing fields.</p> required <p>Returns:</p> Type Description <code>self</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.make_buckets","title":"make_buckets","text":"<pre><code>make_buckets(attr)\n</code></pre> <p>Group items into buckets by attribute value.</p> <p>When a domain is to be considered as a collection of packets of various sizes, buckets mechanism groups pakets by size, allowing further operation with numpy vectorization.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>array - like or str</code> <p>Either an integer of shape <code>(N,)</code> or the name of an existing integer attribute in the domain.</p> required <p>Returns:</p> Type Description <code>list[ndarray(count, n)]</code> <p>A list of int arrays (count, n): count is the number of buckets of length n.</p> <p>Examples:</p> <pre><code>buckets = mesh.make_buckets('material')\nfor bucket in buckets:\n    print(bucket.shape)\n</code></pre> <p>Note: The bucket attribute can be read with <code>attr[bucket[:, 0]]</code>.</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.multiply","title":"multiply","text":"<pre><code>multiply(count)\n</code></pre> <p>Duplicate the current records <code>count</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of times to repeat the current records.</p> required Notes <p>This duplicates the current valid records (up to self._length). If the array is empty or count &lt;= 1, nothing happens.</p> Example: <p>If the array has 3 records and count == 4, the result will be:</p> <p>[rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]</p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_attribute","title":"new_attribute","text":"<pre><code>new_attribute(name, data_type, default, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Register a new attribute in the domain schema.</p> <p>Creates (or ensures) an attribute with a given name, logical data type, default value, and flags controlling Blender transfer and cross-domain propagation.</p> <p>Note: <code>data_type</code> argument is a Blender data type not a python data type. The data type name is compatible with Blender internal storage. <code>FLOAT</code>data type is implemented as <code>np.float32</code> and  'INT' as <code>np.int32</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name (Python identifier recommended).</p> required <code>data_type</code> <code>(FLOAT, INT, BOOL, VECTOR, VECTOR2, COLOR, QUATERNION, MATRIX, STRING, ...)</code> <p>Logical data type used by the domain.</p> <code>'FLOAT'</code> <code>default</code> <code>Any</code> <p>Default value for newly allocated elements.</p> required <code>optional</code> <code>bool</code> <p>If <code>True</code>, the attribute may be absent on some elements.</p> <code>False</code> <code>transfer</code> <code>bool</code> <p>If <code>True</code>, eligible to be transferred to Blender as a geometry attribute.</p> <code>True</code> <code>transdom</code> <code>bool</code> <p>If <code>True</code>, considered a trans-domain attribute that can be copied across compatible domains.</p> <code>True</code> See Also <p><code>new_float</code>, <code>new_vector</code>, <code>new_int</code>, <code>new_bool</code>, <code>new_color</code>, <code>new_vector2</code>, <code>new_quaternion</code>, <code>new_matrix</code></p>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_bool","title":"new_bool","text":"<pre><code>new_bool(name, default=False, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a boolean attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>bool</code> <p>Default value.</p> <code>False</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_color","title":"new_color","text":"<pre><code>new_color(name, default=(0.5, 0.5, 0.5, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a color attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,) or (4,)</code> <p>Default color as RGB or RGBA.</p> <code>(0.5, 0.5, 0.5, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_field","title":"new_field","text":"<pre><code>new_field(name, dtype, shape=None, default=0, optional=False, **infos)\n</code></pre> <p>Add a field to the structured array.</p> Arguments <pre><code>- name (str) : field name\n- dtype (type) : a valid numpy dtype\n- shape (tuple = None) : the shape of the field\n- default (any = 0) : default value\n- optional (bool = False) : the field is created only when accessed\n- infos (dict) : field infos\n</code></pre>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_float","title":"new_float","text":"<pre><code>new_float(name, default=0.0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a scalar float attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>float</code> <p>Default value.</p> <code>0.0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_int","title":"new_int","text":"<pre><code>new_int(name, default=0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure an integer attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>int</code> <p>Default value.</p> <code>0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_matrix","title":"new_matrix","text":"<pre><code>new_matrix(name, default=np.eye(4), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a matrix attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array - like</code> <p>Default matrix. By convention this is a square matrix per element (e.g., <code>(3, 3)</code> rotation or <code>(4, 4)</code> transform).</p> <code>np.eye(4)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code> <code>order</code> required"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_quaternion","title":"new_quaternion","text":"<pre><code>new_quaternion(name, default=(0.0, 0.0, 0.0, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a quaternion attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (4,)</code> <p>Default quaternion in <code>(x, y, z, w)</code> convention.</p> <code>(0.0, 0.0, 0.0, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_vector","title":"new_vector","text":"<pre><code>new_vector(name, default=(0.0, 0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 3D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,)</code> <p>Default XYZ vector.</p> <code>(0.0, 0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.new_vector2","title":"new_vector2","text":"<pre><code>new_vector2(name, default=(0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 2D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (2,)</code> <p>Default XY vector.</p> <code>(0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.to_bl_attributes","title":"to_bl_attributes","text":"<pre><code>to_bl_attributes(attributes, update=False)\n</code></pre> <p>Export attributes to a Blender attribute collection.</p> <p>Writes eligible domain attributes to a Blender data-block, creating missing attributes and adjusting sizes as needed.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Any</code> <p>Blender attributes collection receiving the values.</p> required <code>update</code> <code>bool</code> <p>If <code>True</code>, update existing attributes in-place; otherwise create them when missing.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Caution:*** Only attributes with `transfer=True` are exported. Optional</code> <code>attributes are skipped.</code> <code>&gt; ***Caution:*** Curve domains user attributes are not saved.</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.to_dict","title":"to_dict","text":"<pre><code>to_dict(*, copy=True, with_infos=True)\n</code></pre> <p>Convert the array to a dictionary of fields or (field, infos) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Whether to copy the arrays.</p> <code>True</code> <code>with_infos</code> <code>bool</code> <p>If True, return (array, infos) for each field.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, array or (array, dict)]</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.transfer_attributes","title":"transfer_attributes","text":"<pre><code>transfer_attributes(other, shape=None, other_shape=None)\n</code></pre> <p>Transfer values of trans-domain attributes from another domain.</p> <p>Copies values for each trans-domain attribute present in <code>other</code> into the corresponding attributes of <code>self</code>, with optional reshaping for batched assignments.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain</code> <p>Source domain providing attribute values.</p> required <code>shape</code> <code>tuple of int or None</code> <p>Target reshape for <code>self</code> before assignment. If <code>None</code>, uses <code>(self._length,)</code>.</p> <code>None</code> <code>other_shape</code> <code>tuple of int or None</code> <p>Source reshape for <code>other</code> before assignment. If <code>None</code>, uses <code>(other._length,)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p> <code>&gt; ***Note:*** Each attribute is reshaped as `shape + item_shape` on `self`</code> <code>and `other_shape + item_shape` on `other` prior to assignment.</code>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.transform","title":"transform","text":"<pre><code>transform(transfo, pivot=None)\n</code></pre> <p>Apply a linear transform to control points; rotate handles consistently.</p> <p>Applies the transform to <code>position</code> via <code>transform</code>. If Bezier handles are present, applies only the rotation part to <code>handle_left</code> and <code>handle_right</code> (i.e., scales are not applied to handles). Broadcasting is resolved with</p> <p>Parameters:</p> Name Type Description Default <code>transfo</code> <code>(Transformation, Quaternion or Rotation)</code> <p>The transformtion to apply</p> required <code>pivot</code> <code>array-like of shape ``(..., 3)`` or None</code> <p>Pivot location(s). If <code>None</code>, transforms are applied about the origin.</p> <code>None</code> <p>Returns:</p> Type Description <code>ControlPoint</code> <p>Self (for chaining).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the operand cannot be aligned with the domain size (raised by <code>_get_shape_for_operation</code>).</p> <code>TypeError</code> <p>If <code>transfo</code> does not support the <code>@</code> operator with vectors or lacks a usable <code>rotation</code> component for handle updates.</p> <p>Examples:</p> <pre><code># Per-point rotations (as 3x3 matrices)\nR = npblender.Rotation.from_euler(\"XYZ\", np.random.uniform(0, 1, (len(CP), 3))).as_matrix()\nCP.transform(R)\n\n# Rotate per-spline around per-spline pivot\nCP.transform(R_chunks, pivot=pivots)\n</code></pre>"},{"location":"api/controlpoint/#npblender.domain.ControlPoint.translate","title":"translate","text":"<pre><code>translate(translation)\n</code></pre> <p>Translate points position by a vector or a batch of vectors.</p> <p>Supports per-domain translation (single vector), or grouped/batched translations that broadcast over buckets of equal size.</p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>array-like of shape ``(..., 3)``</code> <p>Translation vectors broadcastable to the domain size.</p> required <p>Returns:</p> Type Description <code>PointDomain</code> <p>Self (for chaining).</p> <p>Examples:</p> <pre><code># Per-point random translation\nD.translate(np.random.uniform(-0.1, 0.1, (len(D), 3)))\n\n```python\n# A mesh made of 8 cubes\ncubes = Mesh.cube(size=.2)*8\ntr = np.random.uniform(-1, 1, (8, 3))\n# Translate each cube individually\ncubes.points.translate(tr)\n</code></pre> <p>Caution: If a provided batch cannot be aligned with the domain, a <code>ValueError</code> is raised by <code>_get_shape_for_operation</code>.</p>"},{"location":"api/corner/","title":"Corner","text":""},{"location":"api/corner/#npblender.domain.Corner","title":"Corner","text":"<pre><code>Corner(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>Mesh corner (loop) domain.</p> <p>Stores, for each corner of each face, the index of the associated vertex and optional per-corner attributes (e.g., UVs).</p> <p>Attributes:</p> Name Type Description <code>vertex_index</code> <code>(M,) int</code> <p>Index of the referenced vertex in the point (vertex) array.</p> <code>UVMap</code> <code>(M, 2) float, optional</code> <p>UV coordinates (you may create additional maps via :meth:<code>new_uvmap</code>).</p> <p>Methods:</p> Name Description <code>check</code> <p>Validate that all vertex indices are &lt; <code>count</code>.</p> <code>new_uvmap</code> <p>Create and optionally initialize a new UV map attribute.</p> <code>compute_attribute_on_points</code> <p>Average a per-corner attribute back to points (vertices).</p> <p>Examples:</p> <p>Create a second UV map:</p> <pre><code>corners.new_uvmap(\"UV2\", value=(0.0, 0.0))\n</code></pre> <p>Accumulate per-corner shading to vertices:</p> <pre><code>v_attr = corners.compute_attribute_on_points(\"illum\", points)\n</code></pre> <p>Initialize a domain array and its attribute schema.</p> <p>Initializes the storage from an existing array/domain or creates an empty structure. Optionally merges attribute definitions/values from another domain and keyword-provided attributes.</p> <p>Domains are never instancied directly but by owning geometries.</p> <p>Actual Domains are <code>Vertex</code>, [<code>Faces</code>][npblender.domain.Faces], <code>Corner</code>, <code>Edge</code>, <code>ControlPoint</code>, <code>Spline</code> and <code>Point</code>.</p> <p>Domains are initialized with their defaults attributes, for instance <code>position</code> for point domaines.</p> <p>Use attributes can be freely added. </p> <p>Note: user attributes are saved in Blender Mesh objects only, Blender Curve objects don't store user attributes.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>array - like or FieldArray or None</code> <p>Source data used to initialize the domain. If <code>None</code>, an empty domain is created and <code>_declare_attributes()</code> is called to register defaults.</p> <code>None</code> <code>mode</code> <code>(COPY, CAPTURE, EMPTY)</code> <p>Initialization mode. <code>'COPY'</code> duplicates the input data, <code>'CAPTURE'</code> references the input buffer when supported, <code>'EMPTY'</code> creates the structure without copying values.</p> <code>'COPY'</code> <code>selector</code> <code>Any</code> <p>Optional row/element selector applied to <code>a</code> prior to initialization.</p> <code>None</code> <code>attr_from</code> <code>Domain or Mapping or None</code> <p>Attribute schema (and possibly values) to merge into this domain.</p> <code>None</code> <code>**attrs</code> <p>Additional attribute name/value pairs to inject or override.</p> <code>{}</code> Notes <p>The effective attribute list results from <code>_declare_attributes()</code>, then <code>attr_from</code>, then <code>**attrs</code> (later entries take precedence).</p> <p>Examples:</p> <pre><code>cube = Mesh.cube() # points, corners, faces and edges domains are created\n# Adding named attribute to point domain\ncube.points.new_float('age')\n# Setting the age\ncube.points.age = np.random.uniforme(10, 10, len(cube.points))\n</code></pre>"},{"location":"api/corner/#npblender.domain.Corner.actual_names","title":"actual_names  <code>property</code>","text":"<pre><code>actual_names\n</code></pre> <p>Column names.</p> <p>Returns the actual field names, excluding optional fields.</p>"},{"location":"api/corner/#npblender.domain.Corner.all_names","title":"all_names  <code>property</code>","text":"<pre><code>all_names\n</code></pre> <p>Column names.</p> <p>Returns all the field names, including optional ones.</p>"},{"location":"api/corner/#npblender.domain.Corner.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Array structured dtype</p> <p>Returns the dtype property of the structured array.</p>"},{"location":"api/corner/#npblender.domain.Corner.transdom_names","title":"transdom_names  <code>property</code>","text":"<pre><code>transdom_names\n</code></pre> <p>List the names of trans-domain attributes.</p> <p>Returns:</p> Type Description <code>list of str</code> <p>Names of attributes flagged with <code>transdom=True</code>.</p> <p>Examples:</p> <pre><code>names = D.transdom_names()\n</code></pre>"},{"location":"api/corner/#npblender.domain.Corner.add","title":"add","text":"<pre><code>add(count, **fields)\n</code></pre> <p>Add count records</p> <p>New records are set with default values or values provided by the user in fields dict.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of records to add.</p> required <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/corner/#npblender.domain.Corner.append","title":"append","text":"<pre><code>append(**fields)\n</code></pre> <p>Append values to the structured array.</p> <p>The number of records to append is determined by the number of fields provided in the fields dictionary. The values of the fields are copied to the new records.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/corner/#npblender.domain.Corner.as_kwargs","title":"as_kwargs","text":"<pre><code>as_kwargs(selector=None, include=None, exclude=None)\n</code></pre> <p>Return a dictionary of field values formatted as kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>slice, int, list, or mask</code> <p>Optional selection of elements to extract.</p> <code>None</code> <code>include</code> <code>list[str]</code> <p>List of field names (original or python names) to include.</p> <code>None</code> <code>exclude</code> <code>list[str]</code> <p>List of field names (original or python names) to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Mapping from python-safe field names to array values.</p>"},{"location":"api/corner/#npblender.domain.Corner.check","title":"check","text":"<pre><code>check(count, halt=True)\n</code></pre> <p>Validate corner indices against a vertex count.</p> <p>Verifies that all entries of <code>vertex_index</code> reference valid vertices (i.e., are strictly less than <code>count</code>). When invalid indices are detected, either raises or logs an error depending on <code>halt</code>.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of vertices in the referenced point/vertex domain.</p> required <code>halt</code> <code>bool</code> <p>If <code>True</code>, raise on failure; otherwise print a message and return <code>False</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the check passes or the domain is empty; <code>False</code> only when invalid and <code>halt</code> is <code>False</code>.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If invalid indices are found and <code>halt</code> is <code>True</code>.</p> <p>Examples:</p> <pre><code>ok = corners.check(count=len(vertices), halt=False)\nif not ok:\n    # fix topology or filter invalid corners\n    ...\n</code></pre>"},{"location":"api/corner/#npblender.domain.Corner.compute_attribute_on_points","title":"compute_attribute_on_points","text":"<pre><code>compute_attribute_on_points(attr, points)\n</code></pre> <p>Average a per-corner attribute back to points (vertices).</p> <p>For each vertex, computes the mean of the source attribute over all incident corners (as defined by <code>vertex_index</code>). The attribute is validated with <code>_check_attribute_to_compute</code>.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str or ndarray, shape ``(M, ...)``</code> <p>Corner attribute to average. If a string, the field is looked up on this domain; if an array, it must have length <code>M == len(self)</code>. The trailing item shape (<code>...</code>) is preserved.</p> required <code>points</code> <code>Vertex</code> <p>Vertex domain used to size the result (<code>len(points)</code>).</p> required <p>Returns:</p> Type Description <code>ndarray, shape ``(len(points), ...)``</code> <p>Per-vertex averaged attribute. The trailing item shape is preserved and the dtype follows the input attribute.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>attr</code> is scalar or its first dimension does not match <code>len(self)</code> (raised by <code>_check_attribute_to_compute</code>).</p> <code>IndexError</code> <p>If <code>vertex_index</code> contains indices outside <code>[0, len(points))</code>.</p> <code>TypeError</code> <p>If the attribute dtype cannot be averaged (e.g., non-numeric types).</p> Notes <p>This routine computes an unweighted arithmetic mean per vertex over all incident corners.</p> <p>Examples:</p> <pre><code># Accumulate per-corner illumination to vertices\nv_illum = corners.compute_attribute_on_points(\"illum\", vertices)\n\n# Average custom corner vectors per vertex\nv_vec = corners.compute_attribute_on_points(corner_vecs, vertices)\n</code></pre>"},{"location":"api/corner/#npblender.domain.Corner.copy_field","title":"copy_field","text":"<pre><code>copy_field(field_name, new_name, **infos)\n</code></pre> <p>Duplicate an existing field under a new name, with optional metadata overrides.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the existing field to copy.</p> required <code>new_name</code> <code>str</code> <p>The name of the new field to create.</p> required <code>infos</code> <code>keyword arguments</code> <p>Optional metadata (e.g. default, unit, description...) to override or supplement the original field's metadata.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the source field does not exist.</p> <code>ValueError</code> <p>If the target name already exists or is reserved.</p>"},{"location":"api/corner/#npblender.domain.Corner.delete","title":"delete","text":"<pre><code>delete(index)\n</code></pre> <p>Delete a selection of items from the array.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int, slice, or array-like</code> <p>The indices of the elements to delete from the current data.</p> required Notes <p>This operates only on the valid range <code>[0:self._length]</code>. The internal buffer is preserved (no reallocation).</p>"},{"location":"api/corner/#npblender.domain.Corner.dump","title":"dump","text":"<pre><code>dump(title='Dump', attributes=None, target='SCREEN')\n</code></pre> <p>Pretty-print or export domain content.</p> <p>Formats attribute values and prints to screen or builds a tabular dump suitable for spreadsheets.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title displayed in the report.</p> <code>'Dump'</code> <code>attributes</code> <code>Sequence[str] or None</code> <p>Subset of attribute names to include. If <code>None</code>, all attributes are shown.</p> <code>None</code> <code>target</code> <code>(SCREEN, ...)</code> <p>Output target. <code>'SCREEN'</code> prints to stdout; other targets may trigger file creation depending on the implementation.</p> <code>'SCREEN'</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>Domain(points).dump(title=\"Vertices\")\n</code></pre> <p>Note: Formatting adapts to the chosen <code>target</code>.</p>"},{"location":"api/corner/#npblender.domain.Corner.extend","title":"extend","text":"<pre><code>extend(other, join_fields=True)\n</code></pre> <p>Append multiple records from another array or FieldArray.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray or structured np.ndarray</code> <p>The array of records to append. Must have named fields matching a subset of the current array's fields.</p> required"},{"location":"api/corner/#npblender.domain.Corner.filtered","title":"filtered","text":"<pre><code>filtered(selector, *, copy=False)\n</code></pre> <p>Return a FieldArray containing only the selected records.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>array\u2011like, slice or int</code> <p>Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice. It is applied to the current valid part of the buffer (<code>self._data[:self._length]</code>).</p> required <code>copy</code> <code>bool</code> <ul> <li>False    (default) =&gt; the new array shares the same memory                          (changes propagate both ways).</li> <li>True           =&gt; the data are physically copied.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>FieldArray</code> <p>A new instance holding exactly <code>len(selector)</code> records and inheriting the current field\u2011infos.</p>"},{"location":"api/corner/#npblender.domain.Corner.from_bl_attributes","title":"from_bl_attributes","text":"<pre><code>from_bl_attributes(bl_attributes)\n</code></pre> <p>Import attributes from a Blender attribute collection.</p> <p>Reads geometry attributes from a Blender data-block and creates/updates the corresponding domain attributes, resizing the domain if needed.</p> <p>Parameters:</p> Name Type Description Default <code>bl_attributes</code> <code>Mapping[str, Any]</code> <p>Blender attributes collection (name \u2192 attribute descriptor) providing at least <code>.domain</code>, <code>.is_internal</code>, <code>.data_type</code>, and <code>.data</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Note:*** Only external (non-internal) Blender attributes matching this</code> <code>domain are imported. Missing attributes are created with `transfer=True`.</code>"},{"location":"api/corner/#npblender.domain.Corner.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Build a FieldArray from a dictionary with field data and optional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, array - like or (array, dict)]</code> <p>Mapping field names to arrays or (array, infos). Infos must include NAME.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the data. Default: True.</p> required <p>Returns:</p> Type Description <code>FieldArray</code>"},{"location":"api/corner/#npblender.domain.Corner.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> <p>Get attribute by name.</p> <p>If name is not an actual field, return default value. Name can be an array. <pre><code>pos = field_array.get(\"position\", (0, 0, 1))\npos = field_array.get([[0, 0, 1], [0, 0, 0]])\n</code></pre></p>"},{"location":"api/corner/#npblender.domain.Corner.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other)\n</code></pre> <p>Merge trans-domain attributes from another domain.</p> <p>Copies or aligns attributes from <code>other</code> into the current domain, excluding any attributes not flagged as trans-domain in <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain or None</code> <p>Source domain. If <code>None</code>, the call is a no-op.</p> required <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p>"},{"location":"api/corner/#npblender.domain.Corner.join_fields","title":"join_fields","text":"<pre><code>join_fields(other, exclude=[])\n</code></pre> <p>Add all missing fields from another FieldArray.</p> <p>For every field in <code>other</code> that is not present in <code>self</code>, a new field is created with the same dtype and shape, and initialized with its default value across all existing records.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray</code> <p>Another FieldArray instance whose fields will be checked for missing fields.</p> required <p>Returns:</p> Type Description <code>self</code>"},{"location":"api/corner/#npblender.domain.Corner.make_buckets","title":"make_buckets","text":"<pre><code>make_buckets(attr)\n</code></pre> <p>Group items into buckets by attribute value.</p> <p>When a domain is to be considered as a collection of packets of various sizes, buckets mechanism groups pakets by size, allowing further operation with numpy vectorization.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>array - like or str</code> <p>Either an integer of shape <code>(N,)</code> or the name of an existing integer attribute in the domain.</p> required <p>Returns:</p> Type Description <code>list[ndarray(count, n)]</code> <p>A list of int arrays (count, n): count is the number of buckets of length n.</p> <p>Examples:</p> <pre><code>buckets = mesh.make_buckets('material')\nfor bucket in buckets:\n    print(bucket.shape)\n</code></pre> <p>Note: The bucket attribute can be read with <code>attr[bucket[:, 0]]</code>.</p>"},{"location":"api/corner/#npblender.domain.Corner.multiply","title":"multiply","text":"<pre><code>multiply(count)\n</code></pre> <p>Duplicate the current records <code>count</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of times to repeat the current records.</p> required Notes <p>This duplicates the current valid records (up to self._length). If the array is empty or count &lt;= 1, nothing happens.</p> Example: <p>If the array has 3 records and count == 4, the result will be:</p> <p>[rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]</p>"},{"location":"api/corner/#npblender.domain.Corner.new_attribute","title":"new_attribute","text":"<pre><code>new_attribute(name, data_type, default, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Register a new attribute in the domain schema.</p> <p>Creates (or ensures) an attribute with a given name, logical data type, default value, and flags controlling Blender transfer and cross-domain propagation.</p> <p>Note: <code>data_type</code> argument is a Blender data type not a python data type. The data type name is compatible with Blender internal storage. <code>FLOAT</code>data type is implemented as <code>np.float32</code> and  'INT' as <code>np.int32</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name (Python identifier recommended).</p> required <code>data_type</code> <code>(FLOAT, INT, BOOL, VECTOR, VECTOR2, COLOR, QUATERNION, MATRIX, STRING, ...)</code> <p>Logical data type used by the domain.</p> <code>'FLOAT'</code> <code>default</code> <code>Any</code> <p>Default value for newly allocated elements.</p> required <code>optional</code> <code>bool</code> <p>If <code>True</code>, the attribute may be absent on some elements.</p> <code>False</code> <code>transfer</code> <code>bool</code> <p>If <code>True</code>, eligible to be transferred to Blender as a geometry attribute.</p> <code>True</code> <code>transdom</code> <code>bool</code> <p>If <code>True</code>, considered a trans-domain attribute that can be copied across compatible domains.</p> <code>True</code> See Also <p><code>new_float</code>, <code>new_vector</code>, <code>new_int</code>, <code>new_bool</code>, <code>new_color</code>, <code>new_vector2</code>, <code>new_quaternion</code>, <code>new_matrix</code></p>"},{"location":"api/corner/#npblender.domain.Corner.new_bool","title":"new_bool","text":"<pre><code>new_bool(name, default=False, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a boolean attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>bool</code> <p>Default value.</p> <code>False</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/corner/#npblender.domain.Corner.new_color","title":"new_color","text":"<pre><code>new_color(name, default=(0.5, 0.5, 0.5, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a color attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,) or (4,)</code> <p>Default color as RGB or RGBA.</p> <code>(0.5, 0.5, 0.5, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/corner/#npblender.domain.Corner.new_field","title":"new_field","text":"<pre><code>new_field(name, dtype, shape=None, default=0, optional=False, **infos)\n</code></pre> <p>Add a field to the structured array.</p> Arguments <pre><code>- name (str) : field name\n- dtype (type) : a valid numpy dtype\n- shape (tuple = None) : the shape of the field\n- default (any = 0) : default value\n- optional (bool = False) : the field is created only when accessed\n- infos (dict) : field infos\n</code></pre>"},{"location":"api/corner/#npblender.domain.Corner.new_float","title":"new_float","text":"<pre><code>new_float(name, default=0.0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a scalar float attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>float</code> <p>Default value.</p> <code>0.0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/corner/#npblender.domain.Corner.new_int","title":"new_int","text":"<pre><code>new_int(name, default=0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure an integer attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>int</code> <p>Default value.</p> <code>0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/corner/#npblender.domain.Corner.new_matrix","title":"new_matrix","text":"<pre><code>new_matrix(name, default=np.eye(4), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a matrix attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array - like</code> <p>Default matrix. By convention this is a square matrix per element (e.g., <code>(3, 3)</code> rotation or <code>(4, 4)</code> transform).</p> <code>np.eye(4)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code> <code>order</code> required"},{"location":"api/corner/#npblender.domain.Corner.new_quaternion","title":"new_quaternion","text":"<pre><code>new_quaternion(name, default=(0.0, 0.0, 0.0, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a quaternion attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (4,)</code> <p>Default quaternion in <code>(x, y, z, w)</code> convention.</p> <code>(0.0, 0.0, 0.0, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/corner/#npblender.domain.Corner.new_uvmap","title":"new_uvmap","text":"<pre><code>new_uvmap(name, value=None)\n</code></pre> <p>Create (and optionally initialize) a per-corner UV map.</p> <p>Declares a new 2D UV attribute with the given <code>name</code>. If <code>value</code> is provided, assigns it to the whole array (broadcast rules apply).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name for the UV map.</p> required <code>value</code> <code>array-like of shape ``(2,)`` or ``(M, 2)`` or None</code> <p>Initial UV values; broadcastable to the corner count.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>value</code> cannot be broadcast to shape <code>(M, 2)</code>.</p> <code>TypeError</code> <p>If <code>value</code> has an incompatible dtype.</p> See Also <p><code>new_vector2</code> :     Registers a 2D vector attribute.</p>"},{"location":"api/corner/#npblender.domain.Corner.new_vector","title":"new_vector","text":"<pre><code>new_vector(name, default=(0.0, 0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 3D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,)</code> <p>Default XYZ vector.</p> <code>(0.0, 0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/corner/#npblender.domain.Corner.new_vector2","title":"new_vector2","text":"<pre><code>new_vector2(name, default=(0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 2D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (2,)</code> <p>Default XY vector.</p> <code>(0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/corner/#npblender.domain.Corner.to_bl_attributes","title":"to_bl_attributes","text":"<pre><code>to_bl_attributes(attributes, update=False)\n</code></pre> <p>Export attributes to a Blender attribute collection.</p> <p>Writes eligible domain attributes to a Blender data-block, creating missing attributes and adjusting sizes as needed.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Any</code> <p>Blender attributes collection receiving the values.</p> required <code>update</code> <code>bool</code> <p>If <code>True</code>, update existing attributes in-place; otherwise create them when missing.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Caution:*** Only attributes with `transfer=True` are exported. Optional</code> <code>attributes are skipped.</code> <code>&gt; ***Caution:*** Curve domains user attributes are not saved.</code>"},{"location":"api/corner/#npblender.domain.Corner.to_dict","title":"to_dict","text":"<pre><code>to_dict(*, copy=True, with_infos=True)\n</code></pre> <p>Convert the array to a dictionary of fields or (field, infos) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Whether to copy the arrays.</p> <code>True</code> <code>with_infos</code> <code>bool</code> <p>If True, return (array, infos) for each field.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, array or (array, dict)]</code>"},{"location":"api/corner/#npblender.domain.Corner.transfer_attributes","title":"transfer_attributes","text":"<pre><code>transfer_attributes(other, shape=None, other_shape=None)\n</code></pre> <p>Transfer values of trans-domain attributes from another domain.</p> <p>Copies values for each trans-domain attribute present in <code>other</code> into the corresponding attributes of <code>self</code>, with optional reshaping for batched assignments.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain</code> <p>Source domain providing attribute values.</p> required <code>shape</code> <code>tuple of int or None</code> <p>Target reshape for <code>self</code> before assignment. If <code>None</code>, uses <code>(self._length,)</code>.</p> <code>None</code> <code>other_shape</code> <code>tuple of int or None</code> <p>Source reshape for <code>other</code> before assignment. If <code>None</code>, uses <code>(other._length,)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p> <code>&gt; ***Note:*** Each attribute is reshaped as `shape + item_shape` on `self`</code> <code>and `other_shape + item_shape` on `other` prior to assignment.</code>"},{"location":"api/curve/","title":"Curve","text":""},{"location":"api/curve/#npblender.curve.Curve","title":"Curve","text":"<pre><code>Curve(points=None, splines=None, curve_type=POLY, materials=None, attr_from=None, **attrs)\n</code></pre> <p>               Bases: <code>Geometry</code></p> <p>Construct a curve geometry.</p> <p>Initializes empty domains by default, or builds a curve from provided control points and spline sizes/types. If both <code>points</code> and <code>splines</code> are already instances of <code>ControlPoint</code> and <code>Spline</code>, the curve is created as a view on these domains (no data copy). Otherwise, domains are allocated and populated via <code>add_splines</code>.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like or [`ControlPoint`](npblender.domain.ControlPoint)</code> <p>Control-point positions (and optional per-point attributes) used to populate the curve. If a <code>ControlPoint</code> domain is provided together with a <code>Spline</code> domain, the curve becomes a view on them.</p> <code>None</code> <code>splines</code> <code>array-like or [`Spline`](npblender.domain.Spline)</code> <p>Per-spline control-point counts (when building), or a ready-made <code>Spline</code> domain (to create a view).</p> <code>None</code> <code>curve_type</code> <code>int</code> <p>Default spline type for construction. One of <code>POLY</code>, <code>BEZIER</code>, <code>NURBS</code>. Ignored when <code>points</code>/<code>splines</code> are full domains.</p> <code>POLY</code> <code>materials</code> <code>str or sequence of str</code> <p>Material names used by the curve. A single string is accepted and promoted to a one-element list.</p> <code>None</code> <code>attr_from</code> <code>object</code> <p>Source whose transferable attributes are joined into this geometry (see <code>join_attributes</code>).</p> <code>None</code> <code>**attrs</code> <p>Additional geometry attributes to forward to <code>add_splines</code> during construction.</p> <code>{}</code> Notes <ul> <li>When <code>points</code> and <code>splines</code> are provided as domains, the instance is a view: <code>self.is_view</code> is <code>True</code> if the sum of <code>splines.loop_total</code> differs from <code>len(points)</code>. Use <code>no_view</code> to materialize a standalone copy. :contentReference[oaicite:0]{index=0}</li> <li>Otherwise, the constructor allocates empty <code>ControlPoint</code> and <code>Spline</code> domains, joins attributes from <code>attr_from</code> if any, then calls <code>add_splines</code>. :contentReference[oaicite:1]{index=1}</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>Propagated from <code>add_splines</code> when <code>curve_type</code> is not a single value (e.g., a list). :contentReference[oaicite:2]{index=2}</p>"},{"location":"api/curve/#npblender.curve.Curve.length","title":"length  <code>property</code>","text":"<pre><code>length\n</code></pre> <p>Lengths of splines.</p> <p>Returns:</p> Type Description <code>array of floats</code>"},{"location":"api/curve/#npblender.curve.Curve.add_bezier","title":"add_bezier","text":"<pre><code>add_bezier(points, splines=None, handle_left=None, handle_right=None, cyclic=False, **attrs)\n</code></pre> <p>Append Bezier spline(s).</p> <p>The arguments <code>splines</code> gives the length(s) of the bezier spline(s). If None: - the number of points is taken (one spline is added) - points.shape[1] is taken if the shape of points is (m, , 3)</p> <p>handle_left and handle_right must have the same shape as points if provided. If they aren't provided, they are computed.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>(ndarray, shape(N, 3) or (B, N, 3))</code> <p>Anchor positions (single spline or a batch).</p> required <code>splines</code> <code>int or 1D array of int or None</code> <p>Per-spline point counts. If <code>None</code>, inferred from <code>points</code>.</p> <code>None</code> <code>handle_left</code> <code>ndarray or None</code> <p>Left handles (same shape as <code>points</code>). Computed if omitted.</p> <code>None</code> <code>handle_right</code> <code>ndarray or None</code> <p>Right handles (same shape as <code>points</code>). Computed if omitted.</p> <code>None</code> <code>cyclic</code> <code>bool or 1D array of bool</code> <p>Whether each spline is closed (broadcastable to number of splines).</p> <code>False</code> <code>**attrs</code> <p>Additional attributes dispatched to points/splines.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Indices of appended points and splines.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>points</code> last dimension is not 3, or if handle shapes don\u2019t match.</p>"},{"location":"api/curve/#npblender.curve.Curve.add_materials","title":"add_materials","text":"<pre><code>add_materials(materials)\n</code></pre> <p>Add a materials list to the existing one.</p> <p>If a material already exist, it is not added another time.</p> Arguments <pre><code>- materials (list of strs) : the list of materials to append.\n</code></pre>"},{"location":"api/curve/#npblender.curve.Curve.add_poly","title":"add_poly","text":"<pre><code>add_poly(points, splines=None, curve_type=POLY, cyclic=False, w=1.0, **attrs)\n</code></pre> <p>Append Poly or NURBS spline(s).</p> <p>The arguments 'splines' gives the length(s) of the spline(s). If None: - the number of points is taken (one spline is added) - points.shape[1] is taken if the shape of points is (m, , 3)</p> <p>Non bezeier splines use 4D points. If the provided vectors are 4D, the argument w is ignored.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>Either <code>(N, 3|4)</code> or <code>(B, N, 3|4)</code>. If 4D, the 4th component is used as w.</p> required <code>splines</code> <code>int or 1D array of int or None</code> <p>Per-spline point counts. If <code>None</code>, inferred from <code>points</code>.</p> <code>None</code> <code>curve_type</code> <code>int</code> <p>[<code>POLY</code>][npblender.constants.POLY] or [<code>NURBS</code>][npblender.constants.NURBS].</p> <code>POLY</code> <code>cyclic</code> <code>bool or 1D array of bool</code> <p>Whether each spline is closed.</p> <code>False</code> <code>w</code> <code>float</code> <p>Default weight if <code>points</code> are 3D.</p> <code>1.0</code> <code>**attrs</code> <p>Additional attributes dispatched to points/splines.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Indices of appended points and splines.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>points</code> are neither 3D nor 4D vectors.</p>"},{"location":"api/curve/#npblender.curve.Curve.add_splines","title":"add_splines","text":"<pre><code>add_splines(points=None, splines=None, curve_type=POLY, **attrs)\n</code></pre> <p>Append new splines (Bezier, Poly, or NURBS) with their control points.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray or None</code> <p>Control-point coordinates. Shape depends on <code>splines</code> (see <code>add_bezier</code> and <code>add_poly</code>).</p> <code>None</code> <code>splines</code> <code>int or 1D array of int or None</code> <p>Per-spline sizes. If <code>None</code>, inferred from <code>points</code> shape.</p> <code>None</code> <code>curve_type</code> <code>int</code> <p>One of [<code>BEZIER</code>][npblender.constants.BEZIER], [<code>POLY</code>][npblender.constants.POLY], [<code>NURBS</code>][npblender.constants.NURBS].</p> <code>POLY</code> <code>**attrs</code> <p>Mixed per-point and per-spline attributes to broadcast and assign.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Keys <code>'points'</code> and <code>'splines'</code> with the indices of appended rows.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>curve_type</code> is not a single scalar value.</p>"},{"location":"api/curve/#npblender.curve.Curve.arc","title":"arc  <code>classmethod</code>","text":"<pre><code>arc(resolution=16, radius=1.0, start_angle=0.0, sweep_angle=7 * np.pi / 4, connect_center=False, invert_arc=False)\n</code></pre> <p>Build a polyline arc in the XY plane.</p> <p>The arc is sampled uniformly with <code>resolution</code> points between <code>start_angle</code> and <code>start_angle + sweep_angle</code>. If <code>invert_arc</code> is True, the parameterization is reversed (clockwise), producing the same locus but with swapped start/end angles. When <code>connect_center</code> is True, the center <code>(0, 0, 0)</code> is appended, and the spline is marked as cyclic to form a pie slice.</p> <p>Parameters:</p> Name Type Description Default <code>resolution</code> <code>int</code> <p>Number of samples along the arc (min 2).</p> <code>16</code> <code>radius</code> <code>float</code> <p>Arc radius.</p> <code>1.0</code> <code>start_angle</code> <code>float</code> <p>Start angle in radians.</p> <code>0.0</code> <code>sweep_angle</code> <code>float</code> <p>Signed sweep angle in radians.</p> <code>7\u03c0/4</code> <code>connect_center</code> <code>bool</code> <p>If True, append the origin and mark the spline cyclic (pie slice).</p> <code>False</code> <code>invert_arc</code> <code>bool</code> <p>If True, reverse the arc direction (clockwise).</p> <code>False</code> <p>Returns:</p> Type Description <code>Curve</code> <p>A curve with one POLY spline sampled in the XY plane.</p> See Also <p>Curve.circle, Curve.bezier_circle</p>"},{"location":"api/curve/#npblender.curve.Curve.bezier_circle","title":"bezier_circle  <code>classmethod</code>","text":"<pre><code>bezier_circle()\n</code></pre> <p>Unit circle approximated by 4 cubic Bezier arcs (cyclic).</p> <p>Returns:</p> Type Description <code>Curve</code> <p>Bezier circle with pre-set handles.</p>"},{"location":"api/curve/#npblender.curve.Curve.bezier_segment","title":"bezier_segment  <code>classmethod</code>","text":"<pre><code>bezier_segment(resolution=16, start=(-1, 0, 0), start_handle=(-0.5, 0.5, 0), end_handle=(0, 0, 0), end=(1, 0, 0))\n</code></pre> <p>Create a single two-point Bezier segment.</p> <p>Produces a Bezier spline with two control points located at <code>start</code> and <code>end</code>. The left/right handles are set from <code>start_handle</code> and <code>end_handle</code> (mirrored appropriately). The <code>resolution</code> argument is accepted for API symmetry but not used at construction; sampling and evaluation rely on the per-spline <code>resolution</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>resolution</code> <code>int</code> <p>Kept for API symmetry; not used during construction.</p> <code>16</code> <code>start</code> <code>(3,) float</code> <p>Start control point.</p> <code>(-1, 0, 0)</code> <code>start_handle</code> <code>(3,) float</code> <p>Handle associated to the start point (as right handle).</p> <code>(-0.5, 0.5, 0)</code> <code>end_handle</code> <code>(3,) float</code> <p>Handle associated to the end point (as left handle).</p> <code>(0, 0, 0)</code> <code>end</code> <code>(3,) float</code> <p>End control point.</p> <code>(1, 0, 0)</code> <p>Returns:</p> Type Description <code>Curve</code> <p>A curve with one BEZIER spline (open).</p> Notes <p>Handles are applied as: - <code>handle_right[0] = start_handle</code> - <code>handle_left[1]  = end_handle</code> The opposite handles are mirrored so that each handle is expressed in absolute coordinates.</p>"},{"location":"api/curve/#npblender.curve.Curve.blender_data","title":"blender_data","text":"<pre><code>blender_data(readonly=False)\n</code></pre> <p>Temporary access to a transient Blender <code>Curve</code> datablock.</p> <p>Yields a throwaway curve data populated from this instance; upon exit, reads back into <code>self</code> unless <code>readonly=True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>readonly</code> <code>bool</code> <p>If True, do not read back any change made to the temporary data.</p> <code>False</code> <p>Yields:</p> Type Description <code>Curve</code> <p>The temporary curve data.</p> <p>Examples:</p> <pre><code>curve = Curve.Spiral()\nwith curve.blender_data() as bcurve:\n    print(\"Number of points\", len(bcurve.splines[0].points))\n</code></pre>"},{"location":"api/curve/#npblender.curve.Curve.capture","title":"capture","text":"<pre><code>capture(other)\n</code></pre> <p>Capture another curve\u2019s buffers (no copy).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Curve</code> <p>Source whose internal buffers are adopted by this instance.</p> required <p>Returns:</p> Type Description <code>Curve</code> <p>Self.</p>"},{"location":"api/curve/#npblender.curve.Curve.check","title":"check","text":"<pre><code>check(title='Mesh Check', halt=True)\n</code></pre> <p>Validate internal spline bookkeeping.</p> <p>Delegates to <code>Spline.check</code>. When invalid and <code>halt=True</code>, raises; otherwise prints a message.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Label used in error messages.</p> <code>\"Mesh Check\"</code> <code>halt</code> <code>bool</code> <p>Whether to raise on failure.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if valid.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the check fails and <code>halt=True</code>.</p>"},{"location":"api/curve/#npblender.curve.Curve.circle","title":"circle  <code>classmethod</code>","text":"<pre><code>circle(resolution=32, radius=1.0)\n</code></pre> <p>Regular polygonal approximation of a circle (Poly, cyclic).</p> <p>Parameters:</p> Name Type Description Default <code>resolution</code> <code>int</code> <p>Number of points.</p> <code>32</code> <code>radius</code> <code>float</code> <p>Circle radius.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Curve</code>"},{"location":"api/curve/#npblender.curve.Curve.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Remove all points and splines (attributes kept, values cleared).</p> <p>Returns:</p> Type Description <code>None</code>"},{"location":"api/curve/#npblender.curve.Curve.compute_bezier_handles","title":"compute_bezier_handles  <code>staticmethod</code>","text":"<pre><code>compute_bezier_handles(points, cyclic=False, eps=1e-06)\n</code></pre> <p>Compute cubic Bezier handles (left/right) from anchors using Catmull-Rom style tangents.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>(N,3) or (B,N,3) float32/float64</code> <p>OPEN storage (no duplicated first point).</p> required <code>cyclic</code> <code>bool</code> <p>If True, wrap neighbors; else use one-sided differences at ends.</p> <code>False</code> <code>eps</code> <code>float</code> <p>Small epsilon to guard against zero-length tangents.</p> <code>1e-06</code> <p>Returns:</p> Type Description <code>left, right : same shape as `points`</code> <p>left[i]  = P[i] - T[i] * (len_in[i]  / 3) right[i] = P[i] + T[i] * (len_out[i] / 3) with len_in = ||P[i] - P[i-1]|| and len_out = ||P[i+1] - P[i]|| (wrapped if cyclic).</p>"},{"location":"api/curve/#npblender.curve.Curve.delete_points","title":"delete_points","text":"<pre><code>delete_points(points=None, splines=None)\n</code></pre> <p>Delete points (and prune splines when emptied).</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>selection or None</code> <p>Points to delete.</p> <code>None</code> <code>splines</code> <code>selection or None</code> <p>Splines whose all points should be deleted.</p> <code>None</code> <p>Returns:</p> Type Description <code>Curve</code> <p>Self (for chaining).</p>"},{"location":"api/curve/#npblender.curve.Curve.delete_splines","title":"delete_splines","text":"<pre><code>delete_splines(splines=None)\n</code></pre> <p>Delete splines (and their points).</p> <p>Parameters:</p> Name Type Description Default <code>splines</code> <code>selection or None</code> <p>Splines to delete.</p> <code>None</code> <p>Returns:</p> Type Description <code>Curve</code> <p>Self (for chaining).</p>"},{"location":"api/curve/#npblender.curve.Curve.evaluate","title":"evaluate","text":"<pre><code>evaluate(t)\n</code></pre> <p>Evaluate positions along each spline at parameter(s) <code>t</code>.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float or ndarray</code> <p>Parametric coordinate(s) in <code>[0, 1]</code> per spline.</p> required <p>Returns:</p> Type Description <code>(ndarray, shape(..., 3))</code> <p>Evaluated positions.</p>"},{"location":"api/curve/#npblender.curve.Curve.for_each_bucket","title":"for_each_bucket","text":"<pre><code>for_each_bucket(func)\n</code></pre> <p>Iterate homogeneous spline buckets and apply <code>func</code>.</p> <p>Spline buckets share the same <code>(curve_type, N, cyclic, resolution)</code> signature. <code>func</code> is called with <code>(curve, curve_type, N, cyclic, resolution)</code> and must return a value; the generator yields <code>(bucket_indices, value)</code> pairs.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>Callback applied once per bucket.</p> required <p>Yields:</p> Type Description <code>tuple</code> <p><code>(bucket_indices, value)</code> for each bucket.</p>"},{"location":"api/curve/#npblender.curve.Curve.from_curve","title":"from_curve  <code>classmethod</code>","text":"<pre><code>from_curve(other, points=None, splines=None)\n</code></pre> <p>Copy a curve (optionally subsetting points and/or splines).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Curve</code> <p>Source curve.</p> required <code>points</code> <code>selection or None</code> <p>Points to exclude when copying (interpreted as mask if array of bool; see code for details).</p> <code>None</code> <code>splines</code> <code>selection or None</code> <p>Splines to exclude when copying.</p> <code>None</code> <p>Returns:</p> Type Description <code>Curve</code>"},{"location":"api/curve/#npblender.curve.Curve.from_curve_data","title":"from_curve_data  <code>classmethod</code>","text":"<pre><code>from_curve_data(data)\n</code></pre> <p>Build a curve from a Blender <code>Curve</code> datablock.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Curve</code> <p>Blender curve data.</p> required <p>Returns:</p> Type Description <code>Curve</code>"},{"location":"api/curve/#npblender.curve.Curve.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d)\n</code></pre> <p>Deserialize a curve from a dict produced by <code>to_dict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Serialized curve payload.</p> required <p>Returns:</p> Type Description <code>Curve</code>"},{"location":"api/curve/#npblender.curve.Curve.from_object","title":"from_object  <code>classmethod</code>","text":"<pre><code>from_object(obj, evaluated=False)\n</code></pre> <p>Build a curve from a Blender object holding curve data.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str or Object</code> <p>Object or object name.</p> required <code>evaluated</code> <code>bool</code> <p>If True, read the evaluated (modifier-applied) data via depsgraph.</p> <code>False</code> <p>Returns:</p> Type Description <code>Curve</code>"},{"location":"api/curve/#npblender.curve.Curve.get_material_index","title":"get_material_index","text":"<pre><code>get_material_index(mat_name)\n</code></pre> <p>Return the index of a material name.</p> <p>If the material doesn't exist, it is created</p> Arguments <pre><code>- mat_name (str) : material name\n</code></pre> <p>Returns:</p> Type Description <code>    - int : index of the material name in the materials list</code>"},{"location":"api/curve/#npblender.curve.Curve.get_points_selection","title":"get_points_selection","text":"<pre><code>get_points_selection()\n</code></pre> <p>Indices/slice selecting the points actually referenced by the current splines.</p> <p>If the curve is a view (splines refer to a subset of points), returns a boolean mask selecting those rows in <code>points</code>. Otherwise returns <code>slice(None)</code>.</p> <p>Returns:</p> Type Description <code>slice or ndarray of bool</code> <p>Selection usable to index <code>self.points</code>.</p>"},{"location":"api/curve/#npblender.curve.Curve.join","title":"join","text":"<pre><code>join(*others)\n</code></pre> <p>Append other curves to this one (points, splines, and material mapping).</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Curve</code> <p>Curves to concatenate.</p> <code>()</code> <p>Returns:</p> Type Description <code>Curve</code> <p>Self (for chaining).</p>"},{"location":"api/curve/#npblender.curve.Curve.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other, **kwargs)\n</code></pre> <p>Capture the attributes from another geometry.</p> <p>Other can be a different geometry, in that case, only domains with the same name are captured. kwargs allows to filter the domains to capture:</p> <pre><code>mesh.join_attributes(other_mesh, faces=False)\nmesh.join_attributes(curve)\n</code></pre> <p>Returns:     - self</p>"},{"location":"api/curve/#npblender.curve.Curve.line","title":"line  <code>classmethod</code>","text":"<pre><code>line(start=(0, 0, 0), end=(0, 0, 1), resolution=2)\n</code></pre> <p>Build a straight polyline between two points.</p> <p>Generates <code>resolution</code> evenly spaced points from <code>start</code> to <code>end</code> (inclusive) and returns an open POLY spline.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>(3,) float</code> <p>Line start point.</p> <code>(0, 0, 0)</code> <code>end</code> <code>(3,) float</code> <p>Line end point.</p> <code>(0, 0, 1)</code> <code>resolution</code> <code>int</code> <p>Number of samples along the line (min 2).</p> <code>2</code> <p>Returns:</p> Type Description <code>Curve</code> <p>A curve with one POLY spline containing <code>resolution</code> points.</p> <p>Examples:</p> <pre><code>c = Curve.line(start=(0, 0, 0), end=(1, 0, 0), resolution=5)\nprint(len(c.points))\n</code></pre>"},{"location":"api/curve/#npblender.curve.Curve.load_models","title":"load_models  <code>staticmethod</code>","text":"<pre><code>load_models(*specs)\n</code></pre> <p>Load a geometry or geometries from specifications.</p> <p>The specs can be:     - a Blender collection     - a Blender object     - a Geometry</p> Arguments <pre><code>- specs (list of objects / collections) : the models to load\n</code></pre> <p>Returns:</p> Type Description <code>    - list of geometries</code>"},{"location":"api/curve/#npblender.curve.Curve.load_object","title":"load_object  <code>staticmethod</code>","text":"<pre><code>load_object(name)\n</code></pre> <p>Load a Blender object and returns either a Mesh or a Curve.</p> Arguments <pre><code>- name (str or bpy.types.Object) : the object to load\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh or Curve</code>"},{"location":"api/curve/#npblender.curve.Curve.multiply","title":"multiply","text":"<pre><code>multiply(count, in_place=True)\n</code></pre> <p>Duplicate the whole curve <code>count</code> times (instancing-like expansion).</p> <p>Multiplying is a way to efficiently duplicate the geometry a great number of times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of copies to create.</p> required <code>in_place</code> <code>bool</code> <p>If True, expand this instance; otherwise return a new expanded curve.</p> <code>True</code> <p>Returns:</p> Type Description <code>Curve or None</code> <p>Self (in place) or a new curve; <code>None</code> if <code>count == 0</code>.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If <code>count</code> is not an integer.</p>"},{"location":"api/curve/#npblender.curve.Curve.no_view","title":"no_view","text":"<pre><code>no_view()\n</code></pre> <p>Materialize a view curve into an owned, self-consistent curve.</p> <p>Deep-copies the <code>splines</code> and gathers the referenced rows of <code>points</code> so that <code>sum(splines.loop_total) == len(points)</code> holds true.</p> <p>Returns:</p> Type Description <code>Curve</code> <p>Self (for chaining).</p>"},{"location":"api/curve/#npblender.curve.Curve.quadratic_bezier","title":"quadratic_bezier  <code>classmethod</code>","text":"<pre><code>quadratic_bezier(resolution=16, start=(-1, 0, 0), middle=(0, 2, 0), end=(1, 0, 0))\n</code></pre> <p>Quadratic B\u00e9zier segment (not implemented).</p> <p>Intended to create a single quadratic B\u00e9zier curve defined by the control points <code>start</code>, <code>middle</code>, and <code>end</code>. Currently not implemented.</p> <p>Parameters:</p> Name Type Description Default <code>resolution</code> <code>int</code> <p>Suggested sampling resolution (unused in the current implementation).</p> <code>16</code> <code>start</code> <code>(3,) float</code> <p>Start control point.</p> <code>(-1, 0, 0)</code> <code>middle</code> <code>(3,) float</code> <p>Middle (control) point.</p> <code>(0, 2, 0)</code> <code>end</code> <code>(3,) float</code> <p>End control point.</p> <code>(1, 0, 0)</code> <p>Raises:</p> Type Description <code>Exception</code> <p>Always raised with the message \"Not implemented yet\".</p> <p>Examples:</p> <pre><code>try:\n    c = Curve.quadratic_bezier()\nexcept Exception as e:\n    print(e)  # \"Not implemented yet\"\n</code></pre>"},{"location":"api/curve/#npblender.curve.Curve.quadrilateral","title":"quadrilateral  <code>classmethod</code>","text":"<pre><code>quadrilateral(width=2.0, height=2.0)\n</code></pre> <p>Axis-aligned rectangle in the XY plane (closed polyline).</p> <p>Builds a cyclic POLY spline with four vertices: <code>(-w/2, -h/2) \u2192 (w/2, -h/2) \u2192 (w/2, h/2) \u2192 (-w/2, h/2)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>Rectangle width along X.</p> <code>2.0</code> <code>height</code> <code>float</code> <p>Rectangle height along Y.</p> <code>2.0</code> <p>Returns:</p> Type Description <code>Curve</code> <p>A curve with one cyclic POLY spline.</p> <p>Examples:</p> <pre><code>c = Curve.quadrilateral(width=1.0, height=0.5)\n</code></pre>"},{"location":"api/curve/#npblender.curve.Curve.sample_attributes","title":"sample_attributes","text":"<pre><code>sample_attributes(t, names=None, cubic=False)\n</code></pre> <p>Sample point-domain attributes along the curve(s) at <code>t</code>.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float or ndarray</code> <p>Parametric coordinate(s) in <code>[0, 1]</code> per spline.</p> required <code>names</code> <code>sequence of str or None</code> <p>Attribute names to sample; if <code>None</code>, samples transferable point fields.</p> <code>None</code> <code>cubic</code> <code>bool</code> <p>Use cubic interpolation (typically for Bezier).</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, ndarray]</code> <p>Sampled arrays keyed by attribute name.</p>"},{"location":"api/curve/#npblender.curve.Curve.select","title":"select","text":"<pre><code>select(indices)\n</code></pre> <p>Convenience alias for subsetting splines: <code>curve[indices]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>selection</code> <p>Boolean mask, slice, or integer array indexing splines.</p> required <p>Returns:</p> Type Description <code>Curve</code> <p>A view on the selected splines (potentially a view curve).</p>"},{"location":"api/curve/#npblender.curve.Curve.spiral","title":"spiral  <code>classmethod</code>","text":"<pre><code>spiral(resolution=32, rotations=2.0, start_radius=1.0, end_radius=2.0, height=2.0, reverse=False)\n</code></pre> <p>Create a 3D polyline spiral in the XY plane with linear Z elevation.</p> <p>Samples a spiral with <code>1 + int(rotations * resolution)</code> points. The radius linearly interpolates from <code>start_radius</code> to <code>end_radius</code>. The angle evolves by <code>2\u03c0 * rotations</code> (clockwise unless <code>reverse=True</code>). The Z coordinate is linearly distributed from <code>0</code> to <code>height</code>.</p> <p>Parameters:</p> Name Type Description Default <code>resolution</code> <code>int</code> <p>Number of samples per full rotation.</p> <code>32</code> <code>rotations</code> <code>float</code> <p>Number of turns (can be fractional).</p> <code>2.0</code> <code>start_radius</code> <code>float</code> <p>Radius at the beginning of the spiral.</p> <code>1.0</code> <code>end_radius</code> <code>float</code> <p>Radius at the end of the spiral.</p> <code>2.0</code> <code>height</code> <code>float</code> <p>Final Z value (start is Z = 0).</p> <code>2.0</code> <code>reverse</code> <code>bool</code> <p>If True, swap the trigonometric direction of the spiral.</p> <code>False</code> <p>Returns:</p> Type Description <code>Curve</code> <p>A curve with a single POLY spline.</p> <p>Examples:</p> <pre><code>c = Curve.spiral(resolution=64, rotations=3.5, start_radius=0.5, end_radius=3.0, height=5.0)\n</code></pre>"},{"location":"api/curve/#npblender.curve.Curve.star","title":"star  <code>classmethod</code>","text":"<pre><code>star(points=8, inner_radius=1.0, outer_radius=2.0, twist=0.0)\n</code></pre> <p>Create a star polygon (alternating outer/inner vertices) in the XY plane.</p> <p>Builds a cyclic POLY spline with <code>2 * points</code> vertices alternating between <code>outer_radius</code> and <code>inner_radius</code>. The inner vertices are rotated by <code>\u03c0 / points + twist</code> to control the star lobes' alignment.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>int</code> <p>Number of star tips (minimum 3).</p> <code>8</code> <code>inner_radius</code> <code>float</code> <p>Radius of inner vertices.</p> <code>1.0</code> <code>outer_radius</code> <code>float</code> <p>Radius of outer vertices (tips).</p> <code>2.0</code> <code>twist</code> <code>float</code> <p>Additional rotation (radians) applied to inner vertices.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Curve</code> <p>A curve with one cyclic POLY spline forming a star.</p> See Also <p>Curve.circle, Curve.arc</p>"},{"location":"api/curve/#npblender.curve.Curve.tangent","title":"tangent","text":"<pre><code>tangent(t, normalize=True)\n</code></pre> <p>Evaluate tangents along each spline at parameter(s) <code>t</code>.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float or ndarray</code> <p>Parametric coordinate(s) in <code>[0, 1]</code> per spline.</p> required <code>normalize</code> <code>bool</code> <p>If True, return unit tangents.</p> <code>True</code> <p>Returns:</p> Type Description <code>(ndarray, shape(..., 3))</code> <p>Tangent vectors.</p>"},{"location":"api/curve/#npblender.curve.Curve.to_bezier","title":"to_bezier","text":"<pre><code>to_bezier(control_count=None, resolution=16)\n</code></pre> <p>Convert all splines to Bezier.</p> <p>Parameters:</p> Name Type Description Default <code>control_count</code> <code>int or None</code> <p>Number of anchors per spline. If <code>None</code>, keep the current <code>loop_total</code>. For cyclic splines, anchors are sampled on <code>[0, 1)</code> (no duplicate).</p> <code>None</code> <code>resolution</code> <code>int</code> <p>Per-segment resolution written to <code>splines.resolution</code> (&gt;= 1).</p> <code>16</code> <p>Returns:</p> Type Description <code>Curve</code> <p>A new Bezier curve.</p>"},{"location":"api/curve/#npblender.curve.Curve.to_curve_data","title":"to_curve_data","text":"<pre><code>to_curve_data(data)\n</code></pre> <p>Write this curve into an existing Blender <code>Curve</code> datablock.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Curve</code> <p>Target Blender curve data (cleared and repopulated).</p> required"},{"location":"api/curve/#npblender.curve.Curve.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize the curve to a plain Python dict.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Keys: <code>geometry</code>, <code>materials</code>, <code>points</code>, <code>splines</code>.</p>"},{"location":"api/curve/#npblender.curve.Curve.to_mesh","title":"to_mesh","text":"<pre><code>to_mesh(profile=None, caps=True, use_radius=True, camera_culling=False)\n</code></pre> <p>Convert the curve to a mesh (optionally sweeping a profile).</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Curve or None</code> <p>Profile curve to sweep along each spline. If <code>None</code>, outputs edges only.</p> <code>None</code> <code>caps</code> <code>bool</code> <p>Close ends when the profile is cyclic and the path is open.</p> <code>True</code> <code>use_radius</code> <code>bool</code> <p>Use per-point <code>radius</code> to scale the profile (when applicable).</p> <code>True</code> <code>camera_culling</code> <code>bool or Camera</code> <p>If truthy, drop splines that would be sub-pixel using a camera model.</p> <code>False</code> <p>Returns:</p> Type Description <code>[Mesh][Mesh]</code> <p>The generated mesh.</p>"},{"location":"api/curve/#npblender.curve.Curve.to_object","title":"to_object","text":"<pre><code>to_object(obj, collection=None)\n</code></pre> <p>Create or update a Blender curve object from this geometry.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str or Object</code> <p>Target object or name (created if it doesn't exist).</p> required <code>collection</code> <code>Collection or None</code> <p>Collection to link a newly created object into.</p> <code>None</code> <p>Returns:</p> Type Description <code>Object</code> <p>The Blender curve object.</p> Notes <p>The object type must be Curve. Type conversion is not performed.</p>"},{"location":"api/curve/#npblender.curve.Curve.to_poly","title":"to_poly","text":"<pre><code>to_poly(resolution=None)\n</code></pre> <p>Convert all splines to Poly.</p> <p>Parameters:</p> Name Type Description Default <code>resolution</code> <code>int or None</code> <p>If <code>None</code>, Bezier splines are split using their per-spline resolution and poly splines are left unchanged. If an integer, resample all splines to that resolution (cyclic splines have no duplicate endpoint).</p> <code>None</code> <p>Returns:</p> Type Description <code>Curve</code> <p>A new curve with <code>curve_type = POLY</code>.</p>"},{"location":"api/curve/#npblender.curve.Curve.transformation","title":"transformation","text":"<pre><code>transformation(rotation=None, scale=None, translation=None, pivot=None)\n</code></pre> <p>The transformation arguments can treat the points as a list of packets of the same size. For instance, 24 vertices can be seend as 3 packets of 8 vertices using a translation of (8, 3) vectors.</p> <p>Examples:</p> <pre><code># A mesh made of 12 cubes\ncubes = Mesh.cube(size=1)*12\n\n# 3 random transformations\ntranslation = np.random.uniform(-1, 1, (4, 3))\npivot = np.random.uniform(-1, 1, (3, 3))\nscale = np.random.uniform(.1, 2, (12, 3))\nrot = Rotation.from_euler(np.random.uniform(0, 2*np.pi, (6, 3)))\n\ncubes.transformation(\n    translation = translation,\n    scale = scale,\n    rotation = rot,\n    pivot=pivot,\n)\n</code></pre>"},{"location":"api/curve/#npblender.curve.Curve.xyfunction","title":"xyfunction  <code>classmethod</code>","text":"<pre><code>xyfunction(func, x0=0.0, x1=1.0, resolution=100, materials=None)\n</code></pre> <p>Sample a 2D function y = f(x) as a polyline in the XY plane.</p> <p>Evaluates <code>y = func(x)</code> for <code>x</code> uniformly spaced in <code>[x0, x1]</code> and creates a POLY spline with points <code>(x, y, 0)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>A function mapping an array of X values to Y values (vectorized).</p> required <code>x0</code> <code>float</code> <p>Start of the X interval.</p> <code>0.0</code> <code>x1</code> <code>float</code> <p>End of the X interval.</p> <code>1.0</code> <code>resolution</code> <code>int</code> <p>Number of samples in <code>[x0, x1]</code>.</p> <code>100</code> <code>materials</code> <code>str or sequence of str or None</code> <p>Optional material(s) to attach to the curve.</p> <code>None</code> <p>Returns:</p> Type Description <code>Curve</code> <p>A curve with one POLY spline sampled from <code>func</code>.</p> <p>Examples:</p> <pre><code>import numpy as np\n\ndef f(x):\n    return np.sin(2 * np.pi * x)\n\nc = Curve.xyfunction(f, x0=0.0, x1=1.0, resolution=200)\n</code></pre>"},{"location":"api/domain/","title":"Domain","text":""},{"location":"api/domain/#npblender.domain.Domain","title":"Domain","text":"<pre><code>Domain(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>Initialize a domain array and its attribute schema.</p> <p>Initializes the storage from an existing array/domain or creates an empty structure. Optionally merges attribute definitions/values from another domain and keyword-provided attributes.</p> <p>Domains are never instancied directly but by owning geometries.</p> <p>Actual Domains are <code>Vertex</code>, [<code>Faces</code>][npblender.domain.Faces], <code>Corner</code>, <code>Edge</code>, <code>ControlPoint</code>, <code>Spline</code> and <code>Point</code>.</p> <p>Domains are initialized with their defaults attributes, for instance <code>position</code> for point domaines.</p> <p>Use attributes can be freely added. </p> <p>Note: user attributes are saved in Blender Mesh objects only, Blender Curve objects don't store user attributes.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>array - like or FieldArray or None</code> <p>Source data used to initialize the domain. If <code>None</code>, an empty domain is created and <code>_declare_attributes()</code> is called to register defaults.</p> <code>None</code> <code>mode</code> <code>(COPY, CAPTURE, EMPTY)</code> <p>Initialization mode. <code>'COPY'</code> duplicates the input data, <code>'CAPTURE'</code> references the input buffer when supported, <code>'EMPTY'</code> creates the structure without copying values.</p> <code>'COPY'</code> <code>selector</code> <code>Any</code> <p>Optional row/element selector applied to <code>a</code> prior to initialization.</p> <code>None</code> <code>attr_from</code> <code>Domain or Mapping or None</code> <p>Attribute schema (and possibly values) to merge into this domain.</p> <code>None</code> <code>**attrs</code> <p>Additional attribute name/value pairs to inject or override.</p> <code>{}</code> Notes <p>The effective attribute list results from <code>_declare_attributes()</code>, then <code>attr_from</code>, then <code>**attrs</code> (later entries take precedence).</p> <p>Examples:</p> <pre><code>cube = Mesh.cube() # points, corners, faces and edges domains are created\n# Adding named attribute to point domain\ncube.points.new_float('age')\n# Setting the age\ncube.points.age = np.random.uniforme(10, 10, len(cube.points))\n</code></pre>"},{"location":"api/domain/#npblender.domain.Domain.actual_names","title":"actual_names  <code>property</code>","text":"<pre><code>actual_names\n</code></pre> <p>Column names.</p> <p>Returns the actual field names, excluding optional fields.</p>"},{"location":"api/domain/#npblender.domain.Domain.all_names","title":"all_names  <code>property</code>","text":"<pre><code>all_names\n</code></pre> <p>Column names.</p> <p>Returns all the field names, including optional ones.</p>"},{"location":"api/domain/#npblender.domain.Domain.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Array structured dtype</p> <p>Returns the dtype property of the structured array.</p>"},{"location":"api/domain/#npblender.domain.Domain.transdom_names","title":"transdom_names  <code>property</code>","text":"<pre><code>transdom_names\n</code></pre> <p>List the names of trans-domain attributes.</p> <p>Returns:</p> Type Description <code>list of str</code> <p>Names of attributes flagged with <code>transdom=True</code>.</p> <p>Examples:</p> <pre><code>names = D.transdom_names()\n</code></pre>"},{"location":"api/domain/#npblender.domain.Domain.add","title":"add","text":"<pre><code>add(count, **fields)\n</code></pre> <p>Add count records</p> <p>New records are set with default values or values provided by the user in fields dict.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of records to add.</p> required <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/domain/#npblender.domain.Domain.append","title":"append","text":"<pre><code>append(**fields)\n</code></pre> <p>Append values to the structured array.</p> <p>The number of records to append is determined by the number of fields provided in the fields dictionary. The values of the fields are copied to the new records.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/domain/#npblender.domain.Domain.as_kwargs","title":"as_kwargs","text":"<pre><code>as_kwargs(selector=None, include=None, exclude=None)\n</code></pre> <p>Return a dictionary of field values formatted as kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>slice, int, list, or mask</code> <p>Optional selection of elements to extract.</p> <code>None</code> <code>include</code> <code>list[str]</code> <p>List of field names (original or python names) to include.</p> <code>None</code> <code>exclude</code> <code>list[str]</code> <p>List of field names (original or python names) to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Mapping from python-safe field names to array values.</p>"},{"location":"api/domain/#npblender.domain.Domain.copy_field","title":"copy_field","text":"<pre><code>copy_field(field_name, new_name, **infos)\n</code></pre> <p>Duplicate an existing field under a new name, with optional metadata overrides.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the existing field to copy.</p> required <code>new_name</code> <code>str</code> <p>The name of the new field to create.</p> required <code>infos</code> <code>keyword arguments</code> <p>Optional metadata (e.g. default, unit, description...) to override or supplement the original field's metadata.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the source field does not exist.</p> <code>ValueError</code> <p>If the target name already exists or is reserved.</p>"},{"location":"api/domain/#npblender.domain.Domain.delete","title":"delete","text":"<pre><code>delete(index)\n</code></pre> <p>Delete a selection of items from the array.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int, slice, or array-like</code> <p>The indices of the elements to delete from the current data.</p> required Notes <p>This operates only on the valid range <code>[0:self._length]</code>. The internal buffer is preserved (no reallocation).</p>"},{"location":"api/domain/#npblender.domain.Domain.dump","title":"dump","text":"<pre><code>dump(title='Dump', attributes=None, target='SCREEN')\n</code></pre> <p>Pretty-print or export domain content.</p> <p>Formats attribute values and prints to screen or builds a tabular dump suitable for spreadsheets.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title displayed in the report.</p> <code>'Dump'</code> <code>attributes</code> <code>Sequence[str] or None</code> <p>Subset of attribute names to include. If <code>None</code>, all attributes are shown.</p> <code>None</code> <code>target</code> <code>(SCREEN, ...)</code> <p>Output target. <code>'SCREEN'</code> prints to stdout; other targets may trigger file creation depending on the implementation.</p> <code>'SCREEN'</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>Domain(points).dump(title=\"Vertices\")\n</code></pre> <p>Note: Formatting adapts to the chosen <code>target</code>.</p>"},{"location":"api/domain/#npblender.domain.Domain.extend","title":"extend","text":"<pre><code>extend(other, join_fields=True)\n</code></pre> <p>Append multiple records from another array or FieldArray.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray or structured np.ndarray</code> <p>The array of records to append. Must have named fields matching a subset of the current array's fields.</p> required"},{"location":"api/domain/#npblender.domain.Domain.filtered","title":"filtered","text":"<pre><code>filtered(selector, *, copy=False)\n</code></pre> <p>Return a FieldArray containing only the selected records.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>array\u2011like, slice or int</code> <p>Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice. It is applied to the current valid part of the buffer (<code>self._data[:self._length]</code>).</p> required <code>copy</code> <code>bool</code> <ul> <li>False    (default) =&gt; the new array shares the same memory                          (changes propagate both ways).</li> <li>True           =&gt; the data are physically copied.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>FieldArray</code> <p>A new instance holding exactly <code>len(selector)</code> records and inheriting the current field\u2011infos.</p>"},{"location":"api/domain/#npblender.domain.Domain.from_bl_attributes","title":"from_bl_attributes","text":"<pre><code>from_bl_attributes(bl_attributes)\n</code></pre> <p>Import attributes from a Blender attribute collection.</p> <p>Reads geometry attributes from a Blender data-block and creates/updates the corresponding domain attributes, resizing the domain if needed.</p> <p>Parameters:</p> Name Type Description Default <code>bl_attributes</code> <code>Mapping[str, Any]</code> <p>Blender attributes collection (name \u2192 attribute descriptor) providing at least <code>.domain</code>, <code>.is_internal</code>, <code>.data_type</code>, and <code>.data</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Note:*** Only external (non-internal) Blender attributes matching this</code> <code>domain are imported. Missing attributes are created with `transfer=True`.</code>"},{"location":"api/domain/#npblender.domain.Domain.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Build a FieldArray from a dictionary with field data and optional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, array - like or (array, dict)]</code> <p>Mapping field names to arrays or (array, infos). Infos must include NAME.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the data. Default: True.</p> required <p>Returns:</p> Type Description <code>FieldArray</code>"},{"location":"api/domain/#npblender.domain.Domain.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> <p>Get attribute by name.</p> <p>If name is not an actual field, return default value. Name can be an array. <pre><code>pos = field_array.get(\"position\", (0, 0, 1))\npos = field_array.get([[0, 0, 1], [0, 0, 0]])\n</code></pre></p>"},{"location":"api/domain/#npblender.domain.Domain.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other)\n</code></pre> <p>Merge trans-domain attributes from another domain.</p> <p>Copies or aligns attributes from <code>other</code> into the current domain, excluding any attributes not flagged as trans-domain in <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain or None</code> <p>Source domain. If <code>None</code>, the call is a no-op.</p> required <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p>"},{"location":"api/domain/#npblender.domain.Domain.join_fields","title":"join_fields","text":"<pre><code>join_fields(other, exclude=[])\n</code></pre> <p>Add all missing fields from another FieldArray.</p> <p>For every field in <code>other</code> that is not present in <code>self</code>, a new field is created with the same dtype and shape, and initialized with its default value across all existing records.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray</code> <p>Another FieldArray instance whose fields will be checked for missing fields.</p> required <p>Returns:</p> Type Description <code>self</code>"},{"location":"api/domain/#npblender.domain.Domain.make_buckets","title":"make_buckets","text":"<pre><code>make_buckets(attr)\n</code></pre> <p>Group items into buckets by attribute value.</p> <p>When a domain is to be considered as a collection of packets of various sizes, buckets mechanism groups pakets by size, allowing further operation with numpy vectorization.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>array - like or str</code> <p>Either an integer of shape <code>(N,)</code> or the name of an existing integer attribute in the domain.</p> required <p>Returns:</p> Type Description <code>list[ndarray(count, n)]</code> <p>A list of int arrays (count, n): count is the number of buckets of length n.</p> <p>Examples:</p> <pre><code>buckets = mesh.make_buckets('material')\nfor bucket in buckets:\n    print(bucket.shape)\n</code></pre> <p>Note: The bucket attribute can be read with <code>attr[bucket[:, 0]]</code>.</p>"},{"location":"api/domain/#npblender.domain.Domain.multiply","title":"multiply","text":"<pre><code>multiply(count)\n</code></pre> <p>Duplicate the current records <code>count</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of times to repeat the current records.</p> required Notes <p>This duplicates the current valid records (up to self._length). If the array is empty or count &lt;= 1, nothing happens.</p> Example: <p>If the array has 3 records and count == 4, the result will be:</p> <p>[rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]</p>"},{"location":"api/domain/#npblender.domain.Domain.new_attribute","title":"new_attribute","text":"<pre><code>new_attribute(name, data_type, default, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Register a new attribute in the domain schema.</p> <p>Creates (or ensures) an attribute with a given name, logical data type, default value, and flags controlling Blender transfer and cross-domain propagation.</p> <p>Note: <code>data_type</code> argument is a Blender data type not a python data type. The data type name is compatible with Blender internal storage. <code>FLOAT</code>data type is implemented as <code>np.float32</code> and  'INT' as <code>np.int32</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name (Python identifier recommended).</p> required <code>data_type</code> <code>(FLOAT, INT, BOOL, VECTOR, VECTOR2, COLOR, QUATERNION, MATRIX, STRING, ...)</code> <p>Logical data type used by the domain.</p> <code>'FLOAT'</code> <code>default</code> <code>Any</code> <p>Default value for newly allocated elements.</p> required <code>optional</code> <code>bool</code> <p>If <code>True</code>, the attribute may be absent on some elements.</p> <code>False</code> <code>transfer</code> <code>bool</code> <p>If <code>True</code>, eligible to be transferred to Blender as a geometry attribute.</p> <code>True</code> <code>transdom</code> <code>bool</code> <p>If <code>True</code>, considered a trans-domain attribute that can be copied across compatible domains.</p> <code>True</code> See Also <p><code>new_float</code>, <code>new_vector</code>, <code>new_int</code>, <code>new_bool</code>, <code>new_color</code>, <code>new_vector2</code>, <code>new_quaternion</code>, <code>new_matrix</code></p>"},{"location":"api/domain/#npblender.domain.Domain.new_bool","title":"new_bool","text":"<pre><code>new_bool(name, default=False, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a boolean attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>bool</code> <p>Default value.</p> <code>False</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/domain/#npblender.domain.Domain.new_color","title":"new_color","text":"<pre><code>new_color(name, default=(0.5, 0.5, 0.5, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a color attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,) or (4,)</code> <p>Default color as RGB or RGBA.</p> <code>(0.5, 0.5, 0.5, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/domain/#npblender.domain.Domain.new_field","title":"new_field","text":"<pre><code>new_field(name, dtype, shape=None, default=0, optional=False, **infos)\n</code></pre> <p>Add a field to the structured array.</p> Arguments <pre><code>- name (str) : field name\n- dtype (type) : a valid numpy dtype\n- shape (tuple = None) : the shape of the field\n- default (any = 0) : default value\n- optional (bool = False) : the field is created only when accessed\n- infos (dict) : field infos\n</code></pre>"},{"location":"api/domain/#npblender.domain.Domain.new_float","title":"new_float","text":"<pre><code>new_float(name, default=0.0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a scalar float attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>float</code> <p>Default value.</p> <code>0.0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/domain/#npblender.domain.Domain.new_int","title":"new_int","text":"<pre><code>new_int(name, default=0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure an integer attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>int</code> <p>Default value.</p> <code>0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/domain/#npblender.domain.Domain.new_matrix","title":"new_matrix","text":"<pre><code>new_matrix(name, default=np.eye(4), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a matrix attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array - like</code> <p>Default matrix. By convention this is a square matrix per element (e.g., <code>(3, 3)</code> rotation or <code>(4, 4)</code> transform).</p> <code>np.eye(4)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code> <code>order</code> required"},{"location":"api/domain/#npblender.domain.Domain.new_quaternion","title":"new_quaternion","text":"<pre><code>new_quaternion(name, default=(0.0, 0.0, 0.0, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a quaternion attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (4,)</code> <p>Default quaternion in <code>(x, y, z, w)</code> convention.</p> <code>(0.0, 0.0, 0.0, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/domain/#npblender.domain.Domain.new_vector","title":"new_vector","text":"<pre><code>new_vector(name, default=(0.0, 0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 3D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,)</code> <p>Default XYZ vector.</p> <code>(0.0, 0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/domain/#npblender.domain.Domain.new_vector2","title":"new_vector2","text":"<pre><code>new_vector2(name, default=(0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 2D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (2,)</code> <p>Default XY vector.</p> <code>(0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/domain/#npblender.domain.Domain.to_bl_attributes","title":"to_bl_attributes","text":"<pre><code>to_bl_attributes(attributes, update=False)\n</code></pre> <p>Export attributes to a Blender attribute collection.</p> <p>Writes eligible domain attributes to a Blender data-block, creating missing attributes and adjusting sizes as needed.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Any</code> <p>Blender attributes collection receiving the values.</p> required <code>update</code> <code>bool</code> <p>If <code>True</code>, update existing attributes in-place; otherwise create them when missing.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Caution:*** Only attributes with `transfer=True` are exported. Optional</code> <code>attributes are skipped.</code> <code>&gt; ***Caution:*** Curve domains user attributes are not saved.</code>"},{"location":"api/domain/#npblender.domain.Domain.to_dict","title":"to_dict","text":"<pre><code>to_dict(*, copy=True, with_infos=True)\n</code></pre> <p>Convert the array to a dictionary of fields or (field, infos) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Whether to copy the arrays.</p> <code>True</code> <code>with_infos</code> <code>bool</code> <p>If True, return (array, infos) for each field.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, array or (array, dict)]</code>"},{"location":"api/domain/#npblender.domain.Domain.transfer_attributes","title":"transfer_attributes","text":"<pre><code>transfer_attributes(other, shape=None, other_shape=None)\n</code></pre> <p>Transfer values of trans-domain attributes from another domain.</p> <p>Copies values for each trans-domain attribute present in <code>other</code> into the corresponding attributes of <code>self</code>, with optional reshaping for batched assignments.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain</code> <p>Source domain providing attribute values.</p> required <code>shape</code> <code>tuple of int or None</code> <p>Target reshape for <code>self</code> before assignment. If <code>None</code>, uses <code>(self._length,)</code>.</p> <code>None</code> <code>other_shape</code> <code>tuple of int or None</code> <p>Source reshape for <code>other</code> before assignment. If <code>None</code>, uses <code>(other._length,)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p> <code>&gt; ***Note:*** Each attribute is reshaped as `shape + item_shape` on `self`</code> <code>and `other_shape + item_shape` on `other` prior to assignment.</code>"},{"location":"api/edge/","title":"Edge","text":""},{"location":"api/edge/#npblender.domain.Edge","title":"Edge","text":"<pre><code>Edge(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>Mesh edge domain.</p> <p>Represents undirected edges as pairs of vertex indices and provides utilities to validate, filter, and transfer attributes.</p> <p>Attributes:</p> Name Type Description <code>vertex0, vertex1</code> <code>(E,) int</code> <p>Endpoints of each edge.</p> Properties <p>vertices : (E, 2) int     View/setter exposing concatenated <code>(vertex0, vertex1)</code>.</p> <p>Methods:</p> Name Description <code>check</code> <p>Validate indices are &lt; <code>count</code> and no degenerate edges exist.</p> <code>remove_face_edges</code> <p>Remove edges that belong to a set of face edges.</p> <code>compute_attribute_on_points</code> <p>Average edge attributes back to points (each endpoint contributes).</p> <p>Examples:</p> <p>Remove edges already represented by faces:</p> <pre><code>edges.remove_face_edges(face_edges)\n</code></pre> <p>Average per-edge scalar to points:</p> <pre><code>p_attr = edges.compute_attribute_on_points(\"heat\", points)\n</code></pre> <p>Caution: <code>check()</code> raises if an endpoint index is out of range or if an edge uses the same vertex twice.</p> <p>Initialize a domain array and its attribute schema.</p> <p>Initializes the storage from an existing array/domain or creates an empty structure. Optionally merges attribute definitions/values from another domain and keyword-provided attributes.</p> <p>Domains are never instancied directly but by owning geometries.</p> <p>Actual Domains are <code>Vertex</code>, [<code>Faces</code>][npblender.domain.Faces], <code>Corner</code>, <code>Edge</code>, <code>ControlPoint</code>, <code>Spline</code> and <code>Point</code>.</p> <p>Domains are initialized with their defaults attributes, for instance <code>position</code> for point domaines.</p> <p>Use attributes can be freely added. </p> <p>Note: user attributes are saved in Blender Mesh objects only, Blender Curve objects don't store user attributes.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>array - like or FieldArray or None</code> <p>Source data used to initialize the domain. If <code>None</code>, an empty domain is created and <code>_declare_attributes()</code> is called to register defaults.</p> <code>None</code> <code>mode</code> <code>(COPY, CAPTURE, EMPTY)</code> <p>Initialization mode. <code>'COPY'</code> duplicates the input data, <code>'CAPTURE'</code> references the input buffer when supported, <code>'EMPTY'</code> creates the structure without copying values.</p> <code>'COPY'</code> <code>selector</code> <code>Any</code> <p>Optional row/element selector applied to <code>a</code> prior to initialization.</p> <code>None</code> <code>attr_from</code> <code>Domain or Mapping or None</code> <p>Attribute schema (and possibly values) to merge into this domain.</p> <code>None</code> <code>**attrs</code> <p>Additional attribute name/value pairs to inject or override.</p> <code>{}</code> Notes <p>The effective attribute list results from <code>_declare_attributes()</code>, then <code>attr_from</code>, then <code>**attrs</code> (later entries take precedence).</p> <p>Examples:</p> <pre><code>cube = Mesh.cube() # points, corners, faces and edges domains are created\n# Adding named attribute to point domain\ncube.points.new_float('age')\n# Setting the age\ncube.points.age = np.random.uniforme(10, 10, len(cube.points))\n</code></pre>"},{"location":"api/edge/#npblender.domain.Edge.actual_names","title":"actual_names  <code>property</code>","text":"<pre><code>actual_names\n</code></pre> <p>Column names.</p> <p>Returns the actual field names, excluding optional fields.</p>"},{"location":"api/edge/#npblender.domain.Edge.all_names","title":"all_names  <code>property</code>","text":"<pre><code>all_names\n</code></pre> <p>Column names.</p> <p>Returns all the field names, including optional ones.</p>"},{"location":"api/edge/#npblender.domain.Edge.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Array structured dtype</p> <p>Returns the dtype property of the structured array.</p>"},{"location":"api/edge/#npblender.domain.Edge.transdom_names","title":"transdom_names  <code>property</code>","text":"<pre><code>transdom_names\n</code></pre> <p>List the names of trans-domain attributes.</p> <p>Returns:</p> Type Description <code>list of str</code> <p>Names of attributes flagged with <code>transdom=True</code>.</p> <p>Examples:</p> <pre><code>names = D.transdom_names()\n</code></pre>"},{"location":"api/edge/#npblender.domain.Edge.vertices","title":"vertices  <code>property</code> <code>writable</code>","text":"<pre><code>vertices\n</code></pre> <p>Return per-edge vertex indices.</p> <p>Provides the connectivity of the edge domain as integer pairs of vertex indices. Each row corresponds to one edge, with the two endpoint indices given as an unordered pair.</p> <p>Parameters:</p> Name Type Description Default <code>None</code> required <p>Returns:</p> Type Description <code>numpy.ndarray of shape ``(E, 2)`` and dtype int</code> <p>Array of vertex index pairs, one row per edge.</p> Notes <ul> <li>The order of indices in each pair is not significant: <code>(i, j)</code> and <code>(j, i)</code> denote the same undirected edge.</li> <li>This array can be used to look up endpoint positions from a point/vertex domain.</li> </ul> <p>Examples:</p> <pre><code># Get vertex index pairs for all edges\nedge_pairs = edges.vertices()\n\n# Use them to fetch endpoint coordinates\ncoords = points.position[edge_pairs]\n</code></pre>"},{"location":"api/edge/#npblender.domain.Edge.add","title":"add","text":"<pre><code>add(count, **fields)\n</code></pre> <p>Add count records</p> <p>New records are set with default values or values provided by the user in fields dict.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of records to add.</p> required <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/edge/#npblender.domain.Edge.append","title":"append","text":"<pre><code>append(**fields)\n</code></pre> <p>Append values to the structured array.</p> <p>The number of records to append is determined by the number of fields provided in the fields dictionary. The values of the fields are copied to the new records.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/edge/#npblender.domain.Edge.as_kwargs","title":"as_kwargs","text":"<pre><code>as_kwargs(selector=None, include=None, exclude=None)\n</code></pre> <p>Return a dictionary of field values formatted as kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>slice, int, list, or mask</code> <p>Optional selection of elements to extract.</p> <code>None</code> <code>include</code> <code>list[str]</code> <p>List of field names (original or python names) to include.</p> <code>None</code> <code>exclude</code> <code>list[str]</code> <p>List of field names (original or python names) to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Mapping from python-safe field names to array values.</p>"},{"location":"api/edge/#npblender.domain.Edge.check","title":"check","text":"<pre><code>check(count, halt=True)\n</code></pre> <p>Validate edge endpoint indices and detect degeneracies.</p> <p>Verifies that all edge endpoints are strictly less than <code>count</code> and that no edge uses the same vertex twice.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of vertices in the referenced point/vertex domain.</p> required <code>halt</code> <code>bool</code> <p>If <code>True</code>, raise on failure; otherwise print a message and return <code>False</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the check passes or the domain is empty; <code>False</code> only when invalid and <code>halt</code> is <code>False</code>.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an endpoint index is out of range or if a degenerate edge is found and <code>halt</code> is <code>True</code>.</p> <p>Examples:</p> <pre><code>ok = edges.check(count=len(points), halt=False)\nif not ok:\n    # inspect or fix edges, then retry\n    ...\n</code></pre>"},{"location":"api/edge/#npblender.domain.Edge.compute_attribute_on_points","title":"compute_attribute_on_points","text":"<pre><code>compute_attribute_on_points(attr, points)\n</code></pre> <p>Average an edge attribute back to points (endpoints).</p> <p>For each edge attribute value, accumulates it to both endpoints and divides by the number of incident contributions per point.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str or ndarray</code> <p>Name of the edge attribute to transfer, or an explicit array with shape <code>(E, ...)</code>.</p> required <code>points</code> <code>Point</code> <p>Target point/vertex domain (<code>len(points)</code> sets the output length).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of shape <code>(len(points), ...)</code> containing the averaged values.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>attr</code> is a string and no such edge attribute exists, or if the provided array length does not match <code>len(self)</code> (validated by <code>_check_attribute_to_compute</code>).</p> <code>IndexError</code> <p>If an endpoint index falls outside <code>[0, len(points))</code>.</p> <code>TypeError</code> <p>If the attribute dtype cannot be averaged (e.g., non-numeric types).</p> <p>Examples:</p> <pre><code># Average per-edge scalar \"heat\" to vertices\nv_heat = edges.compute_attribute_on_points(\"heat\", points)\n</code></pre>"},{"location":"api/edge/#npblender.domain.Edge.copy_field","title":"copy_field","text":"<pre><code>copy_field(field_name, new_name, **infos)\n</code></pre> <p>Duplicate an existing field under a new name, with optional metadata overrides.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the existing field to copy.</p> required <code>new_name</code> <code>str</code> <p>The name of the new field to create.</p> required <code>infos</code> <code>keyword arguments</code> <p>Optional metadata (e.g. default, unit, description...) to override or supplement the original field's metadata.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the source field does not exist.</p> <code>ValueError</code> <p>If the target name already exists or is reserved.</p>"},{"location":"api/edge/#npblender.domain.Edge.delete","title":"delete","text":"<pre><code>delete(index)\n</code></pre> <p>Delete a selection of items from the array.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int, slice, or array-like</code> <p>The indices of the elements to delete from the current data.</p> required Notes <p>This operates only on the valid range <code>[0:self._length]</code>. The internal buffer is preserved (no reallocation).</p>"},{"location":"api/edge/#npblender.domain.Edge.dump","title":"dump","text":"<pre><code>dump(title='Dump', attributes=None, target='SCREEN')\n</code></pre> <p>Pretty-print or export domain content.</p> <p>Formats attribute values and prints to screen or builds a tabular dump suitable for spreadsheets.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title displayed in the report.</p> <code>'Dump'</code> <code>attributes</code> <code>Sequence[str] or None</code> <p>Subset of attribute names to include. If <code>None</code>, all attributes are shown.</p> <code>None</code> <code>target</code> <code>(SCREEN, ...)</code> <p>Output target. <code>'SCREEN'</code> prints to stdout; other targets may trigger file creation depending on the implementation.</p> <code>'SCREEN'</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>Domain(points).dump(title=\"Vertices\")\n</code></pre> <p>Note: Formatting adapts to the chosen <code>target</code>.</p>"},{"location":"api/edge/#npblender.domain.Edge.extend","title":"extend","text":"<pre><code>extend(other, join_fields=True)\n</code></pre> <p>Append multiple records from another array or FieldArray.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray or structured np.ndarray</code> <p>The array of records to append. Must have named fields matching a subset of the current array's fields.</p> required"},{"location":"api/edge/#npblender.domain.Edge.filtered","title":"filtered","text":"<pre><code>filtered(selector, *, copy=False)\n</code></pre> <p>Return a FieldArray containing only the selected records.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>array\u2011like, slice or int</code> <p>Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice. It is applied to the current valid part of the buffer (<code>self._data[:self._length]</code>).</p> required <code>copy</code> <code>bool</code> <ul> <li>False    (default) =&gt; the new array shares the same memory                          (changes propagate both ways).</li> <li>True           =&gt; the data are physically copied.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>FieldArray</code> <p>A new instance holding exactly <code>len(selector)</code> records and inheriting the current field\u2011infos.</p>"},{"location":"api/edge/#npblender.domain.Edge.from_bl_attributes","title":"from_bl_attributes","text":"<pre><code>from_bl_attributes(bl_attributes)\n</code></pre> <p>Import attributes from a Blender attribute collection.</p> <p>Reads geometry attributes from a Blender data-block and creates/updates the corresponding domain attributes, resizing the domain if needed.</p> <p>Parameters:</p> Name Type Description Default <code>bl_attributes</code> <code>Mapping[str, Any]</code> <p>Blender attributes collection (name \u2192 attribute descriptor) providing at least <code>.domain</code>, <code>.is_internal</code>, <code>.data_type</code>, and <code>.data</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Note:*** Only external (non-internal) Blender attributes matching this</code> <code>domain are imported. Missing attributes are created with `transfer=True`.</code>"},{"location":"api/edge/#npblender.domain.Edge.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Build a FieldArray from a dictionary with field data and optional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, array - like or (array, dict)]</code> <p>Mapping field names to arrays or (array, infos). Infos must include NAME.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the data. Default: True.</p> required <p>Returns:</p> Type Description <code>FieldArray</code>"},{"location":"api/edge/#npblender.domain.Edge.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> <p>Get attribute by name.</p> <p>If name is not an actual field, return default value. Name can be an array. <pre><code>pos = field_array.get(\"position\", (0, 0, 1))\npos = field_array.get([[0, 0, 1], [0, 0, 0]])\n</code></pre></p>"},{"location":"api/edge/#npblender.domain.Edge.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other)\n</code></pre> <p>Merge trans-domain attributes from another domain.</p> <p>Copies or aligns attributes from <code>other</code> into the current domain, excluding any attributes not flagged as trans-domain in <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain or None</code> <p>Source domain. If <code>None</code>, the call is a no-op.</p> required <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p>"},{"location":"api/edge/#npblender.domain.Edge.join_fields","title":"join_fields","text":"<pre><code>join_fields(other, exclude=[])\n</code></pre> <p>Add all missing fields from another FieldArray.</p> <p>For every field in <code>other</code> that is not present in <code>self</code>, a new field is created with the same dtype and shape, and initialized with its default value across all existing records.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray</code> <p>Another FieldArray instance whose fields will be checked for missing fields.</p> required <p>Returns:</p> Type Description <code>self</code>"},{"location":"api/edge/#npblender.domain.Edge.make_buckets","title":"make_buckets","text":"<pre><code>make_buckets(attr)\n</code></pre> <p>Group items into buckets by attribute value.</p> <p>When a domain is to be considered as a collection of packets of various sizes, buckets mechanism groups pakets by size, allowing further operation with numpy vectorization.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>array - like or str</code> <p>Either an integer of shape <code>(N,)</code> or the name of an existing integer attribute in the domain.</p> required <p>Returns:</p> Type Description <code>list[ndarray(count, n)]</code> <p>A list of int arrays (count, n): count is the number of buckets of length n.</p> <p>Examples:</p> <pre><code>buckets = mesh.make_buckets('material')\nfor bucket in buckets:\n    print(bucket.shape)\n</code></pre> <p>Note: The bucket attribute can be read with <code>attr[bucket[:, 0]]</code>.</p>"},{"location":"api/edge/#npblender.domain.Edge.multiply","title":"multiply","text":"<pre><code>multiply(count)\n</code></pre> <p>Duplicate the current records <code>count</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of times to repeat the current records.</p> required Notes <p>This duplicates the current valid records (up to self._length). If the array is empty or count &lt;= 1, nothing happens.</p> Example: <p>If the array has 3 records and count == 4, the result will be:</p> <p>[rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]</p>"},{"location":"api/edge/#npblender.domain.Edge.new_attribute","title":"new_attribute","text":"<pre><code>new_attribute(name, data_type, default, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Register a new attribute in the domain schema.</p> <p>Creates (or ensures) an attribute with a given name, logical data type, default value, and flags controlling Blender transfer and cross-domain propagation.</p> <p>Note: <code>data_type</code> argument is a Blender data type not a python data type. The data type name is compatible with Blender internal storage. <code>FLOAT</code>data type is implemented as <code>np.float32</code> and  'INT' as <code>np.int32</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name (Python identifier recommended).</p> required <code>data_type</code> <code>(FLOAT, INT, BOOL, VECTOR, VECTOR2, COLOR, QUATERNION, MATRIX, STRING, ...)</code> <p>Logical data type used by the domain.</p> <code>'FLOAT'</code> <code>default</code> <code>Any</code> <p>Default value for newly allocated elements.</p> required <code>optional</code> <code>bool</code> <p>If <code>True</code>, the attribute may be absent on some elements.</p> <code>False</code> <code>transfer</code> <code>bool</code> <p>If <code>True</code>, eligible to be transferred to Blender as a geometry attribute.</p> <code>True</code> <code>transdom</code> <code>bool</code> <p>If <code>True</code>, considered a trans-domain attribute that can be copied across compatible domains.</p> <code>True</code> See Also <p><code>new_float</code>, <code>new_vector</code>, <code>new_int</code>, <code>new_bool</code>, <code>new_color</code>, <code>new_vector2</code>, <code>new_quaternion</code>, <code>new_matrix</code></p>"},{"location":"api/edge/#npblender.domain.Edge.new_bool","title":"new_bool","text":"<pre><code>new_bool(name, default=False, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a boolean attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>bool</code> <p>Default value.</p> <code>False</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/edge/#npblender.domain.Edge.new_color","title":"new_color","text":"<pre><code>new_color(name, default=(0.5, 0.5, 0.5, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a color attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,) or (4,)</code> <p>Default color as RGB or RGBA.</p> <code>(0.5, 0.5, 0.5, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/edge/#npblender.domain.Edge.new_field","title":"new_field","text":"<pre><code>new_field(name, dtype, shape=None, default=0, optional=False, **infos)\n</code></pre> <p>Add a field to the structured array.</p> Arguments <pre><code>- name (str) : field name\n- dtype (type) : a valid numpy dtype\n- shape (tuple = None) : the shape of the field\n- default (any = 0) : default value\n- optional (bool = False) : the field is created only when accessed\n- infos (dict) : field infos\n</code></pre>"},{"location":"api/edge/#npblender.domain.Edge.new_float","title":"new_float","text":"<pre><code>new_float(name, default=0.0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a scalar float attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>float</code> <p>Default value.</p> <code>0.0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/edge/#npblender.domain.Edge.new_int","title":"new_int","text":"<pre><code>new_int(name, default=0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure an integer attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>int</code> <p>Default value.</p> <code>0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/edge/#npblender.domain.Edge.new_matrix","title":"new_matrix","text":"<pre><code>new_matrix(name, default=np.eye(4), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a matrix attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array - like</code> <p>Default matrix. By convention this is a square matrix per element (e.g., <code>(3, 3)</code> rotation or <code>(4, 4)</code> transform).</p> <code>np.eye(4)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code> <code>order</code> required"},{"location":"api/edge/#npblender.domain.Edge.new_quaternion","title":"new_quaternion","text":"<pre><code>new_quaternion(name, default=(0.0, 0.0, 0.0, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a quaternion attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (4,)</code> <p>Default quaternion in <code>(x, y, z, w)</code> convention.</p> <code>(0.0, 0.0, 0.0, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/edge/#npblender.domain.Edge.new_vector","title":"new_vector","text":"<pre><code>new_vector(name, default=(0.0, 0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 3D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,)</code> <p>Default XYZ vector.</p> <code>(0.0, 0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/edge/#npblender.domain.Edge.new_vector2","title":"new_vector2","text":"<pre><code>new_vector2(name, default=(0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 2D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (2,)</code> <p>Default XY vector.</p> <code>(0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/edge/#npblender.domain.Edge.remove_face_edges","title":"remove_face_edges","text":"<pre><code>remove_face_edges(face_edges)\n</code></pre> <p>Remove edges that belong to a given face-edge set.</p> <p>Compares the (undirected) edge list of this domain to <code>face_edges</code> and deletes any matching edges. Both inputs are normalized internally so that edge order does not matter.</p> <p>This method is typically used when loading a mesh from an object to keep only free edges.</p> <p>Parameters:</p> Name Type Description Default <code>face_edges</code> <code>ndarray of shape ``(M, 2)`` and dtype int</code> <p>Vertex-index pairs representing edges built from faces (e.g., via <code>get_face_edges</code>).</p> required <p>Returns:</p> Type Description <code>None</code> Notes <ul> <li>If <code>face_edges</code> is empty, the method returns immediately.</li> <li>Matching is performed by viewing each pair as a structured item to allow fast set membership tests.</li> </ul>"},{"location":"api/edge/#npblender.domain.Edge.to_bl_attributes","title":"to_bl_attributes","text":"<pre><code>to_bl_attributes(attributes, update=False)\n</code></pre> <p>Export attributes to a Blender attribute collection.</p> <p>Writes eligible domain attributes to a Blender data-block, creating missing attributes and adjusting sizes as needed.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Any</code> <p>Blender attributes collection receiving the values.</p> required <code>update</code> <code>bool</code> <p>If <code>True</code>, update existing attributes in-place; otherwise create them when missing.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Caution:*** Only attributes with `transfer=True` are exported. Optional</code> <code>attributes are skipped.</code> <code>&gt; ***Caution:*** Curve domains user attributes are not saved.</code>"},{"location":"api/edge/#npblender.domain.Edge.to_dict","title":"to_dict","text":"<pre><code>to_dict(*, copy=True, with_infos=True)\n</code></pre> <p>Convert the array to a dictionary of fields or (field, infos) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Whether to copy the arrays.</p> <code>True</code> <code>with_infos</code> <code>bool</code> <p>If True, return (array, infos) for each field.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, array or (array, dict)]</code>"},{"location":"api/edge/#npblender.domain.Edge.transfer_attributes","title":"transfer_attributes","text":"<pre><code>transfer_attributes(other, shape=None, other_shape=None)\n</code></pre> <p>Transfer values of trans-domain attributes from another domain.</p> <p>Copies values for each trans-domain attribute present in <code>other</code> into the corresponding attributes of <code>self</code>, with optional reshaping for batched assignments.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain</code> <p>Source domain providing attribute values.</p> required <code>shape</code> <code>tuple of int or None</code> <p>Target reshape for <code>self</code> before assignment. If <code>None</code>, uses <code>(self._length,)</code>.</p> <code>None</code> <code>other_shape</code> <code>tuple of int or None</code> <p>Source reshape for <code>other</code> before assignment. If <code>None</code>, uses <code>(other._length,)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p> <code>&gt; ***Note:*** Each attribute is reshaped as `shape + item_shape` on `self`</code> <code>and `other_shape + item_shape` on `other` prior to assignment.</code>"},{"location":"api/face/","title":"Face","text":""},{"location":"api/face/#npblender.domain.Face","title":"Face","text":"<pre><code>Face(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>Mesh face (polygon) domain.</p> <p>Inherits loop bookkeeping from :class:<code>FaceSplineDomain</code> and provides face-level operations: area/normal/centroid computation, edge extraction, attribute transfers, and topology-aware deletions.</p> <p>Attributes:</p> Name Type Description <code>loop_start</code> <code>(F,) int</code> <p>Starting corner index of each face.</p> <code>loop_total</code> <code>(F,) int</code> <p>Number of corners per face.</p> <code>material_index</code> <code>(F,) int, optional</code> <p>Material index per face.</p> <code>sharp_face</code> <code>(F,) bool, optional</code> <p>Sharp shading flag.</p> <p>Methods:</p> Name Description <code>delete_loops</code> <p>Delete faces and their incident corners; returns removed vertex indices.</p> <code>get_face_edges</code> <p>Edge list per face as ordered vertex-index pairs.</p> <code>get_edges</code> <p>Unique undirected edges present in the mesh faces.</p> <code>get_position</code> <p>Face centroids by averaging incident vertex positions.</p> <code>area_vectors</code> <p>Area-weighted normal vectors (unnormalized).</p> <code>area</code> <p>Face areas.</p> <code>normal</code> <p>Unit normals.</p> <code>sequences</code> <p>Per-face sequences of vertex indices.</p> <code>compute_attribute_on_points</code> <p>Average a face attribute back to points.</p> <p>Examples:</p> <p>Compute normals and areas:</p> <pre><code>n = faces.normal(corners, points)\nA = faces.area(corners, points)\n</code></pre> <p>Extract unique edges:</p> <pre><code>edges = faces.get_edges(corners)\n</code></pre> <p>Note: Area vectors are computed by triangulating polygons and summing triangle cross products.</p> <p>Warning: After deleting faces via :meth:<code>delete_loops</code>, update dependent domains accordingly (e.g., rebuild edges if needed).</p> <p>Initialize a domain array and its attribute schema.</p> <p>Initializes the storage from an existing array/domain or creates an empty structure. Optionally merges attribute definitions/values from another domain and keyword-provided attributes.</p> <p>Domains are never instancied directly but by owning geometries.</p> <p>Actual Domains are <code>Vertex</code>, [<code>Faces</code>][npblender.domain.Faces], <code>Corner</code>, <code>Edge</code>, <code>ControlPoint</code>, <code>Spline</code> and <code>Point</code>.</p> <p>Domains are initialized with their defaults attributes, for instance <code>position</code> for point domaines.</p> <p>Use attributes can be freely added. </p> <p>Note: user attributes are saved in Blender Mesh objects only, Blender Curve objects don't store user attributes.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>array - like or FieldArray or None</code> <p>Source data used to initialize the domain. If <code>None</code>, an empty domain is created and <code>_declare_attributes()</code> is called to register defaults.</p> <code>None</code> <code>mode</code> <code>(COPY, CAPTURE, EMPTY)</code> <p>Initialization mode. <code>'COPY'</code> duplicates the input data, <code>'CAPTURE'</code> references the input buffer when supported, <code>'EMPTY'</code> creates the structure without copying values.</p> <code>'COPY'</code> <code>selector</code> <code>Any</code> <p>Optional row/element selector applied to <code>a</code> prior to initialization.</p> <code>None</code> <code>attr_from</code> <code>Domain or Mapping or None</code> <p>Attribute schema (and possibly values) to merge into this domain.</p> <code>None</code> <code>**attrs</code> <p>Additional attribute name/value pairs to inject or override.</p> <code>{}</code> Notes <p>The effective attribute list results from <code>_declare_attributes()</code>, then <code>attr_from</code>, then <code>**attrs</code> (later entries take precedence).</p> <p>Examples:</p> <pre><code>cube = Mesh.cube() # points, corners, faces and edges domains are created\n# Adding named attribute to point domain\ncube.points.new_float('age')\n# Setting the age\ncube.points.age = np.random.uniforme(10, 10, len(cube.points))\n</code></pre>"},{"location":"api/face/#npblender.domain.Face.actual_names","title":"actual_names  <code>property</code>","text":"<pre><code>actual_names\n</code></pre> <p>Column names.</p> <p>Returns the actual field names, excluding optional fields.</p>"},{"location":"api/face/#npblender.domain.Face.all_names","title":"all_names  <code>property</code>","text":"<pre><code>all_names\n</code></pre> <p>Column names.</p> <p>Returns all the field names, including optional ones.</p>"},{"location":"api/face/#npblender.domain.Face.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Array structured dtype</p> <p>Returns the dtype property of the structured array.</p>"},{"location":"api/face/#npblender.domain.Face.next_loop_start","title":"next_loop_start  <code>property</code>","text":"<pre><code>next_loop_start\n</code></pre> <p>Offset to use for the next appended item.</p> <p>Returns:</p> Type Description <code>int</code> <p><code>loop_start[-1] + loop_total[-1]</code> if the domain is non-empty, otherwise <code>0</code>.</p> See Also <p><code>compute_loop_start</code></p>"},{"location":"api/face/#npblender.domain.Face.reversed_indices","title":"reversed_indices  <code>property</code>","text":"<pre><code>reversed_indices\n</code></pre> <p>Map each corner/control-point index back to its owning item.</p> <p>Returns:</p> Type Description <code>ndarray of shape ``(sum(loop_total),)``</code> <p>For index <code>k</code> in the flattened corner/control-point array, the value is the face/spline index that owns <code>k</code>.</p>"},{"location":"api/face/#npblender.domain.Face.transdom_names","title":"transdom_names  <code>property</code>","text":"<pre><code>transdom_names\n</code></pre> <p>List the names of trans-domain attributes.</p> <p>Returns:</p> Type Description <code>list of str</code> <p>Names of attributes flagged with <code>transdom=True</code>.</p> <p>Examples:</p> <pre><code>names = D.transdom_names()\n</code></pre>"},{"location":"api/face/#npblender.domain.Face.add","title":"add","text":"<pre><code>add(count, **fields)\n</code></pre> <p>Add count records</p> <p>New records are set with default values or values provided by the user in fields dict.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of records to add.</p> required <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/face/#npblender.domain.Face.append","title":"append","text":"<pre><code>append(**fields)\n</code></pre> <p>Append values to the structured array.</p> <p>The number of records to append is determined by the number of fields provided in the fields dictionary. The values of the fields are copied to the new records.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/face/#npblender.domain.Face.append_sizes","title":"append_sizes","text":"<pre><code>append_sizes(sizes, **fields)\n</code></pre> <p>Append new items given their sizes.</p> <p>If <code>loop_start</code> is not provided in <code>fields</code>, computes it from <code>sizes</code> using <code>compute_loop_start</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sizes</code> <code>array-like of int or None</code> <p>Number of corners/control-points for each new item.</p> required <code>**fields</code> <p>Additional per-item attributes to append (e.g., <code>material_index</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The value returned by <code>append(...)</code> (implementation-defined, often the indices/slice of appended items).</p> Notes <p>Passing <code>sizes=None</code> is a no-op and returns an empty list.</p>"},{"location":"api/face/#npblender.domain.Face.area","title":"area","text":"<pre><code>area(corners, points)\n</code></pre> <p>Compute face areas.</p> <p>Returns the scalar area of each polygonal face by taking half the Euclidean norm of its area-weighted normal vector (see <code>area_vectors</code>).</p> <p>Parameters:</p> Name Type Description Default <code>corners</code> <code>Corner</code> <p>Corner domain providing the per-corner <code>vertex_index</code>.</p> required <code>points</code> <code>Point</code> <p>Point (vertex) domain providing <code>position</code> of shape <code>(P, 3)</code>.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray of shape ``(F,)`` and dtype float</code> <p>Area per face.</p> Notes <ul> <li>Internally, faces are triangulated and triangle cross-products are summed to form area vectors; the area is half the vector norm. See <code>area_vectors</code> for details.</li> <li>Degenerate faces (zero area) produce zeros here.</li> </ul> See Also <p><code>area_vectors</code> <code>normal</code> <code>get_surface</code></p>"},{"location":"api/face/#npblender.domain.Face.as_kwargs","title":"as_kwargs","text":"<pre><code>as_kwargs(selector=None, include=None, exclude=None)\n</code></pre> <p>Return a dictionary of field values formatted as kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>slice, int, list, or mask</code> <p>Optional selection of elements to extract.</p> <code>None</code> <code>include</code> <code>list[str]</code> <p>List of field names (original or python names) to include.</p> <code>None</code> <code>exclude</code> <code>list[str]</code> <p>List of field names (original or python names) to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Mapping from python-safe field names to array values.</p>"},{"location":"api/face/#npblender.domain.Face.check","title":"check","text":"<pre><code>check(count, halt=True)\n</code></pre> <p>Validate loop counters against a reference element count.</p> <p>Verifies that the sum of <code>loop_total</code> equals <code>count</code> (i.e., the total number of referenced elements such as corners or control points).</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Expected total number of elements referenced by all items.</p> required <code>halt</code> <code>bool</code> <p>If <code>True</code>, raise on failure; otherwise print a message and return <code>False</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the check passes or the domain is empty; <code>False</code> only when invalid and <code>halt</code> is <code>False</code>.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If <code>sum(loop_total) != count</code> and <code>halt</code> is <code>True</code>.</p> <p>Examples:</p> <pre><code>ok = fs.check(count=len(corners), halt=False)\nif not ok:\n    # fix topology or sizes, then recompute\n    fs.update_loop_start()\n</code></pre>"},{"location":"api/face/#npblender.domain.Face.compute_attribute_on_points","title":"compute_attribute_on_points","text":"<pre><code>compute_attribute_on_points(attr, corners, points)\n</code></pre> <p>Average a per-face attribute back to points (vertices).</p> <p>For each face attribute value, accumulates it to all incident points (via corners) and divides by the number of incident contributions per point.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str or ndarray</code> <p>Name of the face attribute to transfer, or an explicit array of shape <code>(F, ...)</code>.</p> required <code>corners</code> <code>Corner</code> <p>Corner domain (provides <code>vertex_index</code>).</p> required <code>points</code> <code>Point</code> <p>Target point domain (length defines the number of output points).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of shape <code>(len(points), ...)</code> with the averaged values.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>attr</code> is a string and no such face attribute exists.</p> <code>IndexError</code> <p>If corner vertex indices fall outside <code>[0, len(points))</code>.</p>"},{"location":"api/face/#npblender.domain.Face.compute_loop_start","title":"compute_loop_start","text":"<pre><code>compute_loop_start(loop_total=None)\n</code></pre> <p>Compute offsets for one or many new items to append.</p> <p>Parameters:</p> Name Type Description Default <code>loop_total</code> <code>int or array-like of int or None</code> <p>Sizes of the items to add. If <code>None</code>, returns <code>None</code>. If a scalar, returns the single offset. If 1D array-like, returns one offset per size.</p> <code>None</code> <p>Returns:</p> Type Description <code>int or ndarray or None</code> <p>Offsets starting from <code>next_loop_start</code>, shaped like <code>loop_total</code>.</p> <p>Examples:</p> <pre><code># Prepare offsets for three faces of sizes 4, 5, 4\nstarts = fs.compute_loop_start([4, 5, 4])\nfs.append(loop_start=starts, loop_total=[4, 5, 4])\n</code></pre>"},{"location":"api/face/#npblender.domain.Face.copy_field","title":"copy_field","text":"<pre><code>copy_field(field_name, new_name, **infos)\n</code></pre> <p>Duplicate an existing field under a new name, with optional metadata overrides.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the existing field to copy.</p> required <code>new_name</code> <code>str</code> <p>The name of the new field to create.</p> required <code>infos</code> <code>keyword arguments</code> <p>Optional metadata (e.g. default, unit, description...) to override or supplement the original field's metadata.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the source field does not exist.</p> <code>ValueError</code> <p>If the target name already exists or is reserved.</p>"},{"location":"api/face/#npblender.domain.Face.delete","title":"delete","text":"<pre><code>delete(selection)\n</code></pre> <p>Delete selected items and maintain consistent offsets.</p> <p>After deleting items via <code>super().delete(selection)</code>, recomputes <code>loop_start</code> with <code>update_loop_start</code>.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>Any</code> <p>Boolean mask, integer index, slice, or array of indices.</p> required <p>Returns:</p> Type Description <code>None</code> See Also <p><code>update_loop_start</code></p>"},{"location":"api/face/#npblender.domain.Face.delete_loops","title":"delete_loops","text":"<pre><code>delete_loops(selection, corners)\n</code></pre> <p>Delete faces and their incident corners.</p> <p>Removes the selected faces and deletes the corresponding corner loops from <code>corners</code>. Returns the vertex indices (as stored on corners) that were removed with those loops.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>Any</code> <p>Face selection accepted by the domain (boolean mask, indices, slice, etc.).</p> required <code>corners</code> <code>Corner</code> <p>Corner domain holding at least the per-corner <code>vertex_index</code> array.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray of int</code> <p>The (possibly non-unique) vertex indices referenced by the deleted corners. If you need the unique set of affected vertices, apply <code>np.unique</code> on the result.</p> Notes <ul> <li>Internally calls <code>delete</code> on the face domain, which updates loop bookkeeping (see <code>update_loop_start</code>).</li> <li>Corners corresponding to the deleted faces are also removed via <code>corners.delete(...)</code>.</li> </ul> <p>Raises:</p> Type Description <code>IndexError</code> <p>If <code>selection</code> is out of bounds or if corner indices are inconsistent with the provided <code>corners</code> domain.</p>"},{"location":"api/face/#npblender.domain.Face.dump","title":"dump","text":"<pre><code>dump(title='Dump', attributes=None, target='SCREEN')\n</code></pre> <p>Pretty-print or export domain content.</p> <p>Formats attribute values and prints to screen or builds a tabular dump suitable for spreadsheets.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title displayed in the report.</p> <code>'Dump'</code> <code>attributes</code> <code>Sequence[str] or None</code> <p>Subset of attribute names to include. If <code>None</code>, all attributes are shown.</p> <code>None</code> <code>target</code> <code>(SCREEN, ...)</code> <p>Output target. <code>'SCREEN'</code> prints to stdout; other targets may trigger file creation depending on the implementation.</p> <code>'SCREEN'</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>Domain(points).dump(title=\"Vertices\")\n</code></pre> <p>Note: Formatting adapts to the chosen <code>target</code>.</p>"},{"location":"api/face/#npblender.domain.Face.extend","title":"extend","text":"<pre><code>extend(other, join_fields=True)\n</code></pre> <p>Append multiple records from another array or FieldArray.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray or structured np.ndarray</code> <p>The array of records to append. Must have named fields matching a subset of the current array's fields.</p> required"},{"location":"api/face/#npblender.domain.Face.filtered","title":"filtered","text":"<pre><code>filtered(selector, *, copy=False)\n</code></pre> <p>Return a FieldArray containing only the selected records.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>array\u2011like, slice or int</code> <p>Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice. It is applied to the current valid part of the buffer (<code>self._data[:self._length]</code>).</p> required <code>copy</code> <code>bool</code> <ul> <li>False    (default) =&gt; the new array shares the same memory                          (changes propagate both ways).</li> <li>True           =&gt; the data are physically copied.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>FieldArray</code> <p>A new instance holding exactly <code>len(selector)</code> records and inheriting the current field\u2011infos.</p>"},{"location":"api/face/#npblender.domain.Face.from_bl_attributes","title":"from_bl_attributes","text":"<pre><code>from_bl_attributes(bl_attributes)\n</code></pre> <p>Import attributes from a Blender attribute collection.</p> <p>Reads geometry attributes from a Blender data-block and creates/updates the corresponding domain attributes, resizing the domain if needed.</p> <p>Parameters:</p> Name Type Description Default <code>bl_attributes</code> <code>Mapping[str, Any]</code> <p>Blender attributes collection (name \u2192 attribute descriptor) providing at least <code>.domain</code>, <code>.is_internal</code>, <code>.data_type</code>, and <code>.data</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Note:*** Only external (non-internal) Blender attributes matching this</code> <code>domain are imported. Missing attributes are created with `transfer=True`.</code>"},{"location":"api/face/#npblender.domain.Face.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Build a FieldArray from a dictionary with field data and optional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, array - like or (array, dict)]</code> <p>Mapping field names to arrays or (array, infos). Infos must include NAME.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the data. Default: True.</p> required <p>Returns:</p> Type Description <code>FieldArray</code>"},{"location":"api/face/#npblender.domain.Face.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> <p>Get attribute by name.</p> <p>If name is not an actual field, return default value. Name can be an array. <pre><code>pos = field_array.get(\"position\", (0, 0, 1))\npos = field_array.get([[0, 0, 1], [0, 0, 0]])\n</code></pre></p>"},{"location":"api/face/#npblender.domain.Face.get_corner_indices","title":"get_corner_indices","text":"<pre><code>get_corner_indices()\n</code></pre> <p>Return the contiguous range of corner/control-point indices.</p> <p>For each item, expands its <code>[loop_start, loop_start + loop_total)</code> range and concatenates the result for all items.</p> <p>Returns:</p> Type Description <code>ndarray of shape ``(sum(loop_total),)``</code> <p>Absolute indices into the corner/control-point array.</p> Notes <p>A fast Numba kernel is used for vectorized cases; the scalar case is handled directly.</p>"},{"location":"api/face/#npblender.domain.Face.get_edges","title":"get_edges","text":"<pre><code>get_edges(corners)\n</code></pre> <p>Return the unique undirected edges present in the faces.</p> <p>Uses <code>get_face_edges</code> and deduplicates edges with <code>np.unique(..., axis=0)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>corners</code> <code>Corner</code> <p>Corner domain providing the <code>vertex_index</code> array.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray of shape (E, 2), dtype=int</code> <p>Unique vertex-index pairs for all edges.</p>"},{"location":"api/face/#npblender.domain.Face.get_face_edges","title":"get_face_edges","text":"<pre><code>get_face_edges(corners)\n</code></pre> <p>Build per-face edge list as ordered vertex-index pairs.</p> <p>For each corner loop of each face, returns the undirected edge as a pair <code>(min(v_prev, v_curr), max(v_prev, v_curr))</code> so that an edge appears in consistent order regardless of traversal direction.</p> <p>Parameters:</p> Name Type Description Default <code>corners</code> <code>Corner</code> <p>Corner domain providing the <code>vertex_index</code> array.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray of shape (M, 2), dtype=int</code> <p>One edge per corner (M is the total number of corners across faces).</p> See Also <p><code>get_edges</code>     Get the unique set of edges across all faces.</p>"},{"location":"api/face/#npblender.domain.Face.get_surface","title":"get_surface","text":"<pre><code>get_surface(corners, points)\n</code></pre> <p>Convenience bundle of per-face surface data.</p> <p>Returns a dictionary containing: - <code>normals</code> : (F, 3) float \u2014 unit normals, - <code>areas</code>   : (F,) float \u2014 face areas, - <code>sizes</code>   : (F,) int \u2014 number of corners per face (<code>loop_total</code>), - <code>verts</code>   : (P, 3) float \u2014 reference to point positions array.</p> <p>Parameters:</p> Name Type Description Default <code>corners</code> <code>Corner</code> required <code>points</code> <code>Point</code> required <p>Returns:</p> Type Description <code>dict</code> <p>Mapping with keys <code>normals</code>, <code>areas</code>, <code>sizes</code>, <code>verts</code>.</p>"},{"location":"api/face/#npblender.domain.Face.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other)\n</code></pre> <p>Merge trans-domain attributes from another domain.</p> <p>Copies or aligns attributes from <code>other</code> into the current domain, excluding any attributes not flagged as trans-domain in <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain or None</code> <p>Source domain. If <code>None</code>, the call is a no-op.</p> required <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p>"},{"location":"api/face/#npblender.domain.Face.join_fields","title":"join_fields","text":"<pre><code>join_fields(other, exclude=[])\n</code></pre> <p>Add all missing fields from another FieldArray.</p> <p>For every field in <code>other</code> that is not present in <code>self</code>, a new field is created with the same dtype and shape, and initialized with its default value across all existing records.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray</code> <p>Another FieldArray instance whose fields will be checked for missing fields.</p> required <p>Returns:</p> Type Description <code>self</code>"},{"location":"api/face/#npblender.domain.Face.make_buckets","title":"make_buckets","text":"<pre><code>make_buckets(attr)\n</code></pre> <p>Group items into buckets by attribute value.</p> <p>When a domain is to be considered as a collection of packets of various sizes, buckets mechanism groups pakets by size, allowing further operation with numpy vectorization.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>array - like or str</code> <p>Either an integer of shape <code>(N,)</code> or the name of an existing integer attribute in the domain.</p> required <p>Returns:</p> Type Description <code>list[ndarray(count, n)]</code> <p>A list of int arrays (count, n): count is the number of buckets of length n.</p> <p>Examples:</p> <pre><code>buckets = mesh.make_buckets('material')\nfor bucket in buckets:\n    print(bucket.shape)\n</code></pre> <p>Note: The bucket attribute can be read with <code>attr[bucket[:, 0]]</code>.</p>"},{"location":"api/face/#npblender.domain.Face.multiply","title":"multiply","text":"<pre><code>multiply(count)\n</code></pre> <p>Duplicate the current records <code>count</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of times to repeat the current records.</p> required Notes <p>This duplicates the current valid records (up to self._length). If the array is empty or count &lt;= 1, nothing happens.</p> Example: <p>If the array has 3 records and count == 4, the result will be:</p> <p>[rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]</p>"},{"location":"api/face/#npblender.domain.Face.new_attribute","title":"new_attribute","text":"<pre><code>new_attribute(name, data_type, default, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Register a new attribute in the domain schema.</p> <p>Creates (or ensures) an attribute with a given name, logical data type, default value, and flags controlling Blender transfer and cross-domain propagation.</p> <p>Note: <code>data_type</code> argument is a Blender data type not a python data type. The data type name is compatible with Blender internal storage. <code>FLOAT</code>data type is implemented as <code>np.float32</code> and  'INT' as <code>np.int32</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name (Python identifier recommended).</p> required <code>data_type</code> <code>(FLOAT, INT, BOOL, VECTOR, VECTOR2, COLOR, QUATERNION, MATRIX, STRING, ...)</code> <p>Logical data type used by the domain.</p> <code>'FLOAT'</code> <code>default</code> <code>Any</code> <p>Default value for newly allocated elements.</p> required <code>optional</code> <code>bool</code> <p>If <code>True</code>, the attribute may be absent on some elements.</p> <code>False</code> <code>transfer</code> <code>bool</code> <p>If <code>True</code>, eligible to be transferred to Blender as a geometry attribute.</p> <code>True</code> <code>transdom</code> <code>bool</code> <p>If <code>True</code>, considered a trans-domain attribute that can be copied across compatible domains.</p> <code>True</code> See Also <p><code>new_float</code>, <code>new_vector</code>, <code>new_int</code>, <code>new_bool</code>, <code>new_color</code>, <code>new_vector2</code>, <code>new_quaternion</code>, <code>new_matrix</code></p>"},{"location":"api/face/#npblender.domain.Face.new_bool","title":"new_bool","text":"<pre><code>new_bool(name, default=False, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a boolean attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>bool</code> <p>Default value.</p> <code>False</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/face/#npblender.domain.Face.new_color","title":"new_color","text":"<pre><code>new_color(name, default=(0.5, 0.5, 0.5, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a color attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,) or (4,)</code> <p>Default color as RGB or RGBA.</p> <code>(0.5, 0.5, 0.5, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/face/#npblender.domain.Face.new_field","title":"new_field","text":"<pre><code>new_field(name, dtype, shape=None, default=0, optional=False, **infos)\n</code></pre> <p>Add a field to the structured array.</p> Arguments <pre><code>- name (str) : field name\n- dtype (type) : a valid numpy dtype\n- shape (tuple = None) : the shape of the field\n- default (any = 0) : default value\n- optional (bool = False) : the field is created only when accessed\n- infos (dict) : field infos\n</code></pre>"},{"location":"api/face/#npblender.domain.Face.new_float","title":"new_float","text":"<pre><code>new_float(name, default=0.0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a scalar float attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>float</code> <p>Default value.</p> <code>0.0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/face/#npblender.domain.Face.new_int","title":"new_int","text":"<pre><code>new_int(name, default=0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure an integer attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>int</code> <p>Default value.</p> <code>0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/face/#npblender.domain.Face.new_matrix","title":"new_matrix","text":"<pre><code>new_matrix(name, default=np.eye(4), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a matrix attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array - like</code> <p>Default matrix. By convention this is a square matrix per element (e.g., <code>(3, 3)</code> rotation or <code>(4, 4)</code> transform).</p> <code>np.eye(4)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code> <code>order</code> required"},{"location":"api/face/#npblender.domain.Face.new_quaternion","title":"new_quaternion","text":"<pre><code>new_quaternion(name, default=(0.0, 0.0, 0.0, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a quaternion attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (4,)</code> <p>Default quaternion in <code>(x, y, z, w)</code> convention.</p> <code>(0.0, 0.0, 0.0, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/face/#npblender.domain.Face.new_vector","title":"new_vector","text":"<pre><code>new_vector(name, default=(0.0, 0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 3D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,)</code> <p>Default XYZ vector.</p> <code>(0.0, 0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/face/#npblender.domain.Face.new_vector2","title":"new_vector2","text":"<pre><code>new_vector2(name, default=(0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 2D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (2,)</code> <p>Default XY vector.</p> <code>(0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/face/#npblender.domain.Face.normal","title":"normal","text":"<pre><code>normal(corners, points)\n</code></pre> <p>Compute per-face unit normals.</p> <p>Returns a normalized area vector for each face (see <code>area_vectors</code>). The direction follows the winding of the face\u2019s corners.</p> <p>Parameters:</p> Name Type Description Default <code>corners</code> <code>Corner</code> <p>Corner domain providing the per-corner <code>vertex_index</code>.</p> required <code>points</code> <code>Point</code> <p>Point (vertex) domain providing <code>position</code> of shape <code>(P, 3)</code>.</p> required <p>Returns:</p> Type Description <code>numpy.ndarray of shape ``(F, 3)`` and dtype float</code> <p>Unit normal per face.</p> Notes <ul> <li>Area vectors are obtained by triangulating polygons and summing triangle cross-products before normalization.</li> <li>Degenerate faces (zero area) yield undefined normals (NaNs or inf). You may sanitize with <code>np.nan_to_num</code> or mask faces where the area is zero.</li> </ul> See Also <p><code>area_vectors</code> <code>area</code> <code>get_surface</code></p>"},{"location":"api/face/#npblender.domain.Face.per_size","title":"per_size","text":"<pre><code>per_size()\n</code></pre> <p>Group items by their <code>loop_total</code> (polygon/control-point count).</p> <p>Returns a dictionary keyed by size (<code>3</code>, <code>4</code>, \u2026) where each entry contains: - <code>'start'</code> : array of <code>loop_start</code> values for items of that size. - <code>'indices'</code> : array mapping entry order back to item indices.</p> <p>Returns:</p> Type Description <code>dict[int, dict[str, ndarray]]</code> <p>Grouped start offsets and reverse indices for each size present.</p> Notes <p>Uses a Numba kernel to bucketize items efficiently.</p>"},{"location":"api/face/#npblender.domain.Face.position","title":"position","text":"<pre><code>position(corners, points)\n</code></pre> <p>Face centroids (mean of corner positions).</p> <p>Computes the arithmetic mean of corner positions per face.</p> <p>Parameters:</p> Name Type Description Default <code>corners</code> <code>Corner</code> required <code>points</code> <code>Point</code> required <p>Returns:</p> Type Description <code>numpy.ndarray of shape (F, 3), dtype=float</code> <p>Centroid of each face.</p>"},{"location":"api/face/#npblender.domain.Face.position_DEPRECATED","title":"position_DEPRECATED","text":"<pre><code>position_DEPRECATED(corners, points)\n</code></pre> <p>Centers of the faces</p> <p>Args:     verts (array (:, 3) of floats): The vertices</p> <p>Returns:     array (len(self), 3) of floats: The centers</p>"},{"location":"api/face/#npblender.domain.Face.sequences","title":"sequences","text":"<pre><code>sequences(corners)\n</code></pre> <p>Vertex-index sequences per face.</p> <p>Returns a Python list where each item is the ordered sequence of vertex indices for the corresponding face.</p> <p>Parameters:</p> Name Type Description Default <code>corners</code> <code>Corner</code> required <p>Returns:</p> Type Description <code>list[list[int]]</code> <p>Vertex index sequence for each face.</p>"},{"location":"api/face/#npblender.domain.Face.to_bl_attributes","title":"to_bl_attributes","text":"<pre><code>to_bl_attributes(attributes, update=False)\n</code></pre> <p>Export attributes to a Blender attribute collection.</p> <p>Writes eligible domain attributes to a Blender data-block, creating missing attributes and adjusting sizes as needed.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Any</code> <p>Blender attributes collection receiving the values.</p> required <code>update</code> <code>bool</code> <p>If <code>True</code>, update existing attributes in-place; otherwise create them when missing.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Caution:*** Only attributes with `transfer=True` are exported. Optional</code> <code>attributes are skipped.</code> <code>&gt; ***Caution:*** Curve domains user attributes are not saved.</code>"},{"location":"api/face/#npblender.domain.Face.to_dict","title":"to_dict","text":"<pre><code>to_dict(*, copy=True, with_infos=True)\n</code></pre> <p>Convert the array to a dictionary of fields or (field, infos) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Whether to copy the arrays.</p> <code>True</code> <code>with_infos</code> <code>bool</code> <p>If True, return (array, infos) for each field.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, array or (array, dict)]</code>"},{"location":"api/face/#npblender.domain.Face.transfer_attributes","title":"transfer_attributes","text":"<pre><code>transfer_attributes(other, shape=None, other_shape=None)\n</code></pre> <p>Transfer values of trans-domain attributes from another domain.</p> <p>Copies values for each trans-domain attribute present in <code>other</code> into the corresponding attributes of <code>self</code>, with optional reshaping for batched assignments.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain</code> <p>Source domain providing attribute values.</p> required <code>shape</code> <code>tuple of int or None</code> <p>Target reshape for <code>self</code> before assignment. If <code>None</code>, uses <code>(self._length,)</code>.</p> <code>None</code> <code>other_shape</code> <code>tuple of int or None</code> <p>Source reshape for <code>other</code> before assignment. If <code>None</code>, uses <code>(other._length,)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p> <code>&gt; ***Note:*** Each attribute is reshaped as `shape + item_shape` on `self`</code> <code>and `other_shape + item_shape` on `other` prior to assignment.</code>"},{"location":"api/face/#npblender.domain.Face.update_loop_start","title":"update_loop_start","text":"<pre><code>update_loop_start()\n</code></pre> <p>Recompute <code>loop_start</code> from <code>loop_total</code> (cumulative layout).</p> <p>Sets <code>loop_start</code> to a left-rolled cumulative sum of <code>loop_total</code>, so item i starts right after the end of item i-1.</p> <p>Returns:</p> Type Description <code>FaceSplineDomain</code> <p>Self (for chaining).</p> Notes <p>Call this after deletions / resizes to keep indices consistent.</p> See Also <p><code>compute_loop_start</code> :     Compute offsets for new items to be appended.</p>"},{"location":"api/geometry/","title":"Geometry","text":""},{"location":"api/geometry/#geometry-methods","title":"Geometry - Methods","text":""},{"location":"api/geometry/#npblender.geometry.Geometry","title":"Geometry","text":""},{"location":"api/geometry/#npblender.geometry.Geometry.add_materials","title":"add_materials","text":"<pre><code>add_materials(materials)\n</code></pre> <p>Add a materials list to the existing one.</p> <p>If a material already exist, it is not added another time.</p> Arguments <pre><code>- materials (list of strs) : the list of materials to append.\n</code></pre>"},{"location":"api/geometry/#npblender.geometry.Geometry.get_material_index","title":"get_material_index","text":"<pre><code>get_material_index(mat_name)\n</code></pre> <p>Return the index of a material name.</p> <p>If the material doesn't exist, it is created</p> Arguments <pre><code>- mat_name (str) : material name\n</code></pre> <p>Returns:</p> Type Description <code>    - int : index of the material name in the materials list</code>"},{"location":"api/geometry/#npblender.geometry.Geometry.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other, **kwargs)\n</code></pre> <p>Capture the attributes from another geometry.</p> <p>Other can be a different geometry, in that case, only domains with the same name are captured. kwargs allows to filter the domains to capture:</p> <pre><code>mesh.join_attributes(other_mesh, faces=False)\nmesh.join_attributes(curve)\n</code></pre> <p>Returns:     - self</p>"},{"location":"api/geometry/#npblender.geometry.Geometry.load_models","title":"load_models  <code>staticmethod</code>","text":"<pre><code>load_models(*specs)\n</code></pre> <p>Load a geometry or geometries from specifications.</p> <p>The specs can be:     - a Blender collection     - a Blender object     - a Geometry</p> Arguments <pre><code>- specs (list of objects / collections) : the models to load\n</code></pre> <p>Returns:</p> Type Description <code>    - list of geometries</code>"},{"location":"api/geometry/#npblender.geometry.Geometry.load_object","title":"load_object  <code>staticmethod</code>","text":"<pre><code>load_object(name)\n</code></pre> <p>Load a Blender object and returns either a Mesh or a Curve.</p> Arguments <pre><code>- name (str or bpy.types.Object) : the object to load\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh or Curve</code>"},{"location":"api/geometry/#npblender.geometry.Geometry.transformation","title":"transformation","text":"<pre><code>transformation(rotation=None, scale=None, translation=None, pivot=None)\n</code></pre> <p>The transformation arguments can treat the points as a list of packets of the same size. For instance, 24 vertices can be seend as 3 packets of 8 vertices using a translation of (8, 3) vectors.</p> <p>Examples:</p> <pre><code># A mesh made of 12 cubes\ncubes = Mesh.cube(size=1)*12\n\n# 3 random transformations\ntranslation = np.random.uniform(-1, 1, (4, 3))\npivot = np.random.uniform(-1, 1, (3, 3))\nscale = np.random.uniform(.1, 2, (12, 3))\nrot = Rotation.from_euler(np.random.uniform(0, 2*np.pi, (6, 3)))\n\ncubes.transformation(\n    translation = translation,\n    scale = scale,\n    rotation = rot,\n    pivot=pivot,\n)\n</code></pre>"},{"location":"api/mesh/","title":"Mesh","text":""},{"location":"api/mesh/#npblender.mesh.Mesh","title":"Mesh","text":"<pre><code>Mesh(points=None, corners=None, faces=None, edges=None, materials=None, attr_from=None, **attrs)\n</code></pre> <p>               Bases: <code>Geometry</code></p> <p>Initialize a Mesh Geometry object.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array_like</code> <p>The vertices of the mesh (default is None).</p> <code>None</code> <code>corners</code> <code>array_like of int</code> <p>Corners, i.e., indices on the array of points (default is None).</p> <code>None</code> <code>faces</code> <code>array_like of int</code> <p>Sizes of the faces; the sum of this array must be equal to the length of the corners array (default is None).</p> <code>None</code> <code>edges</code> <code>array_like of tuple of int</code> <p>List of edges defined by pairs of vertex indices (default is None).</p> <code>None</code> <code>materials</code> <code>str or list of str</code> <p>List of materials used in the geometry. If a single string is provided, it is converted to a list containing that string (default is None).</p> <code>None</code> <code>attr_from</code> <code>Geometry</code> <p>Domain attributes to copy from another Geometry object (default is None).</p> <code>None</code> <code>**attrs</code> <code>dict</code> <p>Additional geometry attributes.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>points</code> <code>Vertex</code> <p>The vertices of the mesh.</p> <code>corners</code> <code>Corner</code> <p>The corners of the mesh.</p> <code>faces</code> <code>Face</code> <p>The faces of the mesh.</p> <code>edges</code> <code>Edge</code> <p>The edges of the mesh.</p> <code>materials</code> <code>list of str</code> <p>The list of materials used in the geometry.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_geometry","title":"add_geometry","text":"<pre><code>add_geometry(points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs)\n</code></pre> <p>Add geometry components (vertices, corners, faces, edges) to the mesh.</p> <p>This method appends the specified geometry to the mesh without altering existing indices. It supports referencing existing vertices through corners or adding new vertices.</p> <p>Note: To add independent geometry with new vertices, use <code>Mesh.join_geometry</code> instead.</p> <p>Examples:</p> <pre><code>``` python\ncube = Mesh.cube()\n# Add a triangle on existing vertices\n# corners argument refers to cube vertices\ncube.add_geometry(corners=[0, 1, 2], faces=3)\n\n# Add a triangle with additional vertices\n# corners argument refers to the new vertices, passed values [0, 1, 2]\n# will be shifted to actual values [8, 9, 10]\ncube.join_geometry(points=[[0, 0, 0], [0, 1, 0], [1, 0, 0]], corners=[0, 1, 2], faces=3)\n```\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like of vectors</code> <p>Vertices to add to the mesh.</p> <code>None</code> <code>corners</code> <code>array-like of int</code> <p>Indices referring to vertices in the points array.</p> <code>None</code> <code>faces</code> <code>int, array-like of int, or list of lists</code> <p>Defines the faces topology: - If <code>corners</code> is provided:     - None: Single face made of all corners.     - int: All faces have the same size (must divide the number of corners).     - array-like: Face sizes; sum must equal the number of corners. - If <code>corners</code> is None:     - Must be a list of lists, each sublist is a list of corners.</p> <code>None</code> <code>edges</code> <code>array-like of pairs of int</code> <p>Edges defined by pairs of vertex indices.</p> <code>None</code> <code>safe_mode</code> <code>bool</code> <p>If True, perform a mesh integrity check after adding geometry.</p> <code>False</code> <code>**attrs</code> <code>dict</code> <p>Additional geometry attributes to apply.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys {'points', 'corners', 'faces', 'edges'} mapping to lists of added geometry indices.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If faces and corners lengths are inconsistent or invalid.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_materials","title":"add_materials","text":"<pre><code>add_materials(materials)\n</code></pre> <p>Add a materials list to the existing one.</p> <p>If a material already exist, it is not added another time.</p> Arguments <pre><code>- materials (list of strs) : the list of materials to append.\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.add_points","title":"add_points","text":"<pre><code>add_points(points, **attributes)\n</code></pre> <p>Add vertices.</p> Arguments <pre><code>- points (array of vectors) : the vertices to add\n- attributes (name=value) : value for named attributes\n</code></pre> <p>Returns:</p> Type Description <code>    - array of ints : indices of the added vertices</code>"},{"location":"api/mesh/#npblender.mesh.Mesh.arrow","title":"arrow  <code>classmethod</code>","text":"<pre><code>arrow(vector=(0, 0, 1), radius=0.05, angle=24.0, segments=8, adjust_norm=None, materials=None)\n</code></pre> <p>Create an arrow mesh oriented along a given vector.</p> <p>The arrow is composed of a cylindrical shaft and a conical head, proportionally scaled to the length of the input vector.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>array-like of float, shape (3,)</code> <p>Direction and length of the arrow. The norm of the vector defines the arrow length. Default is (0, 0, 1).</p> <code>(0, 0, 1)</code> <code>radius</code> <code>float</code> <p>Radius of the cylindrical shaft. Default is 0.05.</p> <code>0.05</code> <code>angle</code> <code>float</code> <p>Opening angle of the conical head in degrees. Default is 24.</p> <code>24.0</code> <code>segments</code> <code>int</code> <p>Number of segments around the circumference. Default is 8.</p> <code>8</code> <code>adjust_norm</code> <code>(callable, float, None)</code> <ul> <li>If callable: a function applied to the vector norm to adjust the arrow length.</li> <li>If float: the arrow length is clamped to this maximum.</li> <li>If None: use the norm of <code>vector</code> directly. Default is None.</li> </ul> <code>callable</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the arrow. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the arrow.</p> Notes <ul> <li>The shaft is created with <code>cylinder</code>.</li> <li>The head is created with <code>cone</code> using <code>fill_type='FANS'</code> for proper triangulation.</li> <li>The arrow is aligned to <code>vector</code> using <code>Rotation.look_at</code>.</li> <li>A small correction is applied to avoid overlap between shaft and head.</li> </ul> <p>Examples:</p> <p>Create a default arrow of length 1 along Z:</p> <pre><code>arrow = Mesh.arrow()\n</code></pre> <p>Create an arrow along vector (1, 2, 0.5) with custom shaft radius:</p> <pre><code>arrow = Mesh.arrow(vector=(1, 2, 0.5), radius=0.1)\n</code></pre> <p>Create an arrow clamped to maximum length 2:</p> <pre><code>arrow = Mesh.arrow(vector=(0, 0, 5), adjust_norm=2)\n</code></pre> See Also <p><code>cylinder</code> :     Used to create the arrow shaft. <code>cone</code> :     Used to create the arrow head. <code>Rotation.look_at</code> :     Utility to orient the arrow along a target vector.</p> <p>Caution: If <code>vector</code> has zero length, the arrow cannot be constructed properly.</p> <p>Note: The conical head radius is set to <code>3 * radius</code> by default, and its height is determined by the opening <code>angle</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_circle","title":"bl_circle  <code>classmethod</code>","text":"<pre><code>bl_circle(radius=1, segments=16, fill_tris=False, materials=None)\n</code></pre> <p>Create a circle mesh.</p> <p>Blender constructor for generating a circle primitive using <code>bmesh.ops.create_circle</code>.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the circle. Default is 1.</p> <code>1</code> <code>segments</code> <code>int</code> <p>Number of segments (vertices) forming the circle. Default is 16.</p> <code>16</code> <code>fill_tris</code> <code>bool</code> <p>If True, fills the circle with a triangle fan. Default is False.</p> <code>False</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the circle. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the circle.</p> Notes <ul> <li>The circle is created using <code>bmesh.ops.create_circle</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> <li>By default (<code>fill_tris=False</code>), the circle is an open ring. With <code>fill_tris=True</code>, the circle is filled with triangles (fan topology).</li> </ul> <p>Examples:</p> <p>Create an empty circle of radius 2 with 32 segments:</p> <pre><code>circle = Mesh.bl_circle(radius=2, segments=32)\n</code></pre> <p>Create a filled circle (disk) of radius 1 with 24 segments:</p> <pre><code>circle = Mesh.bl_circle(radius=1, segments=24, fill_tris=True)\n</code></pre> See Also <p><code>bmesh.ops.create_circle</code> :     BMesh operator used for creating a circle primitive.</p> <p>Note: UVs are automatically calculated when the circle is created.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_cone","title":"bl_cone  <code>classmethod</code>","text":"<pre><code>bl_cone(radius1=1, radius2=0, depth=2, segments=16, side_segments=1, cap_ends=True, cap_tris=False, materials=None)\n</code></pre> <p>Create a cone mesh.</p> <p>Blender constructor for generating a cone (or cylinder) primitive using <code>bmesh.ops.create_cone</code>.</p> <p>Parameters:</p> Name Type Description Default <code>radius1</code> <code>float</code> <p>Base radius of the cone. Default is 1.</p> <code>1</code> <code>radius2</code> <code>float</code> <p>Top radius of the cone. If set to 0, produces a true cone; if equal to <code>radius1</code>, produces a cylinder. Default is 0.</p> <code>0</code> <code>depth</code> <code>float</code> <p>Height of the cone along the Z axis. Default is 2.</p> <code>2</code> <code>segments</code> <code>int</code> <p>Number of segments around the circumference. Default is 16.</p> <code>16</code> <code>side_segments</code> <code>int</code> <p>Number of subdivisions along the vertical side edges. Default is 1 (no subdivision).</p> <code>1</code> <code>cap_ends</code> <code>bool</code> <p>If True, fill the top and bottom caps. Default is True.</p> <code>True</code> <code>cap_tris</code> <code>bool</code> <p>If True, fill the caps using triangle fans instead of n-gons. Default is False.</p> <code>False</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the cone. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the cone.</p> Notes <ul> <li>The cone is created using <code>bmesh.ops.create_cone</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> <li>When <code>side_segments &gt; 1</code>, vertical edges crossing the top and bottom are subdivided using <code>bmesh.ops.subdivide_edges</code>.</li> </ul> <p>Examples:</p> <p>Create a simple cone with radius 1 and height 2:</p> <pre><code>cone = Mesh.bl_cone(radius1=1, radius2=0, depth=2, segments=16)\n</code></pre> <p>Create a cylinder with 32 segments and subdivided sides:</p> <pre><code>cylinder = Mesh.bl_cone(radius1=1, radius2=1, depth=3,\n                        segments=32, side_segments=4)\n</code></pre> <p>Create a cone with filled caps using triangle fans:</p> <pre><code>cone = Mesh.bl_cone(radius1=1, radius2=0, depth=2,\n                    cap_ends=True, cap_tris=True)\n</code></pre> See Also <p><code>bmesh.ops.create_cone</code> :     BMesh operator used for creating cone and cylinder primitives. <code>bmesh.ops.subdivide_edges</code> :     BMesh operator used for subdividing vertical edges when <code>side_segments &gt; 1</code>.</p> <p>Note: UVs are automatically calculated when the cone is created.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bl_grid","title":"bl_grid  <code>classmethod</code>","text":"<pre><code>bl_grid(x_segments=1, y_segments=1, size=2, materials=None)\n</code></pre> <p>Create a grid mesh.</p> <p>Blender constructor for generating a grid primitive using <code>bmesh.ops.create_grid</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x_segments</code> <code>int</code> <p>Number of segments along the X axis. Default is 1.</p> <code>1</code> <code>y_segments</code> <code>int</code> <p>Number of segments along the Y axis. Default is 1.</p> <code>1</code> <code>size</code> <code>float or tuple of float</code> <p>Size of the grid. If a single float is given, the grid is square. If a tuple is given, defines the grid dimensions along X and Y. Default is 2.</p> <code>2</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the grid. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the grid.</p> Notes <ul> <li>The grid is created using <code>bmesh.ops.create_grid</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> </ul> <p>Examples:</p> <p>Create a 10x10 grid of size 5:</p> <pre><code>grid = Mesh.bl_grid(x_segments=10, y_segments=10, size=5)\n</code></pre> <p>Create a rectangular grid 4x8 of size (2, 5):</p> <pre><code>grid = Mesh.bl_grid(x_segments=4, y_segments=8, size=(2, 5))\n</code></pre> See Also <p><code>bmesh.ops.create_grid</code> :     BMesh operator used for creating a grid primitive.</p> <p>Note: UVs are automatically calculated when the grid is created.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.blender_data","title":"blender_data","text":"<pre><code>blender_data(readonly=False)\n</code></pre> <p>Context manager to access the Blender Mesh API with a temporary mesh.</p> <p>This method transfers the current mesh geometry to a temporary Blender Mesh data block, yields it for reading or modification, and optionally captures the changes back into the mesh.</p> <p>Example usage:     <pre><code>mesh = Mesh.Cube()\n\nwith mesh.blender_data() as data:\n    normals = np.array([poly.normal for poly in data.polygons])\n\nprint(normals)\n# Output:\n# [[-1. -0.  0.]\n#  [ 0.  1.  0.]\n#  [ 1. -0.  0.]\n#  [ 0. -1.  0.]\n#  [ 0.  0. -1.]\n#  [ 0. -0.  1.]]\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>readonly</code> <code>bool</code> <p>If True, the geometry is not read back from the Blender Mesh after modification. Default is False.</p> <code>False</code> <p>Yields:</p> Type Description <code>Mesh</code> <p>A temporary Blender Mesh data block representing the mesh geometry.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bmesh","title":"bmesh","text":"<pre><code>bmesh(readonly=False)\n</code></pre> <p>Context manager to access and manipulate the mesh using Blender's BMesh API.</p> <p>This method creates a temporary BMesh from the mesh data, yields it for modification, and then writes back the changes to the mesh data unless in readonly mode.</p> <p>Example usage:     <pre><code>mesh = Mesh.Cube()\n\n# Move the vertices with bmesh\nwith mesh.bmesh() as bm:\n    for v in bm.verts:\n        v.co.x += 1.0\n\n# Move the vertices directly in numpy array\nmesh.points.position[:, 1] += 1\n\n# Cube moved along x and y\nmesh.to_object(\"Cube\")\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>readonly</code> <code>bool</code> <p>If True, changes made to the BMesh are not written back to the mesh data (default is False).</p> <code>False</code> <p>Yields:</p> Type Description <code>BMesh</code> <p>A BMesh object representing the mesh data, which can be modified within the context.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.boolean","title":"boolean","text":"<pre><code>boolean(other, operation='DIFFERENCE')\n</code></pre> <p>Apply a boolean CSG operation with another mesh object and return the result.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Mesh</code> <p>The mesh used as the boolean operand.</p> required <code>operation</code> <code>(INTERSECT, UNION, DIFFERENCE)</code> <p>Type of boolean operation to perform. Default is 'DIFFERENCE'.</p> <code>'INTERSECT'</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance created from the object after applying the Boolean modifier.</p> Notes <ul> <li>Internally, a Blender Boolean modifier is added to <code>self</code>, pointing to <code>other</code>, and then applied via <code>bpy.ops.object.modifier_apply</code>.</li> <li>The result is read back as a new mesh using <code>Mesh.from_object</code>.</li> <li>Context managers <code>object</code> are used to obtain temporary Blender objects for both meshes.</li> </ul> <p>Examples:</p> <p>Subtract <code>B</code> from <code>A</code>:</p> <pre><code>result = A.boolean(B, operation='DIFFERENCE')\n</code></pre> <p>Compute the union:</p> <pre><code>result = A.boolean(B, operation='UNION')\n</code></pre> <p>Keep only the intersection:</p> <pre><code>result = A.boolean(B, operation='INTERSECT')\n</code></pre> See Also <p><code>Mesh.from_object</code> :     Converts a Blender object back into a mesh wrapper. <code>object</code> :     Context manager yielding a temporary Blender object.</p> <p>Warning: Applying the modifier is destructive to the underlying Blender object for <code>self</code> (its mesh data is changed). The method returns a new mesh instance representing the modified result.</p> <p>Caution: Ensure <code>operation</code> is one of {'INTERSECT', 'UNION', 'DIFFERENCE'}; other values are invalid for Blender's Boolean modifier.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bridge_loops","title":"bridge_loops","text":"<pre><code>bridge_loops(loop0, loop1, close=False, segments=1, **attributes)\n</code></pre> <p>Create a grid connecting two vertex loops of equal size.</p> <p>The operation selects the edges forming each loop and bridges them using <code>bmesh.ops.bridge_loops</code>. If <code>segments &gt; 1</code>, the newly created edges are subdivided to form a denser grid between the loops.</p> <p>Parameters:</p> Name Type Description Default <code>loop0</code> <code>array-like of int</code> <p>The first loop of vertex indices.</p> required <code>loop1</code> <code>array-like of int</code> <p>The second loop of vertex indices. Must have the same length as <code>loop0</code>.</p> required <code>close</code> <code>bool</code> <p>If True, the loops are treated as closed and the first vertex is appended at the end to close the cycle. Default is False.</p> <code>False</code> <code>segments</code> <code>int</code> <p>Number of segments to subdivide between the loops. Must be &gt;= 1. Default is 1 (no subdivision).</p> <code>1</code> <code>**attributes</code> <code>dict</code> <p>Additional attributes to set on the mesh after bridging (passed as keyword arguments).</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>Modifies the mesh in place. Returns <code>None</code>.</p> Notes <ul> <li>Edges belonging to each loop are identified by sorting endpoint pairs and matching them against the current BMesh edge list via a structured dtype view and <code>np.isin</code>.</li> <li>Bridging is performed with <code>bmesh.ops.bridge_loops</code>.</li> <li>When <code>segments &gt; 1</code>, subdivision of the bridge edges is performed with <code>bmesh.ops.subdivide_edges</code> using <code>cuts=segments - 1</code> and <code>use_grid_fill=False</code>.</li> </ul> <p>Examples:</p> <p>Bridge two loops with no subdivision:</p> <pre><code>obj.bridge_loops(loop0, loop1, segments=1)\n</code></pre> <p>Bridge two closed loops with 3 subdivisions:</p> <pre><code>obj.bridge_loops(loop0, loop1, close=True, segments=3)\n</code></pre> See Also <p>bmesh.ops.bridge_loops : BMesh operator for bridging edge loops. bmesh.ops.subdivide_edges : BMesh operator for subdividing edges.</p> <p>Warning: This function modifies the mesh in place and may create new vertices/edges/faces. Handle undo/history in Blender if needed.</p> <p>Caution: Both loops must have the same number of vertices for correct bridging.</p> <p>Note: When <code>close=True</code>, the first vertex of each loop is duplicated at the end to ensure cyclic connectivity.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.bvh_tree","title":"bvh_tree","text":"<pre><code>bvh_tree(count=None)\n</code></pre> <p>Build a Blender BVH tree for fast spatial queries (ray casting, overlap, nearest point, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>If <code>None</code>, build a single BVH tree for the whole mesh. If an integer <code>count</code> is provided, the mesh is assumed to represent a batch of <code>count</code> sub-meshes laid out in a structured array, and a list of BVH trees (one per sub-mesh) is returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>BVHTree or list of BVHTree</code> <ul> <li>If <code>count</code> is <code>None</code>, a single <code>BVHTree</code> instance built from the current mesh.</li> <li>If <code>count</code> is an integer, a list of <code>BVHTree</code> objects, one for each sub-mesh.</li> </ul> Notes <ul> <li>Internally uses <code>mathutils.bvhtree.BVHTree.FromPolygons</code>.</li> <li>When <code>count</code> is given, vertices are reshaped to <code>(count, n, 3)</code> and faces are assumed to be identical across all sub-meshes.</li> <li><code>epsilon=0.0</code> is used for exact geometry.</li> </ul> <p>Examples:</p> <p>Build a single BVH tree:</p> <pre><code>tree = mesh.bvh_tree()\nloc, normal, index, dist = tree.ray_cast((0, 0, 10), (0, 0, -1))\n</code></pre> <p>Build multiple BVH trees for a batch of 5 sub-meshes:</p> <pre><code>trees = mesh.bvh_tree(count=5)\nfor t in trees:\n    print(t.find_nearest((0, 0, 0)))\n</code></pre> <p>Caution: When <code>count</code> is provided, the mesh must be structured consistently: faces are taken from the first sub-mesh and reused for all.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.capture","title":"capture","text":"<pre><code>capture(other)\n</code></pre> <p>Capture the data of another Mesh.</p> Arguments <pre><code>- other (Mesh) : the mesh to capture\n</code></pre> <p>Returns:</p> Type Description <code>    - self</code>"},{"location":"api/mesh/#npblender.mesh.Mesh.chain_link","title":"chain_link  <code>classmethod</code>","text":"<pre><code>chain_link(major_segments=48, minor_segments=12, radius=1.0, section=0.5, length=4.0, materials=None)\n</code></pre> <p>Create a single chain link (oval torus with straightened sides).</p> <p>The link is built from a torus of major radius <code>radius</code> and tube radius <code>section / 2</code>. If <code>length &gt; 2 * radius</code>, the torus is split in half, translated to open a gap of size <code>delta = length - 2 * radius</code>, mirrored, then the opposite borders are bridged to form the elongated link. UVs are adjusted to keep a clean seam layout.</p> <p>Parameters:</p> Name Type Description Default <code>major_segments</code> <code>int</code> <p>Number of segments around the major loop. Default is 48.</p> <code>48</code> <code>minor_segments</code> <code>int</code> <p>Number of segments around the tube section. Default is 12.</p> <code>12</code> <code>radius</code> <code>float</code> <p>Major radius of the link (half the distance between opposite sides on the long axis before elongation). Default is 1.0.</p> <code>1.0</code> <code>section</code> <code>float</code> <p>Diameter of the link cross-section (tube thickness). Default is 0.5.</p> <code>0.5</code> <code>length</code> <code>float</code> <p>Target overall length of the link along its long axis. If close to <code>2 * radius</code>, the result is essentially a pure torus. Default is 4.0.</p> <code>4.0</code> <code>materials</code> <code>list of str</code> <p>Material names to assign to the link. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the chain link.</p> Notes <ul> <li>Construction steps: 1) Create a torus with <code>torus</code>. 2) Delete approximately half the vertices on the negative Y side with     <code>delete_vertices</code>. 3) Duplicate and mirror the remaining half to the other side. 4) Bridge the facing border loops with     <code>bridge_loops</code> (twice, crossing). 5) Recompute and assign UVs using <code>grid_uv_map</code>     to distribute the texture coordinates and minimize stretching.</li> <li>When <code>length - 2 * radius</code> is smaller than ~<code>radius / 10</code>, the method returns the original torus since elongation would be negligible.</li> </ul> <p>Examples:</p> <p>Create a standard chain link:</p> <pre><code>link = Mesh.chain_link(major_segments=64, minor_segments=16,\n                    radius=0.5, section=0.12, length=1.6)\n</code></pre> <p>Create a thicker, longer link:</p> <pre><code>link = Mesh.chain_link(radius=1.0, section=0.25, length=3.0)\n</code></pre> See Also <p><code>torus</code> :     Base primitive used to start the link. <code>delete_vertices</code> :     Used to remove half of the torus before mirroring. <code>bridge_loops</code> :     Used to reconnect mirrored borders. <code>grid_uv_map</code> :     Generates UVs for the final link surface. <code>from_mesh</code> :     Utility for duplicating mesh halves before joining.</p> <p>Caution: Very small <code>section</code> relative to <code>major_segments</code> can create skinny triangles near the bridged areas. Increase segment counts or <code>section</code> for cleaner topology.</p> <p>Note: If <code>length &lt;= 2 * radius</code>, no elongation is performed and the result is (nearly) identical to a torus of the given parameters.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.check","title":"check","text":"<pre><code>check(title='Mesh Check', halt=True)\n</code></pre> <p>Check if mesh domains (corners, faces, edges) are consistent.</p> <p>This method verifies the consistency of the mesh domains by checking the validity of corners, faces, and edges relative to the number of points. In development mode, it raises an exception to prevent Blender from crashing if inconsistencies are found.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title prefix for error messages (default is \"Mesh Check\").</p> <code>'Mesh Check'</code> <code>halt</code> <code>bool</code> <p>If True, raise an exception on failure; otherwise, print a warning (default is True).</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if all checks pass; otherwise, raises an exception or prints an error.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the check fails and halt is True.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.circle","title":"circle  <code>classmethod</code>","text":"<pre><code>circle(radius=1, segments=16, fill_segments=0, cap='NONE', materials=None)\n</code></pre> <p>Create a circle mesh.</p> <p>The circle can be created as: - An open ring (<code>cap='NONE'</code>). - A filled n-gon (<code>cap='NGON'</code>). - A triangle fan (<code>cap='FANS'</code>).</p> <p>The argument <code>fill_segments</code> controls how the interior of the circle is filled: - If <code>fill_segments == 0</code> and <code>cap='NGON'</code>, the circle is filled with a single polygon. - If <code>fill_segments &gt; 0</code>, the circle is filled with concentric rings and triangle fans (not yet implemented in this method, but the behavior corresponds to <code>cap='FANS'</code>).</p> <p>Note: The <code>disk</code> method provides the same functionality with <code>cap='NGON'</code> as its default mode.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the circle. Default is 1.</p> <code>1</code> <code>segments</code> <code>int</code> <p>Number of segments (vertices) around the circle. Default is 16.</p> <code>16</code> <code>fill_segments</code> <code>int</code> <p>Number of internal subdivisions (concentric circles). If 0, the circle is filled with a single polygon when <code>cap='NGON'</code>. Default is 0.</p> <code>0</code> <code>cap</code> <code>(NONE, NGON, FANS)</code> <p>How to fill the interior of the circle. Default is 'NONE'.</p> <code>'NONE'</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the circle. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the circle.</p> Notes <ul> <li><code>cap='NONE'</code>: returns only the ring of edges.</li> <li><code>cap='NGON'</code>: fills the circle with a polygon face.</li> <li><code>cap='FANS'</code>: fills the circle with a fan of triangles around a central point.</li> <li>UV coordinates are generated with <code>disk_uv_map</code>.</li> <li>Fan topology is generated with <code>fans_corners</code>.</li> </ul> <p>Examples:</p> <p>Create an open circle with 32 segments:</p> <pre><code>circle = Mesh.circle(radius=1, segments=32, cap='NONE')\n</code></pre> <p>Create a filled disk using an n-gon:</p> <pre><code>circle = Mesh.circle(radius=2, segments=24, cap='NGON')\n</code></pre> <p>Create a filled disk with triangle fans:</p> <pre><code>circle = Mesh.circle(radius=1, segments=16, cap='FANS')\n</code></pre> See Also <p><code>disk</code> :     Equivalent method for creating disks (default <code>cap='NGON'</code>). <code>disk_uv_map</code> :     Generates UV coordinates for circular caps. <code>fans_corners</code> :     Generates corner topology for triangle fans.</p> <p>Caution: When using <code>cap='FANS'</code>, a new center vertex is added.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.clear_geometry","title":"clear_geometry","text":"<pre><code>clear_geometry()\n</code></pre> <p>Clear the geometry by deleting all geometric content.</p> <p>This method clears the points, corners, faces, and edges collections, effectively removing all geometric data from the mesh.</p> <p>Note:     The materials list associated with the mesh remains unchanged.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.cone","title":"cone  <code>classmethod</code>","text":"<pre><code>cone(vertices=32, side_segments=1, fill_segments=1, radius_top=0, radius_bottom=1, depth=2, fill_type='NGON', materials=None)\n</code></pre> <p>Create a cone (or cylinder) mesh.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>int</code> <p>Number of vertices around the circumference. Default is 32.</p> <code>32</code> <code>side_segments</code> <code>int</code> <p>Number of subdivisions along the vertical side edges. Default is 1 (no subdivision).</p> <code>1</code> <code>fill_segments</code> <code>int</code> <p>Number of concentric circles added to the caps. Currently unused. Default is 1.</p> <code>1</code> <code>radius_top</code> <code>float</code> <p>Radius of the top face. Default is 0 (cone).</p> <code>0</code> <code>radius_bottom</code> <code>float</code> <p>Radius of the bottom face. Default is 1.</p> <code>1</code> <code>depth</code> <code>float</code> <p>Height of the cone along the Z axis. Default is 2.</p> <code>2</code> <code>fill_type</code> <code>(NGON, FANS, NONE)</code> <p>Type of filling for the top and bottom caps: - <code>'NGON'</code>: fill with n-gons. - <code>'FANS'</code>: fill with triangle fans. - <code>'NONE'</code>: no cap filling. Default is <code>'NGON'</code>.</p> <code>'NGON'</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the cone.</p> Notes <ul> <li>If both <code>radius_top</code> and <code>radius_bottom</code> are zero, the result is an empty mesh.</li> <li>Internally calls <code>bl_cone</code> with <code>cap_ends</code> and <code>cap_tris</code> derived from <code>fill_type</code>.</li> <li>UVs are generated automatically by Blender's cone operator.</li> </ul> <p>Examples:</p> <p>Create a simple cone of height 2 and base radius 1:</p> <pre><code>cone = Mesh.cone(vertices=32, radius_top=0, radius_bottom=1, depth=2)\n</code></pre> <p>Create a cylinder with 16 vertices and subdivided sides:</p> <pre><code>cylinder = Mesh.cone(vertices=16, radius_top=1, radius_bottom=1,\n                    depth=3, side_segments=3)\n</code></pre> <p>Create a cone with triangle fan caps:</p> <pre><code>cone = Mesh.cone(vertices=24, radius_top=0, radius_bottom=2,\n                depth=4, fill_type='FANS')\n</code></pre> See Also <p><code>bl_cone</code> :     Low-level constructor for cones and cylinders. <code>bl_circle</code> :     For creating circle primitives with optional triangle fan filling.</p> <p>Note: Use <code>fill_type='NONE'</code> to create an open-ended cone or cylinder.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.cube","title":"cube  <code>classmethod</code>","text":"<pre><code>cube(size=2, materials=None)\n</code></pre> <p>Create a cube mesh.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>float or array-like of shape (3,)</code> <p>Size of the cube. If a single float is given, the cube is uniform in all dimensions. If an array of three floats is given, it specifies the size along the X, Y, and Z axes. Default is 2.</p> <code>2</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the cube. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the cube.</p> Notes <ul> <li>The cube is created centered at the origin with side length <code>size</code>.</li> <li>UV coordinates are assigned so that all six faces are unwrapped into a cross-like layout.</li> </ul> <p>Examples:</p> <p>Create a default cube of size 2:</p> <pre><code>cube = Mesh.cube()\n</code></pre> <p>Create a cube of size 5:</p> <pre><code>cube = Mesh.cube(size=5)\n</code></pre> <p>Create a rectangular box of dimensions (2, 3, 4):</p> <pre><code>box = Mesh.cube(size=(2, 3, 4))\n</code></pre> See Also <p><code>Mesh</code> :     The mesh class used to construct and manage geometry.</p> <p>Note: The cube is centered at the origin and scaled by <code>size/2</code> after construction.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.cylinder","title":"cylinder  <code>classmethod</code>","text":"<pre><code>cylinder(vertices=32, side_segments=1, radius=1, depth=2, fill_type='NGON', materials=None)\n</code></pre> <p>Create a cylinder mesh.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>int</code> <p>Number of vertices around the circumference. Default is 32.</p> <code>32</code> <code>side_segments</code> <code>int</code> <p>Number of subdivisions along the vertical side edges. Default is 1 (no subdivision).</p> <code>1</code> <code>radius</code> <code>float</code> <p>Radius of both the top and bottom faces. Default is 1.</p> <code>1</code> <code>depth</code> <code>float</code> <p>Height of the cylinder along the Z axis. Default is 2.</p> <code>2</code> <code>fill_type</code> <code>(NGON, FANS, NONE)</code> <p>Type of filling for the top and bottom caps: - <code>'NGON'</code>: fill with n-gons. - <code>'FANS'</code>: fill with triangle fans. - <code>'NONE'</code>: no cap filling. Default is <code>'NGON'</code>.</p> <code>'NGON'</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the cylinder.</p> Notes <ul> <li>Internally calls <code>bl_cone</code> with <code>radius1 = radius2 = radius</code>.</li> <li>UVs are generated automatically by Blender's cone operator.</li> </ul> <p>Examples:</p> <p>Create a default cylinder of radius 1 and height 2:</p> <pre><code>cyl = Mesh.cylinder()\n</code></pre> <p>Create a cylinder with 64 vertices and 4 vertical subdivisions:</p> <pre><code>cyl = Mesh.cylinder(vertices=64, side_segments=4, radius=2, depth=5)\n</code></pre> <p>Create an open cylinder without caps:</p> <pre><code>cyl = Mesh.cylinder(radius=1, depth=3, fill_type='NONE')\n</code></pre> See Also <p><code>bl_cone</code> :     Low-level constructor for cones and cylinders. <code>cone</code> :     Generalized method for cones and cylinders.</p> <p>Note: This method is a convenience wrapper for <code>bl_cone</code> with equal top and bottom radii.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.delete_faces","title":"delete_faces","text":"<pre><code>delete_faces(selection)\n</code></pre> <p>Delete only the selected faces from the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool</code> <p>Indices or boolean mask specifying which faces to delete.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Modifies the mesh in place. Returns <code>None</code>.</p> See Also <p><code>delete_loops</code> :     Method used internally to remove the corners and faces. <code>corners</code> :     Corner array of the mesh, used to identify face connectivity.</p> <p>Warning: This function permanently deletes faces and their associated corners. Handle undo/history in Blender if needed.</p> <p>Note: Only faces are removed. Edges and vertices remain in the mesh unless explicitly deleted by other operations.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.delete_vertices","title":"delete_vertices","text":"<pre><code>delete_vertices(points=None, faces=None, edges=None)\n</code></pre> <p>Delete vertices from the mesh, with optional selection by points, faces, or edges.</p> <p>A vertex is deleted if it is explicitly listed in <code>points</code>, or if it belongs to any of the given <code>faces</code> or <code>edges</code>.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like of int or bool</code> <p>Vertex indices (or boolean mask) specifying which vertices to delete directly.</p> <code>None</code> <code>faces</code> <code>array-like of int or bool</code> <p>Face indices (or boolean mask). Any vertex belonging to these faces will be deleted.</p> <code>None</code> <code>edges</code> <code>array-like of int or bool</code> <p>Edge indices (or boolean mask). Any vertex belonging to these edges will be deleted.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>Modifies the mesh in place. Returns <code>None</code>.</p> Notes <ul> <li>At least one of <code>points</code>, <code>faces</code>, or <code>edges</code> must be provided, otherwise the function does nothing.</li> <li>The deletion is executed using <code>bmesh.ops.delete</code> with <code>context='VERTS'</code>.</li> </ul> <p>Examples:</p> <p>Delete specific vertices:</p> <pre><code>obj.delete_vertices(points=[0, 1, 2])\n</code></pre> <p>Delete all vertices belonging to certain faces:</p> <pre><code>obj.delete_vertices(faces=[10, 11])\n</code></pre> <p>Delete all vertices belonging to certain edges:</p> <pre><code>obj.delete_vertices(edges=[5, 6, 7])\n</code></pre> See Also <p><code>bmesh.ops.delete</code> :     Blender BMesh operator used for deleting geometry.</p> <p>Warning: This function permanently removes vertices and any connected geometry (edges, faces). Handle undo/history in Blender if needed.</p> <p>Note: If multiple selectors (<code>points</code>, <code>faces</code>, <code>edges</code>) are provided, the union of all matched vertices will be deleted.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.disk","title":"disk  <code>classmethod</code>","text":"<pre><code>disk(radius=1, segments=16, fill_segments=0, cap='NGON', materials=None)\n</code></pre> <p>Create a disk mesh.</p> <p>This is equivalent to <code>circle</code>, but with <code>cap='NGON'</code> as the default filling mode.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the disk. Default is 1.</p> <code>1</code> <code>segments</code> <code>int</code> <p>Number of segments (vertices) around the disk. Default is 16.</p> <code>16</code> <code>fill_segments</code> <code>int</code> <p>Number of internal subdivisions (concentric circles). Default is 0 (single n-gon when <code>cap='NGON'</code>).</p> <code>0</code> <code>cap</code> <code>(NONE, NGON, FANS)</code> <p>How to fill the interior of the disk. Default is 'NGON'.</p> <code>'NONE'</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the disk. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the disk.</p> <p>Examples:</p> <p>Create a default disk of radius 2 with 32 segments:</p> <pre><code>disk = Mesh.disk(radius=2, segments=32)\n</code></pre> <p>Create a disk filled with triangle fans:</p> <pre><code>disk = Mesh.disk(radius=1, segments=16, cap='FANS')\n</code></pre> See Also <p><code>circle</code> :     General method for circle/disk creation with customizable cap. <code>disk_uv_map</code> :     Generates UV coordinates for circular caps. <code>fans_corners</code> :     Generates corner topology for triangle fans.</p> <p>Note: This method is a shorthand for <code>circle(..., cap='NGON')</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.dual","title":"dual","text":"<pre><code>dual(center='median')\n</code></pre> <p>Construct the dual mesh: one vertex per original face, and one face per original vertex (linking adjacent face-centers around that vertex).</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>(median, bounds, weighted)</code> <p>Method to compute the position of each dual vertex (i.e., the center of the corresponding original face): - <code>'median'</code>: face median center (<code>BMFace.calc_center_median</code>). - <code>'bounds'</code>: face bounds center (<code>BMFace.calc_center_bounds</code>). - <code>'weighted'</code>: area-weighted center (<code>BMFace.calc_center_median_weighted</code>). Default is <code>'median'</code>.</p> <code>'median'</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>The dual mesh, where: - points = centers of original faces, - faces  = polygons formed by chaining the adjacent original faces around each original vertex.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>center</code> is not one of <code>{'median', 'bounds', 'weighted'}</code>.</p> Notes <ul> <li>For each original face <code>f</code>, a dual vertex is computed using the chosen center method and stored at index <code>f.index</code>.</li> <li>For each original vertex <code>v</code>, its incident faces are ordered by walking across <code>v</code>\u2019s incident edges (each with exactly two linked faces) to form a cyclic sequence of face indices; this ordered loop becomes a polygon in the dual.</li> <li>Non-manifold or boundary configurations (edges with a number of linked faces different from 2) are skipped for that vertex; no dual face is created in such cases.</li> </ul> <p>Examples:</p> <p>Build the dual using area-weighted face centers:</p> <pre><code>d = mesh.dual(center='weighted')\n</code></pre> <p>Build the dual with bounds centers:</p> <pre><code>d = mesh.dual(center='bounds')\n</code></pre> See Also <p><code>triangulate</code> :     Triangulation can improve robustness before dualization. <code>remove_doubles</code> :     Helpful for cleaning geometry prior to constructing the dual.</p> <p>Caution: On meshes with boundaries or non-manifold edges, some vertices may not yield a valid cyclic ordering of adjacent faces; those dual faces are omitted.</p> <p>Note: Dualization does not, in general, invert perfectly (i.e., the dual of the dual is not guaranteed to reproduce the original mesh), especially in the presence of boundaries or irregular valences.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_faces","title":"extrude_faces","text":"<pre><code>extrude_faces(selection, offset=None, scale=1.0)\n</code></pre> <p>Extrude individual faces by duplicating them, optionally displacing them by <code>offset</code>, and connecting side faces.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Indices (or mask) of faces to extrude. If <code>None</code>, all faces are extruded.</p> required <code>offset</code> <code>(array - like, shape(3) or (N, 3))</code> <p>Extrusion vector(s). A single vector is broadcast to all faces. If <code>None</code>, each face is extruded along its own normal.</p> <code>None</code> <code>scale</code> <code>float</code> <p>Scale factor applied to <code>offset</code> (or to the face normal if <code>offset=None</code>). Default is 1.0.</p> <code>1.0</code> <code>dissolve</code> <code>bool</code> <p>Not implemented in this version. Placeholder for removing the starting faces after extrusion.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with two keys: - <code>'top'</code>: indices of the extruded (displaced) faces. - <code>'side'</code>: indices of the side faces connecting the original and new faces.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>offset</code> cannot be broadcast to shape <code>(len(faces), 3)</code>.</p> <code>AssertionError</code> <p>If a side edge of an extruded face does not have exactly two linked faces.</p> Notes <ul> <li>Uses <code>bmesh.ops.extrude_discrete_faces</code> to duplicate each selected face independently.</li> <li>If <code>offset</code> is <code>None</code>, displacement is along each face's local normal.</li> <li>Side faces are identified by checking edges linked to the extruded faces.</li> </ul> <p>Examples:</p> <p>Extrude all faces along their normals:</p> <pre><code>res = Mesh.extrude_faces(selection=None, scale=0.2)\n</code></pre> <p>Extrude a subset of faces by a fixed offset:</p> <pre><code>res = Mesh.extrude_faces(selection=[0, 2, 5], offset=(0, 0, 1))\n</code></pre> <p>Extrude faces with per-face offsets:</p> <pre><code>offs = np.random.randn(len(sel), 3) * 0.1\nres = Mesh.extrude_faces(selection=sel, offset=offs)\n</code></pre> See Also <p><code>extrude_vertices</code> :     Extrude isolated vertices. <code>extrude_loop</code> :     Extrude a vertex loop into a quad strip.</p> <p>Caution: If <code>offset</code> is given per-face, its length must match the number of extruded faces or broadcasting will fail.</p> <p>Note: Side face indices may be repeated if multiple extrusions share edges.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_loop","title":"extrude_loop","text":"<pre><code>extrude_loop(loop, offset, close=False, clockwise=False, **attributes)\n</code></pre> <p>Extrude a loop of vertices by duplicating the loop, offsetting it, and creating a quad strip between the original and the offset loop.</p> <p>Parameters:</p> Name Type Description Default <code>loop</code> <code>array-like of int</code> <p>Vertex indices defining the loop to extrude. Must contain at least 2 vertices.</p> required <code>offset</code> <code>(array - like, shape(3) or (N, 3))</code> <p>Extrusion vector(s). A single 3D vector is broadcast to all vertices in <code>loop</code>, or provide one vector per vertex (N == len(loop)).</p> required <code>close</code> <code>bool</code> <p>If True, treats the input as a closed loop and connects the last vertex back to the first when building side quads. Default is False.</p> <code>False</code> <code>clockwise</code> <code>bool</code> <p>Controls the orientation (winding) of the generated faces and the UV layout. Default is False.</p> <code>False</code> <code>**attributes</code> <code>dict</code> <p>Extra attributes intended for the new geometry (see Caution).</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary describing the created geometry as returned by <code>add_geometry</code>. Contains at least: - <code>'points'</code>: indices of the duplicated (offset) vertices. - <code>'corners'</code>: indices of the generated quad strip corners. - <code>'faces'</code>: face arity (4 for quads).</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>offset</code> is neither a single <code>(3,)</code> vector nor an array of shape <code>(len(loop), 3)</code>.</p> Notes <ul> <li>New vertices are computed as <code>points[loop] + offset</code> (with broadcasting if <code>offset</code> is a single vector).</li> <li>Side faces are constructed using the topology from <code>grid_corners</code> with two rows (original and offset loop).</li> <li>UVs for the side strip are generated by <code>grid_uv_map</code> with matching parameters.</li> </ul> <p>Examples:</p> <p>Extrude an open loop along a single vector:</p> <pre><code>new = Mesh.extrude_loop(loop, offset=(0, 0, 1), close=False)\n</code></pre> <p>Extrude a closed loop with per-vertex offsets and flipped winding:</p> <pre><code>offs = np.random.randn(len(loop), 3) * 0.02\nnew = Mesh.extrude_loop(loop, offset=offs, close=True, clockwise=True)\n</code></pre> See Also <p><code>extrude_vertices</code> :     Extrude isolated vertices with edges to their duplicates. <code>add_geometry</code> :     Adds the new points/corners/faces and returns their indices. <code>grid_corners</code> :     Builds the quad topology of the side strip. <code>grid_uv_map</code> :     Generates UVs for the side strip.</p> <p>Caution: <code>offset</code> must be either a single <code>(3,)</code> vector or an array of shape <code>(len(loop), 3)</code>. Any other shape will raise an error.</p> <p>Caution: The <code>attributes</code> kwargs are currently not forwarded to <code>add_geometry</code> in this implementation. If you need them applied, pass them through explicitly in the call to <code>add_geometry</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_region","title":"extrude_region","text":"<pre><code>extrude_region(selection, offset=(0, 0, 1), dissolve=False)\n</code></pre> <p>Extrude a connected face region, translate the new geometry by <code>offset</code>, and optionally dissolve the original faces.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Indices (or mask) of faces to extrude. If <code>None</code>, all faces are used.</p> required <code>offset</code> <code>array-like of float, shape (3,)</code> <p>Translation vector applied to the newly created vertices of the region. Default is (0, 0, 1).</p> <code>(0, 0, 1)</code> <code>dissolve</code> <code>bool</code> <p>If True, delete the original (pre-extrusion) faces after the region has been extruded. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with two keys: - <code>'top'</code>: indices of the newly extruded faces (translated region). - <code>'side'</code>: indices of the side faces that connect original and new faces.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If a side edge of an extruded face does not have exactly two linked faces (non-manifold condition).</p> Notes <ul> <li>Region extrusion is performed via <code>bmesh.ops.extrude_face_region</code>, then the new vertices are moved using <code>bmesh.ops.translate</code>.</li> <li>Side faces are discovered by scanning the edges of the extruded faces and collecting the adjacent face opposite to each extruded face.</li> </ul> <p>Examples:</p> <p>Extrude a region upward and keep the original faces:</p> <pre><code>res = Mesh.extrude_region(selection=[0, 1, 2], offset=(0, 0, 0.2), dissolve=False)\n</code></pre> <p>Extrude a region and dissolve the starting faces:</p> <pre><code>res = Mesh.extrude_region(selection=mask, offset=(0.1, 0, 0), dissolve=True)\n</code></pre> See Also <p><code>extrude_faces</code> :     Extrude faces individually (discrete), not as a connected region. <code>extrude_loop</code> :     Create a quad strip by offsetting a vertex loop. <code>extrude_vertices</code> :     Duplicate and connect selected vertices.</p> <p>Caution: <code>offset</code> must be a 3D vector. Non-3D inputs may cause the translation operator to fail.</p> <p>Note: With <code>dissolve=True</code>, the original faces are removed, leaving only the extruded shell.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.extrude_vertices","title":"extrude_vertices","text":"<pre><code>extrude_vertices(selection, offset, **attributes)\n</code></pre> <p>Extrude individual vertices by creating new points displaced by <code>offset</code> and connecting each original vertex to its duplicate with an edge.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Vertex indices or boolean mask selecting the vertices to extrude. If <code>None</code>, all vertices are extruded.</p> required <code>offset</code> <code>(array - like, shape(3) or (N, 3))</code> <p>Extrusion vector(s). Can be a single 3D vector applied to every selected vertex, or an array of vectors with one per selected vertex.</p> required <code>**attributes</code> <code>dict</code> <p>Optional attributes to attach to the created geometry (forwarded to <code>add_geometry</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary describing the created geometry as returned by <code>add_geometry</code>. Contains at least: - <code>'points'</code>: indices of newly added vertices. - <code>'edges'</code>: indices of newly added edges.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>offset</code> is neither a single <code>(3,)</code> vector nor an array of shape <code>(len(loop), 3)</code>.</p> Notes <ul> <li>New vertices are positioned at <code>points[selection] + offset</code>.</li> <li>One edge is created between each original vertex and its newly created counterpart using <code>edges_between</code>.</li> </ul> <p>Examples:</p> <p>Extrude all vertices by (0, 0, 1):</p> <pre><code>added = Mesh.extrude_vertices(selection=None, offset=(0, 0, 1))\n</code></pre> <p>Extrude a subset with per-vertex offsets:</p> <pre><code>sel = np.array([0, 2, 5, 7])\noffs = np.random.randn(len(sel), 3) * 0.1\nadded = Mesh.extrude_vertices(selection=sel, offset=offs)\n</code></pre> See Also <p><code>add_geometry</code> :     Adds new points/edges/faces and returns their indices. <code>edges_between</code> :     Builds edge pairs between two index arrays of equal length.</p> <p>Caution: When <code>offset</code> is an array, its length must match the number of selected vertices.</p> <p>Note: This operation creates only points and edges. Faces are not generated automatically.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.faces_neighbors","title":"faces_neighbors","text":"<pre><code>faces_neighbors()\n</code></pre> <p>Compute the neighboring faces for each face, defined as faces sharing at least one edge.</p> <p>Returns:</p> Type Description <code>list of list of int</code> <p>For each face (by index), a list of indices of adjacent faces.</p> Notes <ul> <li>Each face\u2019s neighbors are determined by scanning its incident edges and collecting the two faces linked to each edge.</li> <li>The current face index is excluded from its own neighbor list.</li> <li>Non-manifold edges (with more or fewer than two linked faces) are not expected; if present, results may be incomplete or inconsistent.</li> </ul> <p>Examples:</p> <p>Get adjacency information for all faces:</p> <pre><code>neighbors = mesh.faces_neighbors()\nfor i, ns in enumerate(neighbors):\n    print(f\"Face {i} neighbors: {ns}\")\n</code></pre> <p>Note: The output is a Python list of lists (not a NumPy array).</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.fill_cap","title":"fill_cap","text":"<pre><code>fill_cap(loop, mode='NGON', center=None, segments=1, clockwise=False, **attributes)\n</code></pre> <p>Fill a cap between vertices forming a loop.</p> <p>Supports two modes: - NGON: creates a single n-gon face from the loop. No center point is required. - FANS: creates a fan of triangles around a center point. The center can be: * <code>None</code>: automatically computed as the centroid of the loop. * <code>int</code>: the index of an existing vertex to use as center. * <code>array-like</code>: explicit coordinates of the center, which will be added as a new vertex.</p> <p>Parameters:</p> Name Type Description Default <code>loop</code> <code>array-like of int</code> <p>The vertex indices defining the loop.</p> required <code>mode</code> <code>(NGON, FANS)</code> <p>Fill mode to use. Default is 'NGON'.</p> <code>'NGON'</code> <code>center</code> <code>int or array - like or None</code> <p>Center of the cap (used only in 'FANS' mode). - <code>None</code>: computed centroid. - <code>int</code>: index of an existing vertex. - array-like: coordinates of a new vertex.</p> <code>None</code> <code>segments</code> <code>int</code> <p>Number of radial subdivisions for FANS mode. Must be &gt;= 1. Default is 1 (no subdivision).</p> <code>1</code> <code>clockwise</code> <code>bool</code> <p>Whether the loop is ordered clockwise. Default is False.</p> <code>False</code> <code>**attributes</code> <code>dict</code> <p>Additional attributes to add to the mesh (passed to <code>add_geometry</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the newly added geometry, as returned by <code>add_geometry</code>. Includes at least keys for 'faces' and 'corners'. In FANS mode, also includes the added 'points' if a new center is created.</p> Notes <ul> <li>In 'NGON' mode, a UV map is generated using <code>disk_uv_map</code>.</li> <li>In 'FANS' mode, the fan topology is created with <code>fans_corners</code> and UVs are generated with <code>disk_uv_map</code>.</li> <li>If <code>segments &gt; 1</code> in FANS mode, radial edges are subdivided using <code>split_edges</code>.</li> </ul> <p>Examples:</p> <p>Fill a loop with an n-gon:</p> <pre><code>obj.fill_cap(loop, mode='NGON')\n</code></pre> <p>Fill a loop with a triangle fan around an automatically computed center:</p> <pre><code>obj.fill_cap(loop, mode='FANS')\n</code></pre> <p>Fill a loop with a fan using an existing vertex as the center and add 3 subdivisions:</p> <pre><code>obj.fill_cap(loop, mode='FANS', center=42, segments=3)\n</code></pre> See Also <p><code>add_geometry</code> :     Method used to add the created geometry to the mesh. <code>split_edges</code> :     Used to subdivide radial edges in FANS mode. <code>disk_uv_map</code> :     Generates UV coordinates for circular caps. <code>fans_corners</code> :     Generates corner topology for FANS mode.</p> <p>Warning: This function modifies the mesh in place and may create new vertices, faces, and edges.</p> <p>Caution: In FANS mode, if <code>center=None</code>, a new vertex is added at the centroid of the loop.</p> <p>Note: The <code>segments</code> parameter only applies to FANS mode; NGON mode always produces a single polygon face.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d)\n</code></pre> <p>Create a Mesh instance from a dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>Dictionary containing mesh data with keys 'materials', 'points', 'corners', 'faces', and 'edges'.</p> required <p>Returns:</p> Type Description <code>Mesh</code> <p>A new Mesh instance initialized with the data from the dictionary.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_mesh","title":"from_mesh  <code>classmethod</code>","text":"<pre><code>from_mesh(other, points=None, faces=None, edges=None)\n</code></pre> <p>Create a copy of a Mesh object, optionally excluding specified points, faces, or edges.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Mesh</code> <p>The source Mesh object to copy.</p> required <code>points</code> <code>array-like of int</code> <p>Indices of points to exclude from the copy.</p> <code>None</code> <code>faces</code> <code>array-like of int</code> <p>Indices of faces to exclude from the copy.</p> <code>None</code> <code>edges</code> <code>array-like of int</code> <p>Indices of edges to exclude from the copy.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new Mesh instance copied from the source, with specified elements excluded.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_mesh_data","title":"from_mesh_data  <code>classmethod</code>","text":"<pre><code>from_mesh_data(data)\n</code></pre> <p>Initialize the geometry from a Blender Mesh data.</p> <p>This method creates and returns an instance of the mesh class initialized with vertices, edges, faces, corners, materials, and attributes extracted from the provided Blender mesh data.</p> <p>Args:     data: Blender mesh data or object that can be processed           by the blender.get_mesh function to obtain a Blender Mesh instance.</p> <p>Returns:     An instance of the mesh class initialized with the geometry     and attributes from the Blender Mesh.</p> <p>Raises:     ImportError: If the local blender module cannot be imported.     Any exceptions raised by blender.get_mesh if the data is invalid.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_model","title":"from_model  <code>classmethod</code>","text":"<pre><code>from_model(model, materials=None)\n</code></pre> <p>Create a Mesh instance from various types of input models.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str, bpy.types.Object, dict, Mesh, or bpy.types.Mesh</code> <p>The input model to create the Mesh from. It can be: - A string or Blender object to be evaluated and converted. - A dictionary representing the mesh data. - An existing Mesh instance. - A Blender Mesh data block.</p> required <code>materials</code> <code>list or None</code> <p>Materials to associate with the mesh (currently unused in this method).</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>The created Mesh instance based on the input model.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the type of the model is not supported.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.from_object","title":"from_object  <code>classmethod</code>","text":"<pre><code>from_object(obj, evaluated=False)\n</code></pre> <p>Create a Mesh instance from an existing Blender object.</p> <p>This method initializes a mesh from a Blender object, optionally using the evaluated version of the object (i.e., after applying modifiers).</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str or Object</code> <p>The Blender object or its name from which to create the mesh.</p> required <code>evaluated</code> <code>bool</code> <p>If True, use the evaluated object with modifiers applied. If False, use the raw mesh data. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new Mesh instance created from the specified Blender object.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the local blender module cannot be imported.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_islands","title":"get_islands","text":"<pre><code>get_islands()\n</code></pre> <p>Compute connected components of faces (islands) and assign an island ID to each face.</p> <p>Returns:</p> Type Description <code>ndarray of int, shape (n_faces,)</code> <p>Array of island IDs, one per face. Faces in the same connected component share the same integer ID. Empty mesh returns an empty list.</p> Notes <ul> <li>Islands are defined as groups of faces connected through shared edges.</li> <li>A breadth-first search (BFS) is used to traverse each connected component.</li> <li>IDs are assigned sequentially starting from 0.</li> </ul> <p>Examples:</p> <p>Get island IDs for all faces:</p> <pre><code>ids = mesh.get_islands()\nprint(\"Unique islands:\", np.unique(ids))\n</code></pre> <p>Map faces by island:</p> <pre><code>ids = mesh.get_islands()\nfor island_id in np.unique(ids):\n    faces = np.where(ids == island_id)[0]\n    print(f\"Island {island_id}: faces {faces}\")\n</code></pre> <p>Note: Non-manifold meshes are still handled, but faces that share only a vertex (not an edge) are considered separate islands.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.get_material_index","title":"get_material_index","text":"<pre><code>get_material_index(mat_name)\n</code></pre> <p>Return the index of a material name.</p> <p>If the material doesn't exist, it is created</p> Arguments <pre><code>- mat_name (str) : material name\n</code></pre> <p>Returns:</p> Type Description <code>    - int : index of the material name in the materials list</code>"},{"location":"api/mesh/#npblender.mesh.Mesh.grid","title":"grid  <code>classmethod</code>","text":"<pre><code>grid(size_x=1, size_y=1, vertices_x=3, vertices_y=3, materials=None)\n</code></pre> <p>Create a rectangular grid mesh.</p> <p>The grid is constructed in the XY plane with indexing set to <code>'ij'</code>, meaning the generated arrays have shape <code>(vertices_x, vertices_y)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>size_x</code> <code>float</code> <p>Size of the grid along the X axis. Default is 1.</p> <code>1</code> <code>size_y</code> <code>float</code> <p>Size of the grid along the Y axis. Default is 1.</p> <code>1</code> <code>vertices_x</code> <code>int</code> <p>Number of vertices along the X axis. Must be &gt;= 2. Default is 3.</p> <code>3</code> <code>vertices_y</code> <code>int</code> <p>Number of vertices along the Y axis. Must be &gt;= 2. Default is 3.</p> <code>3</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the grid. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the rectangular grid.</p> Notes <ul> <li>The grid is created with <code>'ij'</code> indexing, so coordinates follow NumPy's <code>meshgrid(..., indexing='ij')</code> convention.</li> <li>UV coordinates are generated using <code>grid_uv_map</code>.</li> <li>The grid topology is built using <code>grid_corners</code>.</li> </ul> <p>Examples:</p> <p>Create a 2x2 grid with 10 vertices along X and 5 along Y:</p> <pre><code>grid = Mesh.grid(size_x=2, size_y=2, vertices_x=10, vertices_y=5)\n</code></pre> <p>Create a square grid of size 5 with default vertex count:</p> <pre><code>grid = Mesh.grid(size_x=5, size_y=5)\n</code></pre> See Also <p><code>grid_corners</code> :     Helper for constructing the corner topology of the grid. <code>grid_uv_map</code> :     Generates UV coordinates for a regular grid.</p> <p>Important: The grid is always created with <code>'ij'</code> indexing (shape = <code>(vertices_x, vertices_y)</code>).</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.icosphere","title":"icosphere  <code>classmethod</code>","text":"<pre><code>icosphere(radius=1, subdivisions=2, materials=None)\n</code></pre> <p>Create an icosphere mesh.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the icosphere. Default is 1.</p> <code>1</code> <code>subdivisions</code> <code>int</code> <p>Number of recursive subdivisions applied to the base icosahedron. Higher values yield smoother spheres. Clamped to a maximum of 10. Default is 2.</p> <code>2</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the icosphere. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the icosphere.</p> Notes <ul> <li>The icosphere is created using <code>bmesh.ops.create_icosphere</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> <li>Unlike a UV sphere, an icosphere has more uniform vertex distribution, making it suitable for certain simulation and subdivision tasks.</li> <li>Subdivisions are internally capped at 10 for performance reasons.</li> </ul> <p>Examples:</p> <p>Create a default icosphere of radius 1 with 2 subdivisions:</p> <pre><code>ico = Mesh.icosphere()\n</code></pre> <p>Create a larger icosphere with 4 subdivisions:</p> <pre><code>ico = Mesh.icosphere(radius=3, subdivisions=4)\n</code></pre> See Also <p><code>uvsphere</code> :     Sphere primitive based on UV parameterization. <code>bmesh.ops.create_icosphere</code> :     BMesh operator used for creating icospheres.</p> <p>Note: Use <code>uvsphere</code> when you require consistent UV mapping, and <code>icosphere</code> for uniform tessellation.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.inset_faces","title":"inset_faces","text":"<pre><code>inset_faces(selection, thickness=0.1, depth=0.0, use_even_offset=True, use_relative_offset=False)\n</code></pre> <p>Inset selected faces individually, optionally adding depth (local extrusion).</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Indices (or mask) of faces to inset. If <code>None</code>, all faces are used.</p> required <code>thickness</code> <code>float</code> <p>Inset thickness applied per face. Default is 0.1.</p> <code>0.1</code> <code>depth</code> <code>float</code> <p>Local extrusion depth along each face normal. Default is 0.0.</p> <code>0.0</code> <code>use_even_offset</code> <code>bool</code> <p>Keep thickness consistent across faces (even offset). Default is True.</p> <code>True</code> <code>use_relative_offset</code> <code>bool</code> <p>Scale thickness relative to face size. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with: - <code>'top'</code>: indices of the original (selected) faces. - <code>'side'</code>: indices of the new faces created by the inset operation (typically the rim/side faces around each inset).</p> Notes <ul> <li>Implementation uses <code>bmesh.ops.inset_individual</code>.</li> <li>The <code>'top'</code> entry mirrors the input selection; <code>'side'</code> comes from <code>d[\"faces\"]</code> returned by the BMesh operator.</li> </ul> <p>Examples:</p> <p>Inset a set of faces with even offset:</p> <pre><code>res = Mesh.inset_faces(selection=[0, 2, 5], thickness=0.05, depth=0.0)\n</code></pre> <p>Inset all faces with relative offset and a small depth:</p> <pre><code>res = Mesh.inset_faces(selection=None, thickness=0.02,\n                    depth=0.01, use_relative_offset=True)\n</code></pre> See Also <p><code>extrude_faces</code> :     Extrude faces discretely instead of insetting. <code>extrude_region</code> :     Extrude connected face regions.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.join","title":"join","text":"<pre><code>join(*others)\n</code></pre> <p>Join other Mesh instances into this mesh.</p> <p>This method appends the geometry and materials of the given meshes to the current mesh, updating indices to maintain consistency.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Mesh</code> <p>One or more Mesh instances to be joined with the current mesh.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>self</code> <code>Mesh</code> <p>The updated mesh instance with joined geometry.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other, **kwargs)\n</code></pre> <p>Capture the attributes from another geometry.</p> <p>Other can be a different geometry, in that case, only domains with the same name are captured. kwargs allows to filter the domains to capture:</p> <pre><code>mesh.join_attributes(other_mesh, faces=False)\nmesh.join_attributes(curve)\n</code></pre> <p>Returns:     - self</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.join_geometry","title":"join_geometry","text":"<pre><code>join_geometry(points=None, corners=None, faces=None, edges=None, safe_mode=False, **attrs)\n</code></pre> <p>Join geometry defined by components into the current mesh.</p> <p>This method creates a new independent mesh from the provided geometry components (points, corners, faces, edges) which do not refer to existing vertices. The new mesh is then joined to the current mesh instance.</p> <p>To add geometry using existing vertices, see <code>Mesh.add_geometry</code>.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>iterable</code> <p>Iterable of points (vertices) to add to the mesh.</p> <code>None</code> <code>corners</code> <code>iterable</code> <p>Iterable of corner indices defining the mesh topology.</p> <code>None</code> <code>faces</code> <code>iterable</code> <p>Iterable of faces defined by indices of corners.</p> <code>None</code> <code>edges</code> <code>iterable</code> <p>Iterable of edges defined by indices of vertices.</p> <code>None</code> <code>safe_mode</code> <code>bool</code> <p>Flag to enable safe mode operations (currently unused).</p> <code>False</code> <code>**attrs</code> <code>dict</code> <p>Additional attributes to be passed to the geometry addition.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>self</code> <code>Mesh</code> <p>The current mesh instance with the new geometry joined.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.line","title":"line  <code>classmethod</code>","text":"<pre><code>line(start=(0, 0, 0), end=(0, 0, 1), segments=1, materials=None)\n</code></pre> <p>Create a mesh representing a straight line (or multiple lines) subdivided into segments.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>array-like of float, shape (..., 3)</code> <p>Coordinates of the start point(s). Can be a single 3D vector or an array of multiple vectors. Default is (0, 0, 0).</p> <code>(0, 0, 0)</code> <code>end</code> <code>array-like of float, shape (..., 3)</code> <p>Coordinates of the end point(s). Can be a single 3D vector or an array of multiple vectors with the same shape as <code>start</code>. Default is (0, 0, 1).</p> <code>(0, 0, 1)</code> <code>segments</code> <code>int</code> <p>Number of line segments (subdivisions) between each pair of start and end points. Must be &gt;= 1. Default is 1.</p> <code>1</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the line mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the subdivided line(s).</p> Notes <ul> <li>The function interpolates <code>segments + 1</code> points between <code>start</code> and <code>end</code> using <code>np.linspace</code>.</li> <li>If <code>start</code> and <code>end</code> are arrays of shape <code>(N, 3)</code>, the method generates <code>N</code> independent polylines, each subdivided into <code>segments</code>.</li> <li>For higher-dimensional batched input, the function reshapes the grid and constructs edges using <code>col_edges</code>.</li> </ul> <p>Examples:</p> <p>Create a simple line with 5 segments between (0, 0, 0) and (0, 0, 1):</p> <pre><code>line = Mesh.line(start=(0, 0, 0), end=(0, 0, 1), segments=5)\n</code></pre> <p>Create three parallel lines defined by arrays of start and end points:</p> <pre><code>starts = np.array([[0, 0, 0],\n                [1, 0, 0],\n                [2, 0, 0]])\nends = np.array([[0, 0, 1],\n                [1, 0, 1],\n                [2, 0, 1]])\nlines = Mesh.line(start=starts, end=ends, segments=4)\n</code></pre> See Also <p><code>border_edges</code> :     Helper for constructing consecutive edges in a single polyline. <code>col_edges</code> :     Helper for constructing edges in multi-dimensional point grids.</p> <p>Note: The line mesh consists only of vertices and edges, no faces are created.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.load_models","title":"load_models  <code>staticmethod</code>","text":"<pre><code>load_models(*specs)\n</code></pre> <p>Load a geometry or geometries from specifications.</p> <p>The specs can be:     - a Blender collection     - a Blender object     - a Geometry</p> Arguments <pre><code>- specs (list of objects / collections) : the models to load\n</code></pre> <p>Returns:</p> Type Description <code>    - list of geometries</code>"},{"location":"api/mesh/#npblender.mesh.Mesh.load_object","title":"load_object  <code>staticmethod</code>","text":"<pre><code>load_object(name)\n</code></pre> <p>Load a Blender object and returns either a Mesh or a Curve.</p> Arguments <pre><code>- name (str or bpy.types.Object) : the object to load\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh or Curve</code>"},{"location":"api/mesh/#npblender.mesh.Mesh.monkey","title":"monkey  <code>classmethod</code>","text":"<pre><code>monkey(materials=None)\n</code></pre> <p>Create the famous Blender \"Suzanne\" monkey mesh.</p> <p>Parameters:</p> Name Type Description Default <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the Suzanne primitive.</p> Notes <ul> <li>The monkey head is created using <code>bmesh.ops.create_monkey</code>.</li> <li>Suzanne is often used as a test model and is considered Blender\u2019s mascot.</li> </ul> <p>Examples:</p> <p>Create a Suzanne mesh:</p> <pre><code>monkey = Mesh.monkey()\n</code></pre> See Also <p><code>bmesh.ops.create_monkey</code> :     BMesh operator used to generate the Suzanne primitive.</p> <p>Note: Suzanne is widely used as a benchmark and test object in Blender.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.multiply","title":"multiply","text":"<pre><code>multiply(count, in_place=True)\n</code></pre> <p>Duplicate the geometry.</p> <p>Multiplying is a way to efficiently duplicate the geometry a great number of times. Once duplicated, the vertices can be reshapped to address each instance individually.</p> <pre><code>count = 16\n\ncube = Mesh.Cube() * count\n\n# Shape the points as 16 blocks of 8 vertices\npoints = np.reshape(cube.points.position, (16, 8, 3))\n\n# Place the cubes in a circle\nags = np.linspace(0, 2*np.pi, count, endpoint=False)\npoints[..., 0] += 6 * np.cos(ags)[:, None]\npoints[..., 1] += 6 * np.sin(ags)[:, None]\n\ncube.to_object(\"Cubes\")\n</code></pre> Arguments <pre><code>- count (int=10) : number of instances\n- attributes (name=value) : value for named attributes\n</code></pre> <p>Returns:</p> Type Description <code>    - Mesh</code>"},{"location":"api/mesh/#npblender.mesh.Mesh.points_cloud","title":"points_cloud  <code>classmethod</code>","text":"<pre><code>points_cloud(points=None, materials=None)\n</code></pre> <p>Create a mesh containing only points at the given positions.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>array-like of shape (N, 3)</code> <p>Coordinates of the points. If None, an empty mesh is created.</p> <code>None</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the given points.</p> Notes <ul> <li>This method does not create any edges or faces, only isolated points.</li> </ul> <p>Examples:</p> <p>Create a point cloud with three points:</p> <pre><code>pts = np.array([[0, 0, 0],\n                [1, 0, 0],\n                [0, 1, 0]])\ncloud = Mesh.points_cloud(points=pts)\n</code></pre> See Also <p><code>Mesh</code> :     The mesh class used to construct and manage geometry.</p> <p>Note: This constructor is useful for importing raw point data or initializing a mesh before adding edges and faces.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.pyramid","title":"pyramid  <code>classmethod</code>","text":"<pre><code>pyramid(size=1, materials=None)\n</code></pre> <p>Create a pyramid mesh.</p> <p>The pyramid is generated as a cone with 3 vertices at the base (a triangle) and an apex at the top.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>float</code> <p>Size of the pyramid. Determines both the base dimensions and the height. Default is 1.</p> <code>1</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the mesh. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the pyramid.</p> Notes <ul> <li>The base radius is scaled by <code>size * sqrt(3)/2</code> so that the pyramid has approximately unit proportions when <code>size=1</code>.</li> <li>Internally calls <code>cone</code> with <code>vertices=3</code>.</li> </ul> <p>Examples:</p> <p>Create a default pyramid of size 1:</p> <pre><code>pyramid = Mesh.pyramid()\n</code></pre> <p>Create a larger pyramid of size 5:</p> <pre><code>pyramid = Mesh.pyramid(size=5)\n</code></pre> See Also <p><code>cone</code> :     Generalized method for cones and pyramids. <code>bl_cone</code> :     Low-level constructor for cone-based primitives.</p> <p>Note: This method is equivalent to creating a triangular-based cone.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.remove_doubles","title":"remove_doubles","text":"<pre><code>remove_doubles(dist=0.001)\n</code></pre> <p>Merge duplicate vertices within a distance threshold.</p> <p>Parameters:</p> Name Type Description Default <code>dist</code> <code>float</code> <p>Maximum distance between vertices to be merged. Default is 0.001.</p> <code>0.001</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>The current mesh instance (<code>self</code>) with duplicate vertices removed.</p> Notes <ul> <li>Internally uses <code>bmesh.ops.remove_doubles</code>.</li> <li>All vertices in the mesh are considered for merging.</li> <li>Useful for cleaning geometry after operations that may generate coincident vertices (e.g., mirroring, joining, or extrusion).</li> </ul> <p>Examples:</p> <p>Remove doubles with default threshold:</p> <pre><code>mesh.remove_doubles()\n</code></pre> <p>Remove doubles with a larger threshold:</p> <pre><code>mesh.remove_doubles(dist=0.01)\n</code></pre> <p>Note: This method modifies the mesh in place and returns <code>self</code> for chaining.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.separate_faces","title":"separate_faces","text":"<pre><code>separate_faces(groups=None)\n</code></pre> <p>Split faces into isolated islands, either one per face or grouped by provided IDs.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>array-like of int, shape (n_faces,)</code> <p>Group IDs for each face. If <code>None</code>, each face is isolated as its own island. If provided, must be the same length as the number of faces.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh where faces are separated into independent islands with duplicated vertices.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>groups</code> is provided but its shape does not match <code>(n_faces,)</code>.</p> Notes <ul> <li>When <code>groups</code> is <code>None</code>, the output mesh has one disconnected island per face.</li> <li>When grouping, faces sharing the same group ID are kept together in the same island, with vertices duplicated so that each group is independent.</li> <li>Face attributes are preserved except for <code>'loop_total'</code> and <code>'loop_start'</code>.</li> </ul> <p>Examples:</p> <p>Separate every face:</p> <pre><code>islands = mesh.separate_faces()\n</code></pre> <p>Separate faces into two groups:</p> <pre><code>groups = np.array([0, 0, 1, 1, 1, 0])  # one group ID per face\nsplit = mesh.separate_faces(groups=groups)\n</code></pre> See Also <p><code>join_geometry</code> :     Utility to assemble new meshes from points, corners, faces, and attributes. <code>join</code> :     Used internally to accumulate separated islands.</p> <p>Caution: The number of groups must equal the number of faces in the mesh, otherwise a <code>ValueError</code> is raised.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.simplified","title":"simplified","text":"<pre><code>simplified(scale, dist=0.001)\n</code></pre> <p>Return a simplified copy of the mesh by merging close vertices, with a fallback to a cubic envelope if the result is too small.</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>float</code> <p>Scale factor applied to the distance threshold.</p> required <code>dist</code> <code>float</code> <p>Base merge distance for vertices. The effective threshold is <code>dist / scale</code>. Default is 0.001.</p> <code>0.001</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A simplified copy of the mesh. If the simplification produces fewer than 8 vertices, returns a cubic envelope instead.</p> Notes <ul> <li>The copy is created with <code>Mesh.from_mesh</code>.</li> <li>Duplicate vertices are merged with <code>remove_doubles</code>.</li> <li>If too few vertices remain, a fallback is generated using <code>get_cubic_envelop</code>.</li> </ul> <p>Examples:</p> <p>Simplify a mesh with scale factor 10:</p> <pre><code>simp = mesh.simplified(scale=10, dist=0.002)\n</code></pre> See Also <p><code>remove_doubles</code> :     Merges vertices within a distance threshold. <code>get_cubic_envelop</code> :     Provides a fallback cubic mesh when simplification collapses geometry.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.solidify","title":"solidify","text":"<pre><code>solidify(thickness=0.01, offset=-1)\n</code></pre> <p>Apply a Solidify modifier to give thickness to a surface mesh.</p> <p>Parameters:</p> Name Type Description Default <code>thickness</code> <code>float</code> <p>Thickness of the shell to generate. Positive values expand outward, negative values inward. Default is 0.01.</p> <code>0.01</code> <code>offset</code> <code>float</code> <p>Offset factor determining the solidification direction relative to the original surface: -1 \u2192 inward, 0 \u2192 centered, +1 \u2192 outward. Default is -1.</p> <code>-1</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance resulting from the solidify operation.</p> Notes <ul> <li>Internally creates a Blender Solidify modifier with <code>use_even_offset=True</code> for consistent thickness.</li> <li>The modifier is applied destructively via <code>bpy.ops.object.modifier_apply</code>, and the resulting mesh is retrieved with <code>Mesh.from_object</code>.</li> <li>Works best on manifold surfaces (open meshes may produce artifacts).</li> </ul> <p>Examples:</p> <p>Solidify a circular glass mesh:</p> <pre><code>glass = Mesh.circle(segments=128)\nglass.extrude_faces(0, -0.01)\nglass.extrude_faces(0, -2)\nglass.extrude_faces(0, -0.01)\nglass.points.translate((0, 0, 2))\n\nglass = glass.solidify(thickness=0.1)\nglass.to_object(\"Solidify\", shade_smooth=True)\n</code></pre> See Also <p><code>Mesh.from_object</code> :     Converts a Blender object back into a mesh wrapper. <code>object</code> :     Context manager yielding a temporary Blender object.</p> <p>Caution: Applying the modifier is destructive to the underlying Blender object; the method returns a new mesh instance of the result.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.solidify_socle","title":"solidify_socle","text":"<pre><code>solidify_socle(shape, z=0, bottom_material_index=0)\n</code></pre> <p>Build a solid base (\u201csocle\u201d) by extruding the outer boundary of a grid mesh down (or up) to a given Z level, then bridging the side wall.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple of int</code> <p>Grid shape <code>(nx, ny)</code> of the mesh topology (using <code>'ij'</code> indexing).</p> required <code>z</code> <code>float</code> <p>Target Z coordinate for the base ring (the new bottom boundary). Default is 0.</p> <code>0</code> <code>bottom_material_index</code> <code>int</code> <p>Material index assigned to the bottom face created by the operation. Default is 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>Modifies the mesh in place. Returns <code>None</code>. The bottom face indices produced by <code>add_geometry</code> are stored internally and their <code>material_index</code> is set to <code>bottom_material_index</code>.</p> Notes <ul> <li>The outer boundary loop is derived from the provided grid <code>shape</code> assuming a regular lattice of <code>nx * ny</code> points laid out with NumPy\u2019s <code>'ij'</code> indexing.</li> <li>A new ring of points is created at Z = <code>z</code> via <code>add_points</code>.</li> <li>The vertical side wall is created by bridging loops with <code>bridge_loops</code> using <code>close=True</code>.</li> <li>The bottom face material is assigned by ensuring and editing the optional <code>material_index</code> field on <code>self.faces</code>.</li> </ul> <p>Examples:</p> <p>Solidify a 20\u00d730 grid down to Z = -0.1 with material index 2:</p> <pre><code>Mesh.solidify_socle(shape=(20, 30), z=-0.1, bottom_material_index=2)\n</code></pre> See Also <p><code>add_points</code> :     Adds the new base ring vertices at Z = <code>z</code>. <code>add_geometry</code> :     Creates the bottom polygon from the added ring. <code>bridge_loops</code> :     Connects the side wall between original and new boundary loops.</p> <p>Caution: This method assumes the mesh vertices correspond to a regular <code>(nx, ny)</code> grid ordered consistently with <code>'ij'</code> indexing; inconsistent layouts will produce incorrect boundaries.</p> <p>Note: The function does not return the created face indices; it sets their <code>material_index</code> internally based on <code>bottom_material_index</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.split_edges","title":"split_edges","text":"<pre><code>split_edges(loop0, loop1, cuts=1)\n</code></pre> <p>Subdivide in place the edges whose endpoints match the pairs (loop0[i], loop1[i]) regardless of order (edges are treated as undirected).</p> <p>The inputs <code>loop0</code> and <code>loop1</code> can be: - scalars (a single vertex index), - sequences of the same length, - or a mix of both (a scalar is broadcast to match the length of the other).</p> <p>The vertex pairs are normalized by sorting (min, max) so that order does not matter, and then compared against the BMesh edge list to determine which edges should be subdivided.</p> <p>Parameters:</p> Name Type Description Default <code>loop0</code> <code>int or array-like of int</code> <p>First vertex (or list of vertices) of the edges to be selected. If scalar, it will be broadcast to the length of <code>loop1</code> if needed.</p> required <code>loop1</code> <code>int or array-like of int</code> <p>Second vertex (or list of vertices) of the edges to be selected. If scalar, it will be broadcast to the length of <code>loop0</code> if needed.</p> required <code>cuts</code> <code>int</code> <p>Number of cuts per selected edge, as defined by <code>bmesh.ops.subdivide_edges</code>. Default is <code>1</code>. Must be &gt;= 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>None</code> <p>Modifies the geometry in place. Returns <code>None</code>. If no edge matches the given pairs, the function returns immediately without modifying the mesh.</p> Notes <ul> <li>Edge selection is performed by constructing an array of sorted vertex pairs <code>(min(v0, v1), max(v0, v1))</code> and checking membership (via <code>np.isin</code> on a structured dtype view) against the BMesh edge list.</li> <li>Subdivision is executed with <code>bmesh.ops.subdivide_edges</code> and <code>use_grid_fill=False</code>.</li> </ul> <p>Examples:</p> <p>Subdivide a single edge (vertices 12 and 34) with 2 cuts:</p> <pre><code>obj = ...  # wrapper object providing .bmesh() and ._bm_edges(...)\nobj.split_edges(12, 34, cuts=2)\n</code></pre> <p>Subdivide multiple edges defined by pairs of vertices:</p> <pre><code>v0 = [1, 5, 9]\nv1 = [2, 6, 10]\nobj.split_edges(v0, v1, cuts=1)\n</code></pre> <p>Use a scalar broadcast against a vector:</p> <pre><code># All edges (7, x) for x in [8, 9, 10]\nobj.split_edges(7, [8, 9, 10], cuts=1)\n</code></pre> See Also <p>bmesh.ops.subdivide_edges : The underlying BMesh operator used for subdivision.</p> <p>Warning: This operation modifies the mesh in place and may create new vertices/edges/faces. Handle undo/history in Blender if needed.</p> <p>Caution: <code>use_grid_fill=False</code> prevents automatic grid filling. Depending on topology, additional n-gons or triangles may be introduced.</p> <p>Note: Edges are considered undirected: (a, b) and (b, a) are equivalent when matching edges.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_curve_REVIEW","title":"to_curve_REVIEW","text":"<pre><code>to_curve_REVIEW()\n</code></pre> <p>Convert mesh to curve</p> <p>Simple conversion when edges domain is defined</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Serialize the Mesh object to a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the serialized data of the mesh, including: - 'geometry': The type of geometry (always 'Mesh'). - 'materials': List of material names. - 'points': Serialized points data. - 'corners': Serialized corners data. - 'faces': Serialized faces data. - 'edges': Serialized edges data.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_mesh_data","title":"to_mesh_data","text":"<pre><code>to_mesh_data(data)\n</code></pre> <p>Write the geometry data from this mesh into a Blender Mesh instance.</p> <p>This method transfers the mesh's vertices, edges, faces, corners, materials, and custom attributes into the provided Blender Mesh data structure.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Blender Mesh instance</code> <p>The Blender Mesh object to which the geometry will be written.</p> required <p>Returns:</p> Type Description <code>None</code> Side Effects <p>Modifies the provided Blender Mesh instance by clearing its current geometry and populating it with the data from this mesh. Updates the mesh to reflect the changes.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.to_object","title":"to_object","text":"<pre><code>to_object(obj, shade_smooth=None, shapekeys=None, collection=None)\n</code></pre> <p>Create or update a Blender mesh object from this mesh data.</p> <p>This method creates a new Blender mesh object if it does not already exist, or updates the existing object's mesh data. It does not perform object type conversion; the existing object must be a mesh.</p> <p>After the object is created or updated, use 'update_object' to modify vertices.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str or Object</code> <p>The Blender object or its name to create or update.</p> required <code>shade_smooth</code> <code>bool or None</code> <p>If specified, sets the shading mode of the mesh polygons to smooth or flat.</p> <code>None</code> <code>shapekeys</code> <code>ShapeKeys or iterable of ShapeKeys</code> <p>Shape keys to apply to the mesh object.</p> <code>None</code> <code>collection</code> <code>Collection or None</code> <p>The collection to which the object should be linked.</p> <code>None</code> <p>Returns:</p> Type Description <code>Object</code> <p>The created or updated Blender mesh object.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.torus","title":"torus  <code>classmethod</code>","text":"<pre><code>torus(major_segments=48, minor_segments=12, major_radius=1.0, minor_radius=0.25, materials=None)\n</code></pre> <p>Create a torus mesh.</p> <p>Parameters:</p> Name Type Description Default <code>major_segments</code> <code>int</code> <p>Number of segments around the major (outer) radius. Default is 48.</p> <code>48</code> <code>minor_segments</code> <code>int</code> <p>Number of segments around the minor (inner) radius (the cross-section). Default is 12.</p> <code>12</code> <code>major_radius</code> <code>float</code> <p>The distance from the center of the torus to the center of the tube. Default is 1.</p> <code>1.0</code> <code>minor_radius</code> <code>float</code> <p>The radius of the tube itself. Default is 0.25.</p> <code>0.25</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the torus. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the torus.</p> Notes <ul> <li>The torus is constructed by sweeping a circle of radius <code>minor_radius</code> around a larger circle of radius <code>major_radius</code>.</li> <li>The transformation of the cross-section is handled by <code>Transformation</code> and <code>Rotation</code>.</li> <li>UV coordinates are generated using <code>grid_uv_map</code>, resulting in a square parameterization.</li> <li>Topology is constructed with <code>grid_corners</code> with both axes closed.</li> </ul> <p>Examples:</p> <p>Create a standard torus:</p> <pre><code>torus = Mesh.torus()\n</code></pre> <p>Create a torus with a larger tube and finer resolution:</p> <pre><code>torus = Mesh.torus(major_segments=64, minor_segments=32,\n                major_radius=2, minor_radius=0.5)\n</code></pre> See Also <p><code>grid_corners</code> :     Helper for constructing the corner topology of the torus grid. <code>grid_uv_map</code> :     Generates UV coordinates for grid-like surfaces. <code>Transformation</code> :     Used to position and orient the swept circle. <code>Rotation</code> :     Used to orient the minor circle along the sweep path.</p> <p>Note: UV coordinates are generated with an offset of \u03c0 to match Blender's default torus orientation.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.transformation","title":"transformation","text":"<pre><code>transformation(rotation=None, scale=None, translation=None, pivot=None)\n</code></pre> <p>The transformation arguments can treat the points as a list of packets of the same size. For instance, 24 vertices can be seend as 3 packets of 8 vertices using a translation of (8, 3) vectors.</p> <p>Examples:</p> <pre><code># A mesh made of 12 cubes\ncubes = Mesh.cube(size=1)*12\n\n# 3 random transformations\ntranslation = np.random.uniform(-1, 1, (4, 3))\npivot = np.random.uniform(-1, 1, (3, 3))\nscale = np.random.uniform(.1, 2, (12, 3))\nrot = Rotation.from_euler(np.random.uniform(0, 2*np.pi, (6, 3)))\n\ncubes.transformation(\n    translation = translation,\n    scale = scale,\n    rotation = rot,\n    pivot=pivot,\n)\n</code></pre>"},{"location":"api/mesh/#npblender.mesh.Mesh.triangulate","title":"triangulate","text":"<pre><code>triangulate(selection=None)\n</code></pre> <p>Triangulate selected faces (or all faces) and return a new mesh.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of int or bool, or None</code> <p>Indices (or mask) of faces to triangulate. If <code>None</code>, all faces are triangulated. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh or None</code> <p>A new mesh instance with the selected faces triangulated. Returns <code>None</code> if no faces were selected.</p> Notes <ul> <li>Creates a copy of the current mesh with <code>Mesh.from_mesh</code>.</li> <li>Triangulation is applied in-place on the copy via <code>bmesh.ops.triangulate</code>.</li> <li>The original mesh is left unchanged.</li> </ul> <p>Examples:</p> <p>Triangulate all faces:</p> <pre><code>tri_mesh = mesh.triangulate()\n</code></pre> <p>Triangulate only a subset:</p> <pre><code>tri_mesh = mesh.triangulate(selection=[0, 5, 7])\n</code></pre> See Also <p><code>Mesh.from_mesh</code> :     Utility to duplicate the mesh before applying triangulation.</p> <p>Note: If <code>selection</code> is empty, the method returns <code>None</code>.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.uvsphere","title":"uvsphere  <code>classmethod</code>","text":"<pre><code>uvsphere(segments=32, rings=16, radius=1, materials=None)\n</code></pre> <p>Create a UV sphere mesh.</p> <p>Parameters:</p> Name Type Description Default <code>segments</code> <code>int</code> <p>Number of longitudinal segments (meridians). Default is 32.</p> <code>32</code> <code>rings</code> <code>int</code> <p>Number of latitudinal rings (parallels). Default is 16.</p> <code>16</code> <code>radius</code> <code>float</code> <p>Radius of the sphere. Default is 1.</p> <code>1</code> <code>materials</code> <code>list of str</code> <p>List of material names to assign to the sphere. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A new mesh instance containing the UV sphere.</p> Notes <ul> <li>The sphere is created using <code>bmesh.ops.create_uvsphere</code> with <code>calc_uvs=True</code> so UV coordinates are automatically generated.</li> <li>The geometry is distributed evenly in the UV parameterization, which means denser vertices near the poles.</li> </ul> <p>Examples:</p> <p>Create a default UV sphere of radius 1:</p> <pre><code>sphere = Mesh.uvsphere()\n</code></pre> <p>Create a high-resolution sphere:</p> <pre><code>sphere = Mesh.uvsphere(segments=64, rings=32, radius=2)\n</code></pre> See Also <p><code>icosphere</code> :     Alternative sphere primitive with more uniform vertex distribution. <code>bmesh.ops.create_uvsphere</code> :     BMesh operator used for creating UV spheres.</p> <p>Note: Use <code>icosphere</code> if you need a more uniform tessellation without poles.</p>"},{"location":"api/mesh/#npblender.mesh.Mesh.vectors_field","title":"vectors_field  <code>classmethod</code>","text":"<pre><code>vectors_field(locations, vectors, radius=0.05, scale_length=1.0, angle=24.0, segments=8, head=None, adjust_norm=None, materials=None)\n</code></pre> <p>Create an arrow at each <code>location</code> oriented and scaled by the corresponding <code>vector</code>.</p> <p>Each arrow consists of a cylindrical shaft and a conical head aligned with the vector direction. Arrow length is derived from the vector norm, optionally transformed by <code>adjust_norm</code>. For very short vectors, the arrow is scaled down to preserve proportions.</p> <p>Parameters:</p> Name Type Description Default <code>locations</code> <code>array-like of shape (N, 3)</code> <p>Positions where arrows are placed.</p> required <code>vectors</code> <code>array-like of shape (N, 3)</code> <p>Direction (and base length) of each arrow. Must match the length of <code>locations</code>.</p> required <code>radius</code> <code>float</code> <p>Shaft radius for the arrows. Default is 0.05.</p> <code>0.05</code> <code>scale_length</code> <code>float</code> <p>Length threshold below which arrows are uniformly scaled down (radius and shaft) while keeping proportions. Default is 1.0.</p> <code>1.0</code> <code>angle</code> <code>float</code> <p>Opening angle (in degrees) of the conical head. Default is 24.</p> <code>24.0</code> <code>segments</code> <code>int</code> <p>Number of radial segments for both shaft and head. Default is 8.</p> <code>8</code> <code>head</code> <code>Mesh or None</code> <p>Optional mesh to use as the arrow head. If <code>None</code>, a cone is created. When provided, its Z size defines the head height.</p> <code>None</code> <code>adjust_norm</code> <code>(callable, float, None)</code> <p>Controls how vector norms are mapped to arrow lengths: - callable: applied to the array of norms. - float: acts as a maximum length (clamp). - None: use the raw norms. Default is None.</p> <code>callable</code> <code>materials</code> <code>list of str</code> <p>Material names to assign to created geometry. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>A mesh containing all arrows.</p> Notes <ul> <li>The head radius is <code>3 * radius</code>; its height is derived from <code>angle</code> via <code>head_height = head_radius / tan(angle)</code>.</li> <li>Arrows with very small vectors are handled specially to avoid degenerate geometry (a minimum total length of approximately <code>2 * head_height</code> is enforced).</li> <li>Alignment is achieved with <code>Rotation.look_at</code>.</li> <li>The shaft is built from <code>cylinder</code>, and the head from <code>cone</code> (when <code>head is None</code>).</li> </ul> <p>Examples:</p> <p>Create a field of unit arrows from a grid:</p> <pre><code>P = np.stack(np.meshgrid(np.linspace(-1, 1, 5),\n                        np.linspace(-1, 1, 5),\n                        [0.0], indexing='ij'), axis=-1).reshape(-1, 3)\nV = np.tile(np.array([0, 0, 1.0]), (len(P), 1))\nfield = Mesh.vectors_field(P, V, radius=0.03, segments=12)\n</code></pre> <p>Clamp arrow lengths to 2 units:</p> <pre><code>field = Mesh.vectors_field(P, V * 5.0, adjust_norm=2.0)\n</code></pre> <p>Map norms nonlinearly (e.g., sqrt):</p> <pre><code>field = Mesh.vectors_field(P, V, adjust_norm=np.sqrt)\n</code></pre> See Also <p><code>arrow</code> :     Convenience method to create a single arrow. <code>cylinder</code> :     Used to create the arrow shafts. <code>cone</code> :     Used to create the arrow heads (when <code>head is None</code>). <code>Rotation.look_at</code> :     Used to orient arrows along their vectors.</p> <p>Caution: <code>locations</code> and <code>vectors</code> must have the same length (N). Mismatched inputs will lead to incorrect alignment or runtime errors.</p> <p>Note: Zero-length vectors are handled safely; corresponding arrows collapse to length 0 and are effectively omitted.</p>"},{"location":"api/point/","title":"Point","text":""},{"location":"api/point/#npblender.domain.Point","title":"Point","text":"<pre><code>Point(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>Point domain for cloud and instances.</p> <p>Adds optional rotation/scale fields and a convenient kinematics initializer, along with several spatial distribution helpers.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>(N, 3) float</code> <p>Point positions.</p> <code>radius</code> <code>(N,) float, optional</code> <p>Point radius (e.g., for particle/cloud visualization).</p> <code>model_index</code> <code>(N,) int, optional</code> <p>Instance model index.</p> <code>euler</code> <code>(N, 3) float, optional</code> <p>Euler angles (radians).</p> <code>quat</code> <code>(N, 4) float, optional</code> <p>Quaternion rotation in (x, y, z, w) convention.</p> <code>scale</code> <code>(N, 3) float, optional</code> <p>Per-point scale.</p> Kinematics (created by <code>init_kinematics()</code>) <p>speed, accel, force : (N, 3) float     Linear kinematics fields. mass : (N,) float     Mass per point. moment : (N,) float     Moment of inertia proxy (placeholder). omega, torque : (N, 3) float     Angular velocity and torque. age : (N,) float     Age (seconds or user-defined units). locked : (N,) bool     Lock flag. last_pos : (N, 3) float     Previous position. viscosity : (N,) float     Drag coefficient.</p> Properties <p>has_rotation : bool     True if either <code>euler</code> or <code>quat</code> is present. rotation : Rotation or Quaternion     Combined rotation (quaternion \u2297 euler if both present).</p> Methods (selection) <p>init_kinematics()     Add standard kinematics fields. line_dist(), arc_dist(), circle_dist(), rect_dist(), pie_dist(), disk_dist(), cylinder_dist(), sphere_dist(), dome_dist(), cube_dist(), ball_dist()     Populate positions (and related attributes like tangent/normal)     from common geometric distributions. speed_along(), disk_speed(), shake_speed()     Generate velocity vectors according to distributions.</p> <p>Examples:</p> <p>Create a ring of instances with tangents:</p> <pre><code>pts = Point().circle_dist(radius=2.0, count=128, seed=0)\n# tangents and angles are appended automatically\n</code></pre> <p>Compose rotations and apply scale:</p> <pre><code>R = pts.rotation              # auto-composed from euler/quat\npts.apply_scale(0.5)\npts.transform(R)              # re-apply or chain with other transforms\n</code></pre> <p>Initialize a domain array and its attribute schema.</p> <p>Initializes the storage from an existing array/domain or creates an empty structure. Optionally merges attribute definitions/values from another domain and keyword-provided attributes.</p> <p>Domains are never instancied directly but by owning geometries.</p> <p>Actual Domains are <code>Vertex</code>, [<code>Faces</code>][npblender.domain.Faces], <code>Corner</code>, <code>Edge</code>, <code>ControlPoint</code>, <code>Spline</code> and <code>Point</code>.</p> <p>Domains are initialized with their defaults attributes, for instance <code>position</code> for point domaines.</p> <p>Use attributes can be freely added. </p> <p>Note: user attributes are saved in Blender Mesh objects only, Blender Curve objects don't store user attributes.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>array - like or FieldArray or None</code> <p>Source data used to initialize the domain. If <code>None</code>, an empty domain is created and <code>_declare_attributes()</code> is called to register defaults.</p> <code>None</code> <code>mode</code> <code>(COPY, CAPTURE, EMPTY)</code> <p>Initialization mode. <code>'COPY'</code> duplicates the input data, <code>'CAPTURE'</code> references the input buffer when supported, <code>'EMPTY'</code> creates the structure without copying values.</p> <code>'COPY'</code> <code>selector</code> <code>Any</code> <p>Optional row/element selector applied to <code>a</code> prior to initialization.</p> <code>None</code> <code>attr_from</code> <code>Domain or Mapping or None</code> <p>Attribute schema (and possibly values) to merge into this domain.</p> <code>None</code> <code>**attrs</code> <p>Additional attribute name/value pairs to inject or override.</p> <code>{}</code> Notes <p>The effective attribute list results from <code>_declare_attributes()</code>, then <code>attr_from</code>, then <code>**attrs</code> (later entries take precedence).</p> <p>Examples:</p> <pre><code>cube = Mesh.cube() # points, corners, faces and edges domains are created\n# Adding named attribute to point domain\ncube.points.new_float('age')\n# Setting the age\ncube.points.age = np.random.uniforme(10, 10, len(cube.points))\n</code></pre>"},{"location":"api/point/#npblender.domain.Point.actual_names","title":"actual_names  <code>property</code>","text":"<pre><code>actual_names\n</code></pre> <p>Column names.</p> <p>Returns the actual field names, excluding optional fields.</p>"},{"location":"api/point/#npblender.domain.Point.all_names","title":"all_names  <code>property</code>","text":"<pre><code>all_names\n</code></pre> <p>Column names.</p> <p>Returns all the field names, including optional ones.</p>"},{"location":"api/point/#npblender.domain.Point.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Array structured dtype</p> <p>Returns the dtype property of the structured array.</p>"},{"location":"api/point/#npblender.domain.Point.has_rotation","title":"has_rotation  <code>property</code>","text":"<pre><code>has_rotation\n</code></pre> <p>Whether this domain has an orientation field.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if either <code>euler</code> or <code>quat</code> exists in the attribute set, <code>False</code> otherwise.</p> See Also <p><code>rotation</code> :     Access the per-point rotation object. <code>get_rotation</code> :     Safe accessor that can return a default.</p>"},{"location":"api/point/#npblender.domain.Point.rotation","title":"rotation  <code>property</code>","text":"<pre><code>rotation\n</code></pre> <p>Per-point rotation object from Euler and/or quaternion.</p> <p>If both <code>euler</code> and <code>quat</code> exist, returns their composition (quaternion composed with Euler). If neither exists, returns an identity rotation with shape <code>(len(position),)</code>.</p> <p>Returns:</p> Type Description <code>Rotation</code> <p>The point rotation</p> See Also <p><code>has_rotation</code> :     Check if a rotation is available. <code>get_rotation</code> :     Return a default when no rotation is stored.</p> <p>Examples:</p> <pre><code>R = P.rotation           # rotation object (vectorized)\neul = R.as_euler()       # (N, 3)\nquat = R.as_quaternion() # (N, 4) in (x, y, z, w)\n</code></pre>"},{"location":"api/point/#npblender.domain.Point.transdom_names","title":"transdom_names  <code>property</code>","text":"<pre><code>transdom_names\n</code></pre> <p>List the names of trans-domain attributes.</p> <p>Returns:</p> Type Description <code>list of str</code> <p>Names of attributes flagged with <code>transdom=True</code>.</p> <p>Examples:</p> <pre><code>names = D.transdom_names()\n</code></pre>"},{"location":"api/point/#npblender.domain.Point.x","title":"x  <code>property</code> <code>writable</code>","text":"<pre><code>x\n</code></pre> <p>X coordinate accessor.</p> <p>Shorthand for <code>position[..., 0]</code>. Reading returns a view; assigning to this property writes into the underlying <code>position</code> field.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>View of shape <code>(...,)</code> selecting the x component of <code>position</code>.</p> <p>Examples:</p> <p>Read and write x in place:</p> <pre><code>xs = points.x              # view on position[..., 0]\npoints.x = xs + 1.0        # shift x by +1\n</code></pre> <p>Note: This is equivalent to <code>points.position[..., 0]</code>.</p>"},{"location":"api/point/#npblender.domain.Point.y","title":"y  <code>property</code> <code>writable</code>","text":"<pre><code>y\n</code></pre> <p>Y coordinate accessor.</p> <p>Shorthand for <code>position[..., 1]</code>. Reading returns a view; assigning to this property writes into the underlying <code>position</code> field.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>View of shape <code>(...,)</code> selecting the y component of <code>position</code>.</p> <p>Examples:</p> <pre><code>points.y = 0.0             # flatten all y to 0\n</code></pre>"},{"location":"api/point/#npblender.domain.Point.z","title":"z  <code>property</code> <code>writable</code>","text":"<pre><code>z\n</code></pre> <p>Z coordinate accessor.</p> <p>Shorthand for <code>position[..., 2]</code>. Reading returns a view; assigning to this property writes into the underlying <code>position</code> field.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>View of shape <code>(...,)</code> selecting the z component of <code>position</code>.</p> <p>Examples:</p> <pre><code>points.z += 2.5\n</code></pre>"},{"location":"api/point/#npblender.domain.Point.add","title":"add","text":"<pre><code>add(count, **fields)\n</code></pre> <p>Add count records</p> <p>New records are set with default values or values provided by the user in fields dict.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of records to add.</p> required <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/point/#npblender.domain.Point.append","title":"append","text":"<pre><code>append(**fields)\n</code></pre> <p>Append values to the structured array.</p> <p>The number of records to append is determined by the number of fields provided in the fields dictionary. The values of the fields are copied to the new records.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/point/#npblender.domain.Point.apply_scale","title":"apply_scale","text":"<pre><code>apply_scale(scale, pivot=None)\n</code></pre> <p>Apply per-axis scales to positions and multiply the <code>scale</code> attribute.</p> <p>Calls the base point scaling (<code>apply_scale</code>) to update <code>position</code> (optionally about <code>pivot</code>), then multiplies the per-point <code>scale</code> attribute when present.</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>array-like of shape ``(..., 3)``</code> <p>Per-axis scale factors broadcastable to the domain size.</p> required <code>pivot</code> <code>array-like of shape ``(..., 3)`` or None</code> <p>Pivot location(s). If <code>None</code>, scaling is applied about the origin.</p> <code>None</code> <p>Returns:</p> Type Description <code>Point</code> <p>Self (for chaining).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If broadcasting cannot align inputs with the domain (raised by <code>_get_shape_for_operation</code>).</p>"},{"location":"api/point/#npblender.domain.Point.as_kwargs","title":"as_kwargs","text":"<pre><code>as_kwargs(selector=None, include=None, exclude=None)\n</code></pre> <p>Return a dictionary of field values formatted as kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>slice, int, list, or mask</code> <p>Optional selection of elements to extract.</p> <code>None</code> <code>include</code> <code>list[str]</code> <p>List of field names (original or python names) to include.</p> <code>None</code> <code>exclude</code> <code>list[str]</code> <p>List of field names (original or python names) to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Mapping from python-safe field names to array values.</p>"},{"location":"api/point/#npblender.domain.Point.copy_field","title":"copy_field","text":"<pre><code>copy_field(field_name, new_name, **infos)\n</code></pre> <p>Duplicate an existing field under a new name, with optional metadata overrides.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the existing field to copy.</p> required <code>new_name</code> <code>str</code> <p>The name of the new field to create.</p> required <code>infos</code> <code>keyword arguments</code> <p>Optional metadata (e.g. default, unit, description...) to override or supplement the original field's metadata.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the source field does not exist.</p> <code>ValueError</code> <p>If the target name already exists or is reserved.</p>"},{"location":"api/point/#npblender.domain.Point.delete","title":"delete","text":"<pre><code>delete(index)\n</code></pre> <p>Delete a selection of items from the array.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int, slice, or array-like</code> <p>The indices of the elements to delete from the current data.</p> required Notes <p>This operates only on the valid range <code>[0:self._length]</code>. The internal buffer is preserved (no reallocation).</p>"},{"location":"api/point/#npblender.domain.Point.disk_speed","title":"disk_speed","text":"<pre><code>disk_speed(speed=1, max_speed=None, normal=None, seed=None)\n</code></pre> <p>Sample velocity vectors in a disk (2D radial distribution).</p> <p>Samples vectors lying in a plane (given by <code>normal</code>) with lengths in <code>[0, max_speed]</code> (or fixed <code>speed</code> if <code>max_speed</code> is <code>None</code>).</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Base radius or fixed magnitude when <code>max_speed</code> is <code>None</code>.</p> <code>1</code> <code>max_speed</code> <code>float or None</code> <p>Maximum radius; if provided, lengths are sampled in <code>[0, max_speed]</code>.</p> <code>None</code> <code>normal</code> <code>(3,) float or None</code> <p>Plane normal. If <code>None</code>, uses +Z.</p> <code>None</code> <code>seed</code> <code>int or None</code> <code>None</code> <p>Returns:</p> Type Description <code>ndarray of shape ``(N, 3)``</code> <p>Sampled velocity vectors.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If inputs are invalid (propagated from the backend).</p>"},{"location":"api/point/#npblender.domain.Point.dump","title":"dump","text":"<pre><code>dump(title='Dump', attributes=None, target='SCREEN')\n</code></pre> <p>Pretty-print or export domain content.</p> <p>Formats attribute values and prints to screen or builds a tabular dump suitable for spreadsheets.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title displayed in the report.</p> <code>'Dump'</code> <code>attributes</code> <code>Sequence[str] or None</code> <p>Subset of attribute names to include. If <code>None</code>, all attributes are shown.</p> <code>None</code> <code>target</code> <code>(SCREEN, ...)</code> <p>Output target. <code>'SCREEN'</code> prints to stdout; other targets may trigger file creation depending on the implementation.</p> <code>'SCREEN'</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>Domain(points).dump(title=\"Vertices\")\n</code></pre> <p>Note: Formatting adapts to the chosen <code>target</code>.</p>"},{"location":"api/point/#npblender.domain.Point.extend","title":"extend","text":"<pre><code>extend(other, join_fields=True)\n</code></pre> <p>Append multiple records from another array or FieldArray.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray or structured np.ndarray</code> <p>The array of records to append. Must have named fields matching a subset of the current array's fields.</p> required"},{"location":"api/point/#npblender.domain.Point.filtered","title":"filtered","text":"<pre><code>filtered(selector, *, copy=False)\n</code></pre> <p>Return a FieldArray containing only the selected records.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>array\u2011like, slice or int</code> <p>Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice. It is applied to the current valid part of the buffer (<code>self._data[:self._length]</code>).</p> required <code>copy</code> <code>bool</code> <ul> <li>False    (default) =&gt; the new array shares the same memory                          (changes propagate both ways).</li> <li>True           =&gt; the data are physically copied.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>FieldArray</code> <p>A new instance holding exactly <code>len(selector)</code> records and inheriting the current field\u2011infos.</p>"},{"location":"api/point/#npblender.domain.Point.from_bl_attributes","title":"from_bl_attributes","text":"<pre><code>from_bl_attributes(bl_attributes)\n</code></pre> <p>Import attributes from a Blender attribute collection.</p> <p>Reads geometry attributes from a Blender data-block and creates/updates the corresponding domain attributes, resizing the domain if needed.</p> <p>Parameters:</p> Name Type Description Default <code>bl_attributes</code> <code>Mapping[str, Any]</code> <p>Blender attributes collection (name \u2192 attribute descriptor) providing at least <code>.domain</code>, <code>.is_internal</code>, <code>.data_type</code>, and <code>.data</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Note:*** Only external (non-internal) Blender attributes matching this</code> <code>domain are imported. Missing attributes are created with `transfer=True`.</code>"},{"location":"api/point/#npblender.domain.Point.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Build a FieldArray from a dictionary with field data and optional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, array - like or (array, dict)]</code> <p>Mapping field names to arrays or (array, infos). Infos must include NAME.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the data. Default: True.</p> required <p>Returns:</p> Type Description <code>FieldArray</code>"},{"location":"api/point/#npblender.domain.Point.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> <p>Get attribute by name.</p> <p>If name is not an actual field, return default value. Name can be an array. <pre><code>pos = field_array.get(\"position\", (0, 0, 1))\npos = field_array.get([[0, 0, 1], [0, 0, 0]])\n</code></pre></p>"},{"location":"api/point/#npblender.domain.Point.get_rotation","title":"get_rotation","text":"<pre><code>get_rotation(default=None)\n</code></pre> <p>Return the per-point rotation or a default.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Any or None</code> <p>Value to return if no rotation field is present. If <code>None</code>, the method returns <code>None</code> when no rotation is available.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any or None</code> <p><code>rotation</code> if available; otherwise <code>default</code>.</p> See Also <p><code>has_rotation</code> <code>rotation</code></p>"},{"location":"api/point/#npblender.domain.Point.init_kinematics","title":"init_kinematics","text":"<pre><code>init_kinematics()\n</code></pre> <p>Create standard kinematics fields (linear &amp; angular).</p> <p>Declares common per-point kinematics attributes for simulation or procedural animation. This method does not modify positions or velocities; it only ensures attributes exist with sensible defaults.</p> Declared attributes <p>speed : (N, 3) float     Linear velocity. accel : (N, 3) float     Linear acceleration. mass : (N,) float, optional     Point mass (default 1.0). force : (N, 3) float     Accumulated external force. moment : (N,) float, optional     Rotational inertia proxy (scalar; simplification). omega : (N, 3) float, optional     Angular velocity (radians/second). torque : (N, 3) float, optional     Accumulated external torque. age : (N,) float, optional     Age/time since spawn (seconds). locked : (N,) bool, optional     Freeze flag for constraints/solvers. last_pos : (N, 3) float, optional     Previous position (for finite differences). viscosity : (N,) float, optional     Linear damping factor.</p> <p>Returns:</p> Type Description <code>None</code>"},{"location":"api/point/#npblender.domain.Point.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other)\n</code></pre> <p>Merge trans-domain attributes from another domain.</p> <p>Copies or aligns attributes from <code>other</code> into the current domain, excluding any attributes not flagged as trans-domain in <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain or None</code> <p>Source domain. If <code>None</code>, the call is a no-op.</p> required <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p>"},{"location":"api/point/#npblender.domain.Point.join_fields","title":"join_fields","text":"<pre><code>join_fields(other, exclude=[])\n</code></pre> <p>Add all missing fields from another FieldArray.</p> <p>For every field in <code>other</code> that is not present in <code>self</code>, a new field is created with the same dtype and shape, and initialized with its default value across all existing records.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray</code> <p>Another FieldArray instance whose fields will be checked for missing fields.</p> required <p>Returns:</p> Type Description <code>self</code>"},{"location":"api/point/#npblender.domain.Point.make_buckets","title":"make_buckets","text":"<pre><code>make_buckets(attr)\n</code></pre> <p>Group items into buckets by attribute value.</p> <p>When a domain is to be considered as a collection of packets of various sizes, buckets mechanism groups pakets by size, allowing further operation with numpy vectorization.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>array - like or str</code> <p>Either an integer of shape <code>(N,)</code> or the name of an existing integer attribute in the domain.</p> required <p>Returns:</p> Type Description <code>list[ndarray(count, n)]</code> <p>A list of int arrays (count, n): count is the number of buckets of length n.</p> <p>Examples:</p> <pre><code>buckets = mesh.make_buckets('material')\nfor bucket in buckets:\n    print(bucket.shape)\n</code></pre> <p>Note: The bucket attribute can be read with <code>attr[bucket[:, 0]]</code>.</p>"},{"location":"api/point/#npblender.domain.Point.multiply","title":"multiply","text":"<pre><code>multiply(count)\n</code></pre> <p>Duplicate the current records <code>count</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of times to repeat the current records.</p> required Notes <p>This duplicates the current valid records (up to self._length). If the array is empty or count &lt;= 1, nothing happens.</p> Example: <p>If the array has 3 records and count == 4, the result will be:</p> <p>[rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]</p>"},{"location":"api/point/#npblender.domain.Point.new_attribute","title":"new_attribute","text":"<pre><code>new_attribute(name, data_type, default, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Register a new attribute in the domain schema.</p> <p>Creates (or ensures) an attribute with a given name, logical data type, default value, and flags controlling Blender transfer and cross-domain propagation.</p> <p>Note: <code>data_type</code> argument is a Blender data type not a python data type. The data type name is compatible with Blender internal storage. <code>FLOAT</code>data type is implemented as <code>np.float32</code> and  'INT' as <code>np.int32</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name (Python identifier recommended).</p> required <code>data_type</code> <code>(FLOAT, INT, BOOL, VECTOR, VECTOR2, COLOR, QUATERNION, MATRIX, STRING, ...)</code> <p>Logical data type used by the domain.</p> <code>'FLOAT'</code> <code>default</code> <code>Any</code> <p>Default value for newly allocated elements.</p> required <code>optional</code> <code>bool</code> <p>If <code>True</code>, the attribute may be absent on some elements.</p> <code>False</code> <code>transfer</code> <code>bool</code> <p>If <code>True</code>, eligible to be transferred to Blender as a geometry attribute.</p> <code>True</code> <code>transdom</code> <code>bool</code> <p>If <code>True</code>, considered a trans-domain attribute that can be copied across compatible domains.</p> <code>True</code> See Also <p><code>new_float</code>, <code>new_vector</code>, <code>new_int</code>, <code>new_bool</code>, <code>new_color</code>, <code>new_vector2</code>, <code>new_quaternion</code>, <code>new_matrix</code></p>"},{"location":"api/point/#npblender.domain.Point.new_bool","title":"new_bool","text":"<pre><code>new_bool(name, default=False, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a boolean attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>bool</code> <p>Default value.</p> <code>False</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/point/#npblender.domain.Point.new_color","title":"new_color","text":"<pre><code>new_color(name, default=(0.5, 0.5, 0.5, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a color attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,) or (4,)</code> <p>Default color as RGB or RGBA.</p> <code>(0.5, 0.5, 0.5, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/point/#npblender.domain.Point.new_field","title":"new_field","text":"<pre><code>new_field(name, dtype, shape=None, default=0, optional=False, **infos)\n</code></pre> <p>Add a field to the structured array.</p> Arguments <pre><code>- name (str) : field name\n- dtype (type) : a valid numpy dtype\n- shape (tuple = None) : the shape of the field\n- default (any = 0) : default value\n- optional (bool = False) : the field is created only when accessed\n- infos (dict) : field infos\n</code></pre>"},{"location":"api/point/#npblender.domain.Point.new_float","title":"new_float","text":"<pre><code>new_float(name, default=0.0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a scalar float attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>float</code> <p>Default value.</p> <code>0.0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/point/#npblender.domain.Point.new_int","title":"new_int","text":"<pre><code>new_int(name, default=0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure an integer attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>int</code> <p>Default value.</p> <code>0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/point/#npblender.domain.Point.new_matrix","title":"new_matrix","text":"<pre><code>new_matrix(name, default=np.eye(4), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a matrix attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array - like</code> <p>Default matrix. By convention this is a square matrix per element (e.g., <code>(3, 3)</code> rotation or <code>(4, 4)</code> transform).</p> <code>np.eye(4)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code> <code>order</code> required"},{"location":"api/point/#npblender.domain.Point.new_quaternion","title":"new_quaternion","text":"<pre><code>new_quaternion(name, default=(0.0, 0.0, 0.0, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a quaternion attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (4,)</code> <p>Default quaternion in <code>(x, y, z, w)</code> convention.</p> <code>(0.0, 0.0, 0.0, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/point/#npblender.domain.Point.new_vector","title":"new_vector","text":"<pre><code>new_vector(name, default=(0.0, 0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 3D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,)</code> <p>Default XYZ vector.</p> <code>(0.0, 0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/point/#npblender.domain.Point.new_vector2","title":"new_vector2","text":"<pre><code>new_vector2(name, default=(0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 2D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (2,)</code> <p>Default XY vector.</p> <code>(0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/point/#npblender.domain.Point.shake_speed","title":"shake_speed","text":"<pre><code>shake_speed(speed, scale=None, length_only=False, seed=None)\n</code></pre> <p>Add random jitter to existing velocity vectors.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>str or ndarray</code> <p>A field name or an array of velocity vectors to perturb.</p> required <code>scale</code> <code>float or (3,) or None</code> <p>Jitter amount (broadcastable).</p> <code>None</code> <code>length_only</code> <code>bool</code> <p>If <code>True</code>, only magnitudes are perturbed; directions are preserved.</p> <code>False</code> <code>seed</code> <code>int or None</code> <code>None</code> <p>Returns:</p> Type Description <code>ndarray of shape ``(N, 3)``</code> <p>Jittered velocity vectors.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If inputs are invalid (propagated from the backend).</p> See Also <p><code>speed_along</code> <code>disk_speed</code></p>"},{"location":"api/point/#npblender.domain.Point.speed_along","title":"speed_along","text":"<pre><code>speed_along(speed=1, direction=(0, 0, 1), angle=np.pi / 2, scale=None, use_vonmises=False, seed=None)\n</code></pre> <p>Sample velocity vectors within a cone around a direction.</p> <p>Returns random 3D vectors with magnitudes given by <code>speed</code> and directions sampled within a cone of half-angle <code>angle</code> around <code>direction</code>. Useful to initialize per-point velocities.</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float or (N,) or (N, 3)</code> <p>Target magnitudes (broadcastable).</p> <code>1</code> <code>direction</code> <code>(3,) or (N, 3)</code> <p>Cone axis per point (broadcastable).</p> <code>(0, 0, 1)</code> <code>angle</code> <code>float</code> <p>Cone half-angle (radians).</p> <code>pi/2</code> <code>scale</code> <code>(3,) float or None</code> <p>Optional anisotropic scaling of the cone.</p> <code>None</code> <code>use_vonmises</code> <code>bool</code> <p>If <code>True</code>, directions follow a Von Mises\u2013Fisher-like distribution.</p> <code>False</code> <code>seed</code> <code>int or None</code> <code>None</code> <p>Returns:</p> Type Description <code>ndarray of shape ``(N, 3)``</code> <p>Sampled velocity vectors.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If inputs cannot be broadcast/aligned (propagated from the backend).</p>"},{"location":"api/point/#npblender.domain.Point.to_bl_attributes","title":"to_bl_attributes","text":"<pre><code>to_bl_attributes(attributes, update=False)\n</code></pre> <p>Export attributes to a Blender attribute collection.</p> <p>Writes eligible domain attributes to a Blender data-block, creating missing attributes and adjusting sizes as needed.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Any</code> <p>Blender attributes collection receiving the values.</p> required <code>update</code> <code>bool</code> <p>If <code>True</code>, update existing attributes in-place; otherwise create them when missing.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Caution:*** Only attributes with `transfer=True` are exported. Optional</code> <code>attributes are skipped.</code> <code>&gt; ***Caution:*** Curve domains user attributes are not saved.</code>"},{"location":"api/point/#npblender.domain.Point.to_dict","title":"to_dict","text":"<pre><code>to_dict(*, copy=True, with_infos=True)\n</code></pre> <p>Convert the array to a dictionary of fields or (field, infos) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Whether to copy the arrays.</p> <code>True</code> <code>with_infos</code> <code>bool</code> <p>If True, return (array, infos) for each field.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, array or (array, dict)]</code>"},{"location":"api/point/#npblender.domain.Point.transfer_attributes","title":"transfer_attributes","text":"<pre><code>transfer_attributes(other, shape=None, other_shape=None)\n</code></pre> <p>Transfer values of trans-domain attributes from another domain.</p> <p>Copies values for each trans-domain attribute present in <code>other</code> into the corresponding attributes of <code>self</code>, with optional reshaping for batched assignments.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain</code> <p>Source domain providing attribute values.</p> required <code>shape</code> <code>tuple of int or None</code> <p>Target reshape for <code>self</code> before assignment. If <code>None</code>, uses <code>(self._length,)</code>.</p> <code>None</code> <code>other_shape</code> <code>tuple of int or None</code> <p>Source reshape for <code>other</code> before assignment. If <code>None</code>, uses <code>(other._length,)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p> <code>&gt; ***Note:*** Each attribute is reshaped as `shape + item_shape` on `self`</code> <code>and `other_shape + item_shape` on `other` prior to assignment.</code>"},{"location":"api/point/#npblender.domain.Point.transform","title":"transform","text":"<pre><code>transform(transfo, pivot=None)\n</code></pre> <p>Transform positions and compose stored orientation.</p> <p>First applies the linear transform to <code>position</code> via the base implementation (<code>transform</code>). Then, if a rotation field exists (<code>euler</code> or <code>quat</code>), composes it with <code>transfo</code>\u2019s rotation component and writes back to the same representation.</p> <p>Parameters:</p> Name Type Description Default <code>transfo</code> <code>array - like or object</code> <p>Transform(s) broadcastable to the domain size. Typical shapes include <code>(..., 3, 3)</code>; project transform types are also supported if they implement <code>@</code> with vectors and expose a <code>.rotation</code> component.</p> required <code>pivot</code> <code>array-like of shape ``(..., 3)`` or None</code> <p>Pivot location(s). If <code>None</code>, transforms are applied about the origin.</p> <code>None</code> <p>Returns:</p> Type Description <code>Point</code> <p>Self (for chaining).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If broadcasting cannot align inputs with the domain (raised by <code>_get_shape_for_operation</code>).</p> <code>TypeError</code> <p>If <code>transfo</code> does not support the <code>@</code> operator with vectors or lacks a usable rotation component.</p>"},{"location":"api/point/#npblender.domain.Point.translate","title":"translate","text":"<pre><code>translate(translation)\n</code></pre> <p>Translate points position by a vector or a batch of vectors.</p> <p>Supports per-domain translation (single vector), or grouped/batched translations that broadcast over buckets of equal size.</p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>array-like of shape ``(..., 3)``</code> <p>Translation vectors broadcastable to the domain size.</p> required <p>Returns:</p> Type Description <code>PointDomain</code> <p>Self (for chaining).</p> <p>Examples:</p> <pre><code># Per-point random translation\nD.translate(np.random.uniform(-0.1, 0.1, (len(D), 3)))\n\n```python\n# A mesh made of 8 cubes\ncubes = Mesh.cube(size=.2)*8\ntr = np.random.uniform(-1, 1, (8, 3))\n# Translate each cube individually\ncubes.points.translate(tr)\n</code></pre> <p>Caution: If a provided batch cannot be aligned with the domain, a <code>ValueError</code> is raised by <code>_get_shape_for_operation</code>.</p>"},{"location":"api/spline/","title":"Spline","text":""},{"location":"api/spline/#npblender.domain.Spline","title":"Spline","text":"<pre><code>Spline(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>Curve spline domain.</p> <p>Groups control points into splines and stores per-spline parameters (type, resolution, cyclic flags, and NURBS settings). Provides accessors to parametric functions and common evaluations.</p> <p>Attributes:</p> Name Type Description <code>loop_start</code> <code>(S,) int</code> <p>Starting control-point index of each spline.</p> <code>loop_total</code> <code>(S,) int</code> <p>Control-point count per spline.</p> <code>material_index</code> <code>(S,) int, optional</code> <p>Material index per spline.</p> <code>curve_type</code> <code>(S,) int</code> <p>One of constants <code>BEZIER</code>, <code>POLY</code>, <code>NURBS</code>.</p> <code>resolution</code> <code>(S,) int, optional</code> <p>Evaluation resolution (samples per segment).</p> <code>cyclic</code> <code>(S,) bool, optional</code> <p>Whether each spline is closed.</p> <code>order</code> <code>(S,) int, optional</code> <p>NURBS order.</p> <code>bezierpoint, endpoint</code> <code>(S,) bool, optional</code> <p>NURBS flags.</p> Properties <p>has_bezier : bool     True if any spline is Bezier. functions : list     List-like container of parametric spline functions (Bezier/Poly/NURBS). length : list of float     Length of each spline (delegates to <code>functions</code>).</p> <p>Methods:</p> Name Description <code>delete_splines</code> <p>Delete splines and their control points.</p> <code>add_splines</code> <p>Append new splines given control-point counts.</p> <code>tangent</code> <p>Evaluate tangents at parameter <code>t</code> in [0, 1].</p> <code>compute_attribute_on_points</code> <p>Broadcast per-spline attributes to control points.</p> <p>Examples:</p> <p>Build functions and sample tangents:</p> <pre><code>funcs = splines.functions\ntan = splines.tangent(0.25)\n</code></pre> <p>Append three splines with different sizes:</p> <pre><code>splines.add_splines([4, 6, 8], material_index=[0, 1, 1])\n</code></pre> <p>Note: <code>functions</code> relies on project spline implementations. Ensure control-point attributes (e.g., handles for Bezier, weights/order for NURBS) are present when required.</p> <p>Caution: <code>resolution</code> semantics differ for cyclic vs. non-cyclic splines (endpoints handling).</p> <p>Initialize a domain array and its attribute schema.</p> <p>Initializes the storage from an existing array/domain or creates an empty structure. Optionally merges attribute definitions/values from another domain and keyword-provided attributes.</p> <p>Domains are never instancied directly but by owning geometries.</p> <p>Actual Domains are <code>Vertex</code>, [<code>Faces</code>][npblender.domain.Faces], <code>Corner</code>, <code>Edge</code>, <code>ControlPoint</code>, <code>Spline</code> and <code>Point</code>.</p> <p>Domains are initialized with their defaults attributes, for instance <code>position</code> for point domaines.</p> <p>Use attributes can be freely added. </p> <p>Note: user attributes are saved in Blender Mesh objects only, Blender Curve objects don't store user attributes.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>array - like or FieldArray or None</code> <p>Source data used to initialize the domain. If <code>None</code>, an empty domain is created and <code>_declare_attributes()</code> is called to register defaults.</p> <code>None</code> <code>mode</code> <code>(COPY, CAPTURE, EMPTY)</code> <p>Initialization mode. <code>'COPY'</code> duplicates the input data, <code>'CAPTURE'</code> references the input buffer when supported, <code>'EMPTY'</code> creates the structure without copying values.</p> <code>'COPY'</code> <code>selector</code> <code>Any</code> <p>Optional row/element selector applied to <code>a</code> prior to initialization.</p> <code>None</code> <code>attr_from</code> <code>Domain or Mapping or None</code> <p>Attribute schema (and possibly values) to merge into this domain.</p> <code>None</code> <code>**attrs</code> <p>Additional attribute name/value pairs to inject or override.</p> <code>{}</code> Notes <p>The effective attribute list results from <code>_declare_attributes()</code>, then <code>attr_from</code>, then <code>**attrs</code> (later entries take precedence).</p> <p>Examples:</p> <pre><code>cube = Mesh.cube() # points, corners, faces and edges domains are created\n# Adding named attribute to point domain\ncube.points.new_float('age')\n# Setting the age\ncube.points.age = np.random.uniforme(10, 10, len(cube.points))\n</code></pre>"},{"location":"api/spline/#npblender.domain.Spline.actual_names","title":"actual_names  <code>property</code>","text":"<pre><code>actual_names\n</code></pre> <p>Column names.</p> <p>Returns the actual field names, excluding optional fields.</p>"},{"location":"api/spline/#npblender.domain.Spline.all_names","title":"all_names  <code>property</code>","text":"<pre><code>all_names\n</code></pre> <p>Column names.</p> <p>Returns all the field names, including optional ones.</p>"},{"location":"api/spline/#npblender.domain.Spline.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Array structured dtype</p> <p>Returns the dtype property of the structured array.</p>"},{"location":"api/spline/#npblender.domain.Spline.has_bezier","title":"has_bezier  <code>property</code>","text":"<pre><code>has_bezier\n</code></pre> <p>Check if the domain contains any B\u00e9zier splines.</p> <p>Evaluates the <code>curve_type</code> attribute and returns <code>True</code> if at least one spline in the domain is of type <code>BEZIER</code>.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the domain has at least one B\u00e9zier spline, <code>False</code> otherwise.</p> Notes <ul> <li>Useful for quickly testing whether B\u00e9zier-specific logic (e.g., handle attributes) must be considered.</li> <li>For mixed domains, the result is <code>True</code> as soon as one B\u00e9zier is present.</li> </ul> <p>Examples:</p> <pre><code>if splines.has_bezier:\n    print(\"Domain contains B\u00e9zier curves.\")\n</code></pre>"},{"location":"api/spline/#npblender.domain.Spline.next_loop_start","title":"next_loop_start  <code>property</code>","text":"<pre><code>next_loop_start\n</code></pre> <p>Offset to use for the next appended item.</p> <p>Returns:</p> Type Description <code>int</code> <p><code>loop_start[-1] + loop_total[-1]</code> if the domain is non-empty, otherwise <code>0</code>.</p> See Also <p><code>compute_loop_start</code></p>"},{"location":"api/spline/#npblender.domain.Spline.reversed_indices","title":"reversed_indices  <code>property</code>","text":"<pre><code>reversed_indices\n</code></pre> <p>Map each corner/control-point index back to its owning item.</p> <p>Returns:</p> Type Description <code>ndarray of shape ``(sum(loop_total),)``</code> <p>For index <code>k</code> in the flattened corner/control-point array, the value is the face/spline index that owns <code>k</code>.</p>"},{"location":"api/spline/#npblender.domain.Spline.transdom_names","title":"transdom_names  <code>property</code>","text":"<pre><code>transdom_names\n</code></pre> <p>List the names of trans-domain attributes.</p> <p>Returns:</p> Type Description <code>list of str</code> <p>Names of attributes flagged with <code>transdom=True</code>.</p> <p>Examples:</p> <pre><code>names = D.transdom_names()\n</code></pre>"},{"location":"api/spline/#npblender.domain.Spline.add","title":"add","text":"<pre><code>add(count, **fields)\n</code></pre> <p>Add count records</p> <p>New records are set with default values or values provided by the user in fields dict.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of records to add.</p> required <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/spline/#npblender.domain.Spline.append","title":"append","text":"<pre><code>append(**fields)\n</code></pre> <p>Append values to the structured array.</p> <p>The number of records to append is determined by the number of fields provided in the fields dictionary. The values of the fields are copied to the new records.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/spline/#npblender.domain.Spline.append_sizes","title":"append_sizes","text":"<pre><code>append_sizes(sizes, **fields)\n</code></pre> <p>Append new items given their sizes.</p> <p>If <code>loop_start</code> is not provided in <code>fields</code>, computes it from <code>sizes</code> using <code>compute_loop_start</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sizes</code> <code>array-like of int or None</code> <p>Number of corners/control-points for each new item.</p> required <code>**fields</code> <p>Additional per-item attributes to append (e.g., <code>material_index</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The value returned by <code>append(...)</code> (implementation-defined, often the indices/slice of appended items).</p> Notes <p>Passing <code>sizes=None</code> is a no-op and returns an empty list.</p>"},{"location":"api/spline/#npblender.domain.Spline.as_kwargs","title":"as_kwargs","text":"<pre><code>as_kwargs(selector=None, include=None, exclude=None)\n</code></pre> <p>Return a dictionary of field values formatted as kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>slice, int, list, or mask</code> <p>Optional selection of elements to extract.</p> <code>None</code> <code>include</code> <code>list[str]</code> <p>List of field names (original or python names) to include.</p> <code>None</code> <code>exclude</code> <code>list[str]</code> <p>List of field names (original or python names) to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Mapping from python-safe field names to array values.</p>"},{"location":"api/spline/#npblender.domain.Spline.check","title":"check","text":"<pre><code>check(count, halt=True)\n</code></pre> <p>Validate loop counters against a reference element count.</p> <p>Verifies that the sum of <code>loop_total</code> equals <code>count</code> (i.e., the total number of referenced elements such as corners or control points).</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Expected total number of elements referenced by all items.</p> required <code>halt</code> <code>bool</code> <p>If <code>True</code>, raise on failure; otherwise print a message and return <code>False</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the check passes or the domain is empty; <code>False</code> only when invalid and <code>halt</code> is <code>False</code>.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If <code>sum(loop_total) != count</code> and <code>halt</code> is <code>True</code>.</p> <p>Examples:</p> <pre><code>ok = fs.check(count=len(corners), halt=False)\nif not ok:\n    # fix topology or sizes, then recompute\n    fs.update_loop_start()\n</code></pre>"},{"location":"api/spline/#npblender.domain.Spline.compute_attribute_on_points","title":"compute_attribute_on_points","text":"<pre><code>compute_attribute_on_points(attr, points)\n</code></pre> <p>Expand spline attributes to control points.</p> <p>Broadcasts attributes defined per-spline into per-point arrays by repeating each spline\u2019s value over all its control points. This ensures compatibility when working in the control-point domain.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str or ndarray</code> <p>Attribute to expand. If a string, it is looked up in this domain. If an array, it must have length equal to the number of splines.</p> required <code>points</code> <code>ControlPoint</code> <p>Control-point domain that receives the expanded attributes. The result has length equal to <code>len(points)</code>.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of shape <code>(len(points), *attr_shape)</code> containing the broadcasted attribute values.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute is not found in this domain.</p> <code>ValueError</code> <p>If the provided attribute array shape does not match the number of splines.</p> Notes <ul> <li>Expansion uses the <code>loop_start</code> and <code>loop_total</code> arrays to map splines to their corresponding ranges of control points.</li> <li>This is the inverse of aggregating per-point attributes back to splines.</li> </ul> <p>Examples:</p> <pre><code># Broadcast per-spline weights to all control points\nw_points = splines.compute_attribute_on_points(\"weight\", cpoints)\n</code></pre>"},{"location":"api/spline/#npblender.domain.Spline.compute_loop_start","title":"compute_loop_start","text":"<pre><code>compute_loop_start(loop_total=None)\n</code></pre> <p>Compute offsets for one or many new items to append.</p> <p>Parameters:</p> Name Type Description Default <code>loop_total</code> <code>int or array-like of int or None</code> <p>Sizes of the items to add. If <code>None</code>, returns <code>None</code>. If a scalar, returns the single offset. If 1D array-like, returns one offset per size.</p> <code>None</code> <p>Returns:</p> Type Description <code>int or ndarray or None</code> <p>Offsets starting from <code>next_loop_start</code>, shaped like <code>loop_total</code>.</p> <p>Examples:</p> <pre><code># Prepare offsets for three faces of sizes 4, 5, 4\nstarts = fs.compute_loop_start([4, 5, 4])\nfs.append(loop_start=starts, loop_total=[4, 5, 4])\n</code></pre>"},{"location":"api/spline/#npblender.domain.Spline.copy_field","title":"copy_field","text":"<pre><code>copy_field(field_name, new_name, **infos)\n</code></pre> <p>Duplicate an existing field under a new name, with optional metadata overrides.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the existing field to copy.</p> required <code>new_name</code> <code>str</code> <p>The name of the new field to create.</p> required <code>infos</code> <code>keyword arguments</code> <p>Optional metadata (e.g. default, unit, description...) to override or supplement the original field's metadata.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the source field does not exist.</p> <code>ValueError</code> <p>If the target name already exists or is reserved.</p>"},{"location":"api/spline/#npblender.domain.Spline.delete","title":"delete","text":"<pre><code>delete(selection)\n</code></pre> <p>Delete selected items and maintain consistent offsets.</p> <p>After deleting items via <code>super().delete(selection)</code>, recomputes <code>loop_start</code> with <code>update_loop_start</code>.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>Any</code> <p>Boolean mask, integer index, slice, or array of indices.</p> required <p>Returns:</p> Type Description <code>None</code> See Also <p><code>update_loop_start</code></p>"},{"location":"api/spline/#npblender.domain.Spline.delete_splines","title":"delete_splines","text":"<pre><code>delete_splines(selection, cpoints)\n</code></pre> <p>Delete splines and their associated control points.</p> <p>Removes the splines selected in this domain, and deletes the corresponding control points from the given control-point domain. Corner indices are retrieved first to ensure consistent cleanup.</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>array-like of bool or int</code> <p>Indices or boolean mask selecting which splines to delete.</p> required <code>cpoints</code> <code>ControlPoint</code> <p>Control-point domain from which the corresponding points are removed.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>IndexError</code> <p>If any index in <code>selection</code> is out of bounds for this domain.</p> <code>ValueError</code> <p>If <code>selection</code> has an incompatible shape or type.</p> Notes <ul> <li>This operation modifies both the spline domain and the control-point domain in place.</li> <li>Deletion preserves consistency between splines and their control points.</li> </ul> <p>Examples:</p> <pre><code># Delete the first spline and its control points\nsplines.delete_splines([0], cpoints)\n</code></pre>"},{"location":"api/spline/#npblender.domain.Spline.dump","title":"dump","text":"<pre><code>dump(title='Dump', attributes=None, target='SCREEN')\n</code></pre> <p>Pretty-print or export domain content.</p> <p>Formats attribute values and prints to screen or builds a tabular dump suitable for spreadsheets.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title displayed in the report.</p> <code>'Dump'</code> <code>attributes</code> <code>Sequence[str] or None</code> <p>Subset of attribute names to include. If <code>None</code>, all attributes are shown.</p> <code>None</code> <code>target</code> <code>(SCREEN, ...)</code> <p>Output target. <code>'SCREEN'</code> prints to stdout; other targets may trigger file creation depending on the implementation.</p> <code>'SCREEN'</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>Domain(points).dump(title=\"Vertices\")\n</code></pre> <p>Note: Formatting adapts to the chosen <code>target</code>.</p>"},{"location":"api/spline/#npblender.domain.Spline.extend","title":"extend","text":"<pre><code>extend(other, join_fields=True)\n</code></pre> <p>Append multiple records from another array or FieldArray.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray or structured np.ndarray</code> <p>The array of records to append. Must have named fields matching a subset of the current array's fields.</p> required"},{"location":"api/spline/#npblender.domain.Spline.filtered","title":"filtered","text":"<pre><code>filtered(selector, *, copy=False)\n</code></pre> <p>Return a FieldArray containing only the selected records.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>array\u2011like, slice or int</code> <p>Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice. It is applied to the current valid part of the buffer (<code>self._data[:self._length]</code>).</p> required <code>copy</code> <code>bool</code> <ul> <li>False    (default) =&gt; the new array shares the same memory                          (changes propagate both ways).</li> <li>True           =&gt; the data are physically copied.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>FieldArray</code> <p>A new instance holding exactly <code>len(selector)</code> records and inheriting the current field\u2011infos.</p>"},{"location":"api/spline/#npblender.domain.Spline.from_bl_attributes","title":"from_bl_attributes","text":"<pre><code>from_bl_attributes(bl_attributes)\n</code></pre> <p>Import attributes from a Blender attribute collection.</p> <p>Reads geometry attributes from a Blender data-block and creates/updates the corresponding domain attributes, resizing the domain if needed.</p> <p>Parameters:</p> Name Type Description Default <code>bl_attributes</code> <code>Mapping[str, Any]</code> <p>Blender attributes collection (name \u2192 attribute descriptor) providing at least <code>.domain</code>, <code>.is_internal</code>, <code>.data_type</code>, and <code>.data</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Note:*** Only external (non-internal) Blender attributes matching this</code> <code>domain are imported. Missing attributes are created with `transfer=True`.</code>"},{"location":"api/spline/#npblender.domain.Spline.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Build a FieldArray from a dictionary with field data and optional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, array - like or (array, dict)]</code> <p>Mapping field names to arrays or (array, infos). Infos must include NAME.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the data. Default: True.</p> required <p>Returns:</p> Type Description <code>FieldArray</code>"},{"location":"api/spline/#npblender.domain.Spline.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> <p>Get attribute by name.</p> <p>If name is not an actual field, return default value. Name can be an array. <pre><code>pos = field_array.get(\"position\", (0, 0, 1))\npos = field_array.get([[0, 0, 1], [0, 0, 0]])\n</code></pre></p>"},{"location":"api/spline/#npblender.domain.Spline.get_corner_indices","title":"get_corner_indices","text":"<pre><code>get_corner_indices()\n</code></pre> <p>Return the contiguous range of corner/control-point indices.</p> <p>For each item, expands its <code>[loop_start, loop_start + loop_total)</code> range and concatenates the result for all items.</p> <p>Returns:</p> Type Description <code>ndarray of shape ``(sum(loop_total),)``</code> <p>Absolute indices into the corner/control-point array.</p> Notes <p>A fast Numba kernel is used for vectorized cases; the scalar case is handled directly.</p>"},{"location":"api/spline/#npblender.domain.Spline.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other)\n</code></pre> <p>Merge trans-domain attributes from another domain.</p> <p>Copies or aligns attributes from <code>other</code> into the current domain, excluding any attributes not flagged as trans-domain in <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain or None</code> <p>Source domain. If <code>None</code>, the call is a no-op.</p> required <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p>"},{"location":"api/spline/#npblender.domain.Spline.join_fields","title":"join_fields","text":"<pre><code>join_fields(other, exclude=[])\n</code></pre> <p>Add all missing fields from another FieldArray.</p> <p>For every field in <code>other</code> that is not present in <code>self</code>, a new field is created with the same dtype and shape, and initialized with its default value across all existing records.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray</code> <p>Another FieldArray instance whose fields will be checked for missing fields.</p> required <p>Returns:</p> Type Description <code>self</code>"},{"location":"api/spline/#npblender.domain.Spline.load_bl_attributes","title":"load_bl_attributes","text":"<pre><code>load_bl_attributes(data)\n</code></pre> <p>Load spline attributes from a Blender object.</p> <p>Reads attributes stored in a Blender data block and transfers those that belong to the spline domain into this domain. New attributes are created if they do not already exist.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ID or similar</code> <p>Blender object or data block exposing an <code>attributes</code> mapping.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If reading or assignment of an attribute fails.</p> <code>AssertionError</code> <p>If Blender provides inconsistent attribute sizes.</p> Notes <ul> <li>Only attributes with a matching domain and not marked as internal are imported.</li> <li>If an attribute does not exist yet, it is created with the appropriate data type and marked as transferable.</li> <li>The domain is resized once to match the size of Blender attributes.</li> </ul> <p>Examples:</p> <pre><code>import bpy\nfrom npblender.domain import Spline\n\ncurve = bpy.data.curves[\"MyCurve\"]\nsplines = Spline()\nsplines.load_bl_attributes(curve)\n</code></pre>"},{"location":"api/spline/#npblender.domain.Spline.make_buckets","title":"make_buckets","text":"<pre><code>make_buckets(attr)\n</code></pre> <p>Group items into buckets by attribute value.</p> <p>When a domain is to be considered as a collection of packets of various sizes, buckets mechanism groups pakets by size, allowing further operation with numpy vectorization.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>array - like or str</code> <p>Either an integer of shape <code>(N,)</code> or the name of an existing integer attribute in the domain.</p> required <p>Returns:</p> Type Description <code>list[ndarray(count, n)]</code> <p>A list of int arrays (count, n): count is the number of buckets of length n.</p> <p>Examples:</p> <pre><code>buckets = mesh.make_buckets('material')\nfor bucket in buckets:\n    print(bucket.shape)\n</code></pre> <p>Note: The bucket attribute can be read with <code>attr[bucket[:, 0]]</code>.</p>"},{"location":"api/spline/#npblender.domain.Spline.multiply","title":"multiply","text":"<pre><code>multiply(count)\n</code></pre> <p>Duplicate the current records <code>count</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of times to repeat the current records.</p> required Notes <p>This duplicates the current valid records (up to self._length). If the array is empty or count &lt;= 1, nothing happens.</p> Example: <p>If the array has 3 records and count == 4, the result will be:</p> <p>[rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]</p>"},{"location":"api/spline/#npblender.domain.Spline.new_attribute","title":"new_attribute","text":"<pre><code>new_attribute(name, data_type, default, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Register a new attribute in the domain schema.</p> <p>Creates (or ensures) an attribute with a given name, logical data type, default value, and flags controlling Blender transfer and cross-domain propagation.</p> <p>Note: <code>data_type</code> argument is a Blender data type not a python data type. The data type name is compatible with Blender internal storage. <code>FLOAT</code>data type is implemented as <code>np.float32</code> and  'INT' as <code>np.int32</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name (Python identifier recommended).</p> required <code>data_type</code> <code>(FLOAT, INT, BOOL, VECTOR, VECTOR2, COLOR, QUATERNION, MATRIX, STRING, ...)</code> <p>Logical data type used by the domain.</p> <code>'FLOAT'</code> <code>default</code> <code>Any</code> <p>Default value for newly allocated elements.</p> required <code>optional</code> <code>bool</code> <p>If <code>True</code>, the attribute may be absent on some elements.</p> <code>False</code> <code>transfer</code> <code>bool</code> <p>If <code>True</code>, eligible to be transferred to Blender as a geometry attribute.</p> <code>True</code> <code>transdom</code> <code>bool</code> <p>If <code>True</code>, considered a trans-domain attribute that can be copied across compatible domains.</p> <code>True</code> See Also <p><code>new_float</code>, <code>new_vector</code>, <code>new_int</code>, <code>new_bool</code>, <code>new_color</code>, <code>new_vector2</code>, <code>new_quaternion</code>, <code>new_matrix</code></p>"},{"location":"api/spline/#npblender.domain.Spline.new_bool","title":"new_bool","text":"<pre><code>new_bool(name, default=False, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a boolean attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>bool</code> <p>Default value.</p> <code>False</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/spline/#npblender.domain.Spline.new_color","title":"new_color","text":"<pre><code>new_color(name, default=(0.5, 0.5, 0.5, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a color attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,) or (4,)</code> <p>Default color as RGB or RGBA.</p> <code>(0.5, 0.5, 0.5, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/spline/#npblender.domain.Spline.new_field","title":"new_field","text":"<pre><code>new_field(name, dtype, shape=None, default=0, optional=False, **infos)\n</code></pre> <p>Add a field to the structured array.</p> Arguments <pre><code>- name (str) : field name\n- dtype (type) : a valid numpy dtype\n- shape (tuple = None) : the shape of the field\n- default (any = 0) : default value\n- optional (bool = False) : the field is created only when accessed\n- infos (dict) : field infos\n</code></pre>"},{"location":"api/spline/#npblender.domain.Spline.new_float","title":"new_float","text":"<pre><code>new_float(name, default=0.0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a scalar float attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>float</code> <p>Default value.</p> <code>0.0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/spline/#npblender.domain.Spline.new_int","title":"new_int","text":"<pre><code>new_int(name, default=0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure an integer attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>int</code> <p>Default value.</p> <code>0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/spline/#npblender.domain.Spline.new_matrix","title":"new_matrix","text":"<pre><code>new_matrix(name, default=np.eye(4), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a matrix attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array - like</code> <p>Default matrix. By convention this is a square matrix per element (e.g., <code>(3, 3)</code> rotation or <code>(4, 4)</code> transform).</p> <code>np.eye(4)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code> <code>order</code> required"},{"location":"api/spline/#npblender.domain.Spline.new_quaternion","title":"new_quaternion","text":"<pre><code>new_quaternion(name, default=(0.0, 0.0, 0.0, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a quaternion attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (4,)</code> <p>Default quaternion in <code>(x, y, z, w)</code> convention.</p> <code>(0.0, 0.0, 0.0, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/spline/#npblender.domain.Spline.new_vector","title":"new_vector","text":"<pre><code>new_vector(name, default=(0.0, 0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 3D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,)</code> <p>Default XYZ vector.</p> <code>(0.0, 0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/spline/#npblender.domain.Spline.new_vector2","title":"new_vector2","text":"<pre><code>new_vector2(name, default=(0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 2D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (2,)</code> <p>Default XY vector.</p> <code>(0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/spline/#npblender.domain.Spline.per_size","title":"per_size","text":"<pre><code>per_size()\n</code></pre> <p>Group items by their <code>loop_total</code> (polygon/control-point count).</p> <p>Returns a dictionary keyed by size (<code>3</code>, <code>4</code>, \u2026) where each entry contains: - <code>'start'</code> : array of <code>loop_start</code> values for items of that size. - <code>'indices'</code> : array mapping entry order back to item indices.</p> <p>Returns:</p> Type Description <code>dict[int, dict[str, ndarray]]</code> <p>Grouped start offsets and reverse indices for each size present.</p> Notes <p>Uses a Numba kernel to bucketize items efficiently.</p>"},{"location":"api/spline/#npblender.domain.Spline.to_bl_attributes","title":"to_bl_attributes","text":"<pre><code>to_bl_attributes(attributes, update=False)\n</code></pre> <p>Export attributes to a Blender attribute collection.</p> <p>Writes eligible domain attributes to a Blender data-block, creating missing attributes and adjusting sizes as needed.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Any</code> <p>Blender attributes collection receiving the values.</p> required <code>update</code> <code>bool</code> <p>If <code>True</code>, update existing attributes in-place; otherwise create them when missing.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Caution:*** Only attributes with `transfer=True` are exported. Optional</code> <code>attributes are skipped.</code> <code>&gt; ***Caution:*** Curve domains user attributes are not saved.</code>"},{"location":"api/spline/#npblender.domain.Spline.to_dict","title":"to_dict","text":"<pre><code>to_dict(*, copy=True, with_infos=True)\n</code></pre> <p>Convert the array to a dictionary of fields or (field, infos) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Whether to copy the arrays.</p> <code>True</code> <code>with_infos</code> <code>bool</code> <p>If True, return (array, infos) for each field.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, array or (array, dict)]</code>"},{"location":"api/spline/#npblender.domain.Spline.to_object","title":"to_object","text":"<pre><code>to_object(data, update=False)\n</code></pre> <p>Transfer spline attributes to a Blender object.</p> <p>Writes this domain\u2019s Blender attributes into the target Blender object or data block.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ID or similar</code> <p>Blender object or data block exposing an <code>attributes</code> mapping.</p> required <code>update</code> <code>bool</code> <p>If <code>True</code>, update existing attributes only. If <code>False</code>, create new attributes when they do not exist.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If attribute creation or assignment fails.</p> Notes <ul> <li>Only attributes flagged with <code>transfer=True</code> are exported.</li> <li>String attributes are currently skipped.</li> </ul> <p>Examples:</p> <pre><code>import bpy\nfrom npblender.domain import Spline\n\ncurve = bpy.data.curves[\"MyCurve\"]\nsplines = Spline()\nsplines.to_object(curve, update=False)\n</code></pre> <p>Caution: Blender does not save user-defined attributes inside curve objects. Attributes written here may be lost when saving and reopening the file.</p>"},{"location":"api/spline/#npblender.domain.Spline.transfer_attributes","title":"transfer_attributes","text":"<pre><code>transfer_attributes(other, shape=None, other_shape=None)\n</code></pre> <p>Transfer values of trans-domain attributes from another domain.</p> <p>Copies values for each trans-domain attribute present in <code>other</code> into the corresponding attributes of <code>self</code>, with optional reshaping for batched assignments.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain</code> <p>Source domain providing attribute values.</p> required <code>shape</code> <code>tuple of int or None</code> <p>Target reshape for <code>self</code> before assignment. If <code>None</code>, uses <code>(self._length,)</code>.</p> <code>None</code> <code>other_shape</code> <code>tuple of int or None</code> <p>Source reshape for <code>other</code> before assignment. If <code>None</code>, uses <code>(other._length,)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p> <code>&gt; ***Note:*** Each attribute is reshaped as `shape + item_shape` on `self`</code> <code>and `other_shape + item_shape` on `other` prior to assignment.</code>"},{"location":"api/spline/#npblender.domain.Spline.update_loop_start","title":"update_loop_start","text":"<pre><code>update_loop_start()\n</code></pre> <p>Recompute <code>loop_start</code> from <code>loop_total</code> (cumulative layout).</p> <p>Sets <code>loop_start</code> to a left-rolled cumulative sum of <code>loop_total</code>, so item i starts right after the end of item i-1.</p> <p>Returns:</p> Type Description <code>FaceSplineDomain</code> <p>Self (for chaining).</p> Notes <p>Call this after deletions / resizes to keep indices consistent.</p> See Also <p><code>compute_loop_start</code> :     Compute offsets for new items to be appended.</p>"},{"location":"api/vertex/","title":"Vertex","text":""},{"location":"api/vertex/#npblender.domain.Vertex","title":"Vertex","text":"<pre><code>Vertex(a=None, mode='COPY', selector=None, attr_from=None, **attrs)\n</code></pre> <p>Vertex (mesh point) domain.</p> <p>This domain represents mesh vertices. It provides fast utilities to transfer (map/average) any per-vertex attribute onto other mesh domains  (faces, corners, edges).</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>(N, 3) float</code> <p>World-space vertex positions inherited from :class:<code>PointDomain</code>.</p> Notes <ul> <li>Attribute transfers are implemented with Numba-jitted kernels for   performance.</li> <li>When mapping to faces, values are averaged over all corners of each face.</li> </ul> <p>Examples:</p> <p>Map a per-vertex scalar to faces:</p> <pre><code>face_attr = vertices.compute_attribute_on_faces(\"mass\", corners, faces)\n</code></pre> <p>Map a per-vertex vector to edges:</p> <pre><code>edge_attr = vertices.compute_attribute_on_edges(\"normal\", edges)\n</code></pre> <p>Initialize a domain array and its attribute schema.</p> <p>Initializes the storage from an existing array/domain or creates an empty structure. Optionally merges attribute definitions/values from another domain and keyword-provided attributes.</p> <p>Domains are never instancied directly but by owning geometries.</p> <p>Actual Domains are <code>Vertex</code>, [<code>Faces</code>][npblender.domain.Faces], <code>Corner</code>, <code>Edge</code>, <code>ControlPoint</code>, <code>Spline</code> and <code>Point</code>.</p> <p>Domains are initialized with their defaults attributes, for instance <code>position</code> for point domaines.</p> <p>Use attributes can be freely added. </p> <p>Note: user attributes are saved in Blender Mesh objects only, Blender Curve objects don't store user attributes.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>array - like or FieldArray or None</code> <p>Source data used to initialize the domain. If <code>None</code>, an empty domain is created and <code>_declare_attributes()</code> is called to register defaults.</p> <code>None</code> <code>mode</code> <code>(COPY, CAPTURE, EMPTY)</code> <p>Initialization mode. <code>'COPY'</code> duplicates the input data, <code>'CAPTURE'</code> references the input buffer when supported, <code>'EMPTY'</code> creates the structure without copying values.</p> <code>'COPY'</code> <code>selector</code> <code>Any</code> <p>Optional row/element selector applied to <code>a</code> prior to initialization.</p> <code>None</code> <code>attr_from</code> <code>Domain or Mapping or None</code> <p>Attribute schema (and possibly values) to merge into this domain.</p> <code>None</code> <code>**attrs</code> <p>Additional attribute name/value pairs to inject or override.</p> <code>{}</code> Notes <p>The effective attribute list results from <code>_declare_attributes()</code>, then <code>attr_from</code>, then <code>**attrs</code> (later entries take precedence).</p> <p>Examples:</p> <pre><code>cube = Mesh.cube() # points, corners, faces and edges domains are created\n# Adding named attribute to point domain\ncube.points.new_float('age')\n# Setting the age\ncube.points.age = np.random.uniforme(10, 10, len(cube.points))\n</code></pre>"},{"location":"api/vertex/#npblender.domain.Vertex.actual_names","title":"actual_names  <code>property</code>","text":"<pre><code>actual_names\n</code></pre> <p>Column names.</p> <p>Returns the actual field names, excluding optional fields.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.all_names","title":"all_names  <code>property</code>","text":"<pre><code>all_names\n</code></pre> <p>Column names.</p> <p>Returns all the field names, including optional ones.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Array structured dtype</p> <p>Returns the dtype property of the structured array.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.transdom_names","title":"transdom_names  <code>property</code>","text":"<pre><code>transdom_names\n</code></pre> <p>List the names of trans-domain attributes.</p> <p>Returns:</p> Type Description <code>list of str</code> <p>Names of attributes flagged with <code>transdom=True</code>.</p> <p>Examples:</p> <pre><code>names = D.transdom_names()\n</code></pre>"},{"location":"api/vertex/#npblender.domain.Vertex.x","title":"x  <code>property</code> <code>writable</code>","text":"<pre><code>x\n</code></pre> <p>X coordinate accessor.</p> <p>Shorthand for <code>position[..., 0]</code>. Reading returns a view; assigning to this property writes into the underlying <code>position</code> field.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>View of shape <code>(...,)</code> selecting the x component of <code>position</code>.</p> <p>Examples:</p> <p>Read and write x in place:</p> <pre><code>xs = points.x              # view on position[..., 0]\npoints.x = xs + 1.0        # shift x by +1\n</code></pre> <p>Note: This is equivalent to <code>points.position[..., 0]</code>.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.y","title":"y  <code>property</code> <code>writable</code>","text":"<pre><code>y\n</code></pre> <p>Y coordinate accessor.</p> <p>Shorthand for <code>position[..., 1]</code>. Reading returns a view; assigning to this property writes into the underlying <code>position</code> field.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>View of shape <code>(...,)</code> selecting the y component of <code>position</code>.</p> <p>Examples:</p> <pre><code>points.y = 0.0             # flatten all y to 0\n</code></pre>"},{"location":"api/vertex/#npblender.domain.Vertex.z","title":"z  <code>property</code> <code>writable</code>","text":"<pre><code>z\n</code></pre> <p>Z coordinate accessor.</p> <p>Shorthand for <code>position[..., 2]</code>. Reading returns a view; assigning to this property writes into the underlying <code>position</code> field.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>View of shape <code>(...,)</code> selecting the z component of <code>position</code>.</p> <p>Examples:</p> <pre><code>points.z += 2.5\n</code></pre>"},{"location":"api/vertex/#npblender.domain.Vertex.add","title":"add","text":"<pre><code>add(count, **fields)\n</code></pre> <p>Add count records</p> <p>New records are set with default values or values provided by the user in fields dict.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of records to add.</p> required <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/vertex/#npblender.domain.Vertex.append","title":"append","text":"<pre><code>append(**fields)\n</code></pre> <p>Append values to the structured array.</p> <p>The number of records to append is determined by the number of fields provided in the fields dictionary. The values of the fields are copied to the new records.</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict</code> <p>Keyword arguments mapping field names to values.</p> <code>{}</code>"},{"location":"api/vertex/#npblender.domain.Vertex.apply_scale","title":"apply_scale","text":"<pre><code>apply_scale(scale, pivot=None)\n</code></pre> <p>Apply per-axis scales to points, optionally about a pivot.</p> <p>The scaling is broadcast across the domain using <code>_get_shape_for_operation</code>. If a pivot is given, points are moved to the local frame, scaled, then moved back.</p> <p>Parameters:</p> Name Type Description Default <code>scale</code> <code>array-like of shape ``(..., 3)``</code> <p>Per-axis scale factors broadcastable to the domain size.</p> required <code>pivot</code> <code>array-like of shape ``(..., 3)`` or None</code> <p>Pivot location(s). If <code>None</code>, scales are applied about the origin.</p> <code>None</code> <p>Returns:</p> Type Description <code>PointDomain</code> <p>Self (for chaining).</p> <p>Examples:</p> <pre><code># A mesh made of 8 cubes\ncubes = Mesh.cube(size=.2)*8\npv = np.random.uniform(-1, 1, (8, 3))\nsc = np.random.uniform(.1, 1, (8, 3))\n# Scale each cube individually\ncubes.points.apply_scale(sc, pivot=pv)\n</code></pre> <p>Note: If broadcasting fails, a <code>ValueError</code> is raised by <code>_get_shape_for_operation</code>.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.as_kwargs","title":"as_kwargs","text":"<pre><code>as_kwargs(selector=None, include=None, exclude=None)\n</code></pre> <p>Return a dictionary of field values formatted as kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>slice, int, list, or mask</code> <p>Optional selection of elements to extract.</p> <code>None</code> <code>include</code> <code>list[str]</code> <p>List of field names (original or python names) to include.</p> <code>None</code> <code>exclude</code> <code>list[str]</code> <p>List of field names (original or python names) to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Mapping from python-safe field names to array values.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.compute_attribute_on_corners","title":"compute_attribute_on_corners","text":"<pre><code>compute_attribute_on_corners(attr, corners)\n</code></pre> <p>Scatter a per-vertex attribute to corners.</p> <p>For each corner, copies the attribute of its associated vertex (via <code>corners.vertex_index</code>). The attribute is validated with <code>_check_attribute_to_compute</code>.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str or ndarray, shape ``(N, ...)``</code> <p>Vertex attribute to scatter. If a string, the field is looked up on this domain; if an array, it must have length <code>N == len(self)</code>.</p> required <code>corners</code> <code>Corner</code> <p>Corner domain providing the <code>vertex_index</code> mapping.</p> required <p>Returns:</p> Type Description <code>ndarray, shape ``(len(corners), ...)``</code> <p>Corner attribute array (one value per corner), preserving the trailing item shape and dtype.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>attr</code> is scalar or its first dimension does not match <code>len(self)</code> (raised by <code>_check_attribute_to_compute</code>).</p> <code>IndexError</code> <p>If <code>corners.vertex_index</code> contains indices outside <code>[0, len(self))</code>.</p> <p>Examples:</p> <pre><code># Duplicate per-vertex colors to corners\ncorner_col = V.compute_attribute_on_corners(\"color\", corners)\n</code></pre>"},{"location":"api/vertex/#npblender.domain.Vertex.compute_attribute_on_edges","title":"compute_attribute_on_edges","text":"<pre><code>compute_attribute_on_edges(attr, edges)\n</code></pre> <p>Average a per-vertex attribute over each edge.</p> <p>For every edge, returns the mean of the attribute at its two endpoint vertices (<code>(v0, v1)</code>). The attribute is validated with <code>_check_attribute_to_compute</code>.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str or ndarray, shape ``(N, ...)``</code> <p>Vertex attribute to average. If a string, the field is looked up on this domain; if an array, it must have length <code>N == len(self)</code>.</p> required <code>edges</code> <code>Edge</code> <p>Edge domain providing <code>vertex0</code> and <code>vertex1</code> index arrays.</p> required <p>Returns:</p> Type Description <code>ndarray, shape ``(len(edges), ...)``</code> <p>Edge-wise averaged attribute. The trailing item shape is preserved and the dtype follows the input attribute.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>attr</code> is scalar or its first dimension does not match <code>len(self)</code> (raised by <code>_check_attribute_to_compute</code>).</p> <code>IndexError</code> <p>If <code>edges.vertex0</code> or <code>edges.vertex1</code> contain indices outside <code>[0, len(self))</code>.</p> <code>TypeError</code> <p>If the attribute dtype is non-numeric or cannot be averaged (e.g., integer types with in-place division).</p> <p>Examples:</p> <pre><code># Edge midpoints from vertex positions\nedge_pos = V.compute_attribute_on_edges(\"position\", edges)\n\n# Average a custom per-vertex scalar on edges\nedge_w = V.compute_attribute_on_edges(weights, edges)\n</code></pre> <p>Note: The average is unweighted: <code>0.5 * (attr[v0] + attr[v1])</code>.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.compute_attribute_on_faces","title":"compute_attribute_on_faces","text":"<pre><code>compute_attribute_on_faces(attr, corners, faces)\n</code></pre> <p>Average a per-vertex attribute over each face.</p> <p>For every face, this computes the mean of the source vertex attribute over all its incident corners (i.e., the face-wise average). The input attribute can be given by name or as an array aligned with the vertex domain. The attribute is validated with <code>_check_attribute_to_compute</code>.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str or ndarray, shape ``(N, ...)``</code> <p>Vertex attribute to aggregate. If a string, the corresponding field is looked up on this domain; if an array, it must have length <code>N == len(self)</code>. Trailing item shape (<code>...</code>) is preserved.</p> required <code>corners</code> <code>Corner</code> <p>Corner domain providing the <code>vertex_index</code> mapping for the mesh.</p> required <code>faces</code> <code>Face</code> <p>Face domain providing <code>loop_start</code> and <code>loop_total</code> (polygon topology).</p> required <p>Returns:</p> Type Description <code>ndarray, shape ``(len(faces), ...)``</code> <p>Face-wise averaged attribute. The trailing item shape is preserved and the dtype follows the input attribute.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If <code>attr</code> is scalar or its first dimension does not match <code>len(self)</code> (raised by <code>_check_attribute_to_compute</code>).</p> <code>IndexError</code> <p>If <code>corners.vertex_index</code> contains indices outside <code>[0, len(self))</code>.</p> <code>TypeError</code> <p>If the attribute dtype is non-numeric or cannot be averaged (e.g., integer types with in-place division).</p> Notes <p>This routine computes an unweighted arithmetic mean over each face's corners.</p> See Also <p><code>compute_attribute_on_corners</code> :     Scatter vertex attributes to corners. <code>compute_attribute_on_edges</code> :     Average vertex attributes on edges.</p> <p>Examples:</p> <pre><code># Face centroids (average of vertex positions)\nface_pos = V.compute_attribute_on_faces(\"position\", corners, faces)\n\n# Average any custom per-vertex float attribute\nface_weight = V.compute_attribute_on_faces(weights, corners, faces)\n</code></pre>"},{"location":"api/vertex/#npblender.domain.Vertex.copy_field","title":"copy_field","text":"<pre><code>copy_field(field_name, new_name, **infos)\n</code></pre> <p>Duplicate an existing field under a new name, with optional metadata overrides.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>The name of the existing field to copy.</p> required <code>new_name</code> <code>str</code> <p>The name of the new field to create.</p> required <code>infos</code> <code>keyword arguments</code> <p>Optional metadata (e.g. default, unit, description...) to override or supplement the original field's metadata.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the source field does not exist.</p> <code>ValueError</code> <p>If the target name already exists or is reserved.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.delete","title":"delete","text":"<pre><code>delete(index)\n</code></pre> <p>Delete a selection of items from the array.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int, slice, or array-like</code> <p>The indices of the elements to delete from the current data.</p> required Notes <p>This operates only on the valid range <code>[0:self._length]</code>. The internal buffer is preserved (no reallocation).</p>"},{"location":"api/vertex/#npblender.domain.Vertex.dump","title":"dump","text":"<pre><code>dump(title='Dump', attributes=None, target='SCREEN')\n</code></pre> <p>Pretty-print or export domain content.</p> <p>Formats attribute values and prints to screen or builds a tabular dump suitable for spreadsheets.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title displayed in the report.</p> <code>'Dump'</code> <code>attributes</code> <code>Sequence[str] or None</code> <p>Subset of attribute names to include. If <code>None</code>, all attributes are shown.</p> <code>None</code> <code>target</code> <code>(SCREEN, ...)</code> <p>Output target. <code>'SCREEN'</code> prints to stdout; other targets may trigger file creation depending on the implementation.</p> <code>'SCREEN'</code> <p>Returns:</p> Type Description <code>None</code> <p>Examples:</p> <pre><code>Domain(points).dump(title=\"Vertices\")\n</code></pre> <p>Note: Formatting adapts to the chosen <code>target</code>.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.extend","title":"extend","text":"<pre><code>extend(other, join_fields=True)\n</code></pre> <p>Append multiple records from another array or FieldArray.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray or structured np.ndarray</code> <p>The array of records to append. Must have named fields matching a subset of the current array's fields.</p> required"},{"location":"api/vertex/#npblender.domain.Vertex.filtered","title":"filtered","text":"<pre><code>filtered(selector, *, copy=False)\n</code></pre> <p>Return a FieldArray containing only the selected records.</p> <p>Parameters:</p> Name Type Description Default <code>selector</code> <code>array\u2011like, slice or int</code> <p>Any valid NumPy 1\u2011D index: boolean mask, integer index/array, or slice. It is applied to the current valid part of the buffer (<code>self._data[:self._length]</code>).</p> required <code>copy</code> <code>bool</code> <ul> <li>False    (default) =&gt; the new array shares the same memory                          (changes propagate both ways).</li> <li>True           =&gt; the data are physically copied.</li> </ul> <code>False</code> <p>Returns:</p> Type Description <code>FieldArray</code> <p>A new instance holding exactly <code>len(selector)</code> records and inheriting the current field\u2011infos.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.from_bl_attributes","title":"from_bl_attributes","text":"<pre><code>from_bl_attributes(bl_attributes)\n</code></pre> <p>Import attributes from a Blender attribute collection.</p> <p>Reads geometry attributes from a Blender data-block and creates/updates the corresponding domain attributes, resizing the domain if needed.</p> <p>Parameters:</p> Name Type Description Default <code>bl_attributes</code> <code>Mapping[str, Any]</code> <p>Blender attributes collection (name \u2192 attribute descriptor) providing at least <code>.domain</code>, <code>.is_internal</code>, <code>.data_type</code>, and <code>.data</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Note:*** Only external (non-internal) Blender attributes matching this</code> <code>domain are imported. Missing attributes are created with `transfer=True`.</code>"},{"location":"api/vertex/#npblender.domain.Vertex.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data)\n</code></pre> <p>Build a FieldArray from a dictionary with field data and optional metadata.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, array - like or (array, dict)]</code> <p>Mapping field names to arrays or (array, infos). Infos must include NAME.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the data. Default: True.</p> required <p>Returns:</p> Type Description <code>FieldArray</code>"},{"location":"api/vertex/#npblender.domain.Vertex.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> <p>Get attribute by name.</p> <p>If name is not an actual field, return default value. Name can be an array. <pre><code>pos = field_array.get(\"position\", (0, 0, 1))\npos = field_array.get([[0, 0, 1], [0, 0, 0]])\n</code></pre></p>"},{"location":"api/vertex/#npblender.domain.Vertex.join_attributes","title":"join_attributes","text":"<pre><code>join_attributes(other)\n</code></pre> <p>Merge trans-domain attributes from another domain.</p> <p>Copies or aligns attributes from <code>other</code> into the current domain, excluding any attributes not flagged as trans-domain in <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain or None</code> <p>Source domain. If <code>None</code>, the call is a no-op.</p> required <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p>"},{"location":"api/vertex/#npblender.domain.Vertex.join_fields","title":"join_fields","text":"<pre><code>join_fields(other, exclude=[])\n</code></pre> <p>Add all missing fields from another FieldArray.</p> <p>For every field in <code>other</code> that is not present in <code>self</code>, a new field is created with the same dtype and shape, and initialized with its default value across all existing records.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>FieldArray</code> <p>Another FieldArray instance whose fields will be checked for missing fields.</p> required <p>Returns:</p> Type Description <code>self</code>"},{"location":"api/vertex/#npblender.domain.Vertex.make_buckets","title":"make_buckets","text":"<pre><code>make_buckets(attr)\n</code></pre> <p>Group items into buckets by attribute value.</p> <p>When a domain is to be considered as a collection of packets of various sizes, buckets mechanism groups pakets by size, allowing further operation with numpy vectorization.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>array - like or str</code> <p>Either an integer of shape <code>(N,)</code> or the name of an existing integer attribute in the domain.</p> required <p>Returns:</p> Type Description <code>list[ndarray(count, n)]</code> <p>A list of int arrays (count, n): count is the number of buckets of length n.</p> <p>Examples:</p> <pre><code>buckets = mesh.make_buckets('material')\nfor bucket in buckets:\n    print(bucket.shape)\n</code></pre> <p>Note: The bucket attribute can be read with <code>attr[bucket[:, 0]]</code>.</p>"},{"location":"api/vertex/#npblender.domain.Vertex.multiply","title":"multiply","text":"<pre><code>multiply(count)\n</code></pre> <p>Duplicate the current records <code>count</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of times to repeat the current records.</p> required Notes <p>This duplicates the current valid records (up to self._length). If the array is empty or count &lt;= 1, nothing happens.</p> Example: <p>If the array has 3 records and count == 4, the result will be:</p> <p>[rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2, rec0, rec1, rec2]</p>"},{"location":"api/vertex/#npblender.domain.Vertex.new_attribute","title":"new_attribute","text":"<pre><code>new_attribute(name, data_type, default, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Register a new attribute in the domain schema.</p> <p>Creates (or ensures) an attribute with a given name, logical data type, default value, and flags controlling Blender transfer and cross-domain propagation.</p> <p>Note: <code>data_type</code> argument is a Blender data type not a python data type. The data type name is compatible with Blender internal storage. <code>FLOAT</code>data type is implemented as <code>np.float32</code> and  'INT' as <code>np.int32</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name (Python identifier recommended).</p> required <code>data_type</code> <code>(FLOAT, INT, BOOL, VECTOR, VECTOR2, COLOR, QUATERNION, MATRIX, STRING, ...)</code> <p>Logical data type used by the domain.</p> <code>'FLOAT'</code> <code>default</code> <code>Any</code> <p>Default value for newly allocated elements.</p> required <code>optional</code> <code>bool</code> <p>If <code>True</code>, the attribute may be absent on some elements.</p> <code>False</code> <code>transfer</code> <code>bool</code> <p>If <code>True</code>, eligible to be transferred to Blender as a geometry attribute.</p> <code>True</code> <code>transdom</code> <code>bool</code> <p>If <code>True</code>, considered a trans-domain attribute that can be copied across compatible domains.</p> <code>True</code> See Also <p><code>new_float</code>, <code>new_vector</code>, <code>new_int</code>, <code>new_bool</code>, <code>new_color</code>, <code>new_vector2</code>, <code>new_quaternion</code>, <code>new_matrix</code></p>"},{"location":"api/vertex/#npblender.domain.Vertex.new_bool","title":"new_bool","text":"<pre><code>new_bool(name, default=False, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a boolean attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>bool</code> <p>Default value.</p> <code>False</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/vertex/#npblender.domain.Vertex.new_color","title":"new_color","text":"<pre><code>new_color(name, default=(0.5, 0.5, 0.5, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a color attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,) or (4,)</code> <p>Default color as RGB or RGBA.</p> <code>(0.5, 0.5, 0.5, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/vertex/#npblender.domain.Vertex.new_field","title":"new_field","text":"<pre><code>new_field(name, dtype, shape=None, default=0, optional=False, **infos)\n</code></pre> <p>Add a field to the structured array.</p> Arguments <pre><code>- name (str) : field name\n- dtype (type) : a valid numpy dtype\n- shape (tuple = None) : the shape of the field\n- default (any = 0) : default value\n- optional (bool = False) : the field is created only when accessed\n- infos (dict) : field infos\n</code></pre>"},{"location":"api/vertex/#npblender.domain.Vertex.new_float","title":"new_float","text":"<pre><code>new_float(name, default=0.0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a scalar float attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>float</code> <p>Default value.</p> <code>0.0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/vertex/#npblender.domain.Vertex.new_int","title":"new_int","text":"<pre><code>new_int(name, default=0, optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure an integer attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>int</code> <p>Default value.</p> <code>0</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/vertex/#npblender.domain.Vertex.new_matrix","title":"new_matrix","text":"<pre><code>new_matrix(name, default=np.eye(4), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a matrix attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array - like</code> <p>Default matrix. By convention this is a square matrix per element (e.g., <code>(3, 3)</code> rotation or <code>(4, 4)</code> transform).</p> <code>np.eye(4)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code> <code>order</code> required"},{"location":"api/vertex/#npblender.domain.Vertex.new_quaternion","title":"new_quaternion","text":"<pre><code>new_quaternion(name, default=(0.0, 0.0, 0.0, 1.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a quaternion attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (4,)</code> <p>Default quaternion in <code>(x, y, z, w)</code> convention.</p> <code>(0.0, 0.0, 0.0, 1.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/vertex/#npblender.domain.Vertex.new_vector","title":"new_vector","text":"<pre><code>new_vector(name, default=(0.0, 0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 3D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (3,)</code> <p>Default XYZ vector.</p> <code>(0.0, 0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/vertex/#npblender.domain.Vertex.new_vector2","title":"new_vector2","text":"<pre><code>new_vector2(name, default=(0.0, 0.0), optional=False, transfer=True, transdom=True)\n</code></pre> <p>Create or ensure a 2D vector attribute.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Attribute name.</p> required <code>default</code> <code>array-like of shape (2,)</code> <p>Default XY vector.</p> <code>(0.0, 0.0)</code> <code>optional</code> <code>bool</code> <code>False</code> <code>transfer</code> <code>bool</code> <code>True</code> <code>transdom</code> <code>bool</code> <code>True</code>"},{"location":"api/vertex/#npblender.domain.Vertex.to_bl_attributes","title":"to_bl_attributes","text":"<pre><code>to_bl_attributes(attributes, update=False)\n</code></pre> <p>Export attributes to a Blender attribute collection.</p> <p>Writes eligible domain attributes to a Blender data-block, creating missing attributes and adjusting sizes as needed.</p> <p>Parameters:</p> Name Type Description Default <code>attributes</code> <code>Any</code> <p>Blender attributes collection receiving the values.</p> required <code>update</code> <code>bool</code> <p>If <code>True</code>, update existing attributes in-place; otherwise create them when missing.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <code>&gt; ***Caution:*** Only attributes with `transfer=True` are exported. Optional</code> <code>attributes are skipped.</code> <code>&gt; ***Caution:*** Curve domains user attributes are not saved.</code>"},{"location":"api/vertex/#npblender.domain.Vertex.to_dict","title":"to_dict","text":"<pre><code>to_dict(*, copy=True, with_infos=True)\n</code></pre> <p>Convert the array to a dictionary of fields or (field, infos) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>copy</code> <code>bool</code> <p>Whether to copy the arrays.</p> <code>True</code> <code>with_infos</code> <code>bool</code> <p>If True, return (array, infos) for each field.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, array or (array, dict)]</code>"},{"location":"api/vertex/#npblender.domain.Vertex.transfer_attributes","title":"transfer_attributes","text":"<pre><code>transfer_attributes(other, shape=None, other_shape=None)\n</code></pre> <p>Transfer values of trans-domain attributes from another domain.</p> <p>Copies values for each trans-domain attribute present in <code>other</code> into the corresponding attributes of <code>self</code>, with optional reshaping for batched assignments.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Domain</code> <p>Source domain providing attribute values.</p> required <code>shape</code> <code>tuple of int or None</code> <p>Target reshape for <code>self</code> before assignment. If <code>None</code>, uses <code>(self._length,)</code>.</p> <code>None</code> <code>other_shape</code> <code>tuple of int or None</code> <p>Source reshape for <code>other</code> before assignment. If <code>None</code>, uses <code>(other._length,)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Domain</code> <p>The domain itself (for chaining).</p> <code>&gt; ***Note:*** Each attribute is reshaped as `shape + item_shape` on `self`</code> <code>and `other_shape + item_shape` on `other` prior to assignment.</code>"},{"location":"api/vertex/#npblender.domain.Vertex.transform","title":"transform","text":"<pre><code>transform(transfo, pivot=None)\n</code></pre> <p>Apply a linear transform (e.g., rotation or transformation) to points.</p> <p>If the transformation or pivot size is less than the domain size, the scale / pivot is applied on buckets of the same size if possible, otherwise an exception is raised.</p> <p>Parameters:</p> Name Type Description Default <code>transfo</code> <code>(Transformation, Rotation or Quaternion)</code> <p>Transform(s) broadcastable to the domain size. Typical shapes include <code>(..., 3, 3)</code>; project-specific transform types are also supported if they define the <code>@</code> operator with vectors.</p> required <code>pivot</code> <code>array-like of shape ``(..., 3)`` or None</code> <p>Pivot location(s). If <code>None</code>, transforms are applied about the origin.</p> <code>None</code> <p>Returns:</p> Type Description <code>PointDomain</code> <p>Self (for chaining).</p> <p>Examples:</p> <pre><code># A mesh made of 8 cubes\ncubes = Mesh.cube(size=1)*8\npv = np.random.uniform(-1, 1, (8, 3))\nrot = Rotation.from_euler(np.random.uniform(0, 2*np.pi, (8, 3)))\n# Transform the 8 cubes indivicually\ncubes.points.transform(rot, pivot=pv)\n</code></pre> Examples: <pre><code># A mesh made of 8 cubes\ncubes = Mesh.cube(size=1)*8\npv = np.random.uniform(-1, 1, (8, 3))\nrot = Rotation.from_euler(np.random.uniform(0, 2*np.pi, (8, 3)))\n# Transform the 8 cubes indivicually\ncubes.points.transform(rot, pivot=pv)\n</code></pre>"},{"location":"api/vertex/#npblender.domain.Vertex.translate","title":"translate","text":"<pre><code>translate(translation)\n</code></pre> <p>Translate points position by a vector or a batch of vectors.</p> <p>Supports per-domain translation (single vector), or grouped/batched translations that broadcast over buckets of equal size.</p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>array-like of shape ``(..., 3)``</code> <p>Translation vectors broadcastable to the domain size.</p> required <p>Returns:</p> Type Description <code>PointDomain</code> <p>Self (for chaining).</p> <p>Examples:</p> <pre><code># Per-point random translation\nD.translate(np.random.uniform(-0.1, 0.1, (len(D), 3)))\n\n```python\n# A mesh made of 8 cubes\ncubes = Mesh.cube(size=.2)*8\ntr = np.random.uniform(-1, 1, (8, 3))\n# Translate each cube individually\ncubes.points.translate(tr)\n</code></pre> <p>Caution: If a provided batch cannot be aligned with the domain, a <code>ValueError</code> is raised by <code>_get_shape_for_operation</code>.</p>"}]}